--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file fifo_fg92_722742878aa74e71.vhd when simulating
-- the core, fifo_fg92_722742878aa74e71. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY fifo_fg92_722742878aa74e71 IS
  PORT (
    clk : IN STD_LOGIC;
    din : IN STD_LOGIC_VECTOR(64 DOWNTO 0);
    wr_en : IN STD_LOGIC;
    rd_en : IN STD_LOGIC;
    dout : OUT STD_LOGIC_VECTOR(64 DOWNTO 0);
    full : OUT STD_LOGIC;
    empty : OUT STD_LOGIC
  );
END fifo_fg92_722742878aa74e71;

ARCHITECTURE fifo_fg92_722742878aa74e71_a OF fifo_fg92_722742878aa74e71 IS
-- synthesis translate_off
COMPONENT wrapped_fifo_fg92_722742878aa74e71
  PORT (
    clk : IN STD_LOGIC;
    din : IN STD_LOGIC_VECTOR(64 DOWNTO 0);
    wr_en : IN STD_LOGIC;
    rd_en : IN STD_LOGIC;
    dout : OUT STD_LOGIC_VECTOR(64 DOWNTO 0);
    full : OUT STD_LOGIC;
    empty : OUT STD_LOGIC
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_fifo_fg92_722742878aa74e71 USE ENTITY XilinxCoreLib.fifo_generator_v9_3(behavioral)
    GENERIC MAP (
      c_add_ngc_constraint => 0,
      c_application_type_axis => 0,
      c_application_type_rach => 0,
      c_application_type_rdch => 0,
      c_application_type_wach => 0,
      c_application_type_wdch => 0,
      c_application_type_wrch => 0,
      c_axi_addr_width => 32,
      c_axi_aruser_width => 1,
      c_axi_awuser_width => 1,
      c_axi_buser_width => 1,
      c_axi_data_width => 64,
      c_axi_id_width => 4,
      c_axi_ruser_width => 1,
      c_axi_type => 0,
      c_axi_wuser_width => 1,
      c_axis_tdata_width => 64,
      c_axis_tdest_width => 4,
      c_axis_tid_width => 8,
      c_axis_tkeep_width => 4,
      c_axis_tstrb_width => 4,
      c_axis_tuser_width => 4,
      c_axis_type => 0,
      c_common_clock => 1,
      c_count_type => 0,
      c_data_count_width => 11,
      c_default_value => "BlankString",
      c_din_width => 65,
      c_din_width_axis => 1,
      c_din_width_rach => 32,
      c_din_width_rdch => 64,
      c_din_width_wach => 32,
      c_din_width_wdch => 64,
      c_din_width_wrch => 2,
      c_dout_rst_val => "0",
      c_dout_width => 65,
      c_enable_rlocs => 0,
      c_enable_rst_sync => 1,
      c_error_injection_type => 0,
      c_error_injection_type_axis => 0,
      c_error_injection_type_rach => 0,
      c_error_injection_type_rdch => 0,
      c_error_injection_type_wach => 0,
      c_error_injection_type_wdch => 0,
      c_error_injection_type_wrch => 0,
      c_family => "virtex6",
      c_full_flags_rst_val => 0,
      c_has_almost_empty => 0,
      c_has_almost_full => 0,
      c_has_axi_aruser => 0,
      c_has_axi_awuser => 0,
      c_has_axi_buser => 0,
      c_has_axi_rd_channel => 0,
      c_has_axi_ruser => 0,
      c_has_axi_wr_channel => 0,
      c_has_axi_wuser => 0,
      c_has_axis_tdata => 0,
      c_has_axis_tdest => 0,
      c_has_axis_tid => 0,
      c_has_axis_tkeep => 0,
      c_has_axis_tlast => 0,
      c_has_axis_tready => 1,
      c_has_axis_tstrb => 0,
      c_has_axis_tuser => 0,
      c_has_backup => 0,
      c_has_data_count => 0,
      c_has_data_counts_axis => 0,
      c_has_data_counts_rach => 0,
      c_has_data_counts_rdch => 0,
      c_has_data_counts_wach => 0,
      c_has_data_counts_wdch => 0,
      c_has_data_counts_wrch => 0,
      c_has_int_clk => 0,
      c_has_master_ce => 0,
      c_has_meminit_file => 0,
      c_has_overflow => 0,
      c_has_prog_flags_axis => 0,
      c_has_prog_flags_rach => 0,
      c_has_prog_flags_rdch => 0,
      c_has_prog_flags_wach => 0,
      c_has_prog_flags_wdch => 0,
      c_has_prog_flags_wrch => 0,
      c_has_rd_data_count => 0,
      c_has_rd_rst => 0,
      c_has_rst => 0,
      c_has_slave_ce => 0,
      c_has_srst => 0,
      c_has_underflow => 0,
      c_has_valid => 0,
      c_has_wr_ack => 0,
      c_has_wr_data_count => 0,
      c_has_wr_rst => 0,
      c_implementation_type => 0,
      c_implementation_type_axis => 1,
      c_implementation_type_rach => 1,
      c_implementation_type_rdch => 1,
      c_implementation_type_wach => 1,
      c_implementation_type_wdch => 1,
      c_implementation_type_wrch => 1,
      c_init_wr_pntr_val => 0,
      c_interface_type => 0,
      c_memory_type => 1,
      c_mif_file_name => "BlankString",
      c_msgon_val => 1,
      c_optimization_mode => 0,
      c_overflow_low => 0,
      c_preload_latency => 1,
      c_preload_regs => 0,
      c_prim_fifo_type => "2kx18",
      c_prog_empty_thresh_assert_val => 2,
      c_prog_empty_thresh_assert_val_axis => 1022,
      c_prog_empty_thresh_assert_val_rach => 1022,
      c_prog_empty_thresh_assert_val_rdch => 1022,
      c_prog_empty_thresh_assert_val_wach => 1022,
      c_prog_empty_thresh_assert_val_wdch => 1022,
      c_prog_empty_thresh_assert_val_wrch => 1022,
      c_prog_empty_thresh_negate_val => 3,
      c_prog_empty_type => 0,
      c_prog_empty_type_axis => 0,
      c_prog_empty_type_rach => 0,
      c_prog_empty_type_rdch => 0,
      c_prog_empty_type_wach => 0,
      c_prog_empty_type_wdch => 0,
      c_prog_empty_type_wrch => 0,
      c_prog_full_thresh_assert_val => 2046,
      c_prog_full_thresh_assert_val_axis => 1023,
      c_prog_full_thresh_assert_val_rach => 1023,
      c_prog_full_thresh_assert_val_rdch => 1023,
      c_prog_full_thresh_assert_val_wach => 1023,
      c_prog_full_thresh_assert_val_wdch => 1023,
      c_prog_full_thresh_assert_val_wrch => 1023,
      c_prog_full_thresh_negate_val => 2045,
      c_prog_full_type => 0,
      c_prog_full_type_axis => 0,
      c_prog_full_type_rach => 0,
      c_prog_full_type_rdch => 0,
      c_prog_full_type_wach => 0,
      c_prog_full_type_wdch => 0,
      c_prog_full_type_wrch => 0,
      c_rach_type => 0,
      c_rd_data_count_width => 11,
      c_rd_depth => 2048,
      c_rd_freq => 1,
      c_rd_pntr_width => 11,
      c_rdch_type => 0,
      c_reg_slice_mode_axis => 0,
      c_reg_slice_mode_rach => 0,
      c_reg_slice_mode_rdch => 0,
      c_reg_slice_mode_wach => 0,
      c_reg_slice_mode_wdch => 0,
      c_reg_slice_mode_wrch => 0,
      c_synchronizer_stage => 2,
      c_underflow_low => 0,
      c_use_common_overflow => 0,
      c_use_common_underflow => 0,
      c_use_default_settings => 0,
      c_use_dout_rst => 0,
      c_use_ecc => 0,
      c_use_ecc_axis => 0,
      c_use_ecc_rach => 0,
      c_use_ecc_rdch => 0,
      c_use_ecc_wach => 0,
      c_use_ecc_wdch => 0,
      c_use_ecc_wrch => 0,
      c_use_embedded_reg => 0,
      c_use_fifo16_flags => 0,
      c_use_fwft_data_count => 0,
      c_valid_low => 0,
      c_wach_type => 0,
      c_wdch_type => 0,
      c_wr_ack_low => 0,
      c_wr_data_count_width => 11,
      c_wr_depth => 2048,
      c_wr_depth_axis => 1024,
      c_wr_depth_rach => 16,
      c_wr_depth_rdch => 1024,
      c_wr_depth_wach => 16,
      c_wr_depth_wdch => 1024,
      c_wr_depth_wrch => 16,
      c_wr_freq => 1,
      c_wr_pntr_width => 11,
      c_wr_pntr_width_axis => 10,
      c_wr_pntr_width_rach => 4,
      c_wr_pntr_width_rdch => 10,
      c_wr_pntr_width_wach => 4,
      c_wr_pntr_width_wdch => 10,
      c_wr_pntr_width_wrch => 4,
      c_wr_response_latency => 1,
      c_wrch_type => 0
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_fifo_fg92_722742878aa74e71
  PORT MAP (
    clk => clk,
    din => din,
    wr_en => wr_en,
    rd_en => rd_en,
    dout => dout,
    full => full,
    empty => empty
  );
-- synthesis translate_on

END fifo_fg92_722742878aa74e71_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_72_79627314d23ed512.vhd when simulating
-- the core, bmg_72_79627314d23ed512. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_72_79627314d23ed512 IS
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(8 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(0 DOWNTO 0)
  );
END bmg_72_79627314d23ed512;

ARCHITECTURE bmg_72_79627314d23ed512_a OF bmg_72_79627314d23ed512 IS
-- synthesis translate_off
COMPONENT wrapped_bmg_72_79627314d23ed512
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(8 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(0 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_bmg_72_79627314d23ed512 USE ENTITY XilinxCoreLib.blk_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addra_width => 9,
      c_addrb_width => 9,
      c_algorithm => 1,
      c_axi_id_width => 4,
      c_axi_slave_type => 0,
      c_axi_type => 1,
      c_byte_size => 9,
      c_common_clk => 0,
      c_default_data => "0",
      c_disable_warn_bhv_coll => 0,
      c_disable_warn_bhv_range => 0,
      c_enable_32bit_address => 0,
      c_family => "virtex6",
      c_has_axi_id => 0,
      c_has_ena => 1,
      c_has_enb => 0,
      c_has_injecterr => 0,
      c_has_mem_output_regs_a => 1,
      c_has_mem_output_regs_b => 0,
      c_has_mux_output_regs_a => 0,
      c_has_mux_output_regs_b => 0,
      c_has_regcea => 0,
      c_has_regceb => 0,
      c_has_rsta => 0,
      c_has_rstb => 0,
      c_has_softecc_input_regs_a => 0,
      c_has_softecc_output_regs_b => 0,
      c_init_file_name => "bmg_72_79627314d23ed512.mif",
      c_inita_val => "0",
      c_initb_val => "0",
      c_interface_type => 0,
      c_load_init_file => 1,
      c_mem_type => 0,
      c_mux_pipeline_stages => 0,
      c_prim_type => 1,
      c_read_depth_a => 512,
      c_read_depth_b => 512,
      c_read_width_a => 1,
      c_read_width_b => 1,
      c_rst_priority_a => "CE",
      c_rst_priority_b => "CE",
      c_rst_type => "SYNC",
      c_rstram_a => 0,
      c_rstram_b => 0,
      c_sim_collision_check => "ALL",
      c_use_byte_wea => 0,
      c_use_byte_web => 0,
      c_use_default_data => 0,
      c_use_ecc => 0,
      c_use_softecc => 0,
      c_wea_width => 1,
      c_web_width => 1,
      c_write_depth_a => 512,
      c_write_depth_b => 512,
      c_write_mode_a => "READ_FIRST",
      c_write_mode_b => "WRITE_FIRST",
      c_write_width_a => 1,
      c_write_width_b => 1,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_72_79627314d23ed512
  PORT MAP (
    clka => clka,
    ena => ena,
    wea => wea,
    addra => addra,
    dina => dina,
    douta => douta
  );
-- synthesis translate_on

END bmg_72_79627314d23ed512_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_72_b40f882ae90aebcf.vhd when simulating
-- the core, bmg_72_b40f882ae90aebcf. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_72_b40f882ae90aebcf IS
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(15 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(15 DOWNTO 0)
  );
END bmg_72_b40f882ae90aebcf;

ARCHITECTURE bmg_72_b40f882ae90aebcf_a OF bmg_72_b40f882ae90aebcf IS
-- synthesis translate_off
COMPONENT wrapped_bmg_72_b40f882ae90aebcf
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(15 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(15 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_bmg_72_b40f882ae90aebcf USE ENTITY XilinxCoreLib.blk_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addra_width => 8,
      c_addrb_width => 8,
      c_algorithm => 0,
      c_axi_id_width => 4,
      c_axi_slave_type => 0,
      c_axi_type => 1,
      c_byte_size => 9,
      c_common_clk => 0,
      c_default_data => "0",
      c_disable_warn_bhv_coll => 0,
      c_disable_warn_bhv_range => 0,
      c_enable_32bit_address => 0,
      c_family => "virtex6",
      c_has_axi_id => 0,
      c_has_ena => 1,
      c_has_enb => 0,
      c_has_injecterr => 0,
      c_has_mem_output_regs_a => 1,
      c_has_mem_output_regs_b => 0,
      c_has_mux_output_regs_a => 0,
      c_has_mux_output_regs_b => 0,
      c_has_regcea => 0,
      c_has_regceb => 0,
      c_has_rsta => 0,
      c_has_rstb => 0,
      c_has_softecc_input_regs_a => 0,
      c_has_softecc_output_regs_b => 0,
      c_init_file_name => "bmg_72_b40f882ae90aebcf.mif",
      c_inita_val => "0",
      c_initb_val => "0",
      c_interface_type => 0,
      c_load_init_file => 1,
      c_mem_type => 0,
      c_mux_pipeline_stages => 0,
      c_prim_type => 5,
      c_read_depth_a => 256,
      c_read_depth_b => 256,
      c_read_width_a => 16,
      c_read_width_b => 16,
      c_rst_priority_a => "CE",
      c_rst_priority_b => "CE",
      c_rst_type => "SYNC",
      c_rstram_a => 0,
      c_rstram_b => 0,
      c_sim_collision_check => "ALL",
      c_use_byte_wea => 0,
      c_use_byte_web => 0,
      c_use_default_data => 0,
      c_use_ecc => 0,
      c_use_softecc => 0,
      c_wea_width => 1,
      c_web_width => 1,
      c_write_depth_a => 256,
      c_write_depth_b => 256,
      c_write_mode_a => "NO_CHANGE",
      c_write_mode_b => "WRITE_FIRST",
      c_write_width_a => 16,
      c_write_width_b => 16,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_72_b40f882ae90aebcf
  PORT MAP (
    clka => clka,
    ena => ena,
    wea => wea,
    addra => addra,
    dina => dina,
    douta => douta
  );
-- synthesis translate_on

END bmg_72_b40f882ae90aebcf_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file cntr_11_0_198c863c3eaf9bde.vhd when simulating
-- the core, cntr_11_0_198c863c3eaf9bde. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY cntr_11_0_198c863c3eaf9bde IS
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sinit : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(8 DOWNTO 0)
  );
END cntr_11_0_198c863c3eaf9bde;

ARCHITECTURE cntr_11_0_198c863c3eaf9bde_a OF cntr_11_0_198c863c3eaf9bde IS
-- synthesis translate_off
COMPONENT wrapped_cntr_11_0_198c863c3eaf9bde
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sinit : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(8 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_cntr_11_0_198c863c3eaf9bde USE ENTITY XilinxCoreLib.c_counter_binary_v11_0(behavioral)
    GENERIC MAP (
      c_ainit_val => "0",
      c_ce_overrides_sync => 0,
      c_count_by => "1",
      c_count_mode => 0,
      c_count_to => "1",
      c_fb_latency => 0,
      c_has_ce => 1,
      c_has_load => 0,
      c_has_sclr => 0,
      c_has_sinit => 1,
      c_has_sset => 0,
      c_has_thresh0 => 0,
      c_implementation => 0,
      c_latency => 1,
      c_load_low => 0,
      c_restrict_count => 0,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_thresh0_value => "1",
      c_verbosity => 0,
      c_width => 9,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_cntr_11_0_198c863c3eaf9bde
  PORT MAP (
    clk => clk,
    ce => ce,
    sinit => sinit,
    q => q
  );
-- synthesis translate_on

END cntr_11_0_198c863c3eaf9bde_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file addsb_11_0_905959d61544ac3e.vhd when simulating
-- the core, addsb_11_0_905959d61544ac3e. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY addsb_11_0_905959d61544ac3e IS
  PORT (
    a : IN STD_LOGIC_VECTOR(39 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(39 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(39 DOWNTO 0)
  );
END addsb_11_0_905959d61544ac3e;

ARCHITECTURE addsb_11_0_905959d61544ac3e_a OF addsb_11_0_905959d61544ac3e IS
-- synthesis translate_off
COMPONENT wrapped_addsb_11_0_905959d61544ac3e
  PORT (
    a : IN STD_LOGIC_VECTOR(39 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(39 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(39 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_addsb_11_0_905959d61544ac3e USE ENTITY XilinxCoreLib.c_addsub_v11_0(behavioral)
    GENERIC MAP (
      c_a_type => 0,
      c_a_width => 40,
      c_add_mode => 1,
      c_ainit_val => "0",
      c_b_constant => 0,
      c_b_type => 0,
      c_b_value => "0000000000000000000000000000000000000000",
      c_b_width => 40,
      c_borrow_low => 1,
      c_bypass_low => 0,
      c_ce_overrides_bypass => 1,
      c_ce_overrides_sclr => 0,
      c_has_bypass => 0,
      c_has_c_in => 0,
      c_has_c_out => 0,
      c_has_ce => 1,
      c_has_sclr => 0,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_implementation => 0,
      c_latency => 1,
      c_out_width => 40,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_addsb_11_0_905959d61544ac3e
  PORT MAP (
    a => a,
    b => b,
    clk => clk,
    ce => ce,
    s => s
  );
-- synthesis translate_on

END addsb_11_0_905959d61544ac3e_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file addsb_11_0_f71caeff01210ab2.vhd when simulating
-- the core, addsb_11_0_f71caeff01210ab2. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY addsb_11_0_f71caeff01210ab2 IS
  PORT (
    a : IN STD_LOGIC_VECTOR(36 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(36 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(36 DOWNTO 0)
  );
END addsb_11_0_f71caeff01210ab2;

ARCHITECTURE addsb_11_0_f71caeff01210ab2_a OF addsb_11_0_f71caeff01210ab2 IS
-- synthesis translate_off
COMPONENT wrapped_addsb_11_0_f71caeff01210ab2
  PORT (
    a : IN STD_LOGIC_VECTOR(36 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(36 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(36 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_addsb_11_0_f71caeff01210ab2 USE ENTITY XilinxCoreLib.c_addsub_v11_0(behavioral)
    GENERIC MAP (
      c_a_type => 0,
      c_a_width => 37,
      c_add_mode => 0,
      c_ainit_val => "0",
      c_b_constant => 0,
      c_b_type => 0,
      c_b_value => "0000000000000000000000000000000000000",
      c_b_width => 37,
      c_borrow_low => 1,
      c_bypass_low => 0,
      c_ce_overrides_bypass => 1,
      c_ce_overrides_sclr => 0,
      c_has_bypass => 0,
      c_has_c_in => 0,
      c_has_c_out => 0,
      c_has_ce => 1,
      c_has_sclr => 0,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_implementation => 1,
      c_latency => 2,
      c_out_width => 37,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_addsb_11_0_f71caeff01210ab2
  PORT MAP (
    a => a,
    b => b,
    clk => clk,
    ce => ce,
    s => s
  );
-- synthesis translate_on

END addsb_11_0_f71caeff01210ab2_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file addsb_11_0_12579c2539e3bba1.vhd when simulating
-- the core, addsb_11_0_12579c2539e3bba1. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY addsb_11_0_12579c2539e3bba1 IS
  PORT (
    a : IN STD_LOGIC_VECTOR(34 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(34 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(34 DOWNTO 0)
  );
END addsb_11_0_12579c2539e3bba1;

ARCHITECTURE addsb_11_0_12579c2539e3bba1_a OF addsb_11_0_12579c2539e3bba1 IS
-- synthesis translate_off
COMPONENT wrapped_addsb_11_0_12579c2539e3bba1
  PORT (
    a : IN STD_LOGIC_VECTOR(34 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(34 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(34 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_addsb_11_0_12579c2539e3bba1 USE ENTITY XilinxCoreLib.c_addsub_v11_0(behavioral)
    GENERIC MAP (
      c_a_type => 0,
      c_a_width => 35,
      c_add_mode => 1,
      c_ainit_val => "0",
      c_b_constant => 0,
      c_b_type => 0,
      c_b_value => "00000000000000000000000000000000000",
      c_b_width => 35,
      c_borrow_low => 1,
      c_bypass_low => 0,
      c_ce_overrides_bypass => 1,
      c_ce_overrides_sclr => 0,
      c_has_bypass => 0,
      c_has_c_in => 0,
      c_has_c_out => 0,
      c_has_ce => 1,
      c_has_sclr => 0,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_implementation => 1,
      c_latency => 2,
      c_out_width => 35,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_addsb_11_0_12579c2539e3bba1
  PORT MAP (
    a => a,
    b => b,
    clk => clk,
    ce => ce,
    s => s
  );
-- synthesis translate_on

END addsb_11_0_12579c2539e3bba1_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file cntr_11_0_9e131a76d2321c17.vhd when simulating
-- the core, cntr_11_0_9e131a76d2321c17. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY cntr_11_0_9e131a76d2321c17 IS
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(9 DOWNTO 0)
  );
END cntr_11_0_9e131a76d2321c17;

ARCHITECTURE cntr_11_0_9e131a76d2321c17_a OF cntr_11_0_9e131a76d2321c17 IS
-- synthesis translate_off
COMPONENT wrapped_cntr_11_0_9e131a76d2321c17
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(9 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_cntr_11_0_9e131a76d2321c17 USE ENTITY XilinxCoreLib.c_counter_binary_v11_0(behavioral)
    GENERIC MAP (
      c_ainit_val => "0",
      c_ce_overrides_sync => 0,
      c_count_by => "1",
      c_count_mode => 0,
      c_count_to => "1",
      c_fb_latency => 0,
      c_has_ce => 1,
      c_has_load => 0,
      c_has_sclr => 1,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_has_thresh0 => 0,
      c_implementation => 1,
      c_latency => 1,
      c_load_low => 0,
      c_restrict_count => 0,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_thresh0_value => "1",
      c_verbosity => 0,
      c_width => 10,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_cntr_11_0_9e131a76d2321c17
  PORT MAP (
    clk => clk,
    ce => ce,
    sclr => sclr,
    q => q
  );
-- synthesis translate_on

END cntr_11_0_9e131a76d2321c17_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file addsb_11_0_ccc02b0ec9bb7d2f.vhd when simulating
-- the core, addsb_11_0_ccc02b0ec9bb7d2f. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY addsb_11_0_ccc02b0ec9bb7d2f IS
  PORT (
    a : IN STD_LOGIC_VECTOR(13 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(13 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(13 DOWNTO 0)
  );
END addsb_11_0_ccc02b0ec9bb7d2f;

ARCHITECTURE addsb_11_0_ccc02b0ec9bb7d2f_a OF addsb_11_0_ccc02b0ec9bb7d2f IS
-- synthesis translate_off
COMPONENT wrapped_addsb_11_0_ccc02b0ec9bb7d2f
  PORT (
    a : IN STD_LOGIC_VECTOR(13 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(13 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(13 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_addsb_11_0_ccc02b0ec9bb7d2f USE ENTITY XilinxCoreLib.c_addsub_v11_0(behavioral)
    GENERIC MAP (
      c_a_type => 1,
      c_a_width => 14,
      c_add_mode => 0,
      c_ainit_val => "0",
      c_b_constant => 0,
      c_b_type => 1,
      c_b_value => "00000000000000",
      c_b_width => 14,
      c_borrow_low => 1,
      c_bypass_low => 0,
      c_ce_overrides_bypass => 1,
      c_ce_overrides_sclr => 0,
      c_has_bypass => 0,
      c_has_c_in => 0,
      c_has_c_out => 0,
      c_has_ce => 1,
      c_has_sclr => 0,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_implementation => 0,
      c_latency => 1,
      c_out_width => 14,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_addsb_11_0_ccc02b0ec9bb7d2f
  PORT MAP (
    a => a,
    b => b,
    clk => clk,
    ce => ce,
    s => s
  );
-- synthesis translate_on

END addsb_11_0_ccc02b0ec9bb7d2f_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file cntr_11_0_4d961a297cbb815e.vhd when simulating
-- the core, cntr_11_0_4d961a297cbb815e. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY cntr_11_0_4d961a297cbb815e IS
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(27 DOWNTO 0)
  );
END cntr_11_0_4d961a297cbb815e;

ARCHITECTURE cntr_11_0_4d961a297cbb815e_a OF cntr_11_0_4d961a297cbb815e IS
-- synthesis translate_off
COMPONENT wrapped_cntr_11_0_4d961a297cbb815e
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(27 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_cntr_11_0_4d961a297cbb815e USE ENTITY XilinxCoreLib.c_counter_binary_v11_0(behavioral)
    GENERIC MAP (
      c_ainit_val => "0",
      c_ce_overrides_sync => 0,
      c_count_by => "1",
      c_count_mode => 0,
      c_count_to => "1",
      c_fb_latency => 0,
      c_has_ce => 1,
      c_has_load => 0,
      c_has_sclr => 1,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_has_thresh0 => 0,
      c_implementation => 1,
      c_latency => 1,
      c_load_low => 0,
      c_restrict_count => 0,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_thresh0_value => "1",
      c_verbosity => 0,
      c_width => 28,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_cntr_11_0_4d961a297cbb815e
  PORT MAP (
    clk => clk,
    ce => ce,
    sclr => sclr,
    q => q
  );
-- synthesis translate_on

END cntr_11_0_4d961a297cbb815e_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file cntr_11_0_564d43d07a40ef72.vhd when simulating
-- the core, cntr_11_0_564d43d07a40ef72. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY cntr_11_0_564d43d07a40ef72 IS
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sinit : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(7 DOWNTO 0)
  );
END cntr_11_0_564d43d07a40ef72;

ARCHITECTURE cntr_11_0_564d43d07a40ef72_a OF cntr_11_0_564d43d07a40ef72 IS
-- synthesis translate_off
COMPONENT wrapped_cntr_11_0_564d43d07a40ef72
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sinit : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(7 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_cntr_11_0_564d43d07a40ef72 USE ENTITY XilinxCoreLib.c_counter_binary_v11_0(behavioral)
    GENERIC MAP (
      c_ainit_val => "0",
      c_ce_overrides_sync => 0,
      c_count_by => "1",
      c_count_mode => 0,
      c_count_to => "1",
      c_fb_latency => 0,
      c_has_ce => 1,
      c_has_load => 0,
      c_has_sclr => 0,
      c_has_sinit => 1,
      c_has_sset => 0,
      c_has_thresh0 => 0,
      c_implementation => 0,
      c_latency => 1,
      c_load_low => 0,
      c_restrict_count => 0,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_thresh0_value => "1",
      c_verbosity => 0,
      c_width => 8,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_cntr_11_0_564d43d07a40ef72
  PORT MAP (
    clk => clk,
    ce => ce,
    sinit => sinit,
    q => q
  );
-- synthesis translate_on

END cntr_11_0_564d43d07a40ef72_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file cmlt_11_2_4ea31a3fb6c988bc.vhd when simulating
-- the core, cmlt_11_2_4ea31a3fb6c988bc. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY cmlt_11_2_4ea31a3fb6c988bc IS
  PORT (
    clk : IN STD_LOGIC;
    a : IN STD_LOGIC_VECTOR(32 DOWNTO 0);
    ce : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    p : OUT STD_LOGIC_VECTOR(43 DOWNTO 0)
  );
END cmlt_11_2_4ea31a3fb6c988bc;

ARCHITECTURE cmlt_11_2_4ea31a3fb6c988bc_a OF cmlt_11_2_4ea31a3fb6c988bc IS
-- synthesis translate_off
COMPONENT wrapped_cmlt_11_2_4ea31a3fb6c988bc
  PORT (
    clk : IN STD_LOGIC;
    a : IN STD_LOGIC_VECTOR(32 DOWNTO 0);
    ce : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    p : OUT STD_LOGIC_VECTOR(43 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_cmlt_11_2_4ea31a3fb6c988bc USE ENTITY XilinxCoreLib.mult_gen_v11_2(behavioral)
    GENERIC MAP (
      c_a_type => 1,
      c_a_width => 33,
      c_b_type => 1,
      c_b_value => "11111010000",
      c_b_width => 11,
      c_ccm_imp => 0,
      c_ce_overrides_sclr => 0,
      c_has_ce => 1,
      c_has_sclr => 1,
      c_has_zero_detect => 0,
      c_latency => 2,
      c_model_type => 0,
      c_mult_type => 2,
      c_optimize_goal => 1,
      c_out_high => 43,
      c_out_low => 0,
      c_round_output => 0,
      c_round_pt => 0,
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_cmlt_11_2_4ea31a3fb6c988bc
  PORT MAP (
    clk => clk,
    a => a,
    ce => ce,
    sclr => sclr,
    p => p
  );
-- synthesis translate_on

END cmlt_11_2_4ea31a3fb6c988bc_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file addsb_11_0_ce88f01554f26992.vhd when simulating
-- the core, addsb_11_0_ce88f01554f26992. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY addsb_11_0_ce88f01554f26992 IS
  PORT (
    a : IN STD_LOGIC_VECTOR(16 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(16 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(16 DOWNTO 0)
  );
END addsb_11_0_ce88f01554f26992;

ARCHITECTURE addsb_11_0_ce88f01554f26992_a OF addsb_11_0_ce88f01554f26992 IS
-- synthesis translate_off
COMPONENT wrapped_addsb_11_0_ce88f01554f26992
  PORT (
    a : IN STD_LOGIC_VECTOR(16 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(16 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(16 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_addsb_11_0_ce88f01554f26992 USE ENTITY XilinxCoreLib.c_addsub_v11_0(behavioral)
    GENERIC MAP (
      c_a_type => 0,
      c_a_width => 17,
      c_add_mode => 1,
      c_ainit_val => "0",
      c_b_constant => 0,
      c_b_type => 0,
      c_b_value => "00000000000000000",
      c_b_width => 17,
      c_borrow_low => 1,
      c_bypass_low => 0,
      c_ce_overrides_bypass => 1,
      c_ce_overrides_sclr => 0,
      c_has_bypass => 0,
      c_has_c_in => 0,
      c_has_c_out => 0,
      c_has_ce => 1,
      c_has_sclr => 0,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_implementation => 1,
      c_latency => 2,
      c_out_width => 17,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_addsb_11_0_ce88f01554f26992
  PORT MAP (
    a => a,
    b => b,
    clk => clk,
    ce => ce,
    s => s
  );
-- synthesis translate_on

END addsb_11_0_ce88f01554f26992_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file addsb_11_0_ca3b6f528ea85846.vhd when simulating
-- the core, addsb_11_0_ca3b6f528ea85846. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY addsb_11_0_ca3b6f528ea85846 IS
  PORT (
    a : IN STD_LOGIC_VECTOR(36 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(36 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(36 DOWNTO 0)
  );
END addsb_11_0_ca3b6f528ea85846;

ARCHITECTURE addsb_11_0_ca3b6f528ea85846_a OF addsb_11_0_ca3b6f528ea85846 IS
-- synthesis translate_off
COMPONENT wrapped_addsb_11_0_ca3b6f528ea85846
  PORT (
    a : IN STD_LOGIC_VECTOR(36 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(36 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(36 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_addsb_11_0_ca3b6f528ea85846 USE ENTITY XilinxCoreLib.c_addsub_v11_0(behavioral)
    GENERIC MAP (
      c_a_type => 1,
      c_a_width => 37,
      c_add_mode => 0,
      c_ainit_val => "0",
      c_b_constant => 0,
      c_b_type => 1,
      c_b_value => "0000000000000000000000000000000000000",
      c_b_width => 37,
      c_borrow_low => 1,
      c_bypass_low => 0,
      c_ce_overrides_bypass => 1,
      c_ce_overrides_sclr => 0,
      c_has_bypass => 0,
      c_has_c_in => 0,
      c_has_c_out => 0,
      c_has_ce => 1,
      c_has_sclr => 0,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_implementation => 0,
      c_latency => 1,
      c_out_width => 37,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_addsb_11_0_ca3b6f528ea85846
  PORT MAP (
    a => a,
    b => b,
    clk => clk,
    ce => ce,
    s => s
  );
-- synthesis translate_on

END addsb_11_0_ca3b6f528ea85846_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file cntr_11_0_45eea7380a7f544c.vhd when simulating
-- the core, cntr_11_0_45eea7380a7f544c. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY cntr_11_0_45eea7380a7f544c IS
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(19 DOWNTO 0)
  );
END cntr_11_0_45eea7380a7f544c;

ARCHITECTURE cntr_11_0_45eea7380a7f544c_a OF cntr_11_0_45eea7380a7f544c IS
-- synthesis translate_off
COMPONENT wrapped_cntr_11_0_45eea7380a7f544c
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(19 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_cntr_11_0_45eea7380a7f544c USE ENTITY XilinxCoreLib.c_counter_binary_v11_0(behavioral)
    GENERIC MAP (
      c_ainit_val => "0",
      c_ce_overrides_sync => 0,
      c_count_by => "1",
      c_count_mode => 0,
      c_count_to => "1",
      c_fb_latency => 0,
      c_has_ce => 1,
      c_has_load => 0,
      c_has_sclr => 1,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_has_thresh0 => 0,
      c_implementation => 1,
      c_latency => 1,
      c_load_low => 0,
      c_restrict_count => 0,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_thresh0_value => "1",
      c_verbosity => 0,
      c_width => 20,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_cntr_11_0_45eea7380a7f544c
  PORT MAP (
    clk => clk,
    ce => ce,
    sclr => sclr,
    q => q
  );
-- synthesis translate_on

END cntr_11_0_45eea7380a7f544c_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file cntr_11_0_c0e13dbe8d12400d.vhd when simulating
-- the core, cntr_11_0_c0e13dbe8d12400d. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY cntr_11_0_c0e13dbe8d12400d IS
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(14 DOWNTO 0)
  );
END cntr_11_0_c0e13dbe8d12400d;

ARCHITECTURE cntr_11_0_c0e13dbe8d12400d_a OF cntr_11_0_c0e13dbe8d12400d IS
-- synthesis translate_off
COMPONENT wrapped_cntr_11_0_c0e13dbe8d12400d
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(14 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_cntr_11_0_c0e13dbe8d12400d USE ENTITY XilinxCoreLib.c_counter_binary_v11_0(behavioral)
    GENERIC MAP (
      c_ainit_val => "0",
      c_ce_overrides_sync => 0,
      c_count_by => "1",
      c_count_mode => 0,
      c_count_to => "1",
      c_fb_latency => 0,
      c_has_ce => 1,
      c_has_load => 0,
      c_has_sclr => 1,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_has_thresh0 => 0,
      c_implementation => 1,
      c_latency => 1,
      c_load_low => 0,
      c_restrict_count => 0,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_thresh0_value => "1",
      c_verbosity => 0,
      c_width => 15,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_cntr_11_0_c0e13dbe8d12400d
  PORT MAP (
    clk => clk,
    ce => ce,
    sclr => sclr,
    q => q
  );
-- synthesis translate_on

END cntr_11_0_c0e13dbe8d12400d_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_72_88f9a9ffe68f6b35.vhd when simulating
-- the core, bmg_72_88f9a9ffe68f6b35. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_72_88f9a9ffe68f6b35 IS
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(31 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(31 DOWNTO 0)
  );
END bmg_72_88f9a9ffe68f6b35;

ARCHITECTURE bmg_72_88f9a9ffe68f6b35_a OF bmg_72_88f9a9ffe68f6b35 IS
-- synthesis translate_off
COMPONENT wrapped_bmg_72_88f9a9ffe68f6b35
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(31 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(31 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_bmg_72_88f9a9ffe68f6b35 USE ENTITY XilinxCoreLib.blk_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addra_width => 8,
      c_addrb_width => 8,
      c_algorithm => 0,
      c_axi_id_width => 4,
      c_axi_slave_type => 0,
      c_axi_type => 1,
      c_byte_size => 9,
      c_common_clk => 0,
      c_default_data => "0",
      c_disable_warn_bhv_coll => 0,
      c_disable_warn_bhv_range => 0,
      c_enable_32bit_address => 0,
      c_family => "virtex6",
      c_has_axi_id => 0,
      c_has_ena => 1,
      c_has_enb => 0,
      c_has_injecterr => 0,
      c_has_mem_output_regs_a => 1,
      c_has_mem_output_regs_b => 0,
      c_has_mux_output_regs_a => 0,
      c_has_mux_output_regs_b => 0,
      c_has_regcea => 0,
      c_has_regceb => 0,
      c_has_rsta => 0,
      c_has_rstb => 0,
      c_has_softecc_input_regs_a => 0,
      c_has_softecc_output_regs_b => 0,
      c_init_file_name => "bmg_72_88f9a9ffe68f6b35.mif",
      c_inita_val => "0",
      c_initb_val => "0",
      c_interface_type => 0,
      c_load_init_file => 1,
      c_mem_type => 0,
      c_mux_pipeline_stages => 0,
      c_prim_type => 5,
      c_read_depth_a => 256,
      c_read_depth_b => 256,
      c_read_width_a => 32,
      c_read_width_b => 32,
      c_rst_priority_a => "CE",
      c_rst_priority_b => "CE",
      c_rst_type => "SYNC",
      c_rstram_a => 0,
      c_rstram_b => 0,
      c_sim_collision_check => "ALL",
      c_use_byte_wea => 0,
      c_use_byte_web => 0,
      c_use_default_data => 0,
      c_use_ecc => 0,
      c_use_softecc => 0,
      c_wea_width => 1,
      c_web_width => 1,
      c_write_depth_a => 256,
      c_write_depth_b => 256,
      c_write_mode_a => "NO_CHANGE",
      c_write_mode_b => "WRITE_FIRST",
      c_write_width_a => 32,
      c_write_width_b => 32,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_72_88f9a9ffe68f6b35
  PORT MAP (
    clka => clka,
    ena => ena,
    wea => wea,
    addra => addra,
    dina => dina,
    douta => douta
  );
-- synthesis translate_on

END bmg_72_88f9a9ffe68f6b35_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file cntr_11_0_0e7aae3b0f9694f8.vhd when simulating
-- the core, cntr_11_0_0e7aae3b0f9694f8. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY cntr_11_0_0e7aae3b0f9694f8 IS
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(11 DOWNTO 0)
  );
END cntr_11_0_0e7aae3b0f9694f8;

ARCHITECTURE cntr_11_0_0e7aae3b0f9694f8_a OF cntr_11_0_0e7aae3b0f9694f8 IS
-- synthesis translate_off
COMPONENT wrapped_cntr_11_0_0e7aae3b0f9694f8
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(11 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_cntr_11_0_0e7aae3b0f9694f8 USE ENTITY XilinxCoreLib.c_counter_binary_v11_0(behavioral)
    GENERIC MAP (
      c_ainit_val => "0",
      c_ce_overrides_sync => 0,
      c_count_by => "1",
      c_count_mode => 0,
      c_count_to => "1",
      c_fb_latency => 0,
      c_has_ce => 1,
      c_has_load => 0,
      c_has_sclr => 1,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_has_thresh0 => 0,
      c_implementation => 1,
      c_latency => 1,
      c_load_low => 0,
      c_restrict_count => 0,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_thresh0_value => "1",
      c_verbosity => 0,
      c_width => 12,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_cntr_11_0_0e7aae3b0f9694f8
  PORT MAP (
    clk => clk,
    ce => ce,
    sclr => sclr,
    q => q
  );
-- synthesis translate_on

END cntr_11_0_0e7aae3b0f9694f8_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file cntr_11_0_ca10e447a1c1c04f.vhd when simulating
-- the core, cntr_11_0_ca10e447a1c1c04f. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY cntr_11_0_ca10e447a1c1c04f IS
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(8 DOWNTO 0)
  );
END cntr_11_0_ca10e447a1c1c04f;

ARCHITECTURE cntr_11_0_ca10e447a1c1c04f_a OF cntr_11_0_ca10e447a1c1c04f IS
-- synthesis translate_off
COMPONENT wrapped_cntr_11_0_ca10e447a1c1c04f
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(8 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_cntr_11_0_ca10e447a1c1c04f USE ENTITY XilinxCoreLib.c_counter_binary_v11_0(behavioral)
    GENERIC MAP (
      c_ainit_val => "0",
      c_ce_overrides_sync => 0,
      c_count_by => "1",
      c_count_mode => 0,
      c_count_to => "1",
      c_fb_latency => 0,
      c_has_ce => 1,
      c_has_load => 0,
      c_has_sclr => 1,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_has_thresh0 => 0,
      c_implementation => 1,
      c_latency => 1,
      c_load_low => 0,
      c_restrict_count => 0,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_thresh0_value => "1",
      c_verbosity => 0,
      c_width => 9,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_cntr_11_0_ca10e447a1c1c04f
  PORT MAP (
    clk => clk,
    ce => ce,
    sclr => sclr,
    q => q
  );
-- synthesis translate_on

END cntr_11_0_ca10e447a1c1c04f_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_72_6496c8c9773931f5.vhd when simulating
-- the core, bmg_72_6496c8c9773931f5. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_72_6496c8c9773931f5 IS
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(8 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(7 DOWNTO 0)
  );
END bmg_72_6496c8c9773931f5;

ARCHITECTURE bmg_72_6496c8c9773931f5_a OF bmg_72_6496c8c9773931f5 IS
-- synthesis translate_off
COMPONENT wrapped_bmg_72_6496c8c9773931f5
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(8 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(7 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_bmg_72_6496c8c9773931f5 USE ENTITY XilinxCoreLib.blk_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addra_width => 9,
      c_addrb_width => 9,
      c_algorithm => 1,
      c_axi_id_width => 4,
      c_axi_slave_type => 0,
      c_axi_type => 1,
      c_byte_size => 9,
      c_common_clk => 0,
      c_default_data => "0",
      c_disable_warn_bhv_coll => 0,
      c_disable_warn_bhv_range => 0,
      c_enable_32bit_address => 0,
      c_family => "virtex6",
      c_has_axi_id => 0,
      c_has_ena => 1,
      c_has_enb => 0,
      c_has_injecterr => 0,
      c_has_mem_output_regs_a => 1,
      c_has_mem_output_regs_b => 0,
      c_has_mux_output_regs_a => 0,
      c_has_mux_output_regs_b => 0,
      c_has_regcea => 0,
      c_has_regceb => 0,
      c_has_rsta => 0,
      c_has_rstb => 0,
      c_has_softecc_input_regs_a => 0,
      c_has_softecc_output_regs_b => 0,
      c_init_file_name => "bmg_72_6496c8c9773931f5.mif",
      c_inita_val => "0",
      c_initb_val => "0",
      c_interface_type => 0,
      c_load_init_file => 1,
      c_mem_type => 0,
      c_mux_pipeline_stages => 0,
      c_prim_type => 1,
      c_read_depth_a => 512,
      c_read_depth_b => 512,
      c_read_width_a => 8,
      c_read_width_b => 8,
      c_rst_priority_a => "CE",
      c_rst_priority_b => "CE",
      c_rst_type => "SYNC",
      c_rstram_a => 0,
      c_rstram_b => 0,
      c_sim_collision_check => "ALL",
      c_use_byte_wea => 0,
      c_use_byte_web => 0,
      c_use_default_data => 0,
      c_use_ecc => 0,
      c_use_softecc => 0,
      c_wea_width => 1,
      c_web_width => 1,
      c_write_depth_a => 512,
      c_write_depth_b => 512,
      c_write_mode_a => "READ_FIRST",
      c_write_mode_b => "WRITE_FIRST",
      c_write_width_a => 8,
      c_write_width_b => 8,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_72_6496c8c9773931f5
  PORT MAP (
    clka => clka,
    ena => ena,
    wea => wea,
    addra => addra,
    dina => dina,
    douta => douta
  );
-- synthesis translate_on

END bmg_72_6496c8c9773931f5_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file cntr_11_0_9ca51386af2c7a71.vhd when simulating
-- the core, cntr_11_0_9ca51386af2c7a71. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY cntr_11_0_9ca51386af2c7a71 IS
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(31 DOWNTO 0)
  );
END cntr_11_0_9ca51386af2c7a71;

ARCHITECTURE cntr_11_0_9ca51386af2c7a71_a OF cntr_11_0_9ca51386af2c7a71 IS
-- synthesis translate_off
COMPONENT wrapped_cntr_11_0_9ca51386af2c7a71
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(31 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_cntr_11_0_9ca51386af2c7a71 USE ENTITY XilinxCoreLib.c_counter_binary_v11_0(behavioral)
    GENERIC MAP (
      c_ainit_val => "0",
      c_ce_overrides_sync => 0,
      c_count_by => "1",
      c_count_mode => 0,
      c_count_to => "1",
      c_fb_latency => 0,
      c_has_ce => 1,
      c_has_load => 0,
      c_has_sclr => 1,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_has_thresh0 => 0,
      c_implementation => 1,
      c_latency => 1,
      c_load_low => 0,
      c_restrict_count => 0,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_thresh0_value => "1",
      c_verbosity => 0,
      c_width => 32,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_cntr_11_0_9ca51386af2c7a71
  PORT MAP (
    clk => clk,
    ce => ce,
    sclr => sclr,
    q => q
  );
-- synthesis translate_on

END cntr_11_0_9ca51386af2c7a71_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file cntr_11_0_b8dff8f48773e3e9.vhd when simulating
-- the core, cntr_11_0_b8dff8f48773e3e9. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY cntr_11_0_b8dff8f48773e3e9 IS
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sinit : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(2 DOWNTO 0)
  );
END cntr_11_0_b8dff8f48773e3e9;

ARCHITECTURE cntr_11_0_b8dff8f48773e3e9_a OF cntr_11_0_b8dff8f48773e3e9 IS
-- synthesis translate_off
COMPONENT wrapped_cntr_11_0_b8dff8f48773e3e9
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sinit : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(2 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_cntr_11_0_b8dff8f48773e3e9 USE ENTITY XilinxCoreLib.c_counter_binary_v11_0(behavioral)
    GENERIC MAP (
      c_ainit_val => "0",
      c_ce_overrides_sync => 0,
      c_count_by => "1",
      c_count_mode => 0,
      c_count_to => "1",
      c_fb_latency => 0,
      c_has_ce => 1,
      c_has_load => 0,
      c_has_sclr => 0,
      c_has_sinit => 1,
      c_has_sset => 0,
      c_has_thresh0 => 0,
      c_implementation => 0,
      c_latency => 1,
      c_load_low => 0,
      c_restrict_count => 0,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_thresh0_value => "1",
      c_verbosity => 0,
      c_width => 3,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_cntr_11_0_b8dff8f48773e3e9
  PORT MAP (
    clk => clk,
    ce => ce,
    sinit => sinit,
    q => q
  );
-- synthesis translate_on

END cntr_11_0_b8dff8f48773e3e9_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file addsb_11_0_7a7e9e33c32e594c.vhd when simulating
-- the core, addsb_11_0_7a7e9e33c32e594c. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY addsb_11_0_7a7e9e33c32e594c IS
  PORT (
    a : IN STD_LOGIC_VECTOR(19 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(19 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(19 DOWNTO 0)
  );
END addsb_11_0_7a7e9e33c32e594c;

ARCHITECTURE addsb_11_0_7a7e9e33c32e594c_a OF addsb_11_0_7a7e9e33c32e594c IS
-- synthesis translate_off
COMPONENT wrapped_addsb_11_0_7a7e9e33c32e594c
  PORT (
    a : IN STD_LOGIC_VECTOR(19 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(19 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(19 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_addsb_11_0_7a7e9e33c32e594c USE ENTITY XilinxCoreLib.c_addsub_v11_0(behavioral)
    GENERIC MAP (
      c_a_type => 0,
      c_a_width => 20,
      c_add_mode => 1,
      c_ainit_val => "0",
      c_b_constant => 0,
      c_b_type => 0,
      c_b_value => "00000000000000000000",
      c_b_width => 20,
      c_borrow_low => 1,
      c_bypass_low => 0,
      c_ce_overrides_bypass => 1,
      c_ce_overrides_sclr => 0,
      c_has_bypass => 0,
      c_has_c_in => 0,
      c_has_c_out => 0,
      c_has_ce => 1,
      c_has_sclr => 0,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_implementation => 1,
      c_latency => 2,
      c_out_width => 20,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_addsb_11_0_7a7e9e33c32e594c
  PORT MAP (
    a => a,
    b => b,
    clk => clk,
    ce => ce,
    s => s
  );
-- synthesis translate_on

END addsb_11_0_7a7e9e33c32e594c_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file addsb_11_0_62b4a1a618c40b84.vhd when simulating
-- the core, addsb_11_0_62b4a1a618c40b84. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY addsb_11_0_62b4a1a618c40b84 IS
  PORT (
    a : IN STD_LOGIC_VECTOR(32 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(32 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(32 DOWNTO 0)
  );
END addsb_11_0_62b4a1a618c40b84;

ARCHITECTURE addsb_11_0_62b4a1a618c40b84_a OF addsb_11_0_62b4a1a618c40b84 IS
-- synthesis translate_off
COMPONENT wrapped_addsb_11_0_62b4a1a618c40b84
  PORT (
    a : IN STD_LOGIC_VECTOR(32 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(32 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(32 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_addsb_11_0_62b4a1a618c40b84 USE ENTITY XilinxCoreLib.c_addsub_v11_0(behavioral)
    GENERIC MAP (
      c_a_type => 1,
      c_a_width => 33,
      c_add_mode => 0,
      c_ainit_val => "0",
      c_b_constant => 0,
      c_b_type => 1,
      c_b_value => "000000000000000000000000000000000",
      c_b_width => 33,
      c_borrow_low => 1,
      c_bypass_low => 0,
      c_ce_overrides_bypass => 1,
      c_ce_overrides_sclr => 0,
      c_has_bypass => 0,
      c_has_c_in => 0,
      c_has_c_out => 0,
      c_has_ce => 1,
      c_has_sclr => 0,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_implementation => 0,
      c_latency => 1,
      c_out_width => 33,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_addsb_11_0_62b4a1a618c40b84
  PORT MAP (
    a => a,
    b => b,
    clk => clk,
    ce => ce,
    s => s
  );
-- synthesis translate_on

END addsb_11_0_62b4a1a618c40b84_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_72_5886869123e35b2f.vhd when simulating
-- the core, bmg_72_5886869123e35b2f. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_72_5886869123e35b2f IS
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(0 DOWNTO 0)
  );
END bmg_72_5886869123e35b2f;

ARCHITECTURE bmg_72_5886869123e35b2f_a OF bmg_72_5886869123e35b2f IS
-- synthesis translate_off
COMPONENT wrapped_bmg_72_5886869123e35b2f
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(0 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_bmg_72_5886869123e35b2f USE ENTITY XilinxCoreLib.blk_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addra_width => 8,
      c_addrb_width => 8,
      c_algorithm => 1,
      c_axi_id_width => 4,
      c_axi_slave_type => 0,
      c_axi_type => 1,
      c_byte_size => 9,
      c_common_clk => 0,
      c_default_data => "0",
      c_disable_warn_bhv_coll => 0,
      c_disable_warn_bhv_range => 0,
      c_enable_32bit_address => 0,
      c_family => "virtex6",
      c_has_axi_id => 0,
      c_has_ena => 1,
      c_has_enb => 0,
      c_has_injecterr => 0,
      c_has_mem_output_regs_a => 1,
      c_has_mem_output_regs_b => 0,
      c_has_mux_output_regs_a => 0,
      c_has_mux_output_regs_b => 0,
      c_has_regcea => 0,
      c_has_regceb => 0,
      c_has_rsta => 0,
      c_has_rstb => 0,
      c_has_softecc_input_regs_a => 0,
      c_has_softecc_output_regs_b => 0,
      c_init_file_name => "bmg_72_5886869123e35b2f.mif",
      c_inita_val => "0",
      c_initb_val => "0",
      c_interface_type => 0,
      c_load_init_file => 1,
      c_mem_type => 0,
      c_mux_pipeline_stages => 0,
      c_prim_type => 1,
      c_read_depth_a => 256,
      c_read_depth_b => 256,
      c_read_width_a => 1,
      c_read_width_b => 1,
      c_rst_priority_a => "CE",
      c_rst_priority_b => "CE",
      c_rst_type => "SYNC",
      c_rstram_a => 0,
      c_rstram_b => 0,
      c_sim_collision_check => "ALL",
      c_use_byte_wea => 0,
      c_use_byte_web => 0,
      c_use_default_data => 0,
      c_use_ecc => 0,
      c_use_softecc => 0,
      c_wea_width => 1,
      c_web_width => 1,
      c_write_depth_a => 256,
      c_write_depth_b => 256,
      c_write_mode_a => "READ_FIRST",
      c_write_mode_b => "WRITE_FIRST",
      c_write_width_a => 1,
      c_write_width_b => 1,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_72_5886869123e35b2f
  PORT MAP (
    clka => clka,
    ena => ena,
    wea => wea,
    addra => addra,
    dina => dina,
    douta => douta
  );
-- synthesis translate_on

END bmg_72_5886869123e35b2f_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_72_4ed81b7c7b802023.vhd when simulating
-- the core, bmg_72_4ed81b7c7b802023. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_72_4ed81b7c7b802023 IS
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(71 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(71 DOWNTO 0)
  );
END bmg_72_4ed81b7c7b802023;

ARCHITECTURE bmg_72_4ed81b7c7b802023_a OF bmg_72_4ed81b7c7b802023 IS
-- synthesis translate_off
COMPONENT wrapped_bmg_72_4ed81b7c7b802023
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(71 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(71 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_bmg_72_4ed81b7c7b802023 USE ENTITY XilinxCoreLib.blk_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addra_width => 8,
      c_addrb_width => 8,
      c_algorithm => 0,
      c_axi_id_width => 4,
      c_axi_slave_type => 0,
      c_axi_type => 1,
      c_byte_size => 9,
      c_common_clk => 0,
      c_default_data => "0",
      c_disable_warn_bhv_coll => 0,
      c_disable_warn_bhv_range => 0,
      c_enable_32bit_address => 0,
      c_family => "virtex6",
      c_has_axi_id => 0,
      c_has_ena => 1,
      c_has_enb => 0,
      c_has_injecterr => 0,
      c_has_mem_output_regs_a => 1,
      c_has_mem_output_regs_b => 0,
      c_has_mux_output_regs_a => 0,
      c_has_mux_output_regs_b => 0,
      c_has_regcea => 0,
      c_has_regceb => 0,
      c_has_rsta => 0,
      c_has_rstb => 0,
      c_has_softecc_input_regs_a => 0,
      c_has_softecc_output_regs_b => 0,
      c_init_file_name => "bmg_72_4ed81b7c7b802023.mif",
      c_inita_val => "0",
      c_initb_val => "0",
      c_interface_type => 0,
      c_load_init_file => 1,
      c_mem_type => 0,
      c_mux_pipeline_stages => 0,
      c_prim_type => 5,
      c_read_depth_a => 256,
      c_read_depth_b => 256,
      c_read_width_a => 72,
      c_read_width_b => 72,
      c_rst_priority_a => "CE",
      c_rst_priority_b => "CE",
      c_rst_type => "SYNC",
      c_rstram_a => 0,
      c_rstram_b => 0,
      c_sim_collision_check => "ALL",
      c_use_byte_wea => 0,
      c_use_byte_web => 0,
      c_use_default_data => 0,
      c_use_ecc => 0,
      c_use_softecc => 0,
      c_wea_width => 1,
      c_web_width => 1,
      c_write_depth_a => 256,
      c_write_depth_b => 256,
      c_write_mode_a => "NO_CHANGE",
      c_write_mode_b => "WRITE_FIRST",
      c_write_width_a => 72,
      c_write_width_b => 72,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_72_4ed81b7c7b802023
  PORT MAP (
    clka => clka,
    ena => ena,
    wea => wea,
    addra => addra,
    dina => dina,
    douta => douta
  );
-- synthesis translate_on

END bmg_72_4ed81b7c7b802023_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file addsb_11_0_18c07b39a9f6c777.vhd when simulating
-- the core, addsb_11_0_18c07b39a9f6c777. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY addsb_11_0_18c07b39a9f6c777 IS
  PORT (
    a : IN STD_LOGIC_VECTOR(39 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(39 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(39 DOWNTO 0)
  );
END addsb_11_0_18c07b39a9f6c777;

ARCHITECTURE addsb_11_0_18c07b39a9f6c777_a OF addsb_11_0_18c07b39a9f6c777 IS
-- synthesis translate_off
COMPONENT wrapped_addsb_11_0_18c07b39a9f6c777
  PORT (
    a : IN STD_LOGIC_VECTOR(39 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(39 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(39 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_addsb_11_0_18c07b39a9f6c777 USE ENTITY XilinxCoreLib.c_addsub_v11_0(behavioral)
    GENERIC MAP (
      c_a_type => 0,
      c_a_width => 40,
      c_add_mode => 0,
      c_ainit_val => "0",
      c_b_constant => 0,
      c_b_type => 0,
      c_b_value => "0000000000000000000000000000000000000000",
      c_b_width => 40,
      c_borrow_low => 1,
      c_bypass_low => 0,
      c_ce_overrides_bypass => 1,
      c_ce_overrides_sclr => 0,
      c_has_bypass => 0,
      c_has_c_in => 0,
      c_has_c_out => 0,
      c_has_ce => 1,
      c_has_sclr => 0,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_implementation => 1,
      c_latency => 1,
      c_out_width => 40,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_addsb_11_0_18c07b39a9f6c777
  PORT MAP (
    a => a,
    b => b,
    clk => clk,
    ce => ce,
    s => s
  );
-- synthesis translate_on

END addsb_11_0_18c07b39a9f6c777_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file cntr_11_0_71ab8bef543acf07.vhd when simulating
-- the core, cntr_11_0_71ab8bef543acf07. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY cntr_11_0_71ab8bef543acf07 IS
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(18 DOWNTO 0)
  );
END cntr_11_0_71ab8bef543acf07;

ARCHITECTURE cntr_11_0_71ab8bef543acf07_a OF cntr_11_0_71ab8bef543acf07 IS
-- synthesis translate_off
COMPONENT wrapped_cntr_11_0_71ab8bef543acf07
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(18 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_cntr_11_0_71ab8bef543acf07 USE ENTITY XilinxCoreLib.c_counter_binary_v11_0(behavioral)
    GENERIC MAP (
      c_ainit_val => "0",
      c_ce_overrides_sync => 0,
      c_count_by => "1",
      c_count_mode => 0,
      c_count_to => "1",
      c_fb_latency => 0,
      c_has_ce => 1,
      c_has_load => 0,
      c_has_sclr => 1,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_has_thresh0 => 0,
      c_implementation => 1,
      c_latency => 1,
      c_load_low => 0,
      c_restrict_count => 0,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_thresh0_value => "1",
      c_verbosity => 0,
      c_width => 19,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_cntr_11_0_71ab8bef543acf07
  PORT MAP (
    clk => clk,
    ce => ce,
    sclr => sclr,
    q => q
  );
-- synthesis translate_on

END cntr_11_0_71ab8bef543acf07_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_72_a5223615887f70b9.vhd when simulating
-- the core, bmg_72_a5223615887f70b9. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_72_a5223615887f70b9 IS
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(11 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(11 DOWNTO 0)
  );
END bmg_72_a5223615887f70b9;

ARCHITECTURE bmg_72_a5223615887f70b9_a OF bmg_72_a5223615887f70b9 IS
-- synthesis translate_off
COMPONENT wrapped_bmg_72_a5223615887f70b9
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(11 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(11 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_bmg_72_a5223615887f70b9 USE ENTITY XilinxCoreLib.blk_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addra_width => 8,
      c_addrb_width => 8,
      c_algorithm => 1,
      c_axi_id_width => 4,
      c_axi_slave_type => 0,
      c_axi_type => 1,
      c_byte_size => 9,
      c_common_clk => 0,
      c_default_data => "0",
      c_disable_warn_bhv_coll => 0,
      c_disable_warn_bhv_range => 0,
      c_enable_32bit_address => 0,
      c_family => "virtex6",
      c_has_axi_id => 0,
      c_has_ena => 1,
      c_has_enb => 0,
      c_has_injecterr => 0,
      c_has_mem_output_regs_a => 1,
      c_has_mem_output_regs_b => 0,
      c_has_mux_output_regs_a => 0,
      c_has_mux_output_regs_b => 0,
      c_has_regcea => 0,
      c_has_regceb => 0,
      c_has_rsta => 0,
      c_has_rstb => 0,
      c_has_softecc_input_regs_a => 0,
      c_has_softecc_output_regs_b => 0,
      c_init_file_name => "bmg_72_a5223615887f70b9.mif",
      c_inita_val => "0",
      c_initb_val => "0",
      c_interface_type => 0,
      c_load_init_file => 1,
      c_mem_type => 0,
      c_mux_pipeline_stages => 0,
      c_prim_type => 1,
      c_read_depth_a => 256,
      c_read_depth_b => 256,
      c_read_width_a => 12,
      c_read_width_b => 12,
      c_rst_priority_a => "CE",
      c_rst_priority_b => "CE",
      c_rst_type => "SYNC",
      c_rstram_a => 0,
      c_rstram_b => 0,
      c_sim_collision_check => "ALL",
      c_use_byte_wea => 0,
      c_use_byte_web => 0,
      c_use_default_data => 0,
      c_use_ecc => 0,
      c_use_softecc => 0,
      c_wea_width => 1,
      c_web_width => 1,
      c_write_depth_a => 256,
      c_write_depth_b => 256,
      c_write_mode_a => "READ_FIRST",
      c_write_mode_b => "WRITE_FIRST",
      c_write_width_a => 12,
      c_write_width_b => 12,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_72_a5223615887f70b9
  PORT MAP (
    clka => clka,
    ena => ena,
    wea => wea,
    addra => addra,
    dina => dina,
    douta => douta
  );
-- synthesis translate_on

END bmg_72_a5223615887f70b9_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file cntr_11_0_8618faf08c8d27ff.vhd when simulating
-- the core, cntr_11_0_8618faf08c8d27ff. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY cntr_11_0_8618faf08c8d27ff IS
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sinit : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(17 DOWNTO 0)
  );
END cntr_11_0_8618faf08c8d27ff;

ARCHITECTURE cntr_11_0_8618faf08c8d27ff_a OF cntr_11_0_8618faf08c8d27ff IS
-- synthesis translate_off
COMPONENT wrapped_cntr_11_0_8618faf08c8d27ff
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sinit : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(17 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_cntr_11_0_8618faf08c8d27ff USE ENTITY XilinxCoreLib.c_counter_binary_v11_0(behavioral)
    GENERIC MAP (
      c_ainit_val => "0",
      c_ce_overrides_sync => 0,
      c_count_by => "1",
      c_count_mode => 0,
      c_count_to => "1",
      c_fb_latency => 0,
      c_has_ce => 1,
      c_has_load => 0,
      c_has_sclr => 0,
      c_has_sinit => 1,
      c_has_sset => 0,
      c_has_thresh0 => 0,
      c_implementation => 0,
      c_latency => 1,
      c_load_low => 0,
      c_restrict_count => 0,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_thresh0_value => "1",
      c_verbosity => 0,
      c_width => 18,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_cntr_11_0_8618faf08c8d27ff
  PORT MAP (
    clk => clk,
    ce => ce,
    sinit => sinit,
    q => q
  );
-- synthesis translate_on

END cntr_11_0_8618faf08c8d27ff_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file addsb_11_0_837b9ca36be57173.vhd when simulating
-- the core, addsb_11_0_837b9ca36be57173. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY addsb_11_0_837b9ca36be57173 IS
  PORT (
    a : IN STD_LOGIC_VECTOR(27 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(27 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(27 DOWNTO 0)
  );
END addsb_11_0_837b9ca36be57173;

ARCHITECTURE addsb_11_0_837b9ca36be57173_a OF addsb_11_0_837b9ca36be57173 IS
-- synthesis translate_off
COMPONENT wrapped_addsb_11_0_837b9ca36be57173
  PORT (
    a : IN STD_LOGIC_VECTOR(27 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(27 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(27 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_addsb_11_0_837b9ca36be57173 USE ENTITY XilinxCoreLib.c_addsub_v11_0(behavioral)
    GENERIC MAP (
      c_a_type => 0,
      c_a_width => 28,
      c_add_mode => 0,
      c_ainit_val => "0",
      c_b_constant => 0,
      c_b_type => 0,
      c_b_value => "0000000000000000000000000000",
      c_b_width => 28,
      c_borrow_low => 1,
      c_bypass_low => 0,
      c_ce_overrides_bypass => 1,
      c_ce_overrides_sclr => 0,
      c_has_bypass => 0,
      c_has_c_in => 0,
      c_has_c_out => 0,
      c_has_ce => 1,
      c_has_sclr => 0,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_implementation => 1,
      c_latency => 2,
      c_out_width => 28,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_addsb_11_0_837b9ca36be57173
  PORT MAP (
    a => a,
    b => b,
    clk => clk,
    ce => ce,
    s => s
  );
-- synthesis translate_on

END addsb_11_0_837b9ca36be57173_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file cntr_11_0_d1eeca027ba03819.vhd when simulating
-- the core, cntr_11_0_d1eeca027ba03819. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY cntr_11_0_d1eeca027ba03819 IS
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(7 DOWNTO 0)
  );
END cntr_11_0_d1eeca027ba03819;

ARCHITECTURE cntr_11_0_d1eeca027ba03819_a OF cntr_11_0_d1eeca027ba03819 IS
-- synthesis translate_off
COMPONENT wrapped_cntr_11_0_d1eeca027ba03819
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(7 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_cntr_11_0_d1eeca027ba03819 USE ENTITY XilinxCoreLib.c_counter_binary_v11_0(behavioral)
    GENERIC MAP (
      c_ainit_val => "0",
      c_ce_overrides_sync => 0,
      c_count_by => "1",
      c_count_mode => 0,
      c_count_to => "1",
      c_fb_latency => 0,
      c_has_ce => 1,
      c_has_load => 0,
      c_has_sclr => 1,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_has_thresh0 => 0,
      c_implementation => 1,
      c_latency => 1,
      c_load_low => 0,
      c_restrict_count => 0,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_thresh0_value => "1",
      c_verbosity => 0,
      c_width => 8,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_cntr_11_0_d1eeca027ba03819
  PORT MAP (
    clk => clk,
    ce => ce,
    sclr => sclr,
    q => q
  );
-- synthesis translate_on

END cntr_11_0_d1eeca027ba03819_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file cntr_11_0_3e8a20e113de20bb.vhd when simulating
-- the core, cntr_11_0_3e8a20e113de20bb. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY cntr_11_0_3e8a20e113de20bb IS
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(12 DOWNTO 0)
  );
END cntr_11_0_3e8a20e113de20bb;

ARCHITECTURE cntr_11_0_3e8a20e113de20bb_a OF cntr_11_0_3e8a20e113de20bb IS
-- synthesis translate_off
COMPONENT wrapped_cntr_11_0_3e8a20e113de20bb
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(12 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_cntr_11_0_3e8a20e113de20bb USE ENTITY XilinxCoreLib.c_counter_binary_v11_0(behavioral)
    GENERIC MAP (
      c_ainit_val => "0",
      c_ce_overrides_sync => 0,
      c_count_by => "1000",
      c_count_mode => 0,
      c_count_to => "1",
      c_fb_latency => 0,
      c_has_ce => 1,
      c_has_load => 0,
      c_has_sclr => 1,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_has_thresh0 => 0,
      c_implementation => 1,
      c_latency => 1,
      c_load_low => 0,
      c_restrict_count => 0,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_thresh0_value => "1",
      c_verbosity => 0,
      c_width => 13,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_cntr_11_0_3e8a20e113de20bb
  PORT MAP (
    clk => clk,
    ce => ce,
    sclr => sclr,
    q => q
  );
-- synthesis translate_on

END cntr_11_0_3e8a20e113de20bb_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file crdc_v4_0_75c75af685d34a44.vhd when simulating
-- the core, crdc_v4_0_75c75af685d34a44. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY crdc_v4_0_75c75af685d34a44 IS
  PORT (
    x_in : IN STD_LOGIC_VECTOR(19 DOWNTO 0);
    y_in : IN STD_LOGIC_VECTOR(19 DOWNTO 0);
    phase_out : OUT STD_LOGIC_VECTOR(11 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC
  );
END crdc_v4_0_75c75af685d34a44;

ARCHITECTURE crdc_v4_0_75c75af685d34a44_a OF crdc_v4_0_75c75af685d34a44 IS
-- synthesis translate_off
COMPONENT wrapped_crdc_v4_0_75c75af685d34a44
  PORT (
    x_in : IN STD_LOGIC_VECTOR(19 DOWNTO 0);
    y_in : IN STD_LOGIC_VECTOR(19 DOWNTO 0);
    phase_out : OUT STD_LOGIC_VECTOR(11 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_crdc_v4_0_75c75af685d34a44 USE ENTITY XilinxCoreLib.cordic_v4_0(behavioral)
    GENERIC MAP (
      c_architecture => 2,
      c_coarse_rotate => 1,
      c_cordic_function => 3,
      c_data_format => 0,
      c_family => "virtex6",
      c_has_ce => 1,
      c_has_clk => 1,
      c_has_nd => 0,
      c_has_phase_in => 0,
      c_has_phase_out => 1,
      c_has_rdy => 0,
      c_has_rfd => 0,
      c_has_sclr => 0,
      c_has_x_in => 1,
      c_has_x_out => 0,
      c_has_y_in => 1,
      c_has_y_out => 0,
      c_input_width => 20,
      c_iterations => 0,
      c_output_width => 12,
      c_phase_format => 0,
      c_pipeline_mode => -2,
      c_precision => 0,
      c_reg_inputs => 1,
      c_reg_outputs => 1,
      c_round_mode => 0,
      c_scale_comp => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_crdc_v4_0_75c75af685d34a44
  PORT MAP (
    x_in => x_in,
    y_in => y_in,
    phase_out => phase_out,
    clk => clk,
    ce => ce
  );
-- synthesis translate_on

END crdc_v4_0_75c75af685d34a44_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file addsb_11_0_07eb1c1df5a181f1.vhd when simulating
-- the core, addsb_11_0_07eb1c1df5a181f1. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY addsb_11_0_07eb1c1df5a181f1 IS
  PORT (
    a : IN STD_LOGIC_VECTOR(37 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(37 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(37 DOWNTO 0)
  );
END addsb_11_0_07eb1c1df5a181f1;

ARCHITECTURE addsb_11_0_07eb1c1df5a181f1_a OF addsb_11_0_07eb1c1df5a181f1 IS
-- synthesis translate_off
COMPONENT wrapped_addsb_11_0_07eb1c1df5a181f1
  PORT (
    a : IN STD_LOGIC_VECTOR(37 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(37 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(37 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_addsb_11_0_07eb1c1df5a181f1 USE ENTITY XilinxCoreLib.c_addsub_v11_0(behavioral)
    GENERIC MAP (
      c_a_type => 0,
      c_a_width => 38,
      c_add_mode => 0,
      c_ainit_val => "0",
      c_b_constant => 0,
      c_b_type => 0,
      c_b_value => "00000000000000000000000000000000000000",
      c_b_width => 38,
      c_borrow_low => 1,
      c_bypass_low => 0,
      c_ce_overrides_bypass => 1,
      c_ce_overrides_sclr => 0,
      c_has_bypass => 0,
      c_has_c_in => 0,
      c_has_c_out => 0,
      c_has_ce => 1,
      c_has_sclr => 0,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_implementation => 1,
      c_latency => 2,
      c_out_width => 38,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_addsb_11_0_07eb1c1df5a181f1
  PORT MAP (
    a => a,
    b => b,
    clk => clk,
    ce => ce,
    s => s
  );
-- synthesis translate_on

END addsb_11_0_07eb1c1df5a181f1_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file addsb_11_0_d9aaab7d6537213f.vhd when simulating
-- the core, addsb_11_0_d9aaab7d6537213f. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY addsb_11_0_d9aaab7d6537213f IS
  PORT (
    a : IN STD_LOGIC_VECTOR(47 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(47 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(47 DOWNTO 0)
  );
END addsb_11_0_d9aaab7d6537213f;

ARCHITECTURE addsb_11_0_d9aaab7d6537213f_a OF addsb_11_0_d9aaab7d6537213f IS
-- synthesis translate_off
COMPONENT wrapped_addsb_11_0_d9aaab7d6537213f
  PORT (
    a : IN STD_LOGIC_VECTOR(47 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(47 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(47 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_addsb_11_0_d9aaab7d6537213f USE ENTITY XilinxCoreLib.c_addsub_v11_0(behavioral)
    GENERIC MAP (
      c_a_type => 0,
      c_a_width => 48,
      c_add_mode => 0,
      c_ainit_val => "0",
      c_b_constant => 0,
      c_b_type => 0,
      c_b_value => "000000000000000000000000000000000000000000000000",
      c_b_width => 48,
      c_borrow_low => 1,
      c_bypass_low => 0,
      c_ce_overrides_bypass => 1,
      c_ce_overrides_sclr => 0,
      c_has_bypass => 0,
      c_has_c_in => 0,
      c_has_c_out => 0,
      c_has_ce => 1,
      c_has_sclr => 0,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_implementation => 0,
      c_latency => 1,
      c_out_width => 48,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_addsb_11_0_d9aaab7d6537213f
  PORT MAP (
    a => a,
    b => b,
    clk => clk,
    ce => ce,
    s => s
  );
-- synthesis translate_on

END addsb_11_0_d9aaab7d6537213f_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file cntr_11_0_ed5c08cc07bca813.vhd when simulating
-- the core, cntr_11_0_ed5c08cc07bca813. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY cntr_11_0_ed5c08cc07bca813 IS
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sinit : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(19 DOWNTO 0)
  );
END cntr_11_0_ed5c08cc07bca813;

ARCHITECTURE cntr_11_0_ed5c08cc07bca813_a OF cntr_11_0_ed5c08cc07bca813 IS
-- synthesis translate_off
COMPONENT wrapped_cntr_11_0_ed5c08cc07bca813
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sinit : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(19 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_cntr_11_0_ed5c08cc07bca813 USE ENTITY XilinxCoreLib.c_counter_binary_v11_0(behavioral)
    GENERIC MAP (
      c_ainit_val => "0",
      c_ce_overrides_sync => 0,
      c_count_by => "1",
      c_count_mode => 0,
      c_count_to => "1",
      c_fb_latency => 0,
      c_has_ce => 1,
      c_has_load => 0,
      c_has_sclr => 0,
      c_has_sinit => 1,
      c_has_sset => 0,
      c_has_thresh0 => 0,
      c_implementation => 0,
      c_latency => 1,
      c_load_low => 0,
      c_restrict_count => 0,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_thresh0_value => "1",
      c_verbosity => 0,
      c_width => 20,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_cntr_11_0_ed5c08cc07bca813
  PORT MAP (
    clk => clk,
    ce => ce,
    sinit => sinit,
    q => q
  );
-- synthesis translate_on

END cntr_11_0_ed5c08cc07bca813_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file addsb_11_0_6603a21774005e29.vhd when simulating
-- the core, addsb_11_0_6603a21774005e29. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY addsb_11_0_6603a21774005e29 IS
  PORT (
    a : IN STD_LOGIC_VECTOR(34 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(34 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(34 DOWNTO 0)
  );
END addsb_11_0_6603a21774005e29;

ARCHITECTURE addsb_11_0_6603a21774005e29_a OF addsb_11_0_6603a21774005e29 IS
-- synthesis translate_off
COMPONENT wrapped_addsb_11_0_6603a21774005e29
  PORT (
    a : IN STD_LOGIC_VECTOR(34 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(34 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(34 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_addsb_11_0_6603a21774005e29 USE ENTITY XilinxCoreLib.c_addsub_v11_0(behavioral)
    GENERIC MAP (
      c_a_type => 0,
      c_a_width => 35,
      c_add_mode => 0,
      c_ainit_val => "0",
      c_b_constant => 0,
      c_b_type => 0,
      c_b_value => "00000000000000000000000000000000000",
      c_b_width => 35,
      c_borrow_low => 1,
      c_bypass_low => 0,
      c_ce_overrides_bypass => 1,
      c_ce_overrides_sclr => 0,
      c_has_bypass => 0,
      c_has_c_in => 0,
      c_has_c_out => 0,
      c_has_ce => 1,
      c_has_sclr => 0,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_implementation => 1,
      c_latency => 2,
      c_out_width => 35,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_addsb_11_0_6603a21774005e29
  PORT MAP (
    a => a,
    b => b,
    clk => clk,
    ce => ce,
    s => s
  );
-- synthesis translate_on

END addsb_11_0_6603a21774005e29_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file addsb_11_0_f46b761f6397bd18.vhd when simulating
-- the core, addsb_11_0_f46b761f6397bd18. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY addsb_11_0_f46b761f6397bd18 IS
  PORT (
    a : IN STD_LOGIC_VECTOR(10 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(10 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(10 DOWNTO 0)
  );
END addsb_11_0_f46b761f6397bd18;

ARCHITECTURE addsb_11_0_f46b761f6397bd18_a OF addsb_11_0_f46b761f6397bd18 IS
-- synthesis translate_off
COMPONENT wrapped_addsb_11_0_f46b761f6397bd18
  PORT (
    a : IN STD_LOGIC_VECTOR(10 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(10 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(10 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_addsb_11_0_f46b761f6397bd18 USE ENTITY XilinxCoreLib.c_addsub_v11_0(behavioral)
    GENERIC MAP (
      c_a_type => 1,
      c_a_width => 11,
      c_add_mode => 0,
      c_ainit_val => "0",
      c_b_constant => 0,
      c_b_type => 1,
      c_b_value => "00000000000",
      c_b_width => 11,
      c_borrow_low => 1,
      c_bypass_low => 0,
      c_ce_overrides_bypass => 1,
      c_ce_overrides_sclr => 0,
      c_has_bypass => 0,
      c_has_c_in => 0,
      c_has_c_out => 0,
      c_has_ce => 1,
      c_has_sclr => 0,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_implementation => 1,
      c_latency => 2,
      c_out_width => 11,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_addsb_11_0_f46b761f6397bd18
  PORT MAP (
    a => a,
    b => b,
    clk => clk,
    ce => ce,
    s => s
  );
-- synthesis translate_on

END addsb_11_0_f46b761f6397bd18_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_72_b851979848828b10.vhd when simulating
-- the core, bmg_72_b851979848828b10. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_72_b851979848828b10 IS
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(11 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(0 DOWNTO 0)
  );
END bmg_72_b851979848828b10;

ARCHITECTURE bmg_72_b851979848828b10_a OF bmg_72_b851979848828b10 IS
-- synthesis translate_off
COMPONENT wrapped_bmg_72_b851979848828b10
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(11 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(0 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_bmg_72_b851979848828b10 USE ENTITY XilinxCoreLib.blk_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addra_width => 12,
      c_addrb_width => 12,
      c_algorithm => 1,
      c_axi_id_width => 4,
      c_axi_slave_type => 0,
      c_axi_type => 1,
      c_byte_size => 9,
      c_common_clk => 0,
      c_default_data => "0",
      c_disable_warn_bhv_coll => 0,
      c_disable_warn_bhv_range => 0,
      c_enable_32bit_address => 0,
      c_family => "virtex6",
      c_has_axi_id => 0,
      c_has_ena => 1,
      c_has_enb => 0,
      c_has_injecterr => 0,
      c_has_mem_output_regs_a => 1,
      c_has_mem_output_regs_b => 0,
      c_has_mux_output_regs_a => 0,
      c_has_mux_output_regs_b => 0,
      c_has_regcea => 0,
      c_has_regceb => 0,
      c_has_rsta => 0,
      c_has_rstb => 0,
      c_has_softecc_input_regs_a => 0,
      c_has_softecc_output_regs_b => 0,
      c_init_file_name => "bmg_72_b851979848828b10.mif",
      c_inita_val => "0",
      c_initb_val => "0",
      c_interface_type => 0,
      c_load_init_file => 1,
      c_mem_type => 0,
      c_mux_pipeline_stages => 0,
      c_prim_type => 1,
      c_read_depth_a => 4096,
      c_read_depth_b => 4096,
      c_read_width_a => 1,
      c_read_width_b => 1,
      c_rst_priority_a => "CE",
      c_rst_priority_b => "CE",
      c_rst_type => "SYNC",
      c_rstram_a => 0,
      c_rstram_b => 0,
      c_sim_collision_check => "ALL",
      c_use_byte_wea => 0,
      c_use_byte_web => 0,
      c_use_default_data => 0,
      c_use_ecc => 0,
      c_use_softecc => 0,
      c_wea_width => 1,
      c_web_width => 1,
      c_write_depth_a => 4096,
      c_write_depth_b => 4096,
      c_write_mode_a => "READ_FIRST",
      c_write_mode_b => "WRITE_FIRST",
      c_write_width_a => 1,
      c_write_width_b => 1,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_72_b851979848828b10
  PORT MAP (
    clka => clka,
    ena => ena,
    wea => wea,
    addra => addra,
    dina => dina,
    douta => douta
  );
-- synthesis translate_on

END bmg_72_b851979848828b10_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file fifo_fg92_afda83fee974586a.vhd when simulating
-- the core, fifo_fg92_afda83fee974586a. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY fifo_fg92_afda83fee974586a IS
  PORT (
    clk : IN STD_LOGIC;
    din : IN STD_LOGIC_VECTOR(63 DOWNTO 0);
    wr_en : IN STD_LOGIC;
    rd_en : IN STD_LOGIC;
    dout : OUT STD_LOGIC_VECTOR(63 DOWNTO 0);
    full : OUT STD_LOGIC;
    empty : OUT STD_LOGIC
  );
END fifo_fg92_afda83fee974586a;

ARCHITECTURE fifo_fg92_afda83fee974586a_a OF fifo_fg92_afda83fee974586a IS
-- synthesis translate_off
COMPONENT wrapped_fifo_fg92_afda83fee974586a
  PORT (
    clk : IN STD_LOGIC;
    din : IN STD_LOGIC_VECTOR(63 DOWNTO 0);
    wr_en : IN STD_LOGIC;
    rd_en : IN STD_LOGIC;
    dout : OUT STD_LOGIC_VECTOR(63 DOWNTO 0);
    full : OUT STD_LOGIC;
    empty : OUT STD_LOGIC
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_fifo_fg92_afda83fee974586a USE ENTITY XilinxCoreLib.fifo_generator_v9_3(behavioral)
    GENERIC MAP (
      c_add_ngc_constraint => 0,
      c_application_type_axis => 0,
      c_application_type_rach => 0,
      c_application_type_rdch => 0,
      c_application_type_wach => 0,
      c_application_type_wdch => 0,
      c_application_type_wrch => 0,
      c_axi_addr_width => 32,
      c_axi_aruser_width => 1,
      c_axi_awuser_width => 1,
      c_axi_buser_width => 1,
      c_axi_data_width => 64,
      c_axi_id_width => 4,
      c_axi_ruser_width => 1,
      c_axi_type => 0,
      c_axi_wuser_width => 1,
      c_axis_tdata_width => 64,
      c_axis_tdest_width => 4,
      c_axis_tid_width => 8,
      c_axis_tkeep_width => 4,
      c_axis_tstrb_width => 4,
      c_axis_tuser_width => 4,
      c_axis_type => 0,
      c_common_clock => 1,
      c_count_type => 0,
      c_data_count_width => 8,
      c_default_value => "BlankString",
      c_din_width => 64,
      c_din_width_axis => 1,
      c_din_width_rach => 32,
      c_din_width_rdch => 64,
      c_din_width_wach => 32,
      c_din_width_wdch => 64,
      c_din_width_wrch => 2,
      c_dout_rst_val => "0",
      c_dout_width => 64,
      c_enable_rlocs => 0,
      c_enable_rst_sync => 1,
      c_error_injection_type => 0,
      c_error_injection_type_axis => 0,
      c_error_injection_type_rach => 0,
      c_error_injection_type_rdch => 0,
      c_error_injection_type_wach => 0,
      c_error_injection_type_wdch => 0,
      c_error_injection_type_wrch => 0,
      c_family => "virtex6",
      c_full_flags_rst_val => 0,
      c_has_almost_empty => 0,
      c_has_almost_full => 0,
      c_has_axi_aruser => 0,
      c_has_axi_awuser => 0,
      c_has_axi_buser => 0,
      c_has_axi_rd_channel => 0,
      c_has_axi_ruser => 0,
      c_has_axi_wr_channel => 0,
      c_has_axi_wuser => 0,
      c_has_axis_tdata => 0,
      c_has_axis_tdest => 0,
      c_has_axis_tid => 0,
      c_has_axis_tkeep => 0,
      c_has_axis_tlast => 0,
      c_has_axis_tready => 1,
      c_has_axis_tstrb => 0,
      c_has_axis_tuser => 0,
      c_has_backup => 0,
      c_has_data_count => 0,
      c_has_data_counts_axis => 0,
      c_has_data_counts_rach => 0,
      c_has_data_counts_rdch => 0,
      c_has_data_counts_wach => 0,
      c_has_data_counts_wdch => 0,
      c_has_data_counts_wrch => 0,
      c_has_int_clk => 0,
      c_has_master_ce => 0,
      c_has_meminit_file => 0,
      c_has_overflow => 0,
      c_has_prog_flags_axis => 0,
      c_has_prog_flags_rach => 0,
      c_has_prog_flags_rdch => 0,
      c_has_prog_flags_wach => 0,
      c_has_prog_flags_wdch => 0,
      c_has_prog_flags_wrch => 0,
      c_has_rd_data_count => 0,
      c_has_rd_rst => 0,
      c_has_rst => 0,
      c_has_slave_ce => 0,
      c_has_srst => 0,
      c_has_underflow => 0,
      c_has_valid => 0,
      c_has_wr_ack => 0,
      c_has_wr_data_count => 0,
      c_has_wr_rst => 0,
      c_implementation_type => 0,
      c_implementation_type_axis => 1,
      c_implementation_type_rach => 1,
      c_implementation_type_rdch => 1,
      c_implementation_type_wach => 1,
      c_implementation_type_wdch => 1,
      c_implementation_type_wrch => 1,
      c_init_wr_pntr_val => 0,
      c_interface_type => 0,
      c_memory_type => 1,
      c_mif_file_name => "BlankString",
      c_msgon_val => 1,
      c_optimization_mode => 0,
      c_overflow_low => 0,
      c_preload_latency => 1,
      c_preload_regs => 0,
      c_prim_fifo_type => "512x72",
      c_prog_empty_thresh_assert_val => 2,
      c_prog_empty_thresh_assert_val_axis => 1022,
      c_prog_empty_thresh_assert_val_rach => 1022,
      c_prog_empty_thresh_assert_val_rdch => 1022,
      c_prog_empty_thresh_assert_val_wach => 1022,
      c_prog_empty_thresh_assert_val_wdch => 1022,
      c_prog_empty_thresh_assert_val_wrch => 1022,
      c_prog_empty_thresh_negate_val => 3,
      c_prog_empty_type => 0,
      c_prog_empty_type_axis => 0,
      c_prog_empty_type_rach => 0,
      c_prog_empty_type_rdch => 0,
      c_prog_empty_type_wach => 0,
      c_prog_empty_type_wdch => 0,
      c_prog_empty_type_wrch => 0,
      c_prog_full_thresh_assert_val => 254,
      c_prog_full_thresh_assert_val_axis => 1023,
      c_prog_full_thresh_assert_val_rach => 1023,
      c_prog_full_thresh_assert_val_rdch => 1023,
      c_prog_full_thresh_assert_val_wach => 1023,
      c_prog_full_thresh_assert_val_wdch => 1023,
      c_prog_full_thresh_assert_val_wrch => 1023,
      c_prog_full_thresh_negate_val => 253,
      c_prog_full_type => 0,
      c_prog_full_type_axis => 0,
      c_prog_full_type_rach => 0,
      c_prog_full_type_rdch => 0,
      c_prog_full_type_wach => 0,
      c_prog_full_type_wdch => 0,
      c_prog_full_type_wrch => 0,
      c_rach_type => 0,
      c_rd_data_count_width => 8,
      c_rd_depth => 256,
      c_rd_freq => 1,
      c_rd_pntr_width => 8,
      c_rdch_type => 0,
      c_reg_slice_mode_axis => 0,
      c_reg_slice_mode_rach => 0,
      c_reg_slice_mode_rdch => 0,
      c_reg_slice_mode_wach => 0,
      c_reg_slice_mode_wdch => 0,
      c_reg_slice_mode_wrch => 0,
      c_synchronizer_stage => 2,
      c_underflow_low => 0,
      c_use_common_overflow => 0,
      c_use_common_underflow => 0,
      c_use_default_settings => 0,
      c_use_dout_rst => 0,
      c_use_ecc => 0,
      c_use_ecc_axis => 0,
      c_use_ecc_rach => 0,
      c_use_ecc_rdch => 0,
      c_use_ecc_wach => 0,
      c_use_ecc_wdch => 0,
      c_use_ecc_wrch => 0,
      c_use_embedded_reg => 0,
      c_use_fifo16_flags => 0,
      c_use_fwft_data_count => 0,
      c_valid_low => 0,
      c_wach_type => 0,
      c_wdch_type => 0,
      c_wr_ack_low => 0,
      c_wr_data_count_width => 8,
      c_wr_depth => 256,
      c_wr_depth_axis => 1024,
      c_wr_depth_rach => 16,
      c_wr_depth_rdch => 1024,
      c_wr_depth_wach => 16,
      c_wr_depth_wdch => 1024,
      c_wr_depth_wrch => 16,
      c_wr_freq => 1,
      c_wr_pntr_width => 8,
      c_wr_pntr_width_axis => 10,
      c_wr_pntr_width_rach => 4,
      c_wr_pntr_width_rdch => 10,
      c_wr_pntr_width_wach => 4,
      c_wr_pntr_width_wdch => 10,
      c_wr_pntr_width_wrch => 4,
      c_wr_response_latency => 1,
      c_wrch_type => 0
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_fifo_fg92_afda83fee974586a
  PORT MAP (
    clk => clk,
    din => din,
    wr_en => wr_en,
    rd_en => rd_en,
    dout => dout,
    full => full,
    empty => empty
  );
-- synthesis translate_on

END fifo_fg92_afda83fee974586a_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_72_386cbab83765f0cd.vhd when simulating
-- the core, bmg_72_386cbab83765f0cd. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_72_386cbab83765f0cd IS
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(18 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(18 DOWNTO 0)
  );
END bmg_72_386cbab83765f0cd;

ARCHITECTURE bmg_72_386cbab83765f0cd_a OF bmg_72_386cbab83765f0cd IS
-- synthesis translate_off
COMPONENT wrapped_bmg_72_386cbab83765f0cd
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(18 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(18 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_bmg_72_386cbab83765f0cd USE ENTITY XilinxCoreLib.blk_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addra_width => 8,
      c_addrb_width => 8,
      c_algorithm => 1,
      c_axi_id_width => 4,
      c_axi_slave_type => 0,
      c_axi_type => 1,
      c_byte_size => 9,
      c_common_clk => 0,
      c_default_data => "0",
      c_disable_warn_bhv_coll => 0,
      c_disable_warn_bhv_range => 0,
      c_enable_32bit_address => 0,
      c_family => "virtex6",
      c_has_axi_id => 0,
      c_has_ena => 1,
      c_has_enb => 0,
      c_has_injecterr => 0,
      c_has_mem_output_regs_a => 1,
      c_has_mem_output_regs_b => 0,
      c_has_mux_output_regs_a => 0,
      c_has_mux_output_regs_b => 0,
      c_has_regcea => 0,
      c_has_regceb => 0,
      c_has_rsta => 0,
      c_has_rstb => 0,
      c_has_softecc_input_regs_a => 0,
      c_has_softecc_output_regs_b => 0,
      c_init_file_name => "bmg_72_386cbab83765f0cd.mif",
      c_inita_val => "0",
      c_initb_val => "0",
      c_interface_type => 0,
      c_load_init_file => 1,
      c_mem_type => 0,
      c_mux_pipeline_stages => 0,
      c_prim_type => 1,
      c_read_depth_a => 256,
      c_read_depth_b => 256,
      c_read_width_a => 19,
      c_read_width_b => 19,
      c_rst_priority_a => "CE",
      c_rst_priority_b => "CE",
      c_rst_type => "SYNC",
      c_rstram_a => 0,
      c_rstram_b => 0,
      c_sim_collision_check => "ALL",
      c_use_byte_wea => 0,
      c_use_byte_web => 0,
      c_use_default_data => 0,
      c_use_ecc => 0,
      c_use_softecc => 0,
      c_wea_width => 1,
      c_web_width => 1,
      c_write_depth_a => 256,
      c_write_depth_b => 256,
      c_write_mode_a => "READ_FIRST",
      c_write_mode_b => "WRITE_FIRST",
      c_write_width_a => 19,
      c_write_width_b => 19,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_72_386cbab83765f0cd
  PORT MAP (
    clka => clka,
    ena => ena,
    wea => wea,
    addra => addra,
    dina => dina,
    douta => douta
  );
-- synthesis translate_on

END bmg_72_386cbab83765f0cd_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file addsb_11_0_aa7bb2ad873d54b6.vhd when simulating
-- the core, addsb_11_0_aa7bb2ad873d54b6. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY addsb_11_0_aa7bb2ad873d54b6 IS
  PORT (
    a : IN STD_LOGIC_VECTOR(10 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(10 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(10 DOWNTO 0)
  );
END addsb_11_0_aa7bb2ad873d54b6;

ARCHITECTURE addsb_11_0_aa7bb2ad873d54b6_a OF addsb_11_0_aa7bb2ad873d54b6 IS
-- synthesis translate_off
COMPONENT wrapped_addsb_11_0_aa7bb2ad873d54b6
  PORT (
    a : IN STD_LOGIC_VECTOR(10 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(10 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(10 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_addsb_11_0_aa7bb2ad873d54b6 USE ENTITY XilinxCoreLib.c_addsub_v11_0(behavioral)
    GENERIC MAP (
      c_a_type => 0,
      c_a_width => 11,
      c_add_mode => 1,
      c_ainit_val => "0",
      c_b_constant => 0,
      c_b_type => 0,
      c_b_value => "00000000000",
      c_b_width => 11,
      c_borrow_low => 1,
      c_bypass_low => 0,
      c_ce_overrides_bypass => 1,
      c_ce_overrides_sclr => 0,
      c_has_bypass => 0,
      c_has_c_in => 0,
      c_has_c_out => 0,
      c_has_ce => 1,
      c_has_sclr => 0,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_implementation => 1,
      c_latency => 2,
      c_out_width => 11,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_addsb_11_0_aa7bb2ad873d54b6
  PORT MAP (
    a => a,
    b => b,
    clk => clk,
    ce => ce,
    s => s
  );
-- synthesis translate_on

END addsb_11_0_aa7bb2ad873d54b6_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file cntr_11_0_dbe4e55db82481fa.vhd when simulating
-- the core, cntr_11_0_dbe4e55db82481fa. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY cntr_11_0_dbe4e55db82481fa IS
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(12 DOWNTO 0)
  );
END cntr_11_0_dbe4e55db82481fa;

ARCHITECTURE cntr_11_0_dbe4e55db82481fa_a OF cntr_11_0_dbe4e55db82481fa IS
-- synthesis translate_off
COMPONENT wrapped_cntr_11_0_dbe4e55db82481fa
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(12 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_cntr_11_0_dbe4e55db82481fa USE ENTITY XilinxCoreLib.c_counter_binary_v11_0(behavioral)
    GENERIC MAP (
      c_ainit_val => "0",
      c_ce_overrides_sync => 0,
      c_count_by => "100",
      c_count_mode => 0,
      c_count_to => "1",
      c_fb_latency => 0,
      c_has_ce => 1,
      c_has_load => 0,
      c_has_sclr => 1,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_has_thresh0 => 0,
      c_implementation => 1,
      c_latency => 1,
      c_load_low => 0,
      c_restrict_count => 0,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_thresh0_value => "1",
      c_verbosity => 0,
      c_width => 13,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_cntr_11_0_dbe4e55db82481fa
  PORT MAP (
    clk => clk,
    ce => ce,
    sclr => sclr,
    q => q
  );
-- synthesis translate_on

END cntr_11_0_dbe4e55db82481fa_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file addsb_11_0_74c24ba8230946d7.vhd when simulating
-- the core, addsb_11_0_74c24ba8230946d7. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY addsb_11_0_74c24ba8230946d7 IS
  PORT (
    a : IN STD_LOGIC_VECTOR(19 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(19 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(19 DOWNTO 0)
  );
END addsb_11_0_74c24ba8230946d7;

ARCHITECTURE addsb_11_0_74c24ba8230946d7_a OF addsb_11_0_74c24ba8230946d7 IS
-- synthesis translate_off
COMPONENT wrapped_addsb_11_0_74c24ba8230946d7
  PORT (
    a : IN STD_LOGIC_VECTOR(19 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(19 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(19 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_addsb_11_0_74c24ba8230946d7 USE ENTITY XilinxCoreLib.c_addsub_v11_0(behavioral)
    GENERIC MAP (
      c_a_type => 0,
      c_a_width => 20,
      c_add_mode => 0,
      c_ainit_val => "0",
      c_b_constant => 0,
      c_b_type => 0,
      c_b_value => "00000000000000000000",
      c_b_width => 20,
      c_borrow_low => 1,
      c_bypass_low => 0,
      c_ce_overrides_bypass => 1,
      c_ce_overrides_sclr => 0,
      c_has_bypass => 0,
      c_has_c_in => 0,
      c_has_c_out => 0,
      c_has_ce => 1,
      c_has_sclr => 0,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_implementation => 0,
      c_latency => 1,
      c_out_width => 20,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_addsb_11_0_74c24ba8230946d7
  PORT MAP (
    a => a,
    b => b,
    clk => clk,
    ce => ce,
    s => s
  );
-- synthesis translate_on

END addsb_11_0_74c24ba8230946d7_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file mult_11_2_025f89b693a36f98.vhd when simulating
-- the core, mult_11_2_025f89b693a36f98. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY mult_11_2_025f89b693a36f98 IS
  PORT (
    clk : IN STD_LOGIC;
    a : IN STD_LOGIC_VECTOR(17 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(15 DOWNTO 0);
    ce : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    p : OUT STD_LOGIC_VECTOR(33 DOWNTO 0)
  );
END mult_11_2_025f89b693a36f98;

ARCHITECTURE mult_11_2_025f89b693a36f98_a OF mult_11_2_025f89b693a36f98 IS
-- synthesis translate_off
COMPONENT wrapped_mult_11_2_025f89b693a36f98
  PORT (
    clk : IN STD_LOGIC;
    a : IN STD_LOGIC_VECTOR(17 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(15 DOWNTO 0);
    ce : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    p : OUT STD_LOGIC_VECTOR(33 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_mult_11_2_025f89b693a36f98 USE ENTITY XilinxCoreLib.mult_gen_v11_2(behavioral)
    GENERIC MAP (
      c_a_type => 0,
      c_a_width => 18,
      c_b_type => 0,
      c_b_value => "10000001",
      c_b_width => 16,
      c_ccm_imp => 0,
      c_ce_overrides_sclr => 1,
      c_has_ce => 1,
      c_has_sclr => 1,
      c_has_zero_detect => 0,
      c_latency => 5,
      c_model_type => 0,
      c_mult_type => 1,
      c_optimize_goal => 1,
      c_out_high => 33,
      c_out_low => 0,
      c_round_output => 0,
      c_round_pt => 0,
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_mult_11_2_025f89b693a36f98
  PORT MAP (
    clk => clk,
    a => a,
    b => b,
    ce => ce,
    sclr => sclr,
    p => p
  );
-- synthesis translate_on

END mult_11_2_025f89b693a36f98_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_72_0164249481f978ca.vhd when simulating
-- the core, bmg_72_0164249481f978ca. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_72_0164249481f978ca IS
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(15 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(15 DOWNTO 0)
  );
END bmg_72_0164249481f978ca;

ARCHITECTURE bmg_72_0164249481f978ca_a OF bmg_72_0164249481f978ca IS
-- synthesis translate_off
COMPONENT wrapped_bmg_72_0164249481f978ca
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(15 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(15 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_bmg_72_0164249481f978ca USE ENTITY XilinxCoreLib.blk_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addra_width => 8,
      c_addrb_width => 8,
      c_algorithm => 1,
      c_axi_id_width => 4,
      c_axi_slave_type => 0,
      c_axi_type => 1,
      c_byte_size => 9,
      c_common_clk => 0,
      c_default_data => "0",
      c_disable_warn_bhv_coll => 0,
      c_disable_warn_bhv_range => 0,
      c_enable_32bit_address => 0,
      c_family => "virtex6",
      c_has_axi_id => 0,
      c_has_ena => 1,
      c_has_enb => 0,
      c_has_injecterr => 0,
      c_has_mem_output_regs_a => 1,
      c_has_mem_output_regs_b => 0,
      c_has_mux_output_regs_a => 0,
      c_has_mux_output_regs_b => 0,
      c_has_regcea => 0,
      c_has_regceb => 0,
      c_has_rsta => 0,
      c_has_rstb => 0,
      c_has_softecc_input_regs_a => 0,
      c_has_softecc_output_regs_b => 0,
      c_init_file_name => "bmg_72_0164249481f978ca.mif",
      c_inita_val => "0",
      c_initb_val => "0",
      c_interface_type => 0,
      c_load_init_file => 1,
      c_mem_type => 0,
      c_mux_pipeline_stages => 0,
      c_prim_type => 1,
      c_read_depth_a => 256,
      c_read_depth_b => 256,
      c_read_width_a => 16,
      c_read_width_b => 16,
      c_rst_priority_a => "CE",
      c_rst_priority_b => "CE",
      c_rst_type => "SYNC",
      c_rstram_a => 0,
      c_rstram_b => 0,
      c_sim_collision_check => "ALL",
      c_use_byte_wea => 0,
      c_use_byte_web => 0,
      c_use_default_data => 0,
      c_use_ecc => 0,
      c_use_softecc => 0,
      c_wea_width => 1,
      c_web_width => 1,
      c_write_depth_a => 256,
      c_write_depth_b => 256,
      c_write_mode_a => "READ_FIRST",
      c_write_mode_b => "WRITE_FIRST",
      c_write_width_a => 16,
      c_write_width_b => 16,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_72_0164249481f978ca
  PORT MAP (
    clka => clka,
    ena => ena,
    wea => wea,
    addra => addra,
    dina => dina,
    douta => douta
  );
-- synthesis translate_on

END bmg_72_0164249481f978ca_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file addsb_11_0_e7ad3a217b0e91ae.vhd when simulating
-- the core, addsb_11_0_e7ad3a217b0e91ae. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY addsb_11_0_e7ad3a217b0e91ae IS
  PORT (
    a : IN STD_LOGIC_VECTOR(32 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(32 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(32 DOWNTO 0)
  );
END addsb_11_0_e7ad3a217b0e91ae;

ARCHITECTURE addsb_11_0_e7ad3a217b0e91ae_a OF addsb_11_0_e7ad3a217b0e91ae IS
-- synthesis translate_off
COMPONENT wrapped_addsb_11_0_e7ad3a217b0e91ae
  PORT (
    a : IN STD_LOGIC_VECTOR(32 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(32 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(32 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_addsb_11_0_e7ad3a217b0e91ae USE ENTITY XilinxCoreLib.c_addsub_v11_0(behavioral)
    GENERIC MAP (
      c_a_type => 0,
      c_a_width => 33,
      c_add_mode => 1,
      c_ainit_val => "0",
      c_b_constant => 0,
      c_b_type => 0,
      c_b_value => "000000000000000000000000000000000",
      c_b_width => 33,
      c_borrow_low => 1,
      c_bypass_low => 0,
      c_ce_overrides_bypass => 1,
      c_ce_overrides_sclr => 0,
      c_has_bypass => 0,
      c_has_c_in => 0,
      c_has_c_out => 0,
      c_has_ce => 1,
      c_has_sclr => 0,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_implementation => 0,
      c_latency => 1,
      c_out_width => 33,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_addsb_11_0_e7ad3a217b0e91ae
  PORT MAP (
    a => a,
    b => b,
    clk => clk,
    ce => ce,
    s => s
  );
-- synthesis translate_on

END addsb_11_0_e7ad3a217b0e91ae_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file cntr_11_0_1e48762428ed22e0.vhd when simulating
-- the core, cntr_11_0_1e48762428ed22e0. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY cntr_11_0_1e48762428ed22e0 IS
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sinit : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(31 DOWNTO 0)
  );
END cntr_11_0_1e48762428ed22e0;

ARCHITECTURE cntr_11_0_1e48762428ed22e0_a OF cntr_11_0_1e48762428ed22e0 IS
-- synthesis translate_off
COMPONENT wrapped_cntr_11_0_1e48762428ed22e0
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sinit : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(31 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_cntr_11_0_1e48762428ed22e0 USE ENTITY XilinxCoreLib.c_counter_binary_v11_0(behavioral)
    GENERIC MAP (
      c_ainit_val => "0",
      c_ce_overrides_sync => 0,
      c_count_by => "1",
      c_count_mode => 0,
      c_count_to => "1",
      c_fb_latency => 0,
      c_has_ce => 1,
      c_has_load => 0,
      c_has_sclr => 0,
      c_has_sinit => 1,
      c_has_sset => 0,
      c_has_thresh0 => 0,
      c_implementation => 0,
      c_latency => 1,
      c_load_low => 0,
      c_restrict_count => 0,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_thresh0_value => "1",
      c_verbosity => 0,
      c_width => 32,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_cntr_11_0_1e48762428ed22e0
  PORT MAP (
    clk => clk,
    ce => ce,
    sinit => sinit,
    q => q
  );
-- synthesis translate_on

END cntr_11_0_1e48762428ed22e0_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file addsb_11_0_9ec4483802d81769.vhd when simulating
-- the core, addsb_11_0_9ec4483802d81769. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY addsb_11_0_9ec4483802d81769 IS
  PORT (
    a : IN STD_LOGIC_VECTOR(29 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(29 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(29 DOWNTO 0)
  );
END addsb_11_0_9ec4483802d81769;

ARCHITECTURE addsb_11_0_9ec4483802d81769_a OF addsb_11_0_9ec4483802d81769 IS
-- synthesis translate_off
COMPONENT wrapped_addsb_11_0_9ec4483802d81769
  PORT (
    a : IN STD_LOGIC_VECTOR(29 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(29 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(29 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_addsb_11_0_9ec4483802d81769 USE ENTITY XilinxCoreLib.c_addsub_v11_0(behavioral)
    GENERIC MAP (
      c_a_type => 0,
      c_a_width => 30,
      c_add_mode => 0,
      c_ainit_val => "0",
      c_b_constant => 0,
      c_b_type => 0,
      c_b_value => "000000000000000000000000000000",
      c_b_width => 30,
      c_borrow_low => 1,
      c_bypass_low => 0,
      c_ce_overrides_bypass => 1,
      c_ce_overrides_sclr => 0,
      c_has_bypass => 0,
      c_has_c_in => 0,
      c_has_c_out => 0,
      c_has_ce => 1,
      c_has_sclr => 0,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_implementation => 1,
      c_latency => 2,
      c_out_width => 30,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_addsb_11_0_9ec4483802d81769
  PORT MAP (
    a => a,
    b => b,
    clk => clk,
    ce => ce,
    s => s
  );
-- synthesis translate_on

END addsb_11_0_9ec4483802d81769_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file addsb_11_0_26c38df2140ab027.vhd when simulating
-- the core, addsb_11_0_26c38df2140ab027. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY addsb_11_0_26c38df2140ab027 IS
  PORT (
    a : IN STD_LOGIC_VECTOR(38 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(38 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(38 DOWNTO 0)
  );
END addsb_11_0_26c38df2140ab027;

ARCHITECTURE addsb_11_0_26c38df2140ab027_a OF addsb_11_0_26c38df2140ab027 IS
-- synthesis translate_off
COMPONENT wrapped_addsb_11_0_26c38df2140ab027
  PORT (
    a : IN STD_LOGIC_VECTOR(38 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(38 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(38 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_addsb_11_0_26c38df2140ab027 USE ENTITY XilinxCoreLib.c_addsub_v11_0(behavioral)
    GENERIC MAP (
      c_a_type => 0,
      c_a_width => 39,
      c_add_mode => 0,
      c_ainit_val => "0",
      c_b_constant => 0,
      c_b_type => 0,
      c_b_value => "000000000000000000000000000000000000000",
      c_b_width => 39,
      c_borrow_low => 1,
      c_bypass_low => 0,
      c_ce_overrides_bypass => 1,
      c_ce_overrides_sclr => 0,
      c_has_bypass => 0,
      c_has_c_in => 0,
      c_has_c_out => 0,
      c_has_ce => 1,
      c_has_sclr => 0,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_implementation => 1,
      c_latency => 2,
      c_out_width => 39,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_addsb_11_0_26c38df2140ab027
  PORT MAP (
    a => a,
    b => b,
    clk => clk,
    ce => ce,
    s => s
  );
-- synthesis translate_on

END addsb_11_0_26c38df2140ab027_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file mult_11_2_0d4e928dcde39e83.vhd when simulating
-- the core, mult_11_2_0d4e928dcde39e83. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY mult_11_2_0d4e928dcde39e83 IS
  PORT (
    clk : IN STD_LOGIC;
    a : IN STD_LOGIC_VECTOR(39 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(17 DOWNTO 0);
    ce : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    p : OUT STD_LOGIC_VECTOR(57 DOWNTO 0)
  );
END mult_11_2_0d4e928dcde39e83;

ARCHITECTURE mult_11_2_0d4e928dcde39e83_a OF mult_11_2_0d4e928dcde39e83 IS
-- synthesis translate_off
COMPONENT wrapped_mult_11_2_0d4e928dcde39e83
  PORT (
    clk : IN STD_LOGIC;
    a : IN STD_LOGIC_VECTOR(39 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(17 DOWNTO 0);
    ce : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    p : OUT STD_LOGIC_VECTOR(57 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_mult_11_2_0d4e928dcde39e83 USE ENTITY XilinxCoreLib.mult_gen_v11_2(behavioral)
    GENERIC MAP (
      c_a_type => 0,
      c_a_width => 40,
      c_b_type => 0,
      c_b_value => "10000001",
      c_b_width => 18,
      c_ccm_imp => 0,
      c_ce_overrides_sclr => 1,
      c_has_ce => 1,
      c_has_sclr => 1,
      c_has_zero_detect => 0,
      c_latency => 4,
      c_model_type => 0,
      c_mult_type => 1,
      c_optimize_goal => 1,
      c_out_high => 57,
      c_out_low => 0,
      c_round_output => 0,
      c_round_pt => 0,
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_mult_11_2_0d4e928dcde39e83
  PORT MAP (
    clk => clk,
    a => a,
    b => b,
    ce => ce,
    sclr => sclr,
    p => p
  );
-- synthesis translate_on

END mult_11_2_0d4e928dcde39e83_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file addsb_11_0_c326c4567b3c5b63.vhd when simulating
-- the core, addsb_11_0_c326c4567b3c5b63. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY addsb_11_0_c326c4567b3c5b63 IS
  PORT (
    a : IN STD_LOGIC_VECTOR(16 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(16 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(16 DOWNTO 0)
  );
END addsb_11_0_c326c4567b3c5b63;

ARCHITECTURE addsb_11_0_c326c4567b3c5b63_a OF addsb_11_0_c326c4567b3c5b63 IS
-- synthesis translate_off
COMPONENT wrapped_addsb_11_0_c326c4567b3c5b63
  PORT (
    a : IN STD_LOGIC_VECTOR(16 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(16 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(16 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_addsb_11_0_c326c4567b3c5b63 USE ENTITY XilinxCoreLib.c_addsub_v11_0(behavioral)
    GENERIC MAP (
      c_a_type => 0,
      c_a_width => 17,
      c_add_mode => 1,
      c_ainit_val => "0",
      c_b_constant => 0,
      c_b_type => 0,
      c_b_value => "00000000000000000",
      c_b_width => 17,
      c_borrow_low => 1,
      c_bypass_low => 0,
      c_ce_overrides_bypass => 1,
      c_ce_overrides_sclr => 0,
      c_has_bypass => 0,
      c_has_c_in => 0,
      c_has_c_out => 0,
      c_has_ce => 1,
      c_has_sclr => 0,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_implementation => 0,
      c_latency => 1,
      c_out_width => 17,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_addsb_11_0_c326c4567b3c5b63
  PORT MAP (
    a => a,
    b => b,
    clk => clk,
    ce => ce,
    s => s
  );
-- synthesis translate_on

END addsb_11_0_c326c4567b3c5b63_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file mult_11_2_603515128dc5baa2.vhd when simulating
-- the core, mult_11_2_603515128dc5baa2. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY mult_11_2_603515128dc5baa2 IS
  PORT (
    clk : IN STD_LOGIC;
    a : IN STD_LOGIC_VECTOR(11 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(11 DOWNTO 0);
    ce : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    p : OUT STD_LOGIC_VECTOR(23 DOWNTO 0)
  );
END mult_11_2_603515128dc5baa2;

ARCHITECTURE mult_11_2_603515128dc5baa2_a OF mult_11_2_603515128dc5baa2 IS
-- synthesis translate_off
COMPONENT wrapped_mult_11_2_603515128dc5baa2
  PORT (
    clk : IN STD_LOGIC;
    a : IN STD_LOGIC_VECTOR(11 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(11 DOWNTO 0);
    ce : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    p : OUT STD_LOGIC_VECTOR(23 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_mult_11_2_603515128dc5baa2 USE ENTITY XilinxCoreLib.mult_gen_v11_2(behavioral)
    GENERIC MAP (
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_value => "10000001",
      c_b_width => 12,
      c_ccm_imp => 0,
      c_ce_overrides_sclr => 1,
      c_has_ce => 1,
      c_has_sclr => 1,
      c_has_zero_detect => 0,
      c_latency => 4,
      c_model_type => 0,
      c_mult_type => 1,
      c_optimize_goal => 1,
      c_out_high => 23,
      c_out_low => 0,
      c_round_output => 0,
      c_round_pt => 0,
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_mult_11_2_603515128dc5baa2
  PORT MAP (
    clk => clk,
    a => a,
    b => b,
    ce => ce,
    sclr => sclr,
    p => p
  );
-- synthesis translate_on

END mult_11_2_603515128dc5baa2_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_72_ccc293fe4d2b0f7a.vhd when simulating
-- the core, bmg_72_ccc293fe4d2b0f7a. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_72_ccc293fe4d2b0f7a IS
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(20 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(20 DOWNTO 0)
  );
END bmg_72_ccc293fe4d2b0f7a;

ARCHITECTURE bmg_72_ccc293fe4d2b0f7a_a OF bmg_72_ccc293fe4d2b0f7a IS
-- synthesis translate_off
COMPONENT wrapped_bmg_72_ccc293fe4d2b0f7a
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(20 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(20 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_bmg_72_ccc293fe4d2b0f7a USE ENTITY XilinxCoreLib.blk_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addra_width => 8,
      c_addrb_width => 8,
      c_algorithm => 1,
      c_axi_id_width => 4,
      c_axi_slave_type => 0,
      c_axi_type => 1,
      c_byte_size => 9,
      c_common_clk => 0,
      c_default_data => "0",
      c_disable_warn_bhv_coll => 0,
      c_disable_warn_bhv_range => 0,
      c_enable_32bit_address => 0,
      c_family => "virtex6",
      c_has_axi_id => 0,
      c_has_ena => 1,
      c_has_enb => 0,
      c_has_injecterr => 0,
      c_has_mem_output_regs_a => 1,
      c_has_mem_output_regs_b => 0,
      c_has_mux_output_regs_a => 0,
      c_has_mux_output_regs_b => 0,
      c_has_regcea => 0,
      c_has_regceb => 0,
      c_has_rsta => 0,
      c_has_rstb => 0,
      c_has_softecc_input_regs_a => 0,
      c_has_softecc_output_regs_b => 0,
      c_init_file_name => "bmg_72_ccc293fe4d2b0f7a.mif",
      c_inita_val => "0",
      c_initb_val => "0",
      c_interface_type => 0,
      c_load_init_file => 1,
      c_mem_type => 0,
      c_mux_pipeline_stages => 0,
      c_prim_type => 1,
      c_read_depth_a => 256,
      c_read_depth_b => 256,
      c_read_width_a => 21,
      c_read_width_b => 21,
      c_rst_priority_a => "CE",
      c_rst_priority_b => "CE",
      c_rst_type => "SYNC",
      c_rstram_a => 0,
      c_rstram_b => 0,
      c_sim_collision_check => "ALL",
      c_use_byte_wea => 0,
      c_use_byte_web => 0,
      c_use_default_data => 0,
      c_use_ecc => 0,
      c_use_softecc => 0,
      c_wea_width => 1,
      c_web_width => 1,
      c_write_depth_a => 256,
      c_write_depth_b => 256,
      c_write_mode_a => "READ_FIRST",
      c_write_mode_b => "WRITE_FIRST",
      c_write_width_a => 21,
      c_write_width_b => 21,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_72_ccc293fe4d2b0f7a
  PORT MAP (
    clka => clka,
    ena => ena,
    wea => wea,
    addra => addra,
    dina => dina,
    douta => douta
  );
-- synthesis translate_on

END bmg_72_ccc293fe4d2b0f7a_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file mult_11_2_bcc54b656f5ca805.vhd when simulating
-- the core, mult_11_2_bcc54b656f5ca805. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY mult_11_2_bcc54b656f5ca805 IS
  PORT (
    clk : IN STD_LOGIC;
    a : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(11 DOWNTO 0);
    ce : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    p : OUT STD_LOGIC_VECTOR(19 DOWNTO 0)
  );
END mult_11_2_bcc54b656f5ca805;

ARCHITECTURE mult_11_2_bcc54b656f5ca805_a OF mult_11_2_bcc54b656f5ca805 IS
-- synthesis translate_off
COMPONENT wrapped_mult_11_2_bcc54b656f5ca805
  PORT (
    clk : IN STD_LOGIC;
    a : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(11 DOWNTO 0);
    ce : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    p : OUT STD_LOGIC_VECTOR(19 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_mult_11_2_bcc54b656f5ca805 USE ENTITY XilinxCoreLib.mult_gen_v11_2(behavioral)
    GENERIC MAP (
      c_a_type => 1,
      c_a_width => 8,
      c_b_type => 0,
      c_b_value => "10000001",
      c_b_width => 12,
      c_ccm_imp => 0,
      c_ce_overrides_sclr => 1,
      c_has_ce => 1,
      c_has_sclr => 1,
      c_has_zero_detect => 0,
      c_latency => 3,
      c_model_type => 0,
      c_mult_type => 1,
      c_optimize_goal => 1,
      c_out_high => 19,
      c_out_low => 0,
      c_round_output => 0,
      c_round_pt => 0,
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_mult_11_2_bcc54b656f5ca805
  PORT MAP (
    clk => clk,
    a => a,
    b => b,
    ce => ce,
    sclr => sclr,
    p => p
  );
-- synthesis translate_on

END mult_11_2_bcc54b656f5ca805_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file cntr_11_0_68b407ad69be9ca8.vhd when simulating
-- the core, cntr_11_0_68b407ad69be9ca8. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY cntr_11_0_68b407ad69be9ca8 IS
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sinit : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(3 DOWNTO 0)
  );
END cntr_11_0_68b407ad69be9ca8;

ARCHITECTURE cntr_11_0_68b407ad69be9ca8_a OF cntr_11_0_68b407ad69be9ca8 IS
-- synthesis translate_off
COMPONENT wrapped_cntr_11_0_68b407ad69be9ca8
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sinit : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(3 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_cntr_11_0_68b407ad69be9ca8 USE ENTITY XilinxCoreLib.c_counter_binary_v11_0(behavioral)
    GENERIC MAP (
      c_ainit_val => "0",
      c_ce_overrides_sync => 0,
      c_count_by => "1",
      c_count_mode => 0,
      c_count_to => "1",
      c_fb_latency => 0,
      c_has_ce => 1,
      c_has_load => 0,
      c_has_sclr => 0,
      c_has_sinit => 1,
      c_has_sset => 0,
      c_has_thresh0 => 0,
      c_implementation => 0,
      c_latency => 1,
      c_load_low => 0,
      c_restrict_count => 0,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_thresh0_value => "1",
      c_verbosity => 0,
      c_width => 4,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_cntr_11_0_68b407ad69be9ca8
  PORT MAP (
    clk => clk,
    ce => ce,
    sinit => sinit,
    q => q
  );
-- synthesis translate_on

END cntr_11_0_68b407ad69be9ca8_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_72_ee57e7186689376a.vhd when simulating
-- the core, bmg_72_ee57e7186689376a. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_72_ee57e7186689376a IS
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(8 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(15 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(15 DOWNTO 0)
  );
END bmg_72_ee57e7186689376a;

ARCHITECTURE bmg_72_ee57e7186689376a_a OF bmg_72_ee57e7186689376a IS
-- synthesis translate_off
COMPONENT wrapped_bmg_72_ee57e7186689376a
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(8 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(15 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(15 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_bmg_72_ee57e7186689376a USE ENTITY XilinxCoreLib.blk_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addra_width => 9,
      c_addrb_width => 9,
      c_algorithm => 1,
      c_axi_id_width => 4,
      c_axi_slave_type => 0,
      c_axi_type => 1,
      c_byte_size => 9,
      c_common_clk => 0,
      c_default_data => "0",
      c_disable_warn_bhv_coll => 0,
      c_disable_warn_bhv_range => 0,
      c_enable_32bit_address => 0,
      c_family => "virtex6",
      c_has_axi_id => 0,
      c_has_ena => 1,
      c_has_enb => 0,
      c_has_injecterr => 0,
      c_has_mem_output_regs_a => 1,
      c_has_mem_output_regs_b => 0,
      c_has_mux_output_regs_a => 0,
      c_has_mux_output_regs_b => 0,
      c_has_regcea => 0,
      c_has_regceb => 0,
      c_has_rsta => 0,
      c_has_rstb => 0,
      c_has_softecc_input_regs_a => 0,
      c_has_softecc_output_regs_b => 0,
      c_init_file_name => "bmg_72_ee57e7186689376a.mif",
      c_inita_val => "0",
      c_initb_val => "0",
      c_interface_type => 0,
      c_load_init_file => 1,
      c_mem_type => 0,
      c_mux_pipeline_stages => 0,
      c_prim_type => 1,
      c_read_depth_a => 512,
      c_read_depth_b => 512,
      c_read_width_a => 16,
      c_read_width_b => 16,
      c_rst_priority_a => "CE",
      c_rst_priority_b => "CE",
      c_rst_type => "SYNC",
      c_rstram_a => 0,
      c_rstram_b => 0,
      c_sim_collision_check => "ALL",
      c_use_byte_wea => 0,
      c_use_byte_web => 0,
      c_use_default_data => 0,
      c_use_ecc => 0,
      c_use_softecc => 0,
      c_wea_width => 1,
      c_web_width => 1,
      c_write_depth_a => 512,
      c_write_depth_b => 512,
      c_write_mode_a => "READ_FIRST",
      c_write_mode_b => "WRITE_FIRST",
      c_write_width_a => 16,
      c_write_width_b => 16,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_72_ee57e7186689376a
  PORT MAP (
    clka => clka,
    ena => ena,
    wea => wea,
    addra => addra,
    dina => dina,
    douta => douta
  );
-- synthesis translate_on

END bmg_72_ee57e7186689376a_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file mult_11_2_645200e4043096c0.vhd when simulating
-- the core, mult_11_2_645200e4043096c0. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY mult_11_2_645200e4043096c0 IS
  PORT (
    clk : IN STD_LOGIC;
    a : IN STD_LOGIC_VECTOR(18 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(15 DOWNTO 0);
    ce : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    p : OUT STD_LOGIC_VECTOR(34 DOWNTO 0)
  );
END mult_11_2_645200e4043096c0;

ARCHITECTURE mult_11_2_645200e4043096c0_a OF mult_11_2_645200e4043096c0 IS
-- synthesis translate_off
COMPONENT wrapped_mult_11_2_645200e4043096c0
  PORT (
    clk : IN STD_LOGIC;
    a : IN STD_LOGIC_VECTOR(18 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(15 DOWNTO 0);
    ce : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    p : OUT STD_LOGIC_VECTOR(34 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_mult_11_2_645200e4043096c0 USE ENTITY XilinxCoreLib.mult_gen_v11_2(behavioral)
    GENERIC MAP (
      c_a_type => 0,
      c_a_width => 19,
      c_b_type => 0,
      c_b_value => "10000001",
      c_b_width => 16,
      c_ccm_imp => 0,
      c_ce_overrides_sclr => 1,
      c_has_ce => 1,
      c_has_sclr => 1,
      c_has_zero_detect => 0,
      c_latency => 4,
      c_model_type => 0,
      c_mult_type => 1,
      c_optimize_goal => 1,
      c_out_high => 34,
      c_out_low => 0,
      c_round_output => 0,
      c_round_pt => 0,
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_mult_11_2_645200e4043096c0
  PORT MAP (
    clk => clk,
    a => a,
    b => b,
    ce => ce,
    sclr => sclr,
    p => p
  );
-- synthesis translate_on

END mult_11_2_645200e4043096c0_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_72_5200d17ea41d7d8d.vhd when simulating
-- the core, bmg_72_5200d17ea41d7d8d. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_72_5200d17ea41d7d8d IS
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(8 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(275 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(275 DOWNTO 0);
    clkb : IN STD_LOGIC;
    enb : IN STD_LOGIC;
    web : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addrb : IN STD_LOGIC_VECTOR(8 DOWNTO 0);
    dinb : IN STD_LOGIC_VECTOR(275 DOWNTO 0);
    doutb : OUT STD_LOGIC_VECTOR(275 DOWNTO 0)
  );
END bmg_72_5200d17ea41d7d8d;

ARCHITECTURE bmg_72_5200d17ea41d7d8d_a OF bmg_72_5200d17ea41d7d8d IS
-- synthesis translate_off
COMPONENT wrapped_bmg_72_5200d17ea41d7d8d
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(8 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(275 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(275 DOWNTO 0);
    clkb : IN STD_LOGIC;
    enb : IN STD_LOGIC;
    web : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addrb : IN STD_LOGIC_VECTOR(8 DOWNTO 0);
    dinb : IN STD_LOGIC_VECTOR(275 DOWNTO 0);
    doutb : OUT STD_LOGIC_VECTOR(275 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_bmg_72_5200d17ea41d7d8d USE ENTITY XilinxCoreLib.blk_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addra_width => 9,
      c_addrb_width => 9,
      c_algorithm => 1,
      c_axi_id_width => 4,
      c_axi_slave_type => 0,
      c_axi_type => 1,
      c_byte_size => 9,
      c_common_clk => 1,
      c_default_data => "0",
      c_disable_warn_bhv_coll => 0,
      c_disable_warn_bhv_range => 0,
      c_enable_32bit_address => 0,
      c_family => "virtex6",
      c_has_axi_id => 0,
      c_has_ena => 1,
      c_has_enb => 1,
      c_has_injecterr => 0,
      c_has_mem_output_regs_a => 1,
      c_has_mem_output_regs_b => 1,
      c_has_mux_output_regs_a => 0,
      c_has_mux_output_regs_b => 0,
      c_has_regcea => 0,
      c_has_regceb => 0,
      c_has_rsta => 0,
      c_has_rstb => 0,
      c_has_softecc_input_regs_a => 0,
      c_has_softecc_output_regs_b => 0,
      c_init_file_name => "bmg_72_5200d17ea41d7d8d.mif",
      c_inita_val => "0",
      c_initb_val => "0",
      c_interface_type => 0,
      c_load_init_file => 1,
      c_mem_type => 2,
      c_mux_pipeline_stages => 0,
      c_prim_type => 1,
      c_read_depth_a => 512,
      c_read_depth_b => 512,
      c_read_width_a => 276,
      c_read_width_b => 276,
      c_rst_priority_a => "CE",
      c_rst_priority_b => "CE",
      c_rst_type => "SYNC",
      c_rstram_a => 0,
      c_rstram_b => 0,
      c_sim_collision_check => "ALL",
      c_use_byte_wea => 0,
      c_use_byte_web => 0,
      c_use_default_data => 0,
      c_use_ecc => 0,
      c_use_softecc => 0,
      c_wea_width => 1,
      c_web_width => 1,
      c_write_depth_a => 512,
      c_write_depth_b => 512,
      c_write_mode_a => "WRITE_FIRST",
      c_write_mode_b => "READ_FIRST",
      c_write_width_a => 276,
      c_write_width_b => 276,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_72_5200d17ea41d7d8d
  PORT MAP (
    clka => clka,
    ena => ena,
    wea => wea,
    addra => addra,
    dina => dina,
    douta => douta,
    clkb => clkb,
    enb => enb,
    web => web,
    addrb => addrb,
    dinb => dinb,
    doutb => doutb
  );
-- synthesis translate_on

END bmg_72_5200d17ea41d7d8d_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file cntr_11_0_10352c017544bebd.vhd when simulating
-- the core, cntr_11_0_10352c017544bebd. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY cntr_11_0_10352c017544bebd IS
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sinit : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(1 DOWNTO 0)
  );
END cntr_11_0_10352c017544bebd;

ARCHITECTURE cntr_11_0_10352c017544bebd_a OF cntr_11_0_10352c017544bebd IS
-- synthesis translate_off
COMPONENT wrapped_cntr_11_0_10352c017544bebd
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sinit : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(1 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_cntr_11_0_10352c017544bebd USE ENTITY XilinxCoreLib.c_counter_binary_v11_0(behavioral)
    GENERIC MAP (
      c_ainit_val => "0",
      c_ce_overrides_sync => 0,
      c_count_by => "1",
      c_count_mode => 0,
      c_count_to => "1",
      c_fb_latency => 0,
      c_has_ce => 1,
      c_has_load => 0,
      c_has_sclr => 0,
      c_has_sinit => 1,
      c_has_sset => 0,
      c_has_thresh0 => 0,
      c_implementation => 0,
      c_latency => 1,
      c_load_low => 0,
      c_restrict_count => 0,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_thresh0_value => "1",
      c_verbosity => 0,
      c_width => 2,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_cntr_11_0_10352c017544bebd
  PORT MAP (
    clk => clk,
    ce => ce,
    sinit => sinit,
    q => q
  );
-- synthesis translate_on

END cntr_11_0_10352c017544bebd_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file addsb_11_0_4e2bc60003cf26be.vhd when simulating
-- the core, addsb_11_0_4e2bc60003cf26be. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY addsb_11_0_4e2bc60003cf26be IS
  PORT (
    a : IN STD_LOGIC_VECTOR(26 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(26 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(26 DOWNTO 0)
  );
END addsb_11_0_4e2bc60003cf26be;

ARCHITECTURE addsb_11_0_4e2bc60003cf26be_a OF addsb_11_0_4e2bc60003cf26be IS
-- synthesis translate_off
COMPONENT wrapped_addsb_11_0_4e2bc60003cf26be
  PORT (
    a : IN STD_LOGIC_VECTOR(26 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(26 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(26 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_addsb_11_0_4e2bc60003cf26be USE ENTITY XilinxCoreLib.c_addsub_v11_0(behavioral)
    GENERIC MAP (
      c_a_type => 0,
      c_a_width => 27,
      c_add_mode => 0,
      c_ainit_val => "0",
      c_b_constant => 0,
      c_b_type => 0,
      c_b_value => "000000000000000000000000000",
      c_b_width => 27,
      c_borrow_low => 1,
      c_bypass_low => 0,
      c_ce_overrides_bypass => 1,
      c_ce_overrides_sclr => 0,
      c_has_bypass => 0,
      c_has_c_in => 0,
      c_has_c_out => 0,
      c_has_ce => 1,
      c_has_sclr => 0,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_implementation => 1,
      c_latency => 2,
      c_out_width => 27,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_addsb_11_0_4e2bc60003cf26be
  PORT MAP (
    a => a,
    b => b,
    clk => clk,
    ce => ce,
    s => s
  );
-- synthesis translate_on

END addsb_11_0_4e2bc60003cf26be_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file addsb_11_0_905df78b66389ded.vhd when simulating
-- the core, addsb_11_0_905df78b66389ded. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY addsb_11_0_905df78b66389ded IS
  PORT (
    a : IN STD_LOGIC_VECTOR(25 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(25 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(25 DOWNTO 0)
  );
END addsb_11_0_905df78b66389ded;

ARCHITECTURE addsb_11_0_905df78b66389ded_a OF addsb_11_0_905df78b66389ded IS
-- synthesis translate_off
COMPONENT wrapped_addsb_11_0_905df78b66389ded
  PORT (
    a : IN STD_LOGIC_VECTOR(25 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(25 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(25 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_addsb_11_0_905df78b66389ded USE ENTITY XilinxCoreLib.c_addsub_v11_0(behavioral)
    GENERIC MAP (
      c_a_type => 0,
      c_a_width => 26,
      c_add_mode => 0,
      c_ainit_val => "0",
      c_b_constant => 0,
      c_b_type => 0,
      c_b_value => "00000000000000000000000000",
      c_b_width => 26,
      c_borrow_low => 1,
      c_bypass_low => 0,
      c_ce_overrides_bypass => 1,
      c_ce_overrides_sclr => 0,
      c_has_bypass => 0,
      c_has_c_in => 0,
      c_has_c_out => 0,
      c_has_ce => 1,
      c_has_sclr => 0,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_implementation => 1,
      c_latency => 2,
      c_out_width => 26,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_addsb_11_0_905df78b66389ded
  PORT MAP (
    a => a,
    b => b,
    clk => clk,
    ce => ce,
    s => s
  );
-- synthesis translate_on

END addsb_11_0_905df78b66389ded_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_72_3b6e667e30cd6119.vhd when simulating
-- the core, bmg_72_3b6e667e30cd6119. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_72_3b6e667e30cd6119 IS
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(11 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(11 DOWNTO 0)
  );
END bmg_72_3b6e667e30cd6119;

ARCHITECTURE bmg_72_3b6e667e30cd6119_a OF bmg_72_3b6e667e30cd6119 IS
-- synthesis translate_off
COMPONENT wrapped_bmg_72_3b6e667e30cd6119
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(11 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(11 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_bmg_72_3b6e667e30cd6119 USE ENTITY XilinxCoreLib.blk_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addra_width => 8,
      c_addrb_width => 8,
      c_algorithm => 1,
      c_axi_id_width => 4,
      c_axi_slave_type => 0,
      c_axi_type => 1,
      c_byte_size => 9,
      c_common_clk => 0,
      c_default_data => "0",
      c_disable_warn_bhv_coll => 0,
      c_disable_warn_bhv_range => 0,
      c_enable_32bit_address => 0,
      c_family => "virtex6",
      c_has_axi_id => 0,
      c_has_ena => 1,
      c_has_enb => 0,
      c_has_injecterr => 0,
      c_has_mem_output_regs_a => 1,
      c_has_mem_output_regs_b => 0,
      c_has_mux_output_regs_a => 0,
      c_has_mux_output_regs_b => 0,
      c_has_regcea => 0,
      c_has_regceb => 0,
      c_has_rsta => 0,
      c_has_rstb => 0,
      c_has_softecc_input_regs_a => 0,
      c_has_softecc_output_regs_b => 0,
      c_init_file_name => "bmg_72_3b6e667e30cd6119.mif",
      c_inita_val => "0",
      c_initb_val => "0",
      c_interface_type => 0,
      c_load_init_file => 1,
      c_mem_type => 0,
      c_mux_pipeline_stages => 0,
      c_prim_type => 1,
      c_read_depth_a => 256,
      c_read_depth_b => 256,
      c_read_width_a => 12,
      c_read_width_b => 12,
      c_rst_priority_a => "CE",
      c_rst_priority_b => "CE",
      c_rst_type => "SYNC",
      c_rstram_a => 0,
      c_rstram_b => 0,
      c_sim_collision_check => "ALL",
      c_use_byte_wea => 0,
      c_use_byte_web => 0,
      c_use_default_data => 0,
      c_use_ecc => 0,
      c_use_softecc => 0,
      c_wea_width => 1,
      c_web_width => 1,
      c_write_depth_a => 256,
      c_write_depth_b => 256,
      c_write_mode_a => "NO_CHANGE",
      c_write_mode_b => "WRITE_FIRST",
      c_write_width_a => 12,
      c_write_width_b => 12,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_72_3b6e667e30cd6119
  PORT MAP (
    clka => clka,
    ena => ena,
    wea => wea,
    addra => addra,
    dina => dina,
    douta => douta
  );
-- synthesis translate_on

END bmg_72_3b6e667e30cd6119_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file mult_11_2_d3611e41a47815a8.vhd when simulating
-- the core, mult_11_2_d3611e41a47815a8. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY mult_11_2_d3611e41a47815a8 IS
  PORT (
    clk : IN STD_LOGIC;
    a : IN STD_LOGIC_VECTOR(20 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(17 DOWNTO 0);
    ce : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    p : OUT STD_LOGIC_VECTOR(38 DOWNTO 0)
  );
END mult_11_2_d3611e41a47815a8;

ARCHITECTURE mult_11_2_d3611e41a47815a8_a OF mult_11_2_d3611e41a47815a8 IS
-- synthesis translate_off
COMPONENT wrapped_mult_11_2_d3611e41a47815a8
  PORT (
    clk : IN STD_LOGIC;
    a : IN STD_LOGIC_VECTOR(20 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(17 DOWNTO 0);
    ce : IN STD_LOGIC;
    sclr : IN STD_LOGIC;
    p : OUT STD_LOGIC_VECTOR(38 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_mult_11_2_d3611e41a47815a8 USE ENTITY XilinxCoreLib.mult_gen_v11_2(behavioral)
    GENERIC MAP (
      c_a_type => 0,
      c_a_width => 21,
      c_b_type => 0,
      c_b_value => "10000001",
      c_b_width => 18,
      c_ccm_imp => 0,
      c_ce_overrides_sclr => 1,
      c_has_ce => 1,
      c_has_sclr => 1,
      c_has_zero_detect => 0,
      c_latency => 3,
      c_model_type => 0,
      c_mult_type => 1,
      c_optimize_goal => 1,
      c_out_high => 38,
      c_out_low => 0,
      c_round_output => 0,
      c_round_pt => 0,
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_mult_11_2_d3611e41a47815a8
  PORT MAP (
    clk => clk,
    a => a,
    b => b,
    ce => ce,
    sclr => sclr,
    p => p
  );
-- synthesis translate_on

END mult_11_2_d3611e41a47815a8_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_72_83f6efe890a72ff6.vhd when simulating
-- the core, bmg_72_83f6efe890a72ff6. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_72_83f6efe890a72ff6 IS
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(43 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(43 DOWNTO 0)
  );
END bmg_72_83f6efe890a72ff6;

ARCHITECTURE bmg_72_83f6efe890a72ff6_a OF bmg_72_83f6efe890a72ff6 IS
-- synthesis translate_off
COMPONENT wrapped_bmg_72_83f6efe890a72ff6
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(43 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(43 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_bmg_72_83f6efe890a72ff6 USE ENTITY XilinxCoreLib.blk_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addra_width => 8,
      c_addrb_width => 8,
      c_algorithm => 0,
      c_axi_id_width => 4,
      c_axi_slave_type => 0,
      c_axi_type => 1,
      c_byte_size => 9,
      c_common_clk => 0,
      c_default_data => "0",
      c_disable_warn_bhv_coll => 0,
      c_disable_warn_bhv_range => 0,
      c_enable_32bit_address => 0,
      c_family => "virtex6",
      c_has_axi_id => 0,
      c_has_ena => 1,
      c_has_enb => 0,
      c_has_injecterr => 0,
      c_has_mem_output_regs_a => 1,
      c_has_mem_output_regs_b => 0,
      c_has_mux_output_regs_a => 0,
      c_has_mux_output_regs_b => 0,
      c_has_regcea => 0,
      c_has_regceb => 0,
      c_has_rsta => 0,
      c_has_rstb => 0,
      c_has_softecc_input_regs_a => 0,
      c_has_softecc_output_regs_b => 0,
      c_init_file_name => "bmg_72_83f6efe890a72ff6.mif",
      c_inita_val => "0",
      c_initb_val => "0",
      c_interface_type => 0,
      c_load_init_file => 1,
      c_mem_type => 0,
      c_mux_pipeline_stages => 0,
      c_prim_type => 5,
      c_read_depth_a => 256,
      c_read_depth_b => 256,
      c_read_width_a => 44,
      c_read_width_b => 44,
      c_rst_priority_a => "CE",
      c_rst_priority_b => "CE",
      c_rst_type => "SYNC",
      c_rstram_a => 0,
      c_rstram_b => 0,
      c_sim_collision_check => "ALL",
      c_use_byte_wea => 0,
      c_use_byte_web => 0,
      c_use_default_data => 0,
      c_use_ecc => 0,
      c_use_softecc => 0,
      c_wea_width => 1,
      c_web_width => 1,
      c_write_depth_a => 256,
      c_write_depth_b => 256,
      c_write_mode_a => "NO_CHANGE",
      c_write_mode_b => "WRITE_FIRST",
      c_write_width_a => 44,
      c_write_width_b => 44,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_72_83f6efe890a72ff6
  PORT MAP (
    clka => clka,
    ena => ena,
    wea => wea,
    addra => addra,
    dina => dina,
    douta => douta
  );
-- synthesis translate_on

END bmg_72_83f6efe890a72ff6_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file cntr_11_0_8fd3bf4fb2c5b76d.vhd when simulating
-- the core, cntr_11_0_8fd3bf4fb2c5b76d. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY cntr_11_0_8fd3bf4fb2c5b76d IS
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sinit : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(31 DOWNTO 0)
  );
END cntr_11_0_8fd3bf4fb2c5b76d;

ARCHITECTURE cntr_11_0_8fd3bf4fb2c5b76d_a OF cntr_11_0_8fd3bf4fb2c5b76d IS
-- synthesis translate_off
COMPONENT wrapped_cntr_11_0_8fd3bf4fb2c5b76d
  PORT (
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    sinit : IN STD_LOGIC;
    q : OUT STD_LOGIC_VECTOR(31 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_cntr_11_0_8fd3bf4fb2c5b76d USE ENTITY XilinxCoreLib.c_counter_binary_v11_0(behavioral)
    GENERIC MAP (
      c_ainit_val => "0",
      c_ce_overrides_sync => 0,
      c_count_by => "1",
      c_count_mode => 0,
      c_count_to => "1",
      c_fb_latency => 0,
      c_has_ce => 1,
      c_has_load => 0,
      c_has_sclr => 0,
      c_has_sinit => 1,
      c_has_sset => 0,
      c_has_thresh0 => 0,
      c_implementation => 0,
      c_latency => 1,
      c_load_low => 0,
      c_restrict_count => 0,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "11111111111111111111111111111111",
      c_thresh0_value => "1",
      c_verbosity => 0,
      c_width => 32,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_cntr_11_0_8fd3bf4fb2c5b76d
  PORT MAP (
    clk => clk,
    ce => ce,
    sinit => sinit,
    q => q
  );
-- synthesis translate_on

END cntr_11_0_8fd3bf4fb2c5b76d_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file addsb_11_0_075266d61a42e95d.vhd when simulating
-- the core, addsb_11_0_075266d61a42e95d. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY addsb_11_0_075266d61a42e95d IS
  PORT (
    a : IN STD_LOGIC_VECTOR(39 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(39 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(39 DOWNTO 0)
  );
END addsb_11_0_075266d61a42e95d;

ARCHITECTURE addsb_11_0_075266d61a42e95d_a OF addsb_11_0_075266d61a42e95d IS
-- synthesis translate_off
COMPONENT wrapped_addsb_11_0_075266d61a42e95d
  PORT (
    a : IN STD_LOGIC_VECTOR(39 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(39 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(39 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_addsb_11_0_075266d61a42e95d USE ENTITY XilinxCoreLib.c_addsub_v11_0(behavioral)
    GENERIC MAP (
      c_a_type => 0,
      c_a_width => 40,
      c_add_mode => 0,
      c_ainit_val => "0",
      c_b_constant => 0,
      c_b_type => 0,
      c_b_value => "0000000000000000000000000000000000000000",
      c_b_width => 40,
      c_borrow_low => 1,
      c_bypass_low => 0,
      c_ce_overrides_bypass => 1,
      c_ce_overrides_sclr => 0,
      c_has_bypass => 0,
      c_has_c_in => 0,
      c_has_c_out => 0,
      c_has_ce => 1,
      c_has_sclr => 0,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_implementation => 1,
      c_latency => 2,
      c_out_width => 40,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_addsb_11_0_075266d61a42e95d
  PORT MAP (
    a => a,
    b => b,
    clk => clk,
    ce => ce,
    s => s
  );
-- synthesis translate_on

END addsb_11_0_075266d61a42e95d_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file bmg_72_c89b8e32d1739de7.vhd when simulating
-- the core, bmg_72_c89b8e32d1739de7. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY bmg_72_c89b8e32d1739de7 IS
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(9 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(9 DOWNTO 0)
  );
END bmg_72_c89b8e32d1739de7;

ARCHITECTURE bmg_72_c89b8e32d1739de7_a OF bmg_72_c89b8e32d1739de7 IS
-- synthesis translate_off
COMPONENT wrapped_bmg_72_c89b8e32d1739de7
  PORT (
    clka : IN STD_LOGIC;
    ena : IN STD_LOGIC;
    wea : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
    addra : IN STD_LOGIC_VECTOR(7 DOWNTO 0);
    dina : IN STD_LOGIC_VECTOR(9 DOWNTO 0);
    douta : OUT STD_LOGIC_VECTOR(9 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_bmg_72_c89b8e32d1739de7 USE ENTITY XilinxCoreLib.blk_mem_gen_v7_2(behavioral)
    GENERIC MAP (
      c_addra_width => 8,
      c_addrb_width => 8,
      c_algorithm => 1,
      c_axi_id_width => 4,
      c_axi_slave_type => 0,
      c_axi_type => 1,
      c_byte_size => 9,
      c_common_clk => 0,
      c_default_data => "0",
      c_disable_warn_bhv_coll => 0,
      c_disable_warn_bhv_range => 0,
      c_enable_32bit_address => 0,
      c_family => "virtex6",
      c_has_axi_id => 0,
      c_has_ena => 1,
      c_has_enb => 0,
      c_has_injecterr => 0,
      c_has_mem_output_regs_a => 1,
      c_has_mem_output_regs_b => 0,
      c_has_mux_output_regs_a => 0,
      c_has_mux_output_regs_b => 0,
      c_has_regcea => 0,
      c_has_regceb => 0,
      c_has_rsta => 0,
      c_has_rstb => 0,
      c_has_softecc_input_regs_a => 0,
      c_has_softecc_output_regs_b => 0,
      c_init_file_name => "bmg_72_c89b8e32d1739de7.mif",
      c_inita_val => "0",
      c_initb_val => "0",
      c_interface_type => 0,
      c_load_init_file => 1,
      c_mem_type => 0,
      c_mux_pipeline_stages => 0,
      c_prim_type => 1,
      c_read_depth_a => 256,
      c_read_depth_b => 256,
      c_read_width_a => 10,
      c_read_width_b => 10,
      c_rst_priority_a => "CE",
      c_rst_priority_b => "CE",
      c_rst_type => "SYNC",
      c_rstram_a => 0,
      c_rstram_b => 0,
      c_sim_collision_check => "ALL",
      c_use_byte_wea => 0,
      c_use_byte_web => 0,
      c_use_default_data => 0,
      c_use_ecc => 0,
      c_use_softecc => 0,
      c_wea_width => 1,
      c_web_width => 1,
      c_write_depth_a => 256,
      c_write_depth_b => 256,
      c_write_mode_a => "READ_FIRST",
      c_write_mode_b => "WRITE_FIRST",
      c_write_width_a => 10,
      c_write_width_b => 10,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_bmg_72_c89b8e32d1739de7
  PORT MAP (
    clka => clka,
    ena => ena,
    wea => wea,
    addra => addra,
    dina => dina,
    douta => douta
  );
-- synthesis translate_on

END bmg_72_c89b8e32d1739de7_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file addsb_11_0_9875f8c5f2e232ba.vhd when simulating
-- the core, addsb_11_0_9875f8c5f2e232ba. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY addsb_11_0_9875f8c5f2e232ba IS
  PORT (
    a : IN STD_LOGIC_VECTOR(28 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(28 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(28 DOWNTO 0)
  );
END addsb_11_0_9875f8c5f2e232ba;

ARCHITECTURE addsb_11_0_9875f8c5f2e232ba_a OF addsb_11_0_9875f8c5f2e232ba IS
-- synthesis translate_off
COMPONENT wrapped_addsb_11_0_9875f8c5f2e232ba
  PORT (
    a : IN STD_LOGIC_VECTOR(28 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(28 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(28 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_addsb_11_0_9875f8c5f2e232ba USE ENTITY XilinxCoreLib.c_addsub_v11_0(behavioral)
    GENERIC MAP (
      c_a_type => 0,
      c_a_width => 29,
      c_add_mode => 0,
      c_ainit_val => "0",
      c_b_constant => 0,
      c_b_type => 0,
      c_b_value => "00000000000000000000000000000",
      c_b_width => 29,
      c_borrow_low => 1,
      c_bypass_low => 0,
      c_ce_overrides_bypass => 1,
      c_ce_overrides_sclr => 0,
      c_has_bypass => 0,
      c_has_c_in => 0,
      c_has_c_out => 0,
      c_has_ce => 1,
      c_has_sclr => 0,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_implementation => 1,
      c_latency => 2,
      c_out_width => 29,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_addsb_11_0_9875f8c5f2e232ba
  PORT MAP (
    a => a,
    b => b,
    clk => clk,
    ce => ce,
    s => s
  );
-- synthesis translate_on

END addsb_11_0_9875f8c5f2e232ba_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file addsb_11_0_d58a8e32191e1b22.vhd when simulating
-- the core, addsb_11_0_d58a8e32191e1b22. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY addsb_11_0_d58a8e32191e1b22 IS
  PORT (
    a : IN STD_LOGIC_VECTOR(58 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(58 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(58 DOWNTO 0)
  );
END addsb_11_0_d58a8e32191e1b22;

ARCHITECTURE addsb_11_0_d58a8e32191e1b22_a OF addsb_11_0_d58a8e32191e1b22 IS
-- synthesis translate_off
COMPONENT wrapped_addsb_11_0_d58a8e32191e1b22
  PORT (
    a : IN STD_LOGIC_VECTOR(58 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(58 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(58 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_addsb_11_0_d58a8e32191e1b22 USE ENTITY XilinxCoreLib.c_addsub_v11_0(behavioral)
    GENERIC MAP (
      c_a_type => 0,
      c_a_width => 59,
      c_add_mode => 0,
      c_ainit_val => "0",
      c_b_constant => 0,
      c_b_type => 0,
      c_b_value => "00000000000000000000000000000000000000000000000000000000000",
      c_b_width => 59,
      c_borrow_low => 1,
      c_bypass_low => 0,
      c_ce_overrides_bypass => 1,
      c_ce_overrides_sclr => 0,
      c_has_bypass => 0,
      c_has_c_in => 0,
      c_has_c_out => 0,
      c_has_ce => 1,
      c_has_sclr => 0,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_implementation => 0,
      c_latency => 1,
      c_out_width => 59,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_addsb_11_0_d58a8e32191e1b22
  PORT MAP (
    a => a,
    b => b,
    clk => clk,
    ce => ce,
    s => s
  );
-- synthesis translate_on

END addsb_11_0_d58a8e32191e1b22_a;
--------------------------------------------------------------------------------
--    This file is owned and controlled by Xilinx and must be used solely     --
--    for design, simulation, implementation and creation of design files     --
--    limited to Xilinx devices or technologies. Use with non-Xilinx          --
--    devices or technologies is expressly prohibited and immediately         --
--    terminates your license.                                                --
--                                                                            --
--    XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" SOLELY    --
--    FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY    --
--    PROVIDING THIS DESIGN, CODE, OR INFORMATION AS ONE POSSIBLE             --
--    IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD, XILINX IS      --
--    MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE FROM ANY      --
--    CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING ANY       --
--    RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY       --
--    DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE   --
--    IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR          --
--    REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF         --
--    INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A   --
--    PARTICULAR PURPOSE.                                                     --
--                                                                            --
--    Xilinx products are not intended for use in life support appliances,    --
--    devices, or systems.  Use in such applications are expressly            --
--    prohibited.                                                             --
--                                                                            --
--    (c) Copyright 1995-2017 Xilinx, Inc.                                    --
--    All rights reserved.                                                    --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
-- You must compile the wrapper file addsb_11_0_d5c2386c66db1f8d.vhd when simulating
-- the core, addsb_11_0_d5c2386c66db1f8d. When compiling the wrapper file, be sure to
-- reference the XilinxCoreLib VHDL simulation library. For detailed
-- instructions, please refer to the "CORE Generator Help".

-- The synthesis directives "translate_off/translate_on" specified
-- below are supported by Xilinx, Mentor Graphics and Synplicity
-- synthesis tools. Ensure they are correct for your synthesis tool(s).

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
-- synthesis translate_off
LIBRARY XilinxCoreLib;
-- synthesis translate_on
ENTITY addsb_11_0_d5c2386c66db1f8d IS
  PORT (
    a : IN STD_LOGIC_VECTOR(21 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(21 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(21 DOWNTO 0)
  );
END addsb_11_0_d5c2386c66db1f8d;

ARCHITECTURE addsb_11_0_d5c2386c66db1f8d_a OF addsb_11_0_d5c2386c66db1f8d IS
-- synthesis translate_off
COMPONENT wrapped_addsb_11_0_d5c2386c66db1f8d
  PORT (
    a : IN STD_LOGIC_VECTOR(21 DOWNTO 0);
    b : IN STD_LOGIC_VECTOR(21 DOWNTO 0);
    clk : IN STD_LOGIC;
    ce : IN STD_LOGIC;
    s : OUT STD_LOGIC_VECTOR(21 DOWNTO 0)
  );
END COMPONENT;

-- Configuration specification
  FOR ALL : wrapped_addsb_11_0_d5c2386c66db1f8d USE ENTITY XilinxCoreLib.c_addsub_v11_0(behavioral)
    GENERIC MAP (
      c_a_type => 0,
      c_a_width => 22,
      c_add_mode => 1,
      c_ainit_val => "0",
      c_b_constant => 0,
      c_b_type => 0,
      c_b_value => "0000000000000000000000",
      c_b_width => 22,
      c_borrow_low => 1,
      c_bypass_low => 0,
      c_ce_overrides_bypass => 1,
      c_ce_overrides_sclr => 0,
      c_has_bypass => 0,
      c_has_c_in => 0,
      c_has_c_out => 0,
      c_has_ce => 1,
      c_has_sclr => 0,
      c_has_sinit => 0,
      c_has_sset => 0,
      c_implementation => 0,
      c_latency => 1,
      c_out_width => 22,
      c_sclr_overrides_sset => 1,
      c_sinit_val => "0",
      c_verbosity => 0,
      c_xdevicefamily => "virtex6"
    );
-- synthesis translate_on
BEGIN
-- synthesis translate_off
U0 : wrapped_addsb_11_0_d5c2386c66db1f8d
  PORT MAP (
    a => a,
    b => b,
    clk => clk,
    ce => ce,
    s => s
  );
-- synthesis translate_on

END addsb_11_0_d5c2386c66db1f8d_a;

-------------------------------------------------------------------
-- System Generator version 14.3 VHDL source file.
--
-- Copyright(C) 2012 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2012 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
package conv_pkg is
    constant simulating : boolean := false
      -- synopsys translate_off
        or true
      -- synopsys translate_on
    ;
    constant xlUnsigned : integer := 1;
    constant xlSigned : integer := 2;
    constant xlFloat : integer := 3;
    constant xlWrap : integer := 1;
    constant xlSaturate : integer := 2;
    constant xlTruncate : integer := 1;
    constant xlRound : integer := 2;
    constant xlRoundBanker : integer := 3;
    constant xlAddMode : integer := 1;
    constant xlSubMode : integer := 2;
    attribute black_box : boolean;
    attribute syn_black_box : boolean;
    attribute fpga_dont_touch: string;
    attribute box_type :  string;
    attribute keep : string;
    attribute syn_keep : boolean;
    function std_logic_vector_to_unsigned(inp : std_logic_vector) return unsigned;
    function unsigned_to_std_logic_vector(inp : unsigned) return std_logic_vector;
    function std_logic_vector_to_signed(inp : std_logic_vector) return signed;
    function signed_to_std_logic_vector(inp : signed) return std_logic_vector;
    function unsigned_to_signed(inp : unsigned) return signed;
    function signed_to_unsigned(inp : signed) return unsigned;
    function pos(inp : std_logic_vector; arith : INTEGER) return boolean;
    function all_same(inp: std_logic_vector) return boolean;
    function all_zeros(inp: std_logic_vector) return boolean;
    function is_point_five(inp: std_logic_vector) return boolean;
    function all_ones(inp: std_logic_vector) return boolean;
    function convert_type (inp : std_logic_vector; old_width, old_bin_pt,
                           old_arith, new_width, new_bin_pt, new_arith,
                           quantization, overflow : INTEGER)
        return std_logic_vector;
    function cast (inp : std_logic_vector; old_bin_pt,
                   new_width, new_bin_pt, new_arith : INTEGER)
        return std_logic_vector;
    function shift_division_result(quotient, fraction: std_logic_vector;
                                   fraction_width, shift_value, shift_dir: INTEGER)
        return std_logic_vector;
    function shift_op (inp: std_logic_vector;
                       result_width, shift_value, shift_dir: INTEGER)
        return std_logic_vector;
    function vec_slice (inp : std_logic_vector; upper, lower : INTEGER)
        return std_logic_vector;
    function s2u_slice (inp : signed; upper, lower : INTEGER)
        return unsigned;
    function u2u_slice (inp : unsigned; upper, lower : INTEGER)
        return unsigned;
    function s2s_cast (inp : signed; old_bin_pt,
                   new_width, new_bin_pt : INTEGER)
        return signed;
    function u2s_cast (inp : unsigned; old_bin_pt,
                   new_width, new_bin_pt : INTEGER)
        return signed;
    function s2u_cast (inp : signed; old_bin_pt,
                   new_width, new_bin_pt : INTEGER)
        return unsigned;
    function u2u_cast (inp : unsigned; old_bin_pt,
                   new_width, new_bin_pt : INTEGER)
        return unsigned;
    function u2v_cast (inp : unsigned; old_bin_pt,
                   new_width, new_bin_pt : INTEGER)
        return std_logic_vector;
    function s2v_cast (inp : signed; old_bin_pt,
                   new_width, new_bin_pt : INTEGER)
        return std_logic_vector;
    function trunc (inp : std_logic_vector; old_width, old_bin_pt, old_arith,
                    new_width, new_bin_pt, new_arith : INTEGER)
        return std_logic_vector;
    function round_towards_inf (inp : std_logic_vector; old_width, old_bin_pt,
                                old_arith, new_width, new_bin_pt,
                                new_arith : INTEGER) return std_logic_vector;
    function round_towards_even (inp : std_logic_vector; old_width, old_bin_pt,
                                old_arith, new_width, new_bin_pt,
                                new_arith : INTEGER) return std_logic_vector;
    function max_signed(width : INTEGER) return std_logic_vector;
    function min_signed(width : INTEGER) return std_logic_vector;
    function saturation_arith(inp:  std_logic_vector;  old_width, old_bin_pt,
                              old_arith, new_width, new_bin_pt, new_arith
                              : INTEGER) return std_logic_vector;
    function wrap_arith(inp:  std_logic_vector;  old_width, old_bin_pt,
                        old_arith, new_width, new_bin_pt, new_arith : INTEGER)
                        return std_logic_vector;
    function fractional_bits(a_bin_pt, b_bin_pt: INTEGER) return INTEGER;
    function integer_bits(a_width, a_bin_pt, b_width, b_bin_pt: INTEGER)
        return INTEGER;
    function sign_ext(inp : std_logic_vector; new_width : INTEGER)
        return std_logic_vector;
    function zero_ext(inp : std_logic_vector; new_width : INTEGER)
        return std_logic_vector;
    function zero_ext(inp : std_logic; new_width : INTEGER)
        return std_logic_vector;
    function extend_MSB(inp : std_logic_vector; new_width, arith : INTEGER)
        return std_logic_vector;
    function align_input(inp : std_logic_vector; old_width, delta, new_arith,
                          new_width: INTEGER)
        return std_logic_vector;
    function pad_LSB(inp : std_logic_vector; new_width: integer)
        return std_logic_vector;
    function pad_LSB(inp : std_logic_vector; new_width, arith : integer)
        return std_logic_vector;
    function max(L, R: INTEGER) return INTEGER;
    function min(L, R: INTEGER) return INTEGER;
    function "="(left,right: STRING) return boolean;
    function boolean_to_signed (inp : boolean; width: integer)
        return signed;
    function boolean_to_unsigned (inp : boolean; width: integer)
        return unsigned;
    function boolean_to_vector (inp : boolean)
        return std_logic_vector;
    function std_logic_to_vector (inp : std_logic)
        return std_logic_vector;
    function integer_to_std_logic_vector (inp : integer;  width, arith : integer)
        return std_logic_vector;
    function std_logic_vector_to_integer (inp : std_logic_vector;  arith : integer)
        return integer;
    function std_logic_to_integer(constant inp : std_logic := '0')
        return integer;
    function bin_string_element_to_std_logic_vector (inp : string;  width, index : integer)
        return std_logic_vector;
    function bin_string_to_std_logic_vector (inp : string)
        return std_logic_vector;
    function hex_string_to_std_logic_vector (inp : string; width : integer)
        return std_logic_vector;
    function makeZeroBinStr (width : integer) return STRING;
    function and_reduce(inp: std_logic_vector) return std_logic;
    -- synopsys translate_off
    function is_binary_string_invalid (inp : string)
        return boolean;
    function is_binary_string_undefined (inp : string)
        return boolean;
    function is_XorU(inp : std_logic_vector)
        return boolean;
    function to_real(inp : std_logic_vector; bin_pt : integer; arith : integer)
        return real;
    function std_logic_to_real(inp : std_logic; bin_pt : integer; arith : integer)
        return real;
    function real_to_std_logic_vector (inp : real;  width, bin_pt, arith : integer)
        return std_logic_vector;
    function real_string_to_std_logic_vector (inp : string;  width, bin_pt, arith : integer)
        return std_logic_vector;
    constant display_precision : integer := 20;
    function real_to_string (inp : real) return string;
    function valid_bin_string(inp : string) return boolean;
    function std_logic_vector_to_bin_string(inp : std_logic_vector) return string;
    function std_logic_to_bin_string(inp : std_logic) return string;
    function std_logic_vector_to_bin_string_w_point(inp : std_logic_vector; bin_pt : integer)
        return string;
    function real_to_bin_string(inp : real;  width, bin_pt, arith : integer)
        return string;
    type stdlogic_to_char_t is array(std_logic) of character;
    constant to_char : stdlogic_to_char_t := (
        'U' => 'U',
        'X' => 'X',
        '0' => '0',
        '1' => '1',
        'Z' => 'Z',
        'W' => 'W',
        'L' => 'L',
        'H' => 'H',
        '-' => '-');
    -- synopsys translate_on
end conv_pkg;
package body conv_pkg is
    function std_logic_vector_to_unsigned(inp : std_logic_vector)
        return unsigned
    is
    begin
        return unsigned (inp);
    end;
    function unsigned_to_std_logic_vector(inp : unsigned)
        return std_logic_vector
    is
    begin
        return std_logic_vector(inp);
    end;
    function std_logic_vector_to_signed(inp : std_logic_vector)
        return signed
    is
    begin
        return  signed (inp);
    end;
    function signed_to_std_logic_vector(inp : signed)
        return std_logic_vector
    is
    begin
        return std_logic_vector(inp);
    end;
    function unsigned_to_signed (inp : unsigned)
        return signed
    is
    begin
        return signed(std_logic_vector(inp));
    end;
    function signed_to_unsigned (inp : signed)
        return unsigned
    is
    begin
        return unsigned(std_logic_vector(inp));
    end;
    function pos(inp : std_logic_vector; arith : INTEGER)
        return boolean
    is
        constant width : integer := inp'length;
        variable vec : std_logic_vector(width-1 downto 0);
    begin
        vec := inp;
        if arith = xlUnsigned then
            return true;
        else
            if vec(width-1) = '0' then
                return true;
            else
                return false;
            end if;
        end if;
        return true;
    end;
    function max_signed(width : INTEGER)
        return std_logic_vector
    is
        variable ones : std_logic_vector(width-2 downto 0);
        variable result : std_logic_vector(width-1 downto 0);
    begin
        ones := (others => '1');
        result(width-1) := '0';
        result(width-2 downto 0) := ones;
        return result;
    end;
    function min_signed(width : INTEGER)
        return std_logic_vector
    is
        variable zeros : std_logic_vector(width-2 downto 0);
        variable result : std_logic_vector(width-1 downto 0);
    begin
        zeros := (others => '0');
        result(width-1) := '1';
        result(width-2 downto 0) := zeros;
        return result;
    end;
    function and_reduce(inp: std_logic_vector) return std_logic
    is
        variable result: std_logic;
        constant width : integer := inp'length;
        variable vec : std_logic_vector(width-1 downto 0);
    begin
        vec := inp;
        result := vec(0);
        if width > 1 then
            for i in 1 to width-1 loop
                result := result and vec(i);
            end loop;
        end if;
        return result;
    end;
    function all_same(inp: std_logic_vector) return boolean
    is
        variable result: boolean;
        constant width : integer := inp'length;
        variable vec : std_logic_vector(width-1 downto 0);
    begin
        vec := inp;
        result := true;
        if width > 0 then
            for i in 1 to width-1 loop
                if vec(i) /= vec(0) then
                    result := false;
                end if;
            end loop;
        end if;
        return result;
    end;
    function all_zeros(inp: std_logic_vector)
        return boolean
    is
        constant width : integer := inp'length;
        variable vec : std_logic_vector(width-1 downto 0);
        variable zero : std_logic_vector(width-1 downto 0);
        variable result : boolean;
    begin
        zero := (others => '0');
        vec := inp;
        -- synopsys translate_off
        if (is_XorU(vec)) then
            return false;
        end if;
         -- synopsys translate_on
        if (std_logic_vector_to_unsigned(vec) = std_logic_vector_to_unsigned(zero)) then
            result := true;
        else
            result := false;
        end if;
        return result;
    end;
    function is_point_five(inp: std_logic_vector)
        return boolean
    is
        constant width : integer := inp'length;
        variable vec : std_logic_vector(width-1 downto 0);
        variable result : boolean;
    begin
        vec := inp;
        -- synopsys translate_off
        if (is_XorU(vec)) then
            return false;
        end if;
         -- synopsys translate_on
        if (width > 1) then
           if ((vec(width-1) = '1') and (all_zeros(vec(width-2 downto 0)) = true)) then
               result := true;
           else
               result := false;
           end if;
        else
           if (vec(width-1) = '1') then
               result := true;
           else
               result := false;
           end if;
        end if;
        return result;
    end;
    function all_ones(inp: std_logic_vector)
        return boolean
    is
        constant width : integer := inp'length;
        variable vec : std_logic_vector(width-1 downto 0);
        variable one : std_logic_vector(width-1 downto 0);
        variable result : boolean;
    begin
        one := (others => '1');
        vec := inp;
        -- synopsys translate_off
        if (is_XorU(vec)) then
            return false;
        end if;
         -- synopsys translate_on
        if (std_logic_vector_to_unsigned(vec) = std_logic_vector_to_unsigned(one)) then
            result := true;
        else
            result := false;
        end if;
        return result;
    end;
    function full_precision_num_width(quantization, overflow, old_width,
                                      old_bin_pt, old_arith,
                                      new_width, new_bin_pt, new_arith : INTEGER)
        return integer
    is
        variable result : integer;
    begin
        result := old_width + 2;
        return result;
    end;
    function quantized_num_width(quantization, overflow, old_width, old_bin_pt,
                                 old_arith, new_width, new_bin_pt, new_arith
                                 : INTEGER)
        return integer
    is
        variable right_of_dp, left_of_dp, result : integer;
    begin
        right_of_dp := max(new_bin_pt, old_bin_pt);
        left_of_dp := max((new_width - new_bin_pt), (old_width - old_bin_pt));
        result := (old_width + 2) + (new_bin_pt - old_bin_pt);
        return result;
    end;
    function convert_type (inp : std_logic_vector; old_width, old_bin_pt,
                           old_arith, new_width, new_bin_pt, new_arith,
                           quantization, overflow : INTEGER)
        return std_logic_vector
    is
        constant fp_width : integer :=
            full_precision_num_width(quantization, overflow, old_width,
                                     old_bin_pt, old_arith, new_width,
                                     new_bin_pt, new_arith);
        constant fp_bin_pt : integer := old_bin_pt;
        constant fp_arith : integer := old_arith;
        variable full_precision_result : std_logic_vector(fp_width-1 downto 0);
        constant q_width : integer :=
            quantized_num_width(quantization, overflow, old_width, old_bin_pt,
                                old_arith, new_width, new_bin_pt, new_arith);
        constant q_bin_pt : integer := new_bin_pt;
        constant q_arith : integer := old_arith;
        variable quantized_result : std_logic_vector(q_width-1 downto 0);
        variable result : std_logic_vector(new_width-1 downto 0);
    begin
        result := (others => '0');
        full_precision_result := cast(inp, old_bin_pt, fp_width, fp_bin_pt,
                                      fp_arith);
        if (quantization = xlRound) then
            quantized_result := round_towards_inf(full_precision_result,
                                                  fp_width, fp_bin_pt,
                                                  fp_arith, q_width, q_bin_pt,
                                                  q_arith);
        elsif (quantization = xlRoundBanker) then
            quantized_result := round_towards_even(full_precision_result,
                                                  fp_width, fp_bin_pt,
                                                  fp_arith, q_width, q_bin_pt,
                                                  q_arith);
        else
            quantized_result := trunc(full_precision_result, fp_width, fp_bin_pt,
                                      fp_arith, q_width, q_bin_pt, q_arith);
        end if;
        if (overflow = xlSaturate) then
            result := saturation_arith(quantized_result, q_width, q_bin_pt,
                                       q_arith, new_width, new_bin_pt, new_arith);
        else
             result := wrap_arith(quantized_result, q_width, q_bin_pt, q_arith,
                                  new_width, new_bin_pt, new_arith);
        end if;
        return result;
    end;
    function cast (inp : std_logic_vector; old_bin_pt, new_width,
                   new_bin_pt, new_arith : INTEGER)
        return std_logic_vector
    is
        constant old_width : integer := inp'length;
        constant left_of_dp : integer := (new_width - new_bin_pt)
                                         - (old_width - old_bin_pt);
        constant right_of_dp : integer := (new_bin_pt - old_bin_pt);
        variable vec : std_logic_vector(old_width-1 downto 0);
        variable result : std_logic_vector(new_width-1 downto 0);
        variable j   : integer;
    begin
        vec := inp;
        for i in new_width-1 downto 0 loop
            j := i - right_of_dp;
            if ( j > old_width-1) then
                if (new_arith = xlUnsigned) then
                    result(i) := '0';
                else
                    result(i) := vec(old_width-1);
                end if;
            elsif ( j >= 0) then
                result(i) := vec(j);
            else
                result(i) := '0';
            end if;
        end loop;
        return result;
    end;
    function shift_division_result(quotient, fraction: std_logic_vector;
                                   fraction_width, shift_value, shift_dir: INTEGER)
        return std_logic_vector
    is
        constant q_width : integer := quotient'length;
        constant f_width : integer := fraction'length;
        constant vec_MSB : integer := q_width+f_width-1;
        constant result_MSB : integer := q_width+fraction_width-1;
        constant result_LSB : integer := vec_MSB-result_MSB;
        variable vec : std_logic_vector(vec_MSB downto 0);
        variable result : std_logic_vector(result_MSB downto 0);
    begin
        vec := ( quotient & fraction );
        if shift_dir = 1 then
            for i in vec_MSB downto 0 loop
                if (i < shift_value) then
                     vec(i) := '0';
                else
                    vec(i) := vec(i-shift_value);
                end if;
            end loop;
        else
            for i in 0 to vec_MSB loop
                if (i > vec_MSB-shift_value) then
                    vec(i) := vec(vec_MSB);
                else
                    vec(i) := vec(i+shift_value);
                end if;
            end loop;
        end if;
        result := vec(vec_MSB downto result_LSB);
        return result;
    end;
    function shift_op (inp: std_logic_vector;
                       result_width, shift_value, shift_dir: INTEGER)
        return std_logic_vector
    is
        constant inp_width : integer := inp'length;
        constant vec_MSB : integer := inp_width-1;
        constant result_MSB : integer := result_width-1;
        constant result_LSB : integer := vec_MSB-result_MSB;
        variable vec : std_logic_vector(vec_MSB downto 0);
        variable result : std_logic_vector(result_MSB downto 0);
    begin
        vec := inp;
        if shift_dir = 1 then
            for i in vec_MSB downto 0 loop
                if (i < shift_value) then
                     vec(i) := '0';
                else
                    vec(i) := vec(i-shift_value);
                end if;
            end loop;
        else
            for i in 0 to vec_MSB loop
                if (i > vec_MSB-shift_value) then
                    vec(i) := vec(vec_MSB);
                else
                    vec(i) := vec(i+shift_value);
                end if;
            end loop;
        end if;
        result := vec(vec_MSB downto result_LSB);
        return result;
    end;
    function vec_slice (inp : std_logic_vector; upper, lower : INTEGER)
      return std_logic_vector
    is
    begin
        return inp(upper downto lower);
    end;
    function s2u_slice (inp : signed; upper, lower : INTEGER)
      return unsigned
    is
    begin
        return unsigned(vec_slice(std_logic_vector(inp), upper, lower));
    end;
    function u2u_slice (inp : unsigned; upper, lower : INTEGER)
      return unsigned
    is
    begin
        return unsigned(vec_slice(std_logic_vector(inp), upper, lower));
    end;
    function s2s_cast (inp : signed; old_bin_pt, new_width, new_bin_pt : INTEGER)
        return signed
    is
    begin
        return signed(cast(std_logic_vector(inp), old_bin_pt, new_width, new_bin_pt, xlSigned));
    end;
    function s2u_cast (inp : signed; old_bin_pt, new_width,
                   new_bin_pt : INTEGER)
        return unsigned
    is
    begin
        return unsigned(cast(std_logic_vector(inp), old_bin_pt, new_width, new_bin_pt, xlSigned));
    end;
    function u2s_cast (inp : unsigned; old_bin_pt, new_width,
                   new_bin_pt : INTEGER)
        return signed
    is
    begin
        return signed(cast(std_logic_vector(inp), old_bin_pt, new_width, new_bin_pt, xlUnsigned));
    end;
    function u2u_cast (inp : unsigned; old_bin_pt, new_width,
                   new_bin_pt : INTEGER)
        return unsigned
    is
    begin
        return unsigned(cast(std_logic_vector(inp), old_bin_pt, new_width, new_bin_pt, xlUnsigned));
    end;
    function u2v_cast (inp : unsigned; old_bin_pt, new_width,
                   new_bin_pt : INTEGER)
        return std_logic_vector
    is
    begin
        return cast(std_logic_vector(inp), old_bin_pt, new_width, new_bin_pt, xlUnsigned);
    end;
    function s2v_cast (inp : signed; old_bin_pt, new_width,
                   new_bin_pt : INTEGER)
        return std_logic_vector
    is
    begin
        return cast(std_logic_vector(inp), old_bin_pt, new_width, new_bin_pt, xlSigned);
    end;
    function boolean_to_signed (inp : boolean; width : integer)
        return signed
    is
        variable result : signed(width - 1 downto 0);
    begin
        result := (others => '0');
        if inp then
          result(0) := '1';
        else
          result(0) := '0';
        end if;
        return result;
    end;
    function boolean_to_unsigned (inp : boolean; width : integer)
        return unsigned
    is
        variable result : unsigned(width - 1 downto 0);
    begin
        result := (others => '0');
        if inp then
          result(0) := '1';
        else
          result(0) := '0';
        end if;
        return result;
    end;
    function boolean_to_vector (inp : boolean)
        return std_logic_vector
    is
        variable result : std_logic_vector(1 - 1 downto 0);
    begin
        result := (others => '0');
        if inp then
          result(0) := '1';
        else
          result(0) := '0';
        end if;
        return result;
    end;
    function std_logic_to_vector (inp : std_logic)
        return std_logic_vector
    is
        variable result : std_logic_vector(1 - 1 downto 0);
    begin
        result(0) := inp;
        return result;
    end;
    function trunc (inp : std_logic_vector; old_width, old_bin_pt, old_arith,
                                new_width, new_bin_pt, new_arith : INTEGER)
        return std_logic_vector
    is
        constant right_of_dp : integer := (old_bin_pt - new_bin_pt);
        variable vec : std_logic_vector(old_width-1 downto 0);
        variable result : std_logic_vector(new_width-1 downto 0);
    begin
        vec := inp;
        if right_of_dp >= 0 then
            if new_arith = xlUnsigned then
                result := zero_ext(vec(old_width-1 downto right_of_dp), new_width);
            else
                result := sign_ext(vec(old_width-1 downto right_of_dp), new_width);
            end if;
        else
            if new_arith = xlUnsigned then
                result := zero_ext(pad_LSB(vec, old_width +
                                           abs(right_of_dp)), new_width);
            else
                result := sign_ext(pad_LSB(vec, old_width +
                                           abs(right_of_dp)), new_width);
            end if;
        end if;
        return result;
    end;
    function round_towards_inf (inp : std_logic_vector; old_width, old_bin_pt,
                                old_arith, new_width, new_bin_pt, new_arith
                                : INTEGER)
        return std_logic_vector
    is
        constant right_of_dp : integer := (old_bin_pt - new_bin_pt);
        constant expected_new_width : integer :=  old_width - right_of_dp  + 1;
        variable vec : std_logic_vector(old_width-1 downto 0);
        variable one_or_zero : std_logic_vector(new_width-1 downto 0);
        variable truncated_val : std_logic_vector(new_width-1 downto 0);
        variable result : std_logic_vector(new_width-1 downto 0);
    begin
        vec := inp;
        if right_of_dp >= 0 then
            if new_arith = xlUnsigned then
                truncated_val := zero_ext(vec(old_width-1 downto right_of_dp),
                                          new_width);
            else
                truncated_val := sign_ext(vec(old_width-1 downto right_of_dp),
                                          new_width);
            end if;
        else
            if new_arith = xlUnsigned then
                truncated_val := zero_ext(pad_LSB(vec, old_width +
                                                  abs(right_of_dp)), new_width);
            else
                truncated_val := sign_ext(pad_LSB(vec, old_width +
                                                  abs(right_of_dp)), new_width);
            end if;
        end if;
        one_or_zero := (others => '0');
        if (new_arith = xlSigned) then
            if (vec(old_width-1) = '0') then
                one_or_zero(0) := '1';
            end if;
            if (right_of_dp >= 2) and (right_of_dp <= old_width) then
                if (all_zeros(vec(right_of_dp-2 downto 0)) = false) then
                    one_or_zero(0) := '1';
                end if;
            end if;
            if (right_of_dp >= 1) and (right_of_dp <= old_width) then
                if vec(right_of_dp-1) = '0' then
                    one_or_zero(0) := '0';
                end if;
            else
                one_or_zero(0) := '0';
            end if;
        else
            if (right_of_dp >= 1) and (right_of_dp <= old_width) then
                one_or_zero(0) :=  vec(right_of_dp-1);
            end if;
        end if;
        if new_arith = xlSigned then
            result := signed_to_std_logic_vector(std_logic_vector_to_signed(truncated_val) +
                                                 std_logic_vector_to_signed(one_or_zero));
        else
            result := unsigned_to_std_logic_vector(std_logic_vector_to_unsigned(truncated_val) +
                                                  std_logic_vector_to_unsigned(one_or_zero));
        end if;
        return result;
    end;
    function round_towards_even (inp : std_logic_vector; old_width, old_bin_pt,
                                old_arith, new_width, new_bin_pt, new_arith
                                : INTEGER)
        return std_logic_vector
    is
        constant right_of_dp : integer := (old_bin_pt - new_bin_pt);
        constant expected_new_width : integer :=  old_width - right_of_dp  + 1;
        variable vec : std_logic_vector(old_width-1 downto 0);
        variable one_or_zero : std_logic_vector(new_width-1 downto 0);
        variable truncated_val : std_logic_vector(new_width-1 downto 0);
        variable result : std_logic_vector(new_width-1 downto 0);
    begin
        vec := inp;
        if right_of_dp >= 0 then
            if new_arith = xlUnsigned then
                truncated_val := zero_ext(vec(old_width-1 downto right_of_dp),
                                          new_width);
            else
                truncated_val := sign_ext(vec(old_width-1 downto right_of_dp),
                                          new_width);
            end if;
        else
            if new_arith = xlUnsigned then
                truncated_val := zero_ext(pad_LSB(vec, old_width +
                                                  abs(right_of_dp)), new_width);
            else
                truncated_val := sign_ext(pad_LSB(vec, old_width +
                                                  abs(right_of_dp)), new_width);
            end if;
        end if;
        one_or_zero := (others => '0');
        if (right_of_dp >= 1) and (right_of_dp <= old_width) then
            if (is_point_five(vec(right_of_dp-1 downto 0)) = false) then
                one_or_zero(0) :=  vec(right_of_dp-1);
            else
                one_or_zero(0) :=  vec(right_of_dp);
            end if;
        end if;
        if new_arith = xlSigned then
            result := signed_to_std_logic_vector(std_logic_vector_to_signed(truncated_val) +
                                                 std_logic_vector_to_signed(one_or_zero));
        else
            result := unsigned_to_std_logic_vector(std_logic_vector_to_unsigned(truncated_val) +
                                                  std_logic_vector_to_unsigned(one_or_zero));
        end if;
        return result;
    end;
    function saturation_arith(inp:  std_logic_vector;  old_width, old_bin_pt,
                              old_arith, new_width, new_bin_pt, new_arith
                              : INTEGER)
        return std_logic_vector
    is
        constant left_of_dp : integer := (old_width - old_bin_pt) -
                                         (new_width - new_bin_pt);
        variable vec : std_logic_vector(old_width-1 downto 0);
        variable result : std_logic_vector(new_width-1 downto 0);
        variable overflow : boolean;
    begin
        vec := inp;
        overflow := true;
        result := (others => '0');
        if (new_width >= old_width) then
            overflow := false;
        end if;
        if ((old_arith = xlSigned and new_arith = xlSigned) and (old_width > new_width)) then
            if all_same(vec(old_width-1 downto new_width-1)) then
                overflow := false;
            end if;
        end if;
        if (old_arith = xlSigned and new_arith = xlUnsigned) then
            if (old_width > new_width) then
                if all_zeros(vec(old_width-1 downto new_width)) then
                    overflow := false;
                end if;
            else
                if (old_width = new_width) then
                    if (vec(new_width-1) = '0') then
                        overflow := false;
                    end if;
                end if;
            end if;
        end if;
        if (old_arith = xlUnsigned and new_arith = xlUnsigned) then
            if (old_width > new_width) then
                if all_zeros(vec(old_width-1 downto new_width)) then
                    overflow := false;
                end if;
            else
                if (old_width = new_width) then
                    overflow := false;
                end if;
            end if;
        end if;
        if ((old_arith = xlUnsigned and new_arith = xlSigned) and (old_width > new_width)) then
            if all_same(vec(old_width-1 downto new_width-1)) then
                overflow := false;
            end if;
        end if;
        if overflow then
            if new_arith = xlSigned then
                if vec(old_width-1) = '0' then
                    result := max_signed(new_width);
                else
                    result := min_signed(new_width);
                end if;
            else
                if ((old_arith = xlSigned) and vec(old_width-1) = '1') then
                    result := (others => '0');
                else
                    result := (others => '1');
                end if;
            end if;
        else
            if (old_arith = xlSigned) and (new_arith = xlUnsigned) then
                if (vec(old_width-1) = '1') then
                    vec := (others => '0');
                end if;
            end if;
            if new_width <= old_width then
                result := vec(new_width-1 downto 0);
            else
                if new_arith = xlUnsigned then
                    result := zero_ext(vec, new_width);
                else
                    result := sign_ext(vec, new_width);
                end if;
            end if;
        end if;
        return result;
    end;
   function wrap_arith(inp:  std_logic_vector;  old_width, old_bin_pt,
                       old_arith, new_width, new_bin_pt, new_arith : INTEGER)
        return std_logic_vector
    is
        variable result : std_logic_vector(new_width-1 downto 0);
        variable result_arith : integer;
    begin
        if (old_arith = xlSigned) and (new_arith = xlUnsigned) then
            result_arith := xlSigned;
        end if;
        result := cast(inp, old_bin_pt, new_width, new_bin_pt, result_arith);
        return result;
    end;
    function fractional_bits(a_bin_pt, b_bin_pt: INTEGER) return INTEGER is
    begin
        return max(a_bin_pt, b_bin_pt);
    end;
    function integer_bits(a_width, a_bin_pt, b_width, b_bin_pt: INTEGER)
        return INTEGER is
    begin
        return  max(a_width - a_bin_pt, b_width - b_bin_pt);
    end;
    function pad_LSB(inp : std_logic_vector; new_width: integer)
        return STD_LOGIC_VECTOR
    is
        constant orig_width : integer := inp'length;
        variable vec : std_logic_vector(orig_width-1 downto 0);
        variable result : std_logic_vector(new_width-1 downto 0);
        variable pos : integer;
        constant pad_pos : integer := new_width - orig_width - 1;
    begin
        vec := inp;
        pos := new_width-1;
        if (new_width >= orig_width) then
            for i in orig_width-1 downto 0 loop
                result(pos) := vec(i);
                pos := pos - 1;
            end loop;
            if pad_pos >= 0 then
                for i in pad_pos downto 0 loop
                    result(i) := '0';
                end loop;
            end if;
        end if;
        return result;
    end;
    function sign_ext(inp : std_logic_vector; new_width : INTEGER)
        return std_logic_vector
    is
        constant old_width : integer := inp'length;
        variable vec : std_logic_vector(old_width-1 downto 0);
        variable result : std_logic_vector(new_width-1 downto 0);
    begin
        vec := inp;
        if new_width >= old_width then
            result(old_width-1 downto 0) := vec;
            if new_width-1 >= old_width then
                for i in new_width-1 downto old_width loop
                    result(i) := vec(old_width-1);
                end loop;
            end if;
        else
            result(new_width-1 downto 0) := vec(new_width-1 downto 0);
        end if;
        return result;
    end;
    function zero_ext(inp : std_logic_vector; new_width : INTEGER)
        return std_logic_vector
    is
        constant old_width : integer := inp'length;
        variable vec : std_logic_vector(old_width-1 downto 0);
        variable result : std_logic_vector(new_width-1 downto 0);
    begin
        vec := inp;
        if new_width >= old_width then
            result(old_width-1 downto 0) := vec;
            if new_width-1 >= old_width then
                for i in new_width-1 downto old_width loop
                    result(i) := '0';
                end loop;
            end if;
        else
            result(new_width-1 downto 0) := vec(new_width-1 downto 0);
        end if;
        return result;
    end;
    function zero_ext(inp : std_logic; new_width : INTEGER)
        return std_logic_vector
    is
        variable result : std_logic_vector(new_width-1 downto 0);
    begin
        result(0) := inp;
        for i in new_width-1 downto 1 loop
            result(i) := '0';
        end loop;
        return result;
    end;
    function extend_MSB(inp : std_logic_vector; new_width, arith : INTEGER)
        return std_logic_vector
    is
        constant orig_width : integer := inp'length;
        variable vec : std_logic_vector(orig_width-1 downto 0);
        variable result : std_logic_vector(new_width-1 downto 0);
    begin
        vec := inp;
        if arith = xlUnsigned then
            result := zero_ext(vec, new_width);
        else
            result := sign_ext(vec, new_width);
        end if;
        return result;
    end;
    function pad_LSB(inp : std_logic_vector; new_width, arith: integer)
        return STD_LOGIC_VECTOR
    is
        constant orig_width : integer := inp'length;
        variable vec : std_logic_vector(orig_width-1 downto 0);
        variable result : std_logic_vector(new_width-1 downto 0);
        variable pos : integer;
    begin
        vec := inp;
        pos := new_width-1;
        if (arith = xlUnsigned) then
            result(pos) := '0';
            pos := pos - 1;
        else
            result(pos) := vec(orig_width-1);
            pos := pos - 1;
        end if;
        if (new_width >= orig_width) then
            for i in orig_width-1 downto 0 loop
                result(pos) := vec(i);
                pos := pos - 1;
            end loop;
            if pos >= 0 then
                for i in pos downto 0 loop
                    result(i) := '0';
                end loop;
            end if;
        end if;
        return result;
    end;
    function align_input(inp : std_logic_vector; old_width, delta, new_arith,
                         new_width: INTEGER)
        return std_logic_vector
    is
        variable vec : std_logic_vector(old_width-1 downto 0);
        variable padded_inp : std_logic_vector((old_width + delta)-1  downto 0);
        variable result : std_logic_vector(new_width-1 downto 0);
    begin
        vec := inp;
        if delta > 0 then
            padded_inp := pad_LSB(vec, old_width+delta);
            result := extend_MSB(padded_inp, new_width, new_arith);
        else
            result := extend_MSB(vec, new_width, new_arith);
        end if;
        return result;
    end;
    function max(L, R: INTEGER) return INTEGER is
    begin
        if L > R then
            return L;
        else
            return R;
        end if;
    end;
    function min(L, R: INTEGER) return INTEGER is
    begin
        if L < R then
            return L;
        else
            return R;
        end if;
    end;
    function "="(left,right: STRING) return boolean is
    begin
        if (left'length /= right'length) then
            return false;
        else
            test : for i in 1 to left'length loop
                if left(i) /= right(i) then
                    return false;
                end if;
            end loop test;
            return true;
        end if;
    end;
    -- synopsys translate_off
    function is_binary_string_invalid (inp : string)
        return boolean
    is
        variable vec : string(1 to inp'length);
        variable result : boolean;
    begin
        vec := inp;
        result := false;
        for i in 1 to vec'length loop
            if ( vec(i) = 'X' ) then
                result := true;
            end if;
        end loop;
        return result;
    end;
    function is_binary_string_undefined (inp : string)
        return boolean
    is
        variable vec : string(1 to inp'length);
        variable result : boolean;
    begin
        vec := inp;
        result := false;
        for i in 1 to vec'length loop
            if ( vec(i) = 'U' ) then
                result := true;
            end if;
        end loop;
        return result;
    end;
    function is_XorU(inp : std_logic_vector)
        return boolean
    is
        constant width : integer := inp'length;
        variable vec : std_logic_vector(width-1 downto 0);
        variable result : boolean;
    begin
        vec := inp;
        result := false;
        for i in 0 to width-1 loop
            if (vec(i) = 'U') or (vec(i) = 'X') then
                result := true;
            end if;
        end loop;
        return result;
    end;
    function to_real(inp : std_logic_vector; bin_pt : integer; arith : integer)
        return real
    is
        variable  vec : std_logic_vector(inp'length-1 downto 0);
        variable result, shift_val, undefined_real : real;
        variable neg_num : boolean;
    begin
        vec := inp;
        result := 0.0;
        neg_num := false;
        if vec(inp'length-1) = '1' then
            neg_num := true;
        end if;
        for i in 0 to inp'length-1 loop
            if  vec(i) = 'U' or vec(i) = 'X' then
                return undefined_real;
            end if;
            if arith = xlSigned then
                if neg_num then
                    if vec(i) = '0' then
                        result := result + 2.0**i;
                    end if;
                else
                    if vec(i) = '1' then
                        result := result + 2.0**i;
                    end if;
                end if;
            else
                if vec(i) = '1' then
                    result := result + 2.0**i;
                end if;
            end if;
        end loop;
        if arith = xlSigned then
            if neg_num then
                result := result + 1.0;
                result := result * (-1.0);
            end if;
        end if;
        shift_val := 2.0**(-1*bin_pt);
        result := result * shift_val;
        return result;
    end;
    function std_logic_to_real(inp : std_logic; bin_pt : integer; arith : integer)
        return real
    is
        variable result : real := 0.0;
    begin
        if inp = '1' then
            result := 1.0;
        end if;
        if arith = xlSigned then
            assert false
                report "It doesn't make sense to convert a 1 bit number to a signed real.";
        end if;
        return result;
    end;
    -- synopsys translate_on
    function integer_to_std_logic_vector (inp : integer;  width, arith : integer)
        return std_logic_vector
    is
        variable result : std_logic_vector(width-1 downto 0);
        variable unsigned_val : unsigned(width-1 downto 0);
        variable signed_val : signed(width-1 downto 0);
    begin
        if (arith = xlSigned) then
            signed_val := to_signed(inp, width);
            result := signed_to_std_logic_vector(signed_val);
        else
            unsigned_val := to_unsigned(inp, width);
            result := unsigned_to_std_logic_vector(unsigned_val);
        end if;
        return result;
    end;
    function std_logic_vector_to_integer (inp : std_logic_vector;  arith : integer)
        return integer
    is
        constant width : integer := inp'length;
        variable unsigned_val : unsigned(width-1 downto 0);
        variable signed_val : signed(width-1 downto 0);
        variable result : integer;
    begin
        if (arith = xlSigned) then
            signed_val := std_logic_vector_to_signed(inp);
            result := to_integer(signed_val);
        else
            unsigned_val := std_logic_vector_to_unsigned(inp);
            result := to_integer(unsigned_val);
        end if;
        return result;
    end;
    function std_logic_to_integer(constant inp : std_logic := '0')
        return integer
    is
    begin
        if inp = '1' then
            return 1;
        else
            return 0;
        end if;
    end;
    function makeZeroBinStr (width : integer) return STRING is
        variable result : string(1 to width+3);
    begin
        result(1) := '0';
        result(2) := 'b';
        for i in 3 to width+2 loop
            result(i) := '0';
        end loop;
        result(width+3) := '.';
        return result;
    end;
    -- synopsys translate_off
    function real_string_to_std_logic_vector (inp : string;  width, bin_pt, arith : integer)
        return std_logic_vector
    is
        variable result : std_logic_vector(width-1 downto 0);
    begin
        result := (others => '0');
        return result;
    end;
    function real_to_std_logic_vector (inp : real;  width, bin_pt, arith : integer)
        return std_logic_vector
    is
        variable real_val : real;
        variable int_val : integer;
        variable result : std_logic_vector(width-1 downto 0) := (others => '0');
        variable unsigned_val : unsigned(width-1 downto 0) := (others => '0');
        variable signed_val : signed(width-1 downto 0) := (others => '0');
    begin
        real_val := inp;
        int_val := integer(real_val * 2.0**(bin_pt));
        if (arith = xlSigned) then
            signed_val := to_signed(int_val, width);
            result := signed_to_std_logic_vector(signed_val);
        else
            unsigned_val := to_unsigned(int_val, width);
            result := unsigned_to_std_logic_vector(unsigned_val);
        end if;
        return result;
    end;
    -- synopsys translate_on
    function valid_bin_string (inp : string)
        return boolean
    is
        variable vec : string(1 to inp'length);
    begin
        vec := inp;
        if (vec(1) = '0' and vec(2) = 'b') then
            return true;
        else
            return false;
        end if;
    end;
    function hex_string_to_std_logic_vector(inp: string; width : integer)
        return std_logic_vector is
        constant strlen       : integer := inp'LENGTH;
        variable result       : std_logic_vector(width-1 downto 0);
        variable bitval       : std_logic_vector((strlen*4)-1 downto 0);
        variable posn         : integer;
        variable ch           : character;
        variable vec          : string(1 to strlen);
    begin
        vec := inp;
        result := (others => '0');
        posn := (strlen*4)-1;
        for i in 1 to strlen loop
            ch := vec(i);
            case ch is
                when '0' => bitval(posn downto posn-3) := "0000";
                when '1' => bitval(posn downto posn-3) := "0001";
                when '2' => bitval(posn downto posn-3) := "0010";
                when '3' => bitval(posn downto posn-3) := "0011";
                when '4' => bitval(posn downto posn-3) := "0100";
                when '5' => bitval(posn downto posn-3) := "0101";
                when '6' => bitval(posn downto posn-3) := "0110";
                when '7' => bitval(posn downto posn-3) := "0111";
                when '8' => bitval(posn downto posn-3) := "1000";
                when '9' => bitval(posn downto posn-3) := "1001";
                when 'A' | 'a' => bitval(posn downto posn-3) := "1010";
                when 'B' | 'b' => bitval(posn downto posn-3) := "1011";
                when 'C' | 'c' => bitval(posn downto posn-3) := "1100";
                when 'D' | 'd' => bitval(posn downto posn-3) := "1101";
                when 'E' | 'e' => bitval(posn downto posn-3) := "1110";
                when 'F' | 'f' => bitval(posn downto posn-3) := "1111";
                when others => bitval(posn downto posn-3) := "XXXX";
                               -- synopsys translate_off
                               ASSERT false
                                   REPORT "Invalid hex value" SEVERITY ERROR;
                               -- synopsys translate_on
            end case;
            posn := posn - 4;
        end loop;
        if (width <= strlen*4) then
            result :=  bitval(width-1 downto 0);
        else
            result((strlen*4)-1 downto 0) := bitval;
        end if;
        return result;
    end;
    function bin_string_to_std_logic_vector (inp : string)
        return std_logic_vector
    is
        variable pos : integer;
        variable vec : string(1 to inp'length);
        variable result : std_logic_vector(inp'length-1 downto 0);
    begin
        vec := inp;
        pos := inp'length-1;
        result := (others => '0');
        for i in 1 to vec'length loop
            -- synopsys translate_off
            if (pos < 0) and (vec(i) = '0' or vec(i) = '1' or vec(i) = 'X' or vec(i) = 'U')  then
                assert false
                    report "Input string is larger than output std_logic_vector. Truncating output.";
                return result;
            end if;
            -- synopsys translate_on
            if vec(i) = '0' then
                result(pos) := '0';
                pos := pos - 1;
            end if;
            if vec(i) = '1' then
                result(pos) := '1';
                pos := pos - 1;
            end if;
            -- synopsys translate_off
            if (vec(i) = 'X' or vec(i) = 'U') then
                result(pos) := 'U';
                pos := pos - 1;
            end if;
            -- synopsys translate_on
        end loop;
        return result;
    end;
    function bin_string_element_to_std_logic_vector (inp : string;  width, index : integer)
        return std_logic_vector
    is
        constant str_width : integer := width + 4;
        constant inp_len : integer := inp'length;
        constant num_elements : integer := (inp_len + 1)/str_width;
        constant reverse_index : integer := (num_elements-1) - index;
        variable left_pos : integer;
        variable right_pos : integer;
        variable vec : string(1 to inp'length);
        variable result : std_logic_vector(width-1 downto 0);
    begin
        vec := inp;
        result := (others => '0');
        if (reverse_index = 0) and (reverse_index < num_elements) and (inp_len-3 >= width) then
            left_pos := 1;
            right_pos := width + 3;
            result := bin_string_to_std_logic_vector(vec(left_pos to right_pos));
        end if;
        if (reverse_index > 0) and (reverse_index < num_elements) and (inp_len-3 >= width) then
            left_pos := (reverse_index * str_width) + 1;
            right_pos := left_pos + width + 2;
            result := bin_string_to_std_logic_vector(vec(left_pos to right_pos));
        end if;
        return result;
    end;
   -- synopsys translate_off
    function std_logic_vector_to_bin_string(inp : std_logic_vector)
        return string
    is
        variable vec : std_logic_vector(1 to inp'length);
        variable result : string(vec'range);
    begin
        vec := inp;
        for i in vec'range loop
            result(i) := to_char(vec(i));
        end loop;
        return result;
    end;
    function std_logic_to_bin_string(inp : std_logic)
        return string
    is
        variable result : string(1 to 3);
    begin
        result(1) := '0';
        result(2) := 'b';
        result(3) := to_char(inp);
        return result;
    end;
    function std_logic_vector_to_bin_string_w_point(inp : std_logic_vector; bin_pt : integer)
        return string
    is
        variable width : integer := inp'length;
        variable vec : std_logic_vector(width-1 downto 0);
        variable str_pos : integer;
        variable result : string(1 to width+3);
    begin
        vec := inp;
        str_pos := 1;
        result(str_pos) := '0';
        str_pos := 2;
        result(str_pos) := 'b';
        str_pos := 3;
        for i in width-1 downto 0  loop
            if (((width+3) - bin_pt) = str_pos) then
                result(str_pos) := '.';
                str_pos := str_pos + 1;
            end if;
            result(str_pos) := to_char(vec(i));
            str_pos := str_pos + 1;
        end loop;
        if (bin_pt = 0) then
            result(str_pos) := '.';
        end if;
        return result;
    end;
    function real_to_bin_string(inp : real;  width, bin_pt, arith : integer)
        return string
    is
        variable result : string(1 to width);
        variable vec : std_logic_vector(width-1 downto 0);
    begin
        vec := real_to_std_logic_vector(inp, width, bin_pt, arith);
        result := std_logic_vector_to_bin_string(vec);
        return result;
    end;
    function real_to_string (inp : real) return string
    is
        variable result : string(1 to display_precision) := (others => ' ');
    begin
        result(real'image(inp)'range) := real'image(inp);
        return result;
    end;
    -- synopsys translate_on
end conv_pkg;

-------------------------------------------------------------------
-- System Generator version 14.3 VHDL source file.
--
-- Copyright(C) 2012 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2012 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
-- synopsys translate_off
library unisim;
use unisim.vcomponents.all;
-- synopsys translate_on
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity srl17e is
    generic (width : integer:=16;
             latency : integer :=8);
    port (clk   : in std_logic;
          ce    : in std_logic;
          d     : in std_logic_vector(width-1 downto 0);
          q     : out std_logic_vector(width-1 downto 0));
end srl17e;
architecture structural of srl17e is
    component SRL16E
        port (D   : in STD_ULOGIC;
              CE  : in STD_ULOGIC;
              CLK : in STD_ULOGIC;
              A0  : in STD_ULOGIC;
              A1  : in STD_ULOGIC;
              A2  : in STD_ULOGIC;
              A3  : in STD_ULOGIC;
              Q   : out STD_ULOGIC);
    end component;
    attribute syn_black_box of SRL16E : component is true;
    attribute fpga_dont_touch of SRL16E : component is "true";
    component FDE
        port(
            Q  :        out   STD_ULOGIC;
            D  :        in    STD_ULOGIC;
            C  :        in    STD_ULOGIC;
            CE :        in    STD_ULOGIC);
    end component;
    attribute syn_black_box of FDE : component is true;
    attribute fpga_dont_touch of FDE : component is "true";
    constant a : std_logic_vector(4 downto 0) :=
        integer_to_std_logic_vector(latency-2,5,xlSigned);
    signal d_delayed : std_logic_vector(width-1 downto 0);
    signal srl16_out : std_logic_vector(width-1 downto 0);
begin
    d_delayed <= d after 200 ps;
    reg_array : for i in 0 to width-1 generate
        srl16_used: if latency > 1 generate
            u1 : srl16e port map(clk => clk,
                                 d => d_delayed(i),
                                 q => srl16_out(i),
                                 ce => ce,
                                 a0 => a(0),
                                 a1 => a(1),
                                 a2 => a(2),
                                 a3 => a(3));
        end generate;
        srl16_not_used: if latency <= 1 generate
            srl16_out(i) <= d_delayed(i);
        end generate;
        fde_used: if latency /= 0  generate
            u2 : fde port map(c => clk,
                              d => srl16_out(i),
                              q => q(i),
                              ce => ce);
        end generate;
        fde_not_used: if latency = 0  generate
            q(i) <= srl16_out(i);
        end generate;
    end generate;
 end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity synth_reg is
    generic (width           : integer := 8;
             latency         : integer := 1);
    port (i       : in std_logic_vector(width-1 downto 0);
          ce      : in std_logic;
          clr     : in std_logic;
          clk     : in std_logic;
          o       : out std_logic_vector(width-1 downto 0));
end synth_reg;
architecture structural of synth_reg is
    component srl17e
        generic (width : integer:=16;
                 latency : integer :=8);
        port (clk : in std_logic;
              ce  : in std_logic;
              d   : in std_logic_vector(width-1 downto 0);
              q   : out std_logic_vector(width-1 downto 0));
    end component;
    function calc_num_srl17es (latency : integer)
        return integer
    is
        variable remaining_latency : integer;
        variable result : integer;
    begin
        result := latency / 17;
        remaining_latency := latency - (result * 17);
        if (remaining_latency /= 0) then
            result := result + 1;
        end if;
        return result;
    end;
    constant complete_num_srl17es : integer := latency / 17;
    constant num_srl17es : integer := calc_num_srl17es(latency);
    constant remaining_latency : integer := latency - (complete_num_srl17es * 17);
    type register_array is array (num_srl17es downto 0) of
        std_logic_vector(width-1 downto 0);
    signal z : register_array;
begin
    z(0) <= i;
    complete_ones : if complete_num_srl17es > 0 generate
        srl17e_array: for i in 0 to complete_num_srl17es-1 generate
            delay_comp : srl17e
                generic map (width => width,
                             latency => 17)
                port map (clk => clk,
                          ce  => ce,
                          d       => z(i),
                          q       => z(i+1));
        end generate;
    end generate;
    partial_one : if remaining_latency > 0 generate
        last_srl17e : srl17e
            generic map (width => width,
                         latency => remaining_latency)
            port map (clk => clk,
                      ce  => ce,
                      d   => z(num_srl17es-1),
                      q   => z(num_srl17es));
    end generate;
    o <= z(num_srl17es);
end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity synth_reg_reg is
    generic (width           : integer := 8;
             latency         : integer := 1);
    port (i       : in std_logic_vector(width-1 downto 0);
          ce      : in std_logic;
          clr     : in std_logic;
          clk     : in std_logic;
          o       : out std_logic_vector(width-1 downto 0));
end synth_reg_reg;
architecture behav of synth_reg_reg is
  type reg_array_type is array (latency-1 downto 0) of std_logic_vector(width -1 downto 0);
  signal reg_bank : reg_array_type := (others => (others => '0'));
  signal reg_bank_in : reg_array_type := (others => (others => '0'));
  attribute syn_allow_retiming : boolean;
  attribute syn_srlstyle : string;
  attribute syn_allow_retiming of reg_bank : signal is true;
  attribute syn_allow_retiming of reg_bank_in : signal is true;
  attribute syn_srlstyle of reg_bank : signal is "registers";
  attribute syn_srlstyle of reg_bank_in : signal is "registers";
begin
  latency_eq_0: if latency = 0 generate
    o <= i;
  end generate latency_eq_0;
  latency_gt_0: if latency >= 1 generate
    o <= reg_bank(latency-1);
    reg_bank_in(0) <= i;
    loop_gen: for idx in latency-2 downto 0 generate
      reg_bank_in(idx+1) <= reg_bank(idx);
    end generate loop_gen;
    sync_loop: for sync_idx in latency-1 downto 0 generate
      sync_proc: process (clk)
      begin
        if clk'event and clk = '1' then
          if clr = '1' then
            reg_bank_in <= (others => (others => '0'));
          elsif ce = '1'  then
            reg_bank(sync_idx) <= reg_bank_in(sync_idx);
          end if;
        end if;
      end process sync_proc;
    end generate sync_loop;
  end generate latency_gt_0;
end behav;

-------------------------------------------------------------------
-- System Generator version 14.3 VHDL source file.
--
-- Copyright(C) 2012 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2012 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
-- synopsys translate_off
library unisim;
use unisim.vcomponents.all;
-- synopsys translate_on
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity single_reg_w_init is
  generic (
    width: integer := 8;
    init_index: integer := 0;
    init_value: bit_vector := b"0000"
  );
  port (
    i: in std_logic_vector(width - 1 downto 0);
    ce: in std_logic;
    clr: in std_logic;
    clk: in std_logic;
    o: out std_logic_vector(width - 1 downto 0)
  );
end single_reg_w_init;
architecture structural of single_reg_w_init is
  function build_init_const(width: integer;
                            init_index: integer;
                            init_value: bit_vector)
    return std_logic_vector
  is
    variable result: std_logic_vector(width - 1 downto 0);
  begin
    if init_index = 0 then
      result := (others => '0');
    elsif init_index = 1 then
      result := (others => '0');
      result(0) := '1';
    else
      result := to_stdlogicvector(init_value);
    end if;
    return result;
  end;
  component fdre
    port (
      q: out std_ulogic;
      d: in  std_ulogic;
      c: in  std_ulogic;
      ce: in  std_ulogic;
      r: in  std_ulogic
    );
  end component;
  attribute syn_black_box of fdre: component is true;
  attribute fpga_dont_touch of fdre: component is "true";
  component fdse
    port (
      q: out std_ulogic;
      d: in  std_ulogic;
      c: in  std_ulogic;
      ce: in  std_ulogic;
      s: in  std_ulogic
    );
  end component;
  attribute syn_black_box of fdse: component is true;
  attribute fpga_dont_touch of fdse: component is "true";
  constant init_const: std_logic_vector(width - 1 downto 0)
    := build_init_const(width, init_index, init_value);
begin
  fd_prim_array: for index in 0 to width - 1 generate
    bit_is_0: if (init_const(index) = '0') generate
      fdre_comp: fdre
        port map (
          c => clk,
          d => i(index),
          q => o(index),
          ce => ce,
          r => clr
        );
    end generate;
    bit_is_1: if (init_const(index) = '1') generate
      fdse_comp: fdse
        port map (
          c => clk,
          d => i(index),
          q => o(index),
          ce => ce,
          s => clr
        );
    end generate;
  end generate;
end architecture structural;
-- synopsys translate_off
library unisim;
use unisim.vcomponents.all;
-- synopsys translate_on
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity synth_reg_w_init is
  generic (
    width: integer := 8;
    init_index: integer := 0;
    init_value: bit_vector := b"0000";
    latency: integer := 1
  );
  port (
    i: in std_logic_vector(width - 1 downto 0);
    ce: in std_logic;
    clr: in std_logic;
    clk: in std_logic;
    o: out std_logic_vector(width - 1 downto 0)
  );
end synth_reg_w_init;
architecture structural of synth_reg_w_init is
  component single_reg_w_init
    generic (
      width: integer := 8;
      init_index: integer := 0;
      init_value: bit_vector := b"0000"
    );
    port (
      i: in std_logic_vector(width - 1 downto 0);
      ce: in std_logic;
      clr: in std_logic;
      clk: in std_logic;
      o: out std_logic_vector(width - 1 downto 0)
    );
  end component;
  signal dly_i: std_logic_vector((latency + 1) * width - 1 downto 0);
  signal dly_clr: std_logic;
begin
  latency_eq_0: if (latency = 0) generate
    o <= i;
  end generate;
  latency_gt_0: if (latency >= 1) generate
    dly_i((latency + 1) * width - 1 downto latency * width) <= i
      after 200 ps;
    dly_clr <= clr after 200 ps;
    fd_array: for index in latency downto 1 generate
       reg_comp: single_reg_w_init
          generic map (
            width => width,
            init_index => init_index,
            init_value => init_value
          )
          port map (
            clk => clk,
            i => dly_i((index + 1) * width - 1 downto index * width),
            o => dly_i(index * width - 1 downto (index - 1) * width),
            ce => ce,
            clr => dly_clr
          );
    end generate;
    o <= dly_i(width - 1 downto 0);
  end generate;
end structural;

-------------------------------------------------------------------
-- System Generator version 14.3 VHDL source file.
--
-- Copyright(C) 2012 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2012 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity convert_func_call is
    generic (
        din_width    : integer := 16;
        din_bin_pt   : integer := 4;
        din_arith    : integer := xlUnsigned;
        dout_width   : integer := 8;
        dout_bin_pt  : integer := 2;
        dout_arith   : integer := xlUnsigned;
        quantization : integer := xlTruncate;
        overflow     : integer := xlWrap);
    port (
        din : in std_logic_vector (din_width-1 downto 0);
        result : out std_logic_vector (dout_width-1 downto 0));
end convert_func_call;
architecture behavior of convert_func_call is
begin
    result <= convert_type(din, din_width, din_bin_pt, din_arith,
                           dout_width, dout_bin_pt, dout_arith,
                           quantization, overflow);
end behavior;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity xlconvert is
    generic (
        din_width    : integer := 16;
        din_bin_pt   : integer := 4;
        din_arith    : integer := xlUnsigned;
        dout_width   : integer := 8;
        dout_bin_pt  : integer := 2;
        dout_arith   : integer := xlUnsigned;
        en_width     : integer := 1;
        en_bin_pt    : integer := 0;
        en_arith     : integer := xlUnsigned;
        bool_conversion : integer :=0;
        latency      : integer := 0;
        quantization : integer := xlTruncate;
        overflow     : integer := xlWrap);
    port (
        din : in std_logic_vector (din_width-1 downto 0);
        en  : in std_logic_vector (en_width-1 downto 0);
        ce  : in std_logic;
        clr : in std_logic;
        clk : in std_logic;
        dout : out std_logic_vector (dout_width-1 downto 0));
end xlconvert;
architecture behavior of xlconvert is
    component synth_reg
        generic (width       : integer;
                 latency     : integer);
        port (i       : in std_logic_vector(width-1 downto 0);
              ce      : in std_logic;
              clr     : in std_logic;
              clk     : in std_logic;
              o       : out std_logic_vector(width-1 downto 0));
    end component;
    component convert_func_call
        generic (
            din_width    : integer := 16;
            din_bin_pt   : integer := 4;
            din_arith    : integer := xlUnsigned;
            dout_width   : integer := 8;
            dout_bin_pt  : integer := 2;
            dout_arith   : integer := xlUnsigned;
            quantization : integer := xlTruncate;
            overflow     : integer := xlWrap);
        port (
            din : in std_logic_vector (din_width-1 downto 0);
            result : out std_logic_vector (dout_width-1 downto 0));
    end component;
    -- synopsys translate_off
    -- synopsys translate_on
    signal result : std_logic_vector(dout_width-1 downto 0);
    signal internal_ce : std_logic;
begin
    -- synopsys translate_off
    -- synopsys translate_on
    internal_ce <= ce and en(0);

    bool_conversion_generate : if (bool_conversion = 1)
    generate
      result <= din;
    end generate;
    std_conversion_generate : if (bool_conversion = 0)
    generate
      convert : convert_func_call
        generic map (
          din_width   => din_width,
          din_bin_pt  => din_bin_pt,
          din_arith   => din_arith,
          dout_width  => dout_width,
          dout_bin_pt => dout_bin_pt,
          dout_arith  => dout_arith,
          quantization => quantization,
          overflow     => overflow)
        port map (
          din => din,
          result => result);
    end generate;
    latency_test : if (latency > 0) generate
        reg : synth_reg
            generic map (
              width => dout_width,
              latency => latency
            )
            port map (
              i => result,
              ce => internal_ce,
              clr => clr,
              clk => clk,
              o => dout
            );
    end generate;
    latency0 : if (latency = 0)
    generate
        dout <= result;
    end generate latency0;
end  behavior;

-------------------------------------------------------------------
-- System Generator version 14.3 VHDL source file.
--
-- Copyright(C) 2012 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2012 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity xldelay is
   generic(width        : integer := -1;
           latency      : integer := -1;
           reg_retiming : integer :=  0;
           reset        : integer :=  0);
   port(d       : in std_logic_vector (width-1 downto 0);
        ce      : in std_logic;
        clk     : in std_logic;
        en      : in std_logic;
        rst     : in std_logic;
        q       : out std_logic_vector (width-1 downto 0));
end xldelay;
architecture behavior of xldelay is
   component synth_reg
      generic (width       : integer;
               latency     : integer);
      port (i       : in std_logic_vector(width-1 downto 0);
            ce      : in std_logic;
            clr     : in std_logic;
            clk     : in std_logic;
            o       : out std_logic_vector(width-1 downto 0));
   end component;
   component synth_reg_reg
      generic (width       : integer;
               latency     : integer);
      port (i       : in std_logic_vector(width-1 downto 0);
            ce      : in std_logic;
            clr     : in std_logic;
            clk     : in std_logic;
            o       : out std_logic_vector(width-1 downto 0));
   end component;
   signal internal_ce  : std_logic;
begin
   internal_ce  <= ce and en;
   srl_delay: if ((reg_retiming = 0) and (reset = 0)) or (latency < 1) generate
     synth_reg_srl_inst : synth_reg
       generic map (
         width   => width,
         latency => latency)
       port map (
         i   => d,
         ce  => internal_ce,
         clr => '0',
         clk => clk,
         o   => q);
   end generate srl_delay;
   reg_delay: if ((reg_retiming = 1) or (reset = 1)) and (latency >= 1) generate
     synth_reg_reg_inst : synth_reg_reg
       generic map (
         width   => width,
         latency => latency)
       port map (
         i   => d,
         ce  => internal_ce,
         clr => rst,
         clk => clk,
         o   => q);
   end generate reg_delay;
end architecture behavior;
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity inverter_e5b38cca3b is
  port (
    ip : in std_logic_vector((1 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end inverter_e5b38cca3b;


architecture behavior of inverter_e5b38cca3b is
  signal ip_1_26: boolean;
  type array_type_op_mem_22_20 is array (0 to (1 - 1)) of boolean;
  signal op_mem_22_20: array_type_op_mem_22_20 := (
    0 => false);
  signal op_mem_22_20_front_din: boolean;
  signal op_mem_22_20_back: boolean;
  signal op_mem_22_20_push_front_pop_back_en: std_logic;
  signal internal_ip_12_1_bitnot: boolean;
begin
  ip_1_26 <= ((ip) = "1");
  op_mem_22_20_back <= op_mem_22_20(0);
  proc_op_mem_22_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_22_20_push_front_pop_back_en = '1')) then
        op_mem_22_20(0) <= op_mem_22_20_front_din;
      end if;
    end if;
  end process proc_op_mem_22_20;
  internal_ip_12_1_bitnot <= ((not boolean_to_vector(ip_1_26)) = "1");
  op_mem_22_20_push_front_pop_back_en <= '0';
  op <= boolean_to_vector(internal_ip_12_1_bitnot);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity logical_dfe2dded7f is
  port (
    d0 : in std_logic_vector((1 - 1) downto 0);
    d1 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end logical_dfe2dded7f;


architecture behavior of logical_dfe2dded7f is
  signal d0_1_24: std_logic;
  signal d1_1_27: std_logic;
  signal bit_2_26: std_logic;
  signal fully_2_1_bitnot: std_logic;
begin
  d0_1_24 <= d0(0);
  d1_1_27 <= d1(0);
  bit_2_26 <= d0_1_24 or d1_1_27;
  fully_2_1_bitnot <= not bit_2_26;
  y <= std_logic_to_vector(fully_2_1_bitnot);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_2b0feb00fb is
  port (
    d : in std_logic_vector((32 - 1) downto 0);
    q : out std_logic_vector((32 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_2b0feb00fb;


architecture behavior of delay_2b0feb00fb is
  signal d_1_22: std_logic_vector((32 - 1) downto 0);
begin
  d_1_22 <= d;
  q <= d_1_22;
end behavior;


-------------------------------------------------------------------
-- System Generator version 14.3 VHDL source file.
--
-- Copyright(C) 2012 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2012 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use work.conv_pkg.all;
entity xlslice is
    generic (
        new_msb      : integer := 9;
        new_lsb      : integer := 1;
        x_width      : integer := 16;
        y_width      : integer := 8);
    port (
        x : in std_logic_vector (x_width-1 downto 0);
        y : out std_logic_vector (y_width-1 downto 0));
end xlslice;
architecture behavior of xlslice is
begin
    y <= x(new_msb downto new_lsb);
end  behavior;
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_c5d4d59b73 is
  port (
    input_port : in std_logic_vector((32 - 1) downto 0);
    output_port : out std_logic_vector((32 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_c5d4d59b73;


architecture behavior of reinterpret_c5d4d59b73 is
  signal input_port_1_40: unsigned((32 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port <= unsigned_to_std_logic_vector(input_port_1_40);
end behavior;


-------------------------------------------------------------------
-- System Generator version 14.3 VHDL source file.
--
-- Copyright(C) 2012 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2012 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity xlpassthrough is
    generic (
        din_width    : integer := 16;
        dout_width   : integer := 16
        );
    port (
        din : in std_logic_vector (din_width-1 downto 0);
        dout : out std_logic_vector (dout_width-1 downto 0));
end xlpassthrough;
architecture passthrough_arch of xlpassthrough is
begin
  dout <= din;
end passthrough_arch;
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_fd757d4b63 is
  port (
    a : in std_logic_vector((2 - 1) downto 0);
    b : in std_logic_vector((2 - 1) downto 0);
    s : out std_logic_vector((2 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_fd757d4b63;


architecture behavior of addsub_fd757d4b63 is
  signal a_17_32: unsigned((2 - 1) downto 0);
  signal b_17_35: unsigned((2 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of unsigned((2 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "00");
  signal op_mem_91_20_front_din: unsigned((2 - 1) downto 0);
  signal op_mem_91_20_back: unsigned((2 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_71_18: signed((4 - 1) downto 0);
  signal cast_71_22: signed((4 - 1) downto 0);
  signal internal_s_71_5_addsub: signed((4 - 1) downto 0);
  signal cast_internal_s_83_3_convert: unsigned((2 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_unsigned(a);
  b_17_35 <= std_logic_vector_to_unsigned(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_71_18 <= u2s_cast(a_17_32, 0, 4, 0);
  cast_71_22 <= u2s_cast(b_17_35, 0, 4, 0);
  internal_s_71_5_addsub <= cast_71_18 - cast_71_22;
  cast_internal_s_83_3_convert <= s2u_cast(internal_s_71_5_addsub, 0, 2, 0);
  op_mem_91_20_push_front_pop_back_en <= '0';
  cout_mem_92_22_push_front_pop_back_en <= '0';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= unsigned_to_std_logic_vector(cast_internal_s_83_3_convert);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_17ed0a7299 is
  port (
    in0 : in std_logic_vector((10 - 1) downto 0);
    in1 : in std_logic_vector((2 - 1) downto 0);
    y : out std_logic_vector((12 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_17ed0a7299;


architecture behavior of concat_17ed0a7299 is
  signal in0_1_23: unsigned((10 - 1) downto 0);
  signal in1_1_27: unsigned((2 - 1) downto 0);
  signal y_2_1_concat: unsigned((12 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_3a9a3daeb9 is
  port (
    op : out std_logic_vector((2 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_3a9a3daeb9;


architecture behavior of constant_3a9a3daeb9 is
begin
  op <= "11";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_6293007044 is
  port (
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_6293007044;


architecture behavior of constant_6293007044 is
begin
  op <= "1";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_c3e1ddb86e is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((12 - 1) downto 0);
    d1 : in std_logic_vector((12 - 1) downto 0);
    y : out std_logic_vector((12 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_c3e1ddb86e;


architecture behavior of mux_c3e1ddb86e is
  signal sel_1_20: std_logic_vector((1 - 1) downto 0);
  signal d0_1_24: std_logic_vector((12 - 1) downto 0);
  signal d1_1_27: std_logic_vector((12 - 1) downto 0);
  signal unregy_join_6_1: std_logic_vector((12 - 1) downto 0);
begin
  sel_1_20 <= sel;
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_1_20)
  is
  begin
    case sel_1_20 is 
      when "0" =>
        unregy_join_6_1 <= d0_1_24;
      when others =>
        unregy_join_6_1 <= d1_1_27;
    end case;
  end process proc_switch_6_1;
  y <= unregy_join_6_1;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_f21e7f2ddf is
  port (
    input_port : in std_logic_vector((8 - 1) downto 0);
    output_port : out std_logic_vector((8 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_f21e7f2ddf;


architecture behavior of reinterpret_f21e7f2ddf is
  signal input_port_1_40: unsigned((8 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port <= unsigned_to_std_logic_vector(input_port_1_40);
end behavior;


-------------------------------------------------------------------
-- System Generator version 14.3 VHDL source file.
--
-- Copyright(C) 2012 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2012 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity xlregister is
   generic (d_width          : integer := 5;
            init_value       : bit_vector := b"00");
   port (d   : in std_logic_vector (d_width-1 downto 0);
         rst : in std_logic_vector(0 downto 0) := "0";
         en  : in std_logic_vector(0 downto 0) := "1";
         ce  : in std_logic;
         clk : in std_logic;
         q   : out std_logic_vector (d_width-1 downto 0));
end xlregister;
architecture behavior of xlregister is
   component synth_reg_w_init
      generic (width      : integer;
               init_index : integer;
               init_value : bit_vector;
               latency    : integer);
      port (i   : in std_logic_vector(width-1 downto 0);
            ce  : in std_logic;
            clr : in std_logic;
            clk : in std_logic;
            o   : out std_logic_vector(width-1 downto 0));
   end component;
   -- synopsys translate_off
   signal real_d, real_q           : real;
   -- synopsys translate_on
   signal internal_clr             : std_logic;
   signal internal_ce              : std_logic;
begin
   internal_clr <= rst(0) and ce;
   internal_ce  <= en(0) and ce;
   synth_reg_inst : synth_reg_w_init
      generic map (width      => d_width,
                   init_index => 2,
                   init_value => init_value,
                   latency    => 1)
      port map (i   => d,
                ce  => internal_ce,
                clr => internal_clr,
                clk => clk,
                o   => q);
end architecture behavior;
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_21355083c1 is
  port (
    d : in std_logic_vector((1 - 1) downto 0);
    q : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_21355083c1;


architecture behavior of delay_21355083c1 is
  signal d_1_22: std_logic_vector((1 - 1) downto 0);
begin
  d_1_22 <= d;
  q <= d_1_22;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_112d91c147 is
  port (
    input_port : in std_logic_vector((1 - 1) downto 0);
    output_port : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_112d91c147;


architecture behavior of reinterpret_112d91c147 is
  signal input_port_1_40: boolean;
  signal output_port_7_5_convert: unsigned((1 - 1) downto 0);
begin
  input_port_1_40 <= ((input_port) = "1");
  output_port_7_5_convert <= u2u_cast(std_logic_vector_to_unsigned(boolean_to_vector(input_port_1_40)), 0, 1, 0);
  output_port <= unsigned_to_std_logic_vector(output_port_7_5_convert);
end behavior;


-------------------------------------------------------------------
-- System Generator version 14.3 VHDL source file.
--
-- Copyright(C) 2012 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2012 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
-- synopsys translate_off
library XilinxCoreLib;
-- synopsys translate_on
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use work.conv_pkg.all;
entity xladdsub_darkquad29 is
  generic (
    core_name0: string := "";
    a_width: integer := 16;
    a_bin_pt: integer := 4;
    a_arith: integer := xlUnsigned;
    c_in_width: integer := 16;
    c_in_bin_pt: integer := 4;
    c_in_arith: integer := xlUnsigned;
    c_out_width: integer := 16;
    c_out_bin_pt: integer := 4;
    c_out_arith: integer := xlUnsigned;
    b_width: integer := 8;
    b_bin_pt: integer := 2;
    b_arith: integer := xlUnsigned;
    s_width: integer := 17;
    s_bin_pt: integer := 4;
    s_arith: integer := xlUnsigned;
    rst_width: integer := 1;
    rst_bin_pt: integer := 0;
    rst_arith: integer := xlUnsigned;
    en_width: integer := 1;
    en_bin_pt: integer := 0;
    en_arith: integer := xlUnsigned;
    full_s_width: integer := 17;
    full_s_arith: integer := xlUnsigned;
    mode: integer := xlAddMode;
    extra_registers: integer := 0;
    latency: integer := 0;
    quantization: integer := xlTruncate;
    overflow: integer := xlWrap;
    c_latency: integer := 0;
    c_output_width: integer := 17;
    c_has_c_in : integer := 0;
    c_has_c_out : integer := 0
  );
  port (
    a: in std_logic_vector(a_width - 1 downto 0);
    b: in std_logic_vector(b_width - 1 downto 0);
    c_in : in std_logic_vector (0 downto 0) := "0";
    ce: in std_logic;
    clr: in std_logic := '0';
    clk: in std_logic;
    rst: in std_logic_vector(rst_width - 1 downto 0) := "0";
    en: in std_logic_vector(en_width - 1 downto 0) := "1";
    c_out : out std_logic_vector (0 downto 0);
    s: out std_logic_vector(s_width - 1 downto 0)
  );
end xladdsub_darkquad29;
architecture behavior of xladdsub_darkquad29 is
  component synth_reg
    generic (
      width: integer := 16;
      latency: integer := 5
    );
    port (
      i: in std_logic_vector(width - 1 downto 0);
      ce: in std_logic;
      clr: in std_logic;
      clk: in std_logic;
      o: out std_logic_vector(width - 1 downto 0)
    );
  end component;
  function format_input(inp: std_logic_vector; old_width, delta, new_arith,
                        new_width: integer)
    return std_logic_vector
  is
    variable vec: std_logic_vector(old_width-1 downto 0);
    variable padded_inp: std_logic_vector((old_width + delta)-1  downto 0);
    variable result: std_logic_vector(new_width-1 downto 0);
  begin
    vec := inp;
    if (delta > 0) then
      padded_inp := pad_LSB(vec, old_width+delta);
      result := extend_MSB(padded_inp, new_width, new_arith);
    else
      result := extend_MSB(vec, new_width, new_arith);
    end if;
    return result;
  end;
  constant full_s_bin_pt: integer := fractional_bits(a_bin_pt, b_bin_pt);
  constant full_a_width: integer := full_s_width;
  constant full_b_width: integer := full_s_width;
  signal full_a: std_logic_vector(full_a_width - 1 downto 0);
  signal full_b: std_logic_vector(full_b_width - 1 downto 0);
  signal core_s: std_logic_vector(full_s_width - 1 downto 0);
  signal conv_s: std_logic_vector(s_width - 1 downto 0);
  signal temp_cout : std_logic;
  signal internal_clr: std_logic;
  signal internal_ce: std_logic;
  signal extra_reg_ce: std_logic;
  signal override: std_logic;
  signal logic1: std_logic_vector(0 downto 0);
  component addsb_11_0_e7ad3a217b0e91ae
    port (
          a: in std_logic_vector(33 - 1 downto 0);
    clk: in std_logic:= '0';
    ce: in std_logic:= '0';
    s: out std_logic_vector(c_output_width - 1 downto 0);
    b: in std_logic_vector(33 - 1 downto 0)
    );
  end component;
  component addsb_11_0_d9aaab7d6537213f
    port (
          a: in std_logic_vector(48 - 1 downto 0);
    clk: in std_logic:= '0';
    ce: in std_logic:= '0';
    s: out std_logic_vector(c_output_width - 1 downto 0);
    b: in std_logic_vector(48 - 1 downto 0)
    );
  end component;
  component addsb_11_0_74c24ba8230946d7
    port (
          a: in std_logic_vector(20 - 1 downto 0);
    clk: in std_logic:= '0';
    ce: in std_logic:= '0';
    s: out std_logic_vector(c_output_width - 1 downto 0);
    b: in std_logic_vector(20 - 1 downto 0)
    );
  end component;
  component addsb_11_0_c326c4567b3c5b63
    port (
          a: in std_logic_vector(17 - 1 downto 0);
    clk: in std_logic:= '0';
    ce: in std_logic:= '0';
    s: out std_logic_vector(c_output_width - 1 downto 0);
    b: in std_logic_vector(17 - 1 downto 0)
    );
  end component;
  component addsb_11_0_d5c2386c66db1f8d
    port (
          a: in std_logic_vector(22 - 1 downto 0);
    clk: in std_logic:= '0';
    ce: in std_logic:= '0';
    s: out std_logic_vector(c_output_width - 1 downto 0);
    b: in std_logic_vector(22 - 1 downto 0)
    );
  end component;
  component addsb_11_0_905959d61544ac3e
    port (
          a: in std_logic_vector(40 - 1 downto 0);
    clk: in std_logic:= '0';
    ce: in std_logic:= '0';
    s: out std_logic_vector(c_output_width - 1 downto 0);
    b: in std_logic_vector(40 - 1 downto 0)
    );
  end component;
  component addsb_11_0_d58a8e32191e1b22
    port (
          a: in std_logic_vector(59 - 1 downto 0);
    clk: in std_logic:= '0';
    ce: in std_logic:= '0';
    s: out std_logic_vector(c_output_width - 1 downto 0);
    b: in std_logic_vector(59 - 1 downto 0)
    );
  end component;
  component addsb_11_0_18c07b39a9f6c777
    port (
          a: in std_logic_vector(40 - 1 downto 0);
    clk: in std_logic:= '0';
    ce: in std_logic:= '0';
    s: out std_logic_vector(c_output_width - 1 downto 0);
    b: in std_logic_vector(40 - 1 downto 0)
    );
  end component;
  component addsb_11_0_ccc02b0ec9bb7d2f
    port (
          a: in std_logic_vector(14 - 1 downto 0);
    clk: in std_logic:= '0';
    ce: in std_logic:= '0';
    s: out std_logic_vector(c_output_width - 1 downto 0);
    b: in std_logic_vector(14 - 1 downto 0)
    );
  end component;
  component addsb_11_0_aa7bb2ad873d54b6
    port (
          a: in std_logic_vector(11 - 1 downto 0);
    clk: in std_logic:= '0';
    ce: in std_logic:= '0';
    s: out std_logic_vector(c_output_width - 1 downto 0);
    b: in std_logic_vector(11 - 1 downto 0)
    );
  end component;
  component addsb_11_0_ce88f01554f26992
    port (
          a: in std_logic_vector(17 - 1 downto 0);
    clk: in std_logic:= '0';
    ce: in std_logic:= '0';
    s: out std_logic_vector(c_output_width - 1 downto 0);
    b: in std_logic_vector(17 - 1 downto 0)
    );
  end component;
  component addsb_11_0_f46b761f6397bd18
    port (
          a: in std_logic_vector(11 - 1 downto 0);
    clk: in std_logic:= '0';
    ce: in std_logic:= '0';
    s: out std_logic_vector(c_output_width - 1 downto 0);
    b: in std_logic_vector(11 - 1 downto 0)
    );
  end component;
  component addsb_11_0_7a7e9e33c32e594c
    port (
          a: in std_logic_vector(20 - 1 downto 0);
    clk: in std_logic:= '0';
    ce: in std_logic:= '0';
    s: out std_logic_vector(c_output_width - 1 downto 0);
    b: in std_logic_vector(20 - 1 downto 0)
    );
  end component;
  component addsb_11_0_f71caeff01210ab2
    port (
          a: in std_logic_vector(37 - 1 downto 0);
    clk: in std_logic:= '0';
    ce: in std_logic:= '0';
    s: out std_logic_vector(c_output_width - 1 downto 0);
    b: in std_logic_vector(37 - 1 downto 0)
    );
  end component;
  component addsb_11_0_07eb1c1df5a181f1
    port (
          a: in std_logic_vector(38 - 1 downto 0);
    clk: in std_logic:= '0';
    ce: in std_logic:= '0';
    s: out std_logic_vector(c_output_width - 1 downto 0);
    b: in std_logic_vector(38 - 1 downto 0)
    );
  end component;
  component addsb_11_0_26c38df2140ab027
    port (
          a: in std_logic_vector(39 - 1 downto 0);
    clk: in std_logic:= '0';
    ce: in std_logic:= '0';
    s: out std_logic_vector(c_output_width - 1 downto 0);
    b: in std_logic_vector(39 - 1 downto 0)
    );
  end component;
  component addsb_11_0_075266d61a42e95d
    port (
          a: in std_logic_vector(40 - 1 downto 0);
    clk: in std_logic:= '0';
    ce: in std_logic:= '0';
    s: out std_logic_vector(c_output_width - 1 downto 0);
    b: in std_logic_vector(40 - 1 downto 0)
    );
  end component;
  component addsb_11_0_12579c2539e3bba1
    port (
          a: in std_logic_vector(35 - 1 downto 0);
    clk: in std_logic:= '0';
    ce: in std_logic:= '0';
    s: out std_logic_vector(c_output_width - 1 downto 0);
    b: in std_logic_vector(35 - 1 downto 0)
    );
  end component;
  component addsb_11_0_6603a21774005e29
    port (
          a: in std_logic_vector(35 - 1 downto 0);
    clk: in std_logic:= '0';
    ce: in std_logic:= '0';
    s: out std_logic_vector(c_output_width - 1 downto 0);
    b: in std_logic_vector(35 - 1 downto 0)
    );
  end component;
  component addsb_11_0_905df78b66389ded
    port (
          a: in std_logic_vector(26 - 1 downto 0);
    clk: in std_logic:= '0';
    ce: in std_logic:= '0';
    s: out std_logic_vector(c_output_width - 1 downto 0);
    b: in std_logic_vector(26 - 1 downto 0)
    );
  end component;
  component addsb_11_0_4e2bc60003cf26be
    port (
          a: in std_logic_vector(27 - 1 downto 0);
    clk: in std_logic:= '0';
    ce: in std_logic:= '0';
    s: out std_logic_vector(c_output_width - 1 downto 0);
    b: in std_logic_vector(27 - 1 downto 0)
    );
  end component;
  component addsb_11_0_837b9ca36be57173
    port (
          a: in std_logic_vector(28 - 1 downto 0);
    clk: in std_logic:= '0';
    ce: in std_logic:= '0';
    s: out std_logic_vector(c_output_width - 1 downto 0);
    b: in std_logic_vector(28 - 1 downto 0)
    );
  end component;
  component addsb_11_0_9875f8c5f2e232ba
    port (
          a: in std_logic_vector(29 - 1 downto 0);
    clk: in std_logic:= '0';
    ce: in std_logic:= '0';
    s: out std_logic_vector(c_output_width - 1 downto 0);
    b: in std_logic_vector(29 - 1 downto 0)
    );
  end component;
  component addsb_11_0_9ec4483802d81769
    port (
          a: in std_logic_vector(30 - 1 downto 0);
    clk: in std_logic:= '0';
    ce: in std_logic:= '0';
    s: out std_logic_vector(c_output_width - 1 downto 0);
    b: in std_logic_vector(30 - 1 downto 0)
    );
  end component;
  component addsb_11_0_62b4a1a618c40b84
    port (
          a: in std_logic_vector(33 - 1 downto 0);
    clk: in std_logic:= '0';
    ce: in std_logic:= '0';
    s: out std_logic_vector(c_output_width - 1 downto 0);
    b: in std_logic_vector(33 - 1 downto 0)
    );
  end component;
  component addsb_11_0_ca3b6f528ea85846
    port (
          a: in std_logic_vector(37 - 1 downto 0);
    clk: in std_logic:= '0';
    ce: in std_logic:= '0';
    s: out std_logic_vector(c_output_width - 1 downto 0);
    b: in std_logic_vector(37 - 1 downto 0)
    );
  end component;
begin
  internal_clr <= (clr or (rst(0))) and ce;
  internal_ce <= ce and en(0);
  logic1(0) <= '1';
  addsub_process: process (a, b, core_s)
  begin
    full_a <= format_input (a, a_width, b_bin_pt - a_bin_pt, a_arith,
                            full_a_width);
    full_b <= format_input (b, b_width, a_bin_pt - b_bin_pt, b_arith,
                            full_b_width);
    conv_s <= convert_type (core_s, full_s_width, full_s_bin_pt, full_s_arith,
                            s_width, s_bin_pt, s_arith, quantization, overflow);
  end process addsub_process;

  comp0: if ((core_name0 = "addsb_11_0_e7ad3a217b0e91ae")) generate
    core_instance0: addsb_11_0_e7ad3a217b0e91ae
      port map (
         a => full_a,
         clk => clk,
         ce => internal_ce,
         s => core_s,
         b => full_b
      );
  end generate;
  comp1: if ((core_name0 = "addsb_11_0_d9aaab7d6537213f")) generate
    core_instance1: addsb_11_0_d9aaab7d6537213f
      port map (
         a => full_a,
         clk => clk,
         ce => internal_ce,
         s => core_s,
         b => full_b
      );
  end generate;
  comp2: if ((core_name0 = "addsb_11_0_74c24ba8230946d7")) generate
    core_instance2: addsb_11_0_74c24ba8230946d7
      port map (
         a => full_a,
         clk => clk,
         ce => internal_ce,
         s => core_s,
         b => full_b
      );
  end generate;
  comp3: if ((core_name0 = "addsb_11_0_c326c4567b3c5b63")) generate
    core_instance3: addsb_11_0_c326c4567b3c5b63
      port map (
         a => full_a,
         clk => clk,
         ce => internal_ce,
         s => core_s,
         b => full_b
      );
  end generate;
  comp4: if ((core_name0 = "addsb_11_0_d5c2386c66db1f8d")) generate
    core_instance4: addsb_11_0_d5c2386c66db1f8d
      port map (
         a => full_a,
         clk => clk,
         ce => internal_ce,
         s => core_s,
         b => full_b
      );
  end generate;
  comp5: if ((core_name0 = "addsb_11_0_905959d61544ac3e")) generate
    core_instance5: addsb_11_0_905959d61544ac3e
      port map (
         a => full_a,
         clk => clk,
         ce => internal_ce,
         s => core_s,
         b => full_b
      );
  end generate;
  comp6: if ((core_name0 = "addsb_11_0_d58a8e32191e1b22")) generate
    core_instance6: addsb_11_0_d58a8e32191e1b22
      port map (
         a => full_a,
         clk => clk,
         ce => internal_ce,
         s => core_s,
         b => full_b
      );
  end generate;
  comp7: if ((core_name0 = "addsb_11_0_18c07b39a9f6c777")) generate
    core_instance7: addsb_11_0_18c07b39a9f6c777
      port map (
         a => full_a,
         clk => clk,
         ce => internal_ce,
         s => core_s,
         b => full_b
      );
  end generate;
  comp8: if ((core_name0 = "addsb_11_0_ccc02b0ec9bb7d2f")) generate
    core_instance8: addsb_11_0_ccc02b0ec9bb7d2f
      port map (
         a => full_a,
         clk => clk,
         ce => internal_ce,
         s => core_s,
         b => full_b
      );
  end generate;
  comp9: if ((core_name0 = "addsb_11_0_aa7bb2ad873d54b6")) generate
    core_instance9: addsb_11_0_aa7bb2ad873d54b6
      port map (
         a => full_a,
         clk => clk,
         ce => internal_ce,
         s => core_s,
         b => full_b
      );
  end generate;
  comp10: if ((core_name0 = "addsb_11_0_ce88f01554f26992")) generate
    core_instance10: addsb_11_0_ce88f01554f26992
      port map (
         a => full_a,
         clk => clk,
         ce => internal_ce,
         s => core_s,
         b => full_b
      );
  end generate;
  comp11: if ((core_name0 = "addsb_11_0_f46b761f6397bd18")) generate
    core_instance11: addsb_11_0_f46b761f6397bd18
      port map (
         a => full_a,
         clk => clk,
         ce => internal_ce,
         s => core_s,
         b => full_b
      );
  end generate;
  comp12: if ((core_name0 = "addsb_11_0_7a7e9e33c32e594c")) generate
    core_instance12: addsb_11_0_7a7e9e33c32e594c
      port map (
         a => full_a,
         clk => clk,
         ce => internal_ce,
         s => core_s,
         b => full_b
      );
  end generate;
  comp13: if ((core_name0 = "addsb_11_0_f71caeff01210ab2")) generate
    core_instance13: addsb_11_0_f71caeff01210ab2
      port map (
         a => full_a,
         clk => clk,
         ce => internal_ce,
         s => core_s,
         b => full_b
      );
  end generate;
  comp14: if ((core_name0 = "addsb_11_0_07eb1c1df5a181f1")) generate
    core_instance14: addsb_11_0_07eb1c1df5a181f1
      port map (
         a => full_a,
         clk => clk,
         ce => internal_ce,
         s => core_s,
         b => full_b
      );
  end generate;
  comp15: if ((core_name0 = "addsb_11_0_26c38df2140ab027")) generate
    core_instance15: addsb_11_0_26c38df2140ab027
      port map (
         a => full_a,
         clk => clk,
         ce => internal_ce,
         s => core_s,
         b => full_b
      );
  end generate;
  comp16: if ((core_name0 = "addsb_11_0_075266d61a42e95d")) generate
    core_instance16: addsb_11_0_075266d61a42e95d
      port map (
         a => full_a,
         clk => clk,
         ce => internal_ce,
         s => core_s,
         b => full_b
      );
  end generate;
  comp17: if ((core_name0 = "addsb_11_0_12579c2539e3bba1")) generate
    core_instance17: addsb_11_0_12579c2539e3bba1
      port map (
         a => full_a,
         clk => clk,
         ce => internal_ce,
         s => core_s,
         b => full_b
      );
  end generate;
  comp18: if ((core_name0 = "addsb_11_0_6603a21774005e29")) generate
    core_instance18: addsb_11_0_6603a21774005e29
      port map (
         a => full_a,
         clk => clk,
         ce => internal_ce,
         s => core_s,
         b => full_b
      );
  end generate;
  comp19: if ((core_name0 = "addsb_11_0_905df78b66389ded")) generate
    core_instance19: addsb_11_0_905df78b66389ded
      port map (
         a => full_a,
         clk => clk,
         ce => internal_ce,
         s => core_s,
         b => full_b
      );
  end generate;
  comp20: if ((core_name0 = "addsb_11_0_4e2bc60003cf26be")) generate
    core_instance20: addsb_11_0_4e2bc60003cf26be
      port map (
         a => full_a,
         clk => clk,
         ce => internal_ce,
         s => core_s,
         b => full_b
      );
  end generate;
  comp21: if ((core_name0 = "addsb_11_0_837b9ca36be57173")) generate
    core_instance21: addsb_11_0_837b9ca36be57173
      port map (
         a => full_a,
         clk => clk,
         ce => internal_ce,
         s => core_s,
         b => full_b
      );
  end generate;
  comp22: if ((core_name0 = "addsb_11_0_9875f8c5f2e232ba")) generate
    core_instance22: addsb_11_0_9875f8c5f2e232ba
      port map (
         a => full_a,
         clk => clk,
         ce => internal_ce,
         s => core_s,
         b => full_b
      );
  end generate;
  comp24: if ((core_name0 = "addsb_11_0_9ec4483802d81769")) generate
    core_instance24: addsb_11_0_9ec4483802d81769
      port map (
         a => full_a,
         clk => clk,
         ce => internal_ce,
         s => core_s,
         b => full_b
      );
  end generate;
  comp25: if ((core_name0 = "addsb_11_0_62b4a1a618c40b84")) generate
    core_instance25: addsb_11_0_62b4a1a618c40b84
      port map (
         a => full_a,
         clk => clk,
         ce => internal_ce,
         s => core_s,
         b => full_b
      );
  end generate;
  comp26: if ((core_name0 = "addsb_11_0_ca3b6f528ea85846")) generate
    core_instance26: addsb_11_0_ca3b6f528ea85846
      port map (
         a => full_a,
         clk => clk,
         ce => internal_ce,
         s => core_s,
         b => full_b
      );
  end generate;
  latency_test: if (extra_registers > 0) generate
      override_test: if (c_latency > 1) generate
       override_pipe: synth_reg
          generic map (
            width => 1,
            latency => c_latency
          )
          port map (
            i => logic1,
            ce => internal_ce,
            clr => internal_clr,
            clk => clk,
            o(0) => override);
       extra_reg_ce <= ce and en(0) and override;
      end generate override_test;
      no_override: if ((c_latency = 0) or (c_latency = 1)) generate
       extra_reg_ce <= ce and en(0);
      end generate no_override;
      extra_reg: synth_reg
        generic map (
          width => s_width,
          latency => extra_registers
        )
        port map (
          i => conv_s,
          ce => extra_reg_ce,
          clr => internal_clr,
          clk => clk,
          o => s
        );
      cout_test: if (c_has_c_out = 1) generate
      c_out_extra_reg: synth_reg
        generic map (
          width => 1,
          latency => extra_registers
        )
        port map (
          i(0) => temp_cout,
          ce => extra_reg_ce,
          clr => internal_clr,
          clk => clk,
          o => c_out
        );
      end generate cout_test;
  end generate;
  latency_s: if ((latency = 0) or (extra_registers = 0)) generate
    s <= conv_s;
  end generate latency_s;
  latency0: if (((latency = 0) or (extra_registers = 0)) and
                 (c_has_c_out = 1)) generate
    c_out(0) <= temp_cout;
  end generate latency0;
  tie_dangling_cout: if (c_has_c_out = 0) generate
    c_out <= "0";
  end generate tie_dangling_cout;
end architecture behavior;
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_963ed6358a is
  port (
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_963ed6358a;


architecture behavior of constant_963ed6358a is
begin
  op <= "0";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_37567836aa is
  port (
    op : out std_logic_vector((32 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_37567836aa;


architecture behavior of constant_37567836aa is
begin
  op <= "00000000000000000000000000000000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_ebdfb0074f is
  port (
    op : out std_logic_vector((32 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_ebdfb0074f;


architecture behavior of constant_ebdfb0074f is
begin
  op <= "00000000000000000000000000000001";
end behavior;


-------------------------------------------------------------------
-- System Generator version 14.3 VHDL source file.
--
-- Copyright(C) 2012 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2012 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
-- synopsys translate_off
library XilinxCoreLib;
-- synopsys translate_on
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity xlcounter_free_darkquad29 is
  generic (
    core_name0: string := "";
    op_width: integer := 5;
    op_arith: integer := xlSigned
  );
  port (
    ce: in std_logic;
    clr: in std_logic;
    clk: in std_logic;
    op: out std_logic_vector(op_width - 1 downto 0);
    up: in std_logic_vector(0 downto 0) := (others => '0');
    load: in std_logic_vector(0 downto 0) := (others => '0');
    din: in std_logic_vector(op_width - 1 downto 0) := (others => '0');
    en: in std_logic_vector(0 downto 0);
    rst: in std_logic_vector(0 downto 0)
  );
end xlcounter_free_darkquad29 ;
architecture behavior of xlcounter_free_darkquad29 is
  component cntr_11_0_8fd3bf4fb2c5b76d
    port (
      clk: in std_logic;
      ce: in std_logic;
      SINIT: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of cntr_11_0_8fd3bf4fb2c5b76d:
    component is true;
  attribute fpga_dont_touch of cntr_11_0_8fd3bf4fb2c5b76d:
    component is "true";
  attribute box_type of cntr_11_0_8fd3bf4fb2c5b76d:
    component  is "black_box";
  component cntr_11_0_1e48762428ed22e0
    port (
      clk: in std_logic;
      ce: in std_logic;
      SINIT: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of cntr_11_0_1e48762428ed22e0:
    component is true;
  attribute fpga_dont_touch of cntr_11_0_1e48762428ed22e0:
    component is "true";
  attribute box_type of cntr_11_0_1e48762428ed22e0:
    component  is "black_box";
  component cntr_11_0_198c863c3eaf9bde
    port (
      clk: in std_logic;
      ce: in std_logic;
      SINIT: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of cntr_11_0_198c863c3eaf9bde:
    component is true;
  attribute fpga_dont_touch of cntr_11_0_198c863c3eaf9bde:
    component is "true";
  attribute box_type of cntr_11_0_198c863c3eaf9bde:
    component  is "black_box";
  component cntr_11_0_8618faf08c8d27ff
    port (
      clk: in std_logic;
      ce: in std_logic;
      SINIT: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of cntr_11_0_8618faf08c8d27ff:
    component is true;
  attribute fpga_dont_touch of cntr_11_0_8618faf08c8d27ff:
    component is "true";
  attribute box_type of cntr_11_0_8618faf08c8d27ff:
    component  is "black_box";
  component cntr_11_0_dbe4e55db82481fa
    port (
      clk: in std_logic;
      ce: in std_logic;
      SCLR: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of cntr_11_0_dbe4e55db82481fa:
    component is true;
  attribute fpga_dont_touch of cntr_11_0_dbe4e55db82481fa:
    component is "true";
  attribute box_type of cntr_11_0_dbe4e55db82481fa:
    component  is "black_box";
  component cntr_11_0_10352c017544bebd
    port (
      clk: in std_logic;
      ce: in std_logic;
      SINIT: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of cntr_11_0_10352c017544bebd:
    component is true;
  attribute fpga_dont_touch of cntr_11_0_10352c017544bebd:
    component is "true";
  attribute box_type of cntr_11_0_10352c017544bebd:
    component  is "black_box";
  component cntr_11_0_71ab8bef543acf07
    port (
      clk: in std_logic;
      ce: in std_logic;
      SCLR: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of cntr_11_0_71ab8bef543acf07:
    component is true;
  attribute fpga_dont_touch of cntr_11_0_71ab8bef543acf07:
    component is "true";
  attribute box_type of cntr_11_0_71ab8bef543acf07:
    component  is "black_box";
  component cntr_11_0_ca10e447a1c1c04f
    port (
      clk: in std_logic;
      ce: in std_logic;
      SCLR: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of cntr_11_0_ca10e447a1c1c04f:
    component is true;
  attribute fpga_dont_touch of cntr_11_0_ca10e447a1c1c04f:
    component is "true";
  attribute box_type of cntr_11_0_ca10e447a1c1c04f:
    component  is "black_box";
  component cntr_11_0_3e8a20e113de20bb
    port (
      clk: in std_logic;
      ce: in std_logic;
      SCLR: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of cntr_11_0_3e8a20e113de20bb:
    component is true;
  attribute fpga_dont_touch of cntr_11_0_3e8a20e113de20bb:
    component is "true";
  attribute box_type of cntr_11_0_3e8a20e113de20bb:
    component  is "black_box";
  component cntr_11_0_c0e13dbe8d12400d
    port (
      clk: in std_logic;
      ce: in std_logic;
      SCLR: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of cntr_11_0_c0e13dbe8d12400d:
    component is true;
  attribute fpga_dont_touch of cntr_11_0_c0e13dbe8d12400d:
    component is "true";
  attribute box_type of cntr_11_0_c0e13dbe8d12400d:
    component  is "black_box";
  component cntr_11_0_4d961a297cbb815e
    port (
      clk: in std_logic;
      ce: in std_logic;
      SCLR: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of cntr_11_0_4d961a297cbb815e:
    component is true;
  attribute fpga_dont_touch of cntr_11_0_4d961a297cbb815e:
    component is "true";
  attribute box_type of cntr_11_0_4d961a297cbb815e:
    component  is "black_box";
  component cntr_11_0_9ca51386af2c7a71
    port (
      clk: in std_logic;
      ce: in std_logic;
      SCLR: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of cntr_11_0_9ca51386af2c7a71:
    component is true;
  attribute fpga_dont_touch of cntr_11_0_9ca51386af2c7a71:
    component is "true";
  attribute box_type of cntr_11_0_9ca51386af2c7a71:
    component  is "black_box";
  component cntr_11_0_ed5c08cc07bca813
    port (
      clk: in std_logic;
      ce: in std_logic;
      SINIT: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of cntr_11_0_ed5c08cc07bca813:
    component is true;
  attribute fpga_dont_touch of cntr_11_0_ed5c08cc07bca813:
    component is "true";
  attribute box_type of cntr_11_0_ed5c08cc07bca813:
    component  is "black_box";
  component cntr_11_0_68b407ad69be9ca8
    port (
      clk: in std_logic;
      ce: in std_logic;
      SINIT: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of cntr_11_0_68b407ad69be9ca8:
    component is true;
  attribute fpga_dont_touch of cntr_11_0_68b407ad69be9ca8:
    component is "true";
  attribute box_type of cntr_11_0_68b407ad69be9ca8:
    component  is "black_box";
  component cntr_11_0_b8dff8f48773e3e9
    port (
      clk: in std_logic;
      ce: in std_logic;
      SINIT: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of cntr_11_0_b8dff8f48773e3e9:
    component is true;
  attribute fpga_dont_touch of cntr_11_0_b8dff8f48773e3e9:
    component is "true";
  attribute box_type of cntr_11_0_b8dff8f48773e3e9:
    component  is "black_box";
  component cntr_11_0_0e7aae3b0f9694f8
    port (
      clk: in std_logic;
      ce: in std_logic;
      SCLR: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of cntr_11_0_0e7aae3b0f9694f8:
    component is true;
  attribute fpga_dont_touch of cntr_11_0_0e7aae3b0f9694f8:
    component is "true";
  attribute box_type of cntr_11_0_0e7aae3b0f9694f8:
    component  is "black_box";
  component cntr_11_0_564d43d07a40ef72
    port (
      clk: in std_logic;
      ce: in std_logic;
      SINIT: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of cntr_11_0_564d43d07a40ef72:
    component is true;
  attribute fpga_dont_touch of cntr_11_0_564d43d07a40ef72:
    component is "true";
  attribute box_type of cntr_11_0_564d43d07a40ef72:
    component  is "black_box";
  component cntr_11_0_9e131a76d2321c17
    port (
      clk: in std_logic;
      ce: in std_logic;
      SCLR: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of cntr_11_0_9e131a76d2321c17:
    component is true;
  attribute fpga_dont_touch of cntr_11_0_9e131a76d2321c17:
    component is "true";
  attribute box_type of cntr_11_0_9e131a76d2321c17:
    component  is "black_box";
  component cntr_11_0_45eea7380a7f544c
    port (
      clk: in std_logic;
      ce: in std_logic;
      SCLR: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of cntr_11_0_45eea7380a7f544c:
    component is true;
  attribute fpga_dont_touch of cntr_11_0_45eea7380a7f544c:
    component is "true";
  attribute box_type of cntr_11_0_45eea7380a7f544c:
    component  is "black_box";
-- synopsys translate_off
  constant zeroVec: std_logic_vector(op_width - 1 downto 0) := (others => '0');
  constant oneVec: std_logic_vector(op_width - 1 downto 0) := (others => '1');
  constant zeroStr: string(1 to op_width) :=
    std_logic_vector_to_bin_string(zeroVec);
  constant oneStr: string(1 to op_width) :=
    std_logic_vector_to_bin_string(oneVec);
-- synopsys translate_on
  signal core_sinit: std_logic;
  signal core_ce: std_logic;
  signal op_net: std_logic_vector(op_width - 1 downto 0);
begin
  core_ce <= ce and en(0);
  core_sinit <= (clr or rst(0)) and ce;
  op <= op_net;
  comp0: if ((core_name0 = "cntr_11_0_8fd3bf4fb2c5b76d")) generate
    core_instance0: cntr_11_0_8fd3bf4fb2c5b76d
      port map (
        clk => clk,
        ce => core_ce,
        SINIT => core_sinit,
        q => op_net
      );
  end generate;
  comp1: if ((core_name0 = "cntr_11_0_1e48762428ed22e0")) generate
    core_instance1: cntr_11_0_1e48762428ed22e0
      port map (
        clk => clk,
        ce => core_ce,
        SINIT => core_sinit,
        q => op_net
      );
  end generate;
  comp2: if ((core_name0 = "cntr_11_0_198c863c3eaf9bde")) generate
    core_instance2: cntr_11_0_198c863c3eaf9bde
      port map (
        clk => clk,
        ce => core_ce,
        SINIT => core_sinit,
        q => op_net
      );
  end generate;
  comp3: if ((core_name0 = "cntr_11_0_8618faf08c8d27ff")) generate
    core_instance3: cntr_11_0_8618faf08c8d27ff
      port map (
        clk => clk,
        ce => core_ce,
        SINIT => core_sinit,
        q => op_net
      );
  end generate;
  comp4: if ((core_name0 = "cntr_11_0_dbe4e55db82481fa")) generate
    core_instance4: cntr_11_0_dbe4e55db82481fa
      port map (
        clk => clk,
        ce => core_ce,
        SCLR => core_sinit,
        q => op_net
      );
  end generate;
  comp5: if ((core_name0 = "cntr_11_0_10352c017544bebd")) generate
    core_instance5: cntr_11_0_10352c017544bebd
      port map (
        clk => clk,
        ce => core_ce,
        SINIT => core_sinit,
        q => op_net
      );
  end generate;
  comp6: if ((core_name0 = "cntr_11_0_71ab8bef543acf07")) generate
    core_instance6: cntr_11_0_71ab8bef543acf07
      port map (
        clk => clk,
        ce => core_ce,
        SCLR => core_sinit,
        q => op_net
      );
  end generate;
  comp7: if ((core_name0 = "cntr_11_0_ca10e447a1c1c04f")) generate
    core_instance7: cntr_11_0_ca10e447a1c1c04f
      port map (
        clk => clk,
        ce => core_ce,
        SCLR => core_sinit,
        q => op_net
      );
  end generate;
  comp8: if ((core_name0 = "cntr_11_0_3e8a20e113de20bb")) generate
    core_instance8: cntr_11_0_3e8a20e113de20bb
      port map (
        clk => clk,
        ce => core_ce,
        SCLR => core_sinit,
        q => op_net
      );
  end generate;
  comp9: if ((core_name0 = "cntr_11_0_c0e13dbe8d12400d")) generate
    core_instance9: cntr_11_0_c0e13dbe8d12400d
      port map (
        clk => clk,
        ce => core_ce,
        SCLR => core_sinit,
        q => op_net
      );
  end generate;
  comp10: if ((core_name0 = "cntr_11_0_4d961a297cbb815e")) generate
    core_instance10: cntr_11_0_4d961a297cbb815e
      port map (
        clk => clk,
        ce => core_ce,
        SCLR => core_sinit,
        q => op_net
      );
  end generate;
  comp11: if ((core_name0 = "cntr_11_0_9ca51386af2c7a71")) generate
    core_instance11: cntr_11_0_9ca51386af2c7a71
      port map (
        clk => clk,
        ce => core_ce,
        SCLR => core_sinit,
        q => op_net
      );
  end generate;
  comp12: if ((core_name0 = "cntr_11_0_ed5c08cc07bca813")) generate
    core_instance12: cntr_11_0_ed5c08cc07bca813
      port map (
        clk => clk,
        ce => core_ce,
        SINIT => core_sinit,
        q => op_net
      );
  end generate;
  comp13: if ((core_name0 = "cntr_11_0_68b407ad69be9ca8")) generate
    core_instance13: cntr_11_0_68b407ad69be9ca8
      port map (
        clk => clk,
        ce => core_ce,
        SINIT => core_sinit,
        q => op_net
      );
  end generate;
  comp14: if ((core_name0 = "cntr_11_0_b8dff8f48773e3e9")) generate
    core_instance14: cntr_11_0_b8dff8f48773e3e9
      port map (
        clk => clk,
        ce => core_ce,
        SINIT => core_sinit,
        q => op_net
      );
  end generate;
  comp15: if ((core_name0 = "cntr_11_0_0e7aae3b0f9694f8")) generate
    core_instance15: cntr_11_0_0e7aae3b0f9694f8
      port map (
        clk => clk,
        ce => core_ce,
        SCLR => core_sinit,
        q => op_net
      );
  end generate;
  comp16: if ((core_name0 = "cntr_11_0_564d43d07a40ef72")) generate
    core_instance16: cntr_11_0_564d43d07a40ef72
      port map (
        clk => clk,
        ce => core_ce,
        SINIT => core_sinit,
        q => op_net
      );
  end generate;
  comp17: if ((core_name0 = "cntr_11_0_9e131a76d2321c17")) generate
    core_instance17: cntr_11_0_9e131a76d2321c17
      port map (
        clk => clk,
        ce => core_ce,
        SCLR => core_sinit,
        q => op_net
      );
  end generate;
  comp18: if ((core_name0 = "cntr_11_0_45eea7380a7f544c")) generate
    core_instance18: cntr_11_0_45eea7380a7f544c
      port map (
        clk => clk,
        ce => core_ce,
        SCLR => core_sinit,
        q => op_net
      );
  end generate;
end behavior;
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity logical_80f90b97d0 is
  port (
    d0 : in std_logic_vector((1 - 1) downto 0);
    d1 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end logical_80f90b97d0;


architecture behavior of logical_80f90b97d0 is
  signal d0_1_24: std_logic;
  signal d1_1_27: std_logic;
  signal fully_2_1_bit: std_logic;
begin
  d0_1_24 <= d0(0);
  d1_1_27 <= d1(0);
  fully_2_1_bit <= d0_1_24 and d1_1_27;
  y <= std_logic_to_vector(fully_2_1_bit);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_3ffd1d0a40 is
  port (
    a : in std_logic_vector((32 - 1) downto 0);
    b : in std_logic_vector((32 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_3ffd1d0a40;


architecture behavior of relational_3ffd1d0a40 is
  signal a_1_31: unsigned((32 - 1) downto 0);
  signal b_1_34: unsigned((32 - 1) downto 0);
  signal result_12_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  result_12_3_rel <= a_1_31 = b_1_34;
  op <= boolean_to_vector(result_12_3_rel);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_423c6c1400 is
  port (
    d : in std_logic_vector((8 - 1) downto 0);
    q : out std_logic_vector((8 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_423c6c1400;


architecture behavior of delay_423c6c1400 is
  signal d_1_22: std_logic_vector((8 - 1) downto 0);
begin
  d_1_22 <= d;
  q <= d_1_22;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_387191112d is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((8 - 1) downto 0);
    d1 : in std_logic_vector((8 - 1) downto 0);
    y : out std_logic_vector((8 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_387191112d;


architecture behavior of mux_387191112d is
  signal sel_1_20: std_logic;
  signal d0_1_24: std_logic_vector((8 - 1) downto 0);
  signal d1_1_27: std_logic_vector((8 - 1) downto 0);
  signal sel_internal_2_1_convert: std_logic_vector((1 - 1) downto 0);
  signal unregy_join_6_1: std_logic_vector((8 - 1) downto 0);
begin
  sel_1_20 <= sel(0);
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  sel_internal_2_1_convert <= cast(std_logic_to_vector(sel_1_20), 0, 1, 0, xlUnsigned);
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_internal_2_1_convert)
  is
  begin
    case sel_internal_2_1_convert is 
      when "0" =>
        unregy_join_6_1 <= d0_1_24;
      when others =>
        unregy_join_6_1 <= d1_1_27;
    end case;
  end process proc_switch_6_1;
  y <= unregy_join_6_1;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_d99e59b6d4 is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((1 - 1) downto 0);
    d1 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_d99e59b6d4;


architecture behavior of mux_d99e59b6d4 is
  signal sel_1_20: std_logic;
  signal d0_1_24: std_logic;
  signal d1_1_27: std_logic;
  signal sel_internal_2_1_convert: std_logic_vector((1 - 1) downto 0);
  signal unregy_join_6_1: std_logic;
begin
  sel_1_20 <= sel(0);
  d0_1_24 <= d0(0);
  d1_1_27 <= d1(0);
  sel_internal_2_1_convert <= cast(std_logic_to_vector(sel_1_20), 0, 1, 0, xlUnsigned);
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_internal_2_1_convert)
  is
  begin
    case sel_internal_2_1_convert is 
      when "0" =>
        unregy_join_6_1 <= d0_1_24;
      when others =>
        unregy_join_6_1 <= d1_1_27;
    end case;
  end process proc_switch_6_1;
  y <= std_logic_to_vector(unregy_join_6_1);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_63700884f5 is
  port (
    input_port : in std_logic_vector((19 - 1) downto 0);
    output_port : out std_logic_vector((19 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_63700884f5;


architecture behavior of reinterpret_63700884f5 is
  signal input_port_1_40: unsigned((19 - 1) downto 0);
  signal output_port_5_5_force: signed((19 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port_5_5_force <= unsigned_to_signed(input_port_1_40);
  output_port <= signed_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_4a391b9a0e is
  port (
    op : out std_logic_vector((9 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_4a391b9a0e;


architecture behavior of constant_4a391b9a0e is
begin
  op <= "100000000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_78eac2928d is
  port (
    a : in std_logic_vector((9 - 1) downto 0);
    b : in std_logic_vector((9 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_78eac2928d;


architecture behavior of relational_78eac2928d is
  signal a_1_31: unsigned((9 - 1) downto 0);
  signal b_1_34: unsigned((9 - 1) downto 0);
  signal result_14_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  result_14_3_rel <= a_1_31 /= b_1_34;
  op <= boolean_to_vector(result_14_3_rel);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_edea2790a5 is
  port (
    op : out std_logic_vector((30 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_edea2790a5;


architecture behavior of constant_edea2790a5 is
begin
  op <= "000000000000000000000000000000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_dd7b6fe6cd is
  port (
    op : out std_logic_vector((18 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_dd7b6fe6cd;


architecture behavior of constant_dd7b6fe6cd is
begin
  op <= "111111111100000000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_b54edc8403 is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((30 - 1) downto 0);
    d1 : in std_logic_vector((30 - 1) downto 0);
    y : out std_logic_vector((47 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_b54edc8403;


architecture behavior of mux_b54edc8403 is
  signal sel_1_20: std_logic;
  signal d0_1_24: std_logic_vector((30 - 1) downto 0);
  signal d1_1_27: std_logic_vector((30 - 1) downto 0);
  type array_type_pipe_16_22 is array (0 to (1 - 1)) of std_logic_vector((47 - 1) downto 0);
  signal pipe_16_22: array_type_pipe_16_22 := (
    0 => "00000000000000000000000000000000000000000000000");
  signal pipe_16_22_front_din: std_logic_vector((47 - 1) downto 0);
  signal pipe_16_22_back: std_logic_vector((47 - 1) downto 0);
  signal pipe_16_22_push_front_pop_back_en: std_logic;
  signal sel_internal_2_1_convert: std_logic_vector((1 - 1) downto 0);
  signal unregy_join_6_1: std_logic_vector((47 - 1) downto 0);
begin
  sel_1_20 <= sel(0);
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  pipe_16_22_back <= pipe_16_22(0);
  proc_pipe_16_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (pipe_16_22_push_front_pop_back_en = '1')) then
        pipe_16_22(0) <= pipe_16_22_front_din;
      end if;
    end if;
  end process proc_pipe_16_22;
  sel_internal_2_1_convert <= cast(std_logic_to_vector(sel_1_20), 0, 1, 0, xlUnsigned);
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_internal_2_1_convert)
  is
  begin
    case sel_internal_2_1_convert is 
      when "0" =>
        unregy_join_6_1 <= cast(d0_1_24, 17, 47, 17, xlSigned);
      when others =>
        unregy_join_6_1 <= cast(d1_1_27, 0, 47, 17, xlSigned);
    end case;
  end process proc_switch_6_1;
  pipe_16_22_front_din <= unregy_join_6_1;
  pipe_16_22_push_front_pop_back_en <= '1';
  y <= pipe_16_22_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_86a34309e7 is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((32 - 1) downto 0);
    d1 : in std_logic_vector((32 - 1) downto 0);
    y : out std_logic_vector((32 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_86a34309e7;


architecture behavior of mux_86a34309e7 is
  signal sel_1_20: std_logic;
  signal d0_1_24: std_logic_vector((32 - 1) downto 0);
  signal d1_1_27: std_logic_vector((32 - 1) downto 0);
  type array_type_pipe_16_22 is array (0 to (1 - 1)) of std_logic_vector((32 - 1) downto 0);
  signal pipe_16_22: array_type_pipe_16_22 := (
    0 => "00000000000000000000000000000000");
  signal pipe_16_22_front_din: std_logic_vector((32 - 1) downto 0);
  signal pipe_16_22_back: std_logic_vector((32 - 1) downto 0);
  signal pipe_16_22_push_front_pop_back_en: std_logic;
  signal sel_internal_2_1_convert: std_logic_vector((1 - 1) downto 0);
  signal unregy_join_6_1: std_logic_vector((32 - 1) downto 0);
begin
  sel_1_20 <= sel(0);
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  pipe_16_22_back <= pipe_16_22(0);
  proc_pipe_16_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (pipe_16_22_push_front_pop_back_en = '1')) then
        pipe_16_22(0) <= pipe_16_22_front_din;
      end if;
    end if;
  end process proc_pipe_16_22;
  sel_internal_2_1_convert <= cast(std_logic_to_vector(sel_1_20), 0, 1, 0, xlUnsigned);
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_internal_2_1_convert)
  is
  begin
    case sel_internal_2_1_convert is 
      when "0" =>
        unregy_join_6_1 <= d0_1_24;
      when others =>
        unregy_join_6_1 <= d1_1_27;
    end case;
  end process proc_switch_6_1;
  pipe_16_22_front_din <= unregy_join_6_1;
  pipe_16_22_push_front_pop_back_en <= '1';
  y <= pipe_16_22_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_1e22c21d05 is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((1 - 1) downto 0);
    d1 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_1e22c21d05;


architecture behavior of mux_1e22c21d05 is
  signal sel_1_20: std_logic;
  signal d0_1_24: std_logic;
  signal d1_1_27: std_logic;
  type array_type_pipe_16_22 is array (0 to (1 - 1)) of std_logic;
  signal pipe_16_22: array_type_pipe_16_22 := (
    0 => '0');
  signal pipe_16_22_front_din: std_logic;
  signal pipe_16_22_back: std_logic;
  signal pipe_16_22_push_front_pop_back_en: std_logic;
  signal sel_internal_2_1_convert: std_logic_vector((1 - 1) downto 0);
  signal unregy_join_6_1: std_logic;
begin
  sel_1_20 <= sel(0);
  d0_1_24 <= d0(0);
  d1_1_27 <= d1(0);
  pipe_16_22_back <= pipe_16_22(0);
  proc_pipe_16_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (pipe_16_22_push_front_pop_back_en = '1')) then
        pipe_16_22(0) <= pipe_16_22_front_din;
      end if;
    end if;
  end process proc_pipe_16_22;
  sel_internal_2_1_convert <= cast(std_logic_to_vector(sel_1_20), 0, 1, 0, xlUnsigned);
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_internal_2_1_convert)
  is
  begin
    case sel_internal_2_1_convert is 
      when "0" =>
        unregy_join_6_1 <= d0_1_24;
      when others =>
        unregy_join_6_1 <= d1_1_27;
    end case;
  end process proc_switch_6_1;
  pipe_16_22_front_din <= unregy_join_6_1;
  pipe_16_22_push_front_pop_back_en <= '1';
  y <= std_logic_to_vector(pipe_16_22_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_29020b53d3 is
  port (
    input_port : in std_logic_vector((19 - 1) downto 0);
    output_port : out std_logic_vector((19 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_29020b53d3;


architecture behavior of reinterpret_29020b53d3 is
  signal input_port_1_40: signed((19 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_signed(input_port);
  output_port <= signed_to_std_logic_vector(input_port_1_40);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_46dd2ac081 is
  port (
    input_port : in std_logic_vector((30 - 1) downto 0);
    output_port : out std_logic_vector((30 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_46dd2ac081;


architecture behavior of reinterpret_46dd2ac081 is
  signal input_port_1_40: signed((30 - 1) downto 0);
  signal output_port_5_5_force: unsigned((30 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_signed(input_port);
  output_port_5_5_force <= signed_to_unsigned(input_port_1_40);
  output_port <= unsigned_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_4e76b03051 is
  port (
    a : in std_logic_vector((18 - 1) downto 0);
    b : in std_logic_vector((18 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_4e76b03051;


architecture behavior of relational_4e76b03051 is
  signal a_1_31: unsigned((18 - 1) downto 0);
  signal b_1_34: unsigned((18 - 1) downto 0);
  type array_type_op_mem_32_22 is array (0 to (1 - 1)) of boolean;
  signal op_mem_32_22: array_type_op_mem_32_22 := (
    0 => false);
  signal op_mem_32_22_front_din: boolean;
  signal op_mem_32_22_back: boolean;
  signal op_mem_32_22_push_front_pop_back_en: std_logic;
  signal result_12_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  op_mem_32_22_back <= op_mem_32_22(0);
  proc_op_mem_32_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_32_22_push_front_pop_back_en = '1')) then
        op_mem_32_22(0) <= op_mem_32_22_front_din;
      end if;
    end if;
  end process proc_op_mem_32_22;
  result_12_3_rel <= a_1_31 = b_1_34;
  op_mem_32_22_front_din <= result_12_3_rel;
  op_mem_32_22_push_front_pop_back_en <= '1';
  op <= boolean_to_vector(op_mem_32_22_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_3f7e3674f6 is
  port (
    input_port : in std_logic_vector((32 - 1) downto 0);
    output_port : out std_logic_vector((32 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_3f7e3674f6;


architecture behavior of reinterpret_3f7e3674f6 is
  signal input_port_1_40: signed((32 - 1) downto 0);
  signal output_port_5_5_force: unsigned((32 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_signed(input_port);
  output_port_5_5_force <= signed_to_unsigned(input_port_1_40);
  output_port <= unsigned_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity logical_f6397bdee1 is
  port (
    d0 : in std_logic_vector((1 - 1) downto 0);
    d1 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end logical_f6397bdee1;


architecture behavior of logical_f6397bdee1 is
  signal d0_1_24: std_logic;
  signal d1_1_27: std_logic;
  signal bit_2_27: std_logic;
  signal fully_2_1_bitnot: std_logic;
begin
  d0_1_24 <= d0(0);
  d1_1_27 <= d1(0);
  bit_2_27 <= d0_1_24 xor d1_1_27;
  fully_2_1_bitnot <= not bit_2_27;
  y <= std_logic_to_vector(fully_2_1_bitnot);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_1d665a7331 is
  port (
    in0 : in std_logic_vector((19 - 1) downto 0);
    in1 : in std_logic_vector((1 - 1) downto 0);
    in2 : in std_logic_vector((12 - 1) downto 0);
    y : out std_logic_vector((32 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_1d665a7331;


architecture behavior of concat_1d665a7331 is
  signal in0_1_23: unsigned((19 - 1) downto 0);
  signal in1_1_27: boolean;
  signal in2_1_31: unsigned((12 - 1) downto 0);
  signal y_2_1_concat: unsigned((32 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= ((in1) = "1");
  in2_1_31 <= std_logic_vector_to_unsigned(in2);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & boolean_to_vector(in1_1_27) & unsigned_to_std_logic_vector(in2_1_31));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_9f02caa990 is
  port (
    d : in std_logic_vector((1 - 1) downto 0);
    q : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_9f02caa990;


architecture behavior of delay_9f02caa990 is
  signal d_1_22: std_logic;
  type array_type_op_mem_20_24 is array (0 to (1 - 1)) of std_logic;
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    0 => '0');
  signal op_mem_20_24_front_din: std_logic;
  signal op_mem_20_24_back: std_logic;
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d(0);
  op_mem_20_24_back <= op_mem_20_24(0);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= std_logic_to_vector(op_mem_20_24_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_672d2b8d1e is
  port (
    d : in std_logic_vector((32 - 1) downto 0);
    q : out std_logic_vector((32 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_672d2b8d1e;


architecture behavior of delay_672d2b8d1e is
  signal d_1_22: std_logic_vector((32 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (1 - 1)) of std_logic_vector((32 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    0 => "00000000000000000000000000000000");
  signal op_mem_20_24_front_din: std_logic_vector((32 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((32 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(0);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity inverter_6844eee868 is
  port (
    ip : in std_logic_vector((1 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end inverter_6844eee868;


architecture behavior of inverter_6844eee868 is
  signal ip_1_26: boolean;
  type array_type_op_mem_22_20 is array (0 to (1 - 1)) of boolean;
  signal op_mem_22_20: array_type_op_mem_22_20 := (
    0 => false);
  signal op_mem_22_20_front_din: boolean;
  signal op_mem_22_20_back: boolean;
  signal op_mem_22_20_push_front_pop_back_en: std_logic;
  signal internal_ip_12_1_bitnot: boolean;
begin
  ip_1_26 <= ((ip) = "1");
  op_mem_22_20_back <= op_mem_22_20(0);
  proc_op_mem_22_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_22_20_push_front_pop_back_en = '1')) then
        op_mem_22_20(0) <= op_mem_22_20_front_din;
      end if;
    end if;
  end process proc_op_mem_22_20;
  internal_ip_12_1_bitnot <= ((not boolean_to_vector(ip_1_26)) = "1");
  op_mem_22_20_front_din <= internal_ip_12_1_bitnot;
  op_mem_22_20_push_front_pop_back_en <= '1';
  op <= boolean_to_vector(op_mem_22_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity logical_799f62af22 is
  port (
    d0 : in std_logic_vector((1 - 1) downto 0);
    d1 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end logical_799f62af22;


architecture behavior of logical_799f62af22 is
  signal d0_1_24: std_logic;
  signal d1_1_27: std_logic;
  type array_type_latency_pipe_5_26 is array (0 to (1 - 1)) of std_logic;
  signal latency_pipe_5_26: array_type_latency_pipe_5_26 := (
    0 => '0');
  signal latency_pipe_5_26_front_din: std_logic;
  signal latency_pipe_5_26_back: std_logic;
  signal latency_pipe_5_26_push_front_pop_back_en: std_logic;
  signal fully_2_1_bit: std_logic;
begin
  d0_1_24 <= d0(0);
  d1_1_27 <= d1(0);
  latency_pipe_5_26_back <= latency_pipe_5_26(0);
  proc_latency_pipe_5_26: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (latency_pipe_5_26_push_front_pop_back_en = '1')) then
        latency_pipe_5_26(0) <= latency_pipe_5_26_front_din;
      end if;
    end if;
  end process proc_latency_pipe_5_26;
  fully_2_1_bit <= d0_1_24 and d1_1_27;
  latency_pipe_5_26_front_din <= fully_2_1_bit;
  latency_pipe_5_26_push_front_pop_back_en <= '1';
  y <= std_logic_to_vector(latency_pipe_5_26_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity logical_aacf6e1b0e is
  port (
    d0 : in std_logic_vector((1 - 1) downto 0);
    d1 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end logical_aacf6e1b0e;


architecture behavior of logical_aacf6e1b0e is
  signal d0_1_24: std_logic;
  signal d1_1_27: std_logic;
  signal fully_2_1_bit: std_logic;
begin
  d0_1_24 <= d0(0);
  d1_1_27 <= d1(0);
  fully_2_1_bit <= d0_1_24 or d1_1_27;
  y <= std_logic_to_vector(fully_2_1_bit);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity logical_954ee29728 is
  port (
    d0 : in std_logic_vector((1 - 1) downto 0);
    d1 : in std_logic_vector((1 - 1) downto 0);
    d2 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end logical_954ee29728;


architecture behavior of logical_954ee29728 is
  signal d0_1_24: std_logic;
  signal d1_1_27: std_logic;
  signal d2_1_30: std_logic;
  signal fully_2_1_bit: std_logic;
begin
  d0_1_24 <= d0(0);
  d1_1_27 <= d1(0);
  d2_1_30 <= d2(0);
  fully_2_1_bit <= d0_1_24 and d1_1_27 and d2_1_30;
  y <= std_logic_to_vector(fully_2_1_bit);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity shift_892c2104f7 is
  port (
    ip : in std_logic_vector((19 - 1) downto 0);
    op : out std_logic_vector((19 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end shift_892c2104f7;


architecture behavior of shift_892c2104f7 is
  signal ip_1_23: unsigned((19 - 1) downto 0);
  type array_type_op_mem_46_20 is array (0 to (1 - 1)) of unsigned((19 - 1) downto 0);
  signal op_mem_46_20: array_type_op_mem_46_20 := (
    0 => "0000000000000000000");
  signal op_mem_46_20_front_din: unsigned((19 - 1) downto 0);
  signal op_mem_46_20_back: unsigned((19 - 1) downto 0);
  signal op_mem_46_20_push_front_pop_back_en: std_logic;
  signal cast_internal_ip_25_3_lsh: unsigned((37 - 1) downto 0);
  signal cast_internal_ip_36_3_convert: unsigned((19 - 1) downto 0);
begin
  ip_1_23 <= std_logic_vector_to_unsigned(ip);
  op_mem_46_20_back <= op_mem_46_20(0);
  proc_op_mem_46_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_46_20_push_front_pop_back_en = '1')) then
        op_mem_46_20(0) <= op_mem_46_20_front_din;
      end if;
    end if;
  end process proc_op_mem_46_20;
  cast_internal_ip_25_3_lsh <= u2u_cast(ip_1_23, 0, 37, 18);
  cast_internal_ip_36_3_convert <= u2u_cast(cast_internal_ip_25_3_lsh, 0, 19, 0);
  op_mem_46_20_front_din <= cast_internal_ip_36_3_convert;
  op_mem_46_20_push_front_pop_back_en <= '1';
  op <= unsigned_to_std_logic_vector(op_mem_46_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_762608f33d is
  port (
    in0 : in std_logic_vector((8 - 1) downto 0);
    in1 : in std_logic_vector((32 - 1) downto 0);
    in2 : in std_logic_vector((8 - 1) downto 0);
    in3 : in std_logic_vector((32 - 1) downto 0);
    y : out std_logic_vector((80 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_762608f33d;


architecture behavior of concat_762608f33d is
  signal in0_1_23: unsigned((8 - 1) downto 0);
  signal in1_1_27: unsigned((32 - 1) downto 0);
  signal in2_1_31: unsigned((8 - 1) downto 0);
  signal in3_1_35: unsigned((32 - 1) downto 0);
  signal y_2_1_concat: unsigned((80 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  in2_1_31 <= std_logic_vector_to_unsigned(in2);
  in3_1_35 <= std_logic_vector_to_unsigned(in3);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27) & unsigned_to_std_logic_vector(in2_1_31) & unsigned_to_std_logic_vector(in3_1_35));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_91ef1678ca is
  port (
    op : out std_logic_vector((8 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_91ef1678ca;


architecture behavior of constant_91ef1678ca is
begin
  op <= "00000000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_a575c74b27 is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((80 - 1) downto 0);
    d1 : in std_logic_vector((80 - 1) downto 0);
    y : out std_logic_vector((80 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_a575c74b27;


architecture behavior of mux_a575c74b27 is
  signal sel_1_20: std_logic_vector((1 - 1) downto 0);
  signal d0_1_24: std_logic_vector((80 - 1) downto 0);
  signal d1_1_27: std_logic_vector((80 - 1) downto 0);
  type array_type_pipe_16_22 is array (0 to (1 - 1)) of std_logic_vector((80 - 1) downto 0);
  signal pipe_16_22: array_type_pipe_16_22 := (
    0 => "00000000000000000000000000000000000000000000000000000000000000000000000000000000");
  signal pipe_16_22_front_din: std_logic_vector((80 - 1) downto 0);
  signal pipe_16_22_back: std_logic_vector((80 - 1) downto 0);
  signal pipe_16_22_push_front_pop_back_en: std_logic;
  signal unregy_join_6_1: std_logic_vector((80 - 1) downto 0);
begin
  sel_1_20 <= sel;
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  pipe_16_22_back <= pipe_16_22(0);
  proc_pipe_16_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (pipe_16_22_push_front_pop_back_en = '1')) then
        pipe_16_22(0) <= pipe_16_22_front_din;
      end if;
    end if;
  end process proc_pipe_16_22;
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_1_20)
  is
  begin
    case sel_1_20 is 
      when "0" =>
        unregy_join_6_1 <= d0_1_24;
      when others =>
        unregy_join_6_1 <= d1_1_27;
    end case;
  end process proc_switch_6_1;
  pipe_16_22_front_din <= unregy_join_6_1;
  pipe_16_22_push_front_pop_back_en <= '1';
  y <= pipe_16_22_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_5f1eb17108 is
  port (
    a : in std_logic_vector((2 - 1) downto 0);
    b : in std_logic_vector((2 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_5f1eb17108;


architecture behavior of relational_5f1eb17108 is
  signal a_1_31: unsigned((2 - 1) downto 0);
  signal b_1_34: unsigned((2 - 1) downto 0);
  signal result_12_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  result_12_3_rel <= a_1_31 = b_1_34;
  op <= boolean_to_vector(result_12_3_rel);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_cda50df78a is
  port (
    op : out std_logic_vector((2 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_cda50df78a;


architecture behavior of constant_cda50df78a is
begin
  op <= "00";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_a7e2bb9e12 is
  port (
    op : out std_logic_vector((2 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_a7e2bb9e12;


architecture behavior of constant_a7e2bb9e12 is
begin
  op <= "01";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_e8ddc079e9 is
  port (
    op : out std_logic_vector((2 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_e8ddc079e9;


architecture behavior of constant_e8ddc079e9 is
begin
  op <= "10";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_b4a3823c60 is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((32 - 1) downto 0);
    d1 : in std_logic_vector((80 - 1) downto 0);
    y : out std_logic_vector((32 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_b4a3823c60;


architecture behavior of mux_b4a3823c60 is
  signal sel_1_20: std_logic;
  signal d0_1_24: std_logic_vector((32 - 1) downto 0);
  signal d1_1_27: std_logic_vector((80 - 1) downto 0);
  signal sel_internal_2_1_convert: std_logic_vector((1 - 1) downto 0);
  signal unregy_join_6_1: std_logic_vector((80 - 1) downto 0);
  signal cast_unregy_13_5_convert: std_logic_vector((32 - 1) downto 0);
begin
  sel_1_20 <= sel(0);
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  sel_internal_2_1_convert <= cast(std_logic_to_vector(sel_1_20), 0, 1, 0, xlUnsigned);
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_internal_2_1_convert)
  is
  begin
    case sel_internal_2_1_convert is 
      when "0" =>
        unregy_join_6_1 <= cast(d0_1_24, 0, 80, 0, xlUnsigned);
      when others =>
        unregy_join_6_1 <= d1_1_27;
    end case;
  end process proc_switch_6_1;
  cast_unregy_13_5_convert <= cast(unregy_join_6_1, 0, 32, 0, xlUnsigned);
  y <= cast_unregy_13_5_convert;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity counter_caa2b01eef is
  port (
    rst : in std_logic_vector((1 - 1) downto 0);
    en : in std_logic_vector((1 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end counter_caa2b01eef;


architecture behavior of counter_caa2b01eef is
  signal rst_1_40: boolean;
  signal en_1_45: boolean;
  signal count_reg_20_23: unsigned((1 - 1) downto 0) := "0";
  signal count_reg_20_23_rst: std_logic;
  signal count_reg_20_23_en: std_logic;
  signal bool_44_4: boolean;
  signal count_reg_join_44_1: unsigned((2 - 1) downto 0);
  signal count_reg_join_44_1_en: std_logic;
  signal count_reg_join_44_1_rst: std_logic;
  signal rst_limit_join_44_1: boolean;
begin
  rst_1_40 <= ((rst) = "1");
  en_1_45 <= ((en) = "1");
  proc_count_reg_20_23: process (clk)
  is
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (count_reg_20_23_rst = '1')) then
        count_reg_20_23 <= "0";
      elsif ((ce = '1') and (count_reg_20_23_en = '1')) then 
        count_reg_20_23 <= count_reg_20_23 + std_logic_vector_to_unsigned("1");
      end if;
    end if;
  end process proc_count_reg_20_23;
  bool_44_4 <= rst_1_40 or false;
  proc_if_44_1: process (bool_44_4, count_reg_20_23, en_1_45)
  is
  begin
    if bool_44_4 then
      count_reg_join_44_1_rst <= '1';
    elsif en_1_45 then
      count_reg_join_44_1_rst <= '0';
    else 
      count_reg_join_44_1_rst <= '0';
    end if;
    if en_1_45 then
      count_reg_join_44_1_en <= '1';
    else 
      count_reg_join_44_1_en <= '0';
    end if;
    if bool_44_4 then
      rst_limit_join_44_1 <= false;
    elsif en_1_45 then
      rst_limit_join_44_1 <= false;
    else 
      rst_limit_join_44_1 <= false;
    end if;
  end process proc_if_44_1;
  count_reg_20_23_rst <= count_reg_join_44_1_rst;
  count_reg_20_23_en <= count_reg_join_44_1_en;
  op <= unsigned_to_std_logic_vector(count_reg_20_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_c13097e33e is
  port (
    a : in std_logic_vector((1 - 1) downto 0);
    b : in std_logic_vector((1 - 1) downto 0);
    s : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_c13097e33e;


architecture behavior of addsub_c13097e33e is
  signal a_17_32: unsigned((1 - 1) downto 0);
  signal b_17_35: unsigned((1 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "0");
  signal op_mem_91_20_front_din: unsigned((1 - 1) downto 0);
  signal op_mem_91_20_back: unsigned((1 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_71_18: signed((3 - 1) downto 0);
  signal cast_71_22: signed((3 - 1) downto 0);
  signal internal_s_71_5_addsub: signed((3 - 1) downto 0);
  signal cast_internal_s_83_3_convert: unsigned((1 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_unsigned(a);
  b_17_35 <= std_logic_vector_to_unsigned(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_71_18 <= u2s_cast(a_17_32, 0, 3, 0);
  cast_71_22 <= u2s_cast(b_17_35, 0, 3, 0);
  internal_s_71_5_addsub <= cast_71_18 - cast_71_22;
  cast_internal_s_83_3_convert <= s2u_cast(internal_s_71_5_addsub, 0, 1, 0);
  op_mem_91_20_push_front_pop_back_en <= '0';
  cout_mem_92_22_push_front_pop_back_en <= '0';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= unsigned_to_std_logic_vector(cast_internal_s_83_3_convert);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_1d98d96b58 is
  port (
    in0 : in std_logic_vector((9 - 1) downto 0);
    in1 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((10 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_1d98d96b58;


architecture behavior of concat_1d98d96b58 is
  signal in0_1_23: unsigned((9 - 1) downto 0);
  signal in1_1_27: unsigned((1 - 1) downto 0);
  signal y_2_1_concat: unsigned((10 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_4fe5face7f is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((10 - 1) downto 0);
    d1 : in std_logic_vector((10 - 1) downto 0);
    y : out std_logic_vector((10 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_4fe5face7f;


architecture behavior of mux_4fe5face7f is
  signal sel_1_20: std_logic_vector((1 - 1) downto 0);
  signal d0_1_24: std_logic_vector((10 - 1) downto 0);
  signal d1_1_27: std_logic_vector((10 - 1) downto 0);
  signal unregy_join_6_1: std_logic_vector((10 - 1) downto 0);
begin
  sel_1_20 <= sel;
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_1_20)
  is
  begin
    case sel_1_20 is 
      when "0" =>
        unregy_join_6_1 <= d0_1_24;
      when others =>
        unregy_join_6_1 <= d1_1_27;
    end case;
  end process proc_switch_6_1;
  y <= unregy_join_6_1;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_cf4f99539f is
  port (
    d : in std_logic_vector((10 - 1) downto 0);
    q : out std_logic_vector((10 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_cf4f99539f;


architecture behavior of delay_cf4f99539f is
  signal d_1_22: std_logic_vector((10 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (1 - 1)) of std_logic_vector((10 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    0 => "0000000000");
  signal op_mem_20_24_front_din: std_logic_vector((10 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((10 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(0);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_b713aad2a7 is
  port (
    op : out std_logic_vector((19 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_b713aad2a7;


architecture behavior of constant_b713aad2a7 is
begin
  op <= "1000000000000000000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_502d6cf7c0 is
  port (
    a : in std_logic_vector((19 - 1) downto 0);
    b : in std_logic_vector((19 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_502d6cf7c0;


architecture behavior of relational_502d6cf7c0 is
  signal a_1_31: unsigned((19 - 1) downto 0);
  signal b_1_34: unsigned((19 - 1) downto 0);
  signal result_14_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  result_14_3_rel <= a_1_31 /= b_1_34;
  op <= boolean_to_vector(result_14_3_rel);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_deb0401f42 is
  port (
    a : in std_logic_vector((8 - 1) downto 0);
    b : in std_logic_vector((8 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_deb0401f42;


architecture behavior of relational_deb0401f42 is
  signal a_1_31: unsigned((8 - 1) downto 0);
  signal b_1_34: unsigned((8 - 1) downto 0);
  type array_type_op_mem_32_22 is array (0 to (1 - 1)) of boolean;
  signal op_mem_32_22: array_type_op_mem_32_22 := (
    0 => false);
  signal op_mem_32_22_front_din: boolean;
  signal op_mem_32_22_back: boolean;
  signal op_mem_32_22_push_front_pop_back_en: std_logic;
  signal result_12_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  op_mem_32_22_back <= op_mem_32_22(0);
  proc_op_mem_32_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_32_22_push_front_pop_back_en = '1')) then
        op_mem_32_22(0) <= op_mem_32_22_front_din;
      end if;
    end if;
  end process proc_op_mem_32_22;
  result_12_3_rel <= a_1_31 = b_1_34;
  op_mem_32_22_front_din <= result_12_3_rel;
  op_mem_32_22_push_front_pop_back_en <= '1';
  op <= boolean_to_vector(op_mem_32_22_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_f861ea8324 is
  port (
    in0 : in std_logic_vector((24 - 1) downto 0);
    in1 : in std_logic_vector((24 - 1) downto 0);
    in2 : in std_logic_vector((24 - 1) downto 0);
    in3 : in std_logic_vector((24 - 1) downto 0);
    in4 : in std_logic_vector((24 - 1) downto 0);
    in5 : in std_logic_vector((24 - 1) downto 0);
    in6 : in std_logic_vector((24 - 1) downto 0);
    in7 : in std_logic_vector((24 - 1) downto 0);
    y : out std_logic_vector((192 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_f861ea8324;


architecture behavior of concat_f861ea8324 is
  signal in0_1_23: unsigned((24 - 1) downto 0);
  signal in1_1_27: unsigned((24 - 1) downto 0);
  signal in2_1_31: unsigned((24 - 1) downto 0);
  signal in3_1_35: unsigned((24 - 1) downto 0);
  signal in4_1_39: unsigned((24 - 1) downto 0);
  signal in5_1_43: unsigned((24 - 1) downto 0);
  signal in6_1_47: unsigned((24 - 1) downto 0);
  signal in7_1_51: unsigned((24 - 1) downto 0);
  signal y_2_1_concat: unsigned((192 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  in2_1_31 <= std_logic_vector_to_unsigned(in2);
  in3_1_35 <= std_logic_vector_to_unsigned(in3);
  in4_1_39 <= std_logic_vector_to_unsigned(in4);
  in5_1_43 <= std_logic_vector_to_unsigned(in5);
  in6_1_47 <= std_logic_vector_to_unsigned(in6);
  in7_1_51 <= std_logic_vector_to_unsigned(in7);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27) & unsigned_to_std_logic_vector(in2_1_31) & unsigned_to_std_logic_vector(in3_1_35) & unsigned_to_std_logic_vector(in4_1_39) & unsigned_to_std_logic_vector(in5_1_43) & unsigned_to_std_logic_vector(in6_1_47) & unsigned_to_std_logic_vector(in7_1_51));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_950635102d is
  port (
    input_port : in std_logic_vector((24 - 1) downto 0);
    output_port : out std_logic_vector((24 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_950635102d;


architecture behavior of reinterpret_950635102d is
  signal input_port_1_40: unsigned((24 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port <= unsigned_to_std_logic_vector(input_port_1_40);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_915e90bb96 is
  port (
    d : in std_logic_vector((15 - 1) downto 0);
    q : out std_logic_vector((15 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_915e90bb96;


architecture behavior of delay_915e90bb96 is
  signal d_1_22: std_logic_vector((15 - 1) downto 0);
begin
  d_1_22 <= d;
  q <= d_1_22;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_1001cf4171 is
  port (
    input_port : in std_logic_vector((15 - 1) downto 0);
    output_port : out std_logic_vector((15 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_1001cf4171;


architecture behavior of reinterpret_1001cf4171 is
  signal input_port_1_40: unsigned((15 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port <= unsigned_to_std_logic_vector(input_port_1_40);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_6188124172 is
  port (
    in0 : in std_logic_vector((12 - 1) downto 0);
    in1 : in std_logic_vector((12 - 1) downto 0);
    y : out std_logic_vector((24 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_6188124172;


architecture behavior of concat_6188124172 is
  signal in0_1_23: unsigned((12 - 1) downto 0);
  signal in1_1_27: unsigned((12 - 1) downto 0);
  signal y_2_1_concat: unsigned((24 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_a106f99236 is
  port (
    input_port : in std_logic_vector((12 - 1) downto 0);
    output_port : out std_logic_vector((12 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_a106f99236;


architecture behavior of reinterpret_a106f99236 is
  signal input_port_1_40: signed((12 - 1) downto 0);
  signal output_port_5_5_force: unsigned((12 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_signed(input_port);
  output_port_5_5_force <= signed_to_unsigned(input_port_1_40);
  output_port <= unsigned_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_08ed6107eb is
  port (
    in0 : in std_logic_vector((12 - 1) downto 0);
    in1 : in std_logic_vector((12 - 1) downto 0);
    in2 : in std_logic_vector((12 - 1) downto 0);
    in3 : in std_logic_vector((12 - 1) downto 0);
    y : out std_logic_vector((48 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_08ed6107eb;


architecture behavior of concat_08ed6107eb is
  signal in0_1_23: unsigned((12 - 1) downto 0);
  signal in1_1_27: unsigned((12 - 1) downto 0);
  signal in2_1_31: unsigned((12 - 1) downto 0);
  signal in3_1_35: unsigned((12 - 1) downto 0);
  signal y_2_1_concat: unsigned((48 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  in2_1_31 <= std_logic_vector_to_unsigned(in2);
  in3_1_35 <= std_logic_vector_to_unsigned(in3);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27) & unsigned_to_std_logic_vector(in2_1_31) & unsigned_to_std_logic_vector(in3_1_35));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_e2d047c154 is
  port (
    d : in std_logic_vector((64 - 1) downto 0);
    q : out std_logic_vector((64 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_e2d047c154;


architecture behavior of delay_e2d047c154 is
  signal d_1_22: std_logic_vector((64 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (1 - 1)) of std_logic_vector((64 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    0 => "0000000000000000000000000000000000000000000000000000000000000000");
  signal op_mem_20_24_front_din: std_logic_vector((64 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((64 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(0);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_1cf6dd7a8c is
  port (
    in0 : in std_logic_vector((8 - 1) downto 0);
    in1 : in std_logic_vector((64 - 1) downto 0);
    in2 : in std_logic_vector((8 - 1) downto 0);
    in3 : in std_logic_vector((64 - 1) downto 0);
    y : out std_logic_vector((144 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_1cf6dd7a8c;


architecture behavior of concat_1cf6dd7a8c is
  signal in0_1_23: unsigned((8 - 1) downto 0);
  signal in1_1_27: unsigned((64 - 1) downto 0);
  signal in2_1_31: unsigned((8 - 1) downto 0);
  signal in3_1_35: unsigned((64 - 1) downto 0);
  signal y_2_1_concat: unsigned((144 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  in2_1_31 <= std_logic_vector_to_unsigned(in2);
  in3_1_35 <= std_logic_vector_to_unsigned(in3);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27) & unsigned_to_std_logic_vector(in2_1_31) & unsigned_to_std_logic_vector(in3_1_35));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_d10510a905 is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((144 - 1) downto 0);
    d1 : in std_logic_vector((144 - 1) downto 0);
    y : out std_logic_vector((144 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_d10510a905;


architecture behavior of mux_d10510a905 is
  signal sel_1_20: std_logic_vector((1 - 1) downto 0);
  signal d0_1_24: std_logic_vector((144 - 1) downto 0);
  signal d1_1_27: std_logic_vector((144 - 1) downto 0);
  type array_type_pipe_16_22 is array (0 to (1 - 1)) of std_logic_vector((144 - 1) downto 0);
  signal pipe_16_22: array_type_pipe_16_22 := (
    0 => "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
  signal pipe_16_22_front_din: std_logic_vector((144 - 1) downto 0);
  signal pipe_16_22_back: std_logic_vector((144 - 1) downto 0);
  signal pipe_16_22_push_front_pop_back_en: std_logic;
  signal unregy_join_6_1: std_logic_vector((144 - 1) downto 0);
begin
  sel_1_20 <= sel;
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  pipe_16_22_back <= pipe_16_22(0);
  proc_pipe_16_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (pipe_16_22_push_front_pop_back_en = '1')) then
        pipe_16_22(0) <= pipe_16_22_front_din;
      end if;
    end if;
  end process proc_pipe_16_22;
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_1_20)
  is
  begin
    case sel_1_20 is 
      when "0" =>
        unregy_join_6_1 <= d0_1_24;
      when others =>
        unregy_join_6_1 <= d1_1_27;
    end case;
  end process proc_switch_6_1;
  pipe_16_22_front_din <= unregy_join_6_1;
  pipe_16_22_push_front_pop_back_en <= '1';
  y <= pipe_16_22_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_5b4e0018fe is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((64 - 1) downto 0);
    d1 : in std_logic_vector((144 - 1) downto 0);
    y : out std_logic_vector((64 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_5b4e0018fe;


architecture behavior of mux_5b4e0018fe is
  signal sel_1_20: std_logic;
  signal d0_1_24: std_logic_vector((64 - 1) downto 0);
  signal d1_1_27: std_logic_vector((144 - 1) downto 0);
  signal sel_internal_2_1_convert: std_logic_vector((1 - 1) downto 0);
  signal unregy_join_6_1: std_logic_vector((144 - 1) downto 0);
  signal cast_unregy_13_5_convert: std_logic_vector((64 - 1) downto 0);
begin
  sel_1_20 <= sel(0);
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  sel_internal_2_1_convert <= cast(std_logic_to_vector(sel_1_20), 0, 1, 0, xlUnsigned);
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_internal_2_1_convert)
  is
  begin
    case sel_internal_2_1_convert is 
      when "0" =>
        unregy_join_6_1 <= cast(d0_1_24, 0, 144, 0, xlUnsigned);
      when others =>
        unregy_join_6_1 <= d1_1_27;
    end case;
  end process proc_switch_6_1;
  cast_unregy_13_5_convert <= cast(unregy_join_6_1, 0, 64, 0, xlUnsigned);
  y <= cast_unregy_13_5_convert;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_e27c8b361a is
  port (
    in0 : in std_logic_vector((8 - 1) downto 0);
    in1 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((9 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_e27c8b361a;


architecture behavior of concat_e27c8b361a is
  signal in0_1_23: unsigned((8 - 1) downto 0);
  signal in1_1_27: unsigned((1 - 1) downto 0);
  signal y_2_1_concat: unsigned((9 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_1c9c15de9c is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((9 - 1) downto 0);
    d1 : in std_logic_vector((9 - 1) downto 0);
    y : out std_logic_vector((9 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_1c9c15de9c;


architecture behavior of mux_1c9c15de9c is
  signal sel_1_20: std_logic_vector((1 - 1) downto 0);
  signal d0_1_24: std_logic_vector((9 - 1) downto 0);
  signal d1_1_27: std_logic_vector((9 - 1) downto 0);
  signal unregy_join_6_1: std_logic_vector((9 - 1) downto 0);
begin
  sel_1_20 <= sel;
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_1_20)
  is
  begin
    case sel_1_20 is 
      when "0" =>
        unregy_join_6_1 <= d0_1_24;
      when others =>
        unregy_join_6_1 <= d1_1_27;
    end case;
  end process proc_switch_6_1;
  y <= unregy_join_6_1;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_62c4475a80 is
  port (
    in0 : in std_logic_vector((32 - 1) downto 0);
    in1 : in std_logic_vector((32 - 1) downto 0);
    y : out std_logic_vector((64 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_62c4475a80;


architecture behavior of concat_62c4475a80 is
  signal in0_1_23: unsigned((32 - 1) downto 0);
  signal in1_1_27: unsigned((32 - 1) downto 0);
  signal y_2_1_concat: unsigned((64 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_9a13f6a2a0 is
  port (
    input_port : in std_logic_vector((64 - 1) downto 0);
    output_port : out std_logic_vector((64 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_9a13f6a2a0;


architecture behavior of reinterpret_9a13f6a2a0 is
  signal input_port_1_40: unsigned((64 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port <= unsigned_to_std_logic_vector(input_port_1_40);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_09771002d6 is
  port (
    d : in std_logic_vector((9 - 1) downto 0);
    q : out std_logic_vector((9 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_09771002d6;


architecture behavior of delay_09771002d6 is
  signal d_1_22: std_logic_vector((9 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (1 - 1)) of std_logic_vector((9 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    0 => "000000000");
  signal op_mem_20_24_front_din: std_logic_vector((9 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((9 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(0);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_b0553f3acc is
  port (
    input_port : in std_logic_vector((48 - 1) downto 0);
    output_port : out std_logic_vector((48 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_b0553f3acc;


architecture behavior of reinterpret_b0553f3acc is
  signal input_port_1_40: unsigned((48 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port <= unsigned_to_std_logic_vector(input_port_1_40);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_c50603e098 is
  port (
    op : out std_logic_vector((28 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_c50603e098;


architecture behavior of constant_c50603e098 is
begin
  op <= "1011111010111100001000000000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_32693f9bda is
  port (
    op : out std_logic_vector((28 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_32693f9bda;


architecture behavior of constant_32693f9bda is
begin
  op <= "1110111001101011001010110010";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity logical_444d3f5046 is
  port (
    d0 : in std_logic_vector((1 - 1) downto 0);
    d1 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end logical_444d3f5046;


architecture behavior of logical_444d3f5046 is
  signal d0_1_24: std_logic;
  signal d1_1_27: std_logic;
  type array_type_latency_pipe_5_26 is array (0 to (1 - 1)) of std_logic;
  signal latency_pipe_5_26: array_type_latency_pipe_5_26 := (
    0 => '0');
  signal latency_pipe_5_26_front_din: std_logic;
  signal latency_pipe_5_26_back: std_logic;
  signal latency_pipe_5_26_push_front_pop_back_en: std_logic;
  signal fully_2_1_bit: std_logic;
begin
  d0_1_24 <= d0(0);
  d1_1_27 <= d1(0);
  latency_pipe_5_26_back <= latency_pipe_5_26(0);
  proc_latency_pipe_5_26: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (latency_pipe_5_26_push_front_pop_back_en = '1')) then
        latency_pipe_5_26(0) <= latency_pipe_5_26_front_din;
      end if;
    end if;
  end process proc_latency_pipe_5_26;
  fully_2_1_bit <= d0_1_24 or d1_1_27;
  latency_pipe_5_26_front_din <= fully_2_1_bit;
  latency_pipe_5_26_push_front_pop_back_en <= '1';
  y <= std_logic_to_vector(latency_pipe_5_26_back);
end behavior;


-------------------------------------------------------------------
-- System Generator version 14.3 VHDL source file.
--
-- Copyright(C) 2012 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2012 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
-- synopsys translate_off
library XilinxCoreLib;
-- synopsys translate_on
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use work.conv_pkg.all;
entity xlmult_darkquad29 is
  generic (
    core_name0: string := "";
    a_width: integer := 4;
    a_bin_pt: integer := 2;
    a_arith: integer := xlSigned;
    b_width: integer := 4;
    b_bin_pt: integer := 1;
    b_arith: integer := xlSigned;
    p_width: integer := 8;
    p_bin_pt: integer := 2;
    p_arith: integer := xlSigned;
    rst_width: integer := 1;
    rst_bin_pt: integer := 0;
    rst_arith: integer := xlUnsigned;
    en_width: integer := 1;
    en_bin_pt: integer := 0;
    en_arith: integer := xlUnsigned;
    quantization: integer := xlTruncate;
    overflow: integer := xlWrap;
    extra_registers: integer := 0;
    c_a_width: integer := 7;
    c_b_width: integer := 7;
    c_type: integer := 0;
    c_a_type: integer := 0;
    c_b_type: integer := 0;
    c_pipelined: integer := 1;
    c_baat: integer := 4;
    multsign: integer := xlSigned;
    c_output_width: integer := 16
  );
  port (
    a: in std_logic_vector(a_width - 1 downto 0);
    b: in std_logic_vector(b_width - 1 downto 0);
    ce: in std_logic;
    clr: in std_logic;
    clk: in std_logic;
    core_ce: in std_logic := '0';
    core_clr: in std_logic := '0';
    core_clk: in std_logic := '0';
    rst: in std_logic_vector(rst_width - 1 downto 0);
    en: in std_logic_vector(en_width - 1 downto 0);
    p: out std_logic_vector(p_width - 1 downto 0)
  );
end xlmult_darkquad29;
architecture behavior of xlmult_darkquad29 is
  component synth_reg
    generic (
      width: integer := 16;
      latency: integer := 5
    );
    port (
      i: in std_logic_vector(width - 1 downto 0);
      ce: in std_logic;
      clr: in std_logic;
      clk: in std_logic;
      o: out std_logic_vector(width - 1 downto 0)
    );
  end component;
  component mult_11_2_bcc54b656f5ca805
    port (
      b: in std_logic_vector(c_b_width - 1 downto 0);
      p: out std_logic_vector(c_output_width - 1 downto 0);
      clk: in std_logic;
      ce: in std_logic;
      sclr: in std_logic;
      a: in std_logic_vector(c_a_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of mult_11_2_bcc54b656f5ca805:
    component is true;
  attribute fpga_dont_touch of mult_11_2_bcc54b656f5ca805:
    component is "true";
  attribute box_type of mult_11_2_bcc54b656f5ca805:
    component  is "black_box";
  component mult_11_2_d3611e41a47815a8
    port (
      b: in std_logic_vector(c_b_width - 1 downto 0);
      p: out std_logic_vector(c_output_width - 1 downto 0);
      clk: in std_logic;
      ce: in std_logic;
      sclr: in std_logic;
      a: in std_logic_vector(c_a_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of mult_11_2_d3611e41a47815a8:
    component is true;
  attribute fpga_dont_touch of mult_11_2_d3611e41a47815a8:
    component is "true";
  attribute box_type of mult_11_2_d3611e41a47815a8:
    component  is "black_box";
  component mult_11_2_0d4e928dcde39e83
    port (
      b: in std_logic_vector(c_b_width - 1 downto 0);
      p: out std_logic_vector(c_output_width - 1 downto 0);
      clk: in std_logic;
      ce: in std_logic;
      sclr: in std_logic;
      a: in std_logic_vector(c_a_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of mult_11_2_0d4e928dcde39e83:
    component is true;
  attribute fpga_dont_touch of mult_11_2_0d4e928dcde39e83:
    component is "true";
  attribute box_type of mult_11_2_0d4e928dcde39e83:
    component  is "black_box";
  component mult_11_2_645200e4043096c0
    port (
      b: in std_logic_vector(c_b_width - 1 downto 0);
      p: out std_logic_vector(c_output_width - 1 downto 0);
      clk: in std_logic;
      ce: in std_logic;
      sclr: in std_logic;
      a: in std_logic_vector(c_a_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of mult_11_2_645200e4043096c0:
    component is true;
  attribute fpga_dont_touch of mult_11_2_645200e4043096c0:
    component is "true";
  attribute box_type of mult_11_2_645200e4043096c0:
    component  is "black_box";
  component mult_11_2_025f89b693a36f98
    port (
      b: in std_logic_vector(c_b_width - 1 downto 0);
      p: out std_logic_vector(c_output_width - 1 downto 0);
      clk: in std_logic;
      ce: in std_logic;
      sclr: in std_logic;
      a: in std_logic_vector(c_a_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of mult_11_2_025f89b693a36f98:
    component is true;
  attribute fpga_dont_touch of mult_11_2_025f89b693a36f98:
    component is "true";
  attribute box_type of mult_11_2_025f89b693a36f98:
    component  is "black_box";
  component mult_11_2_603515128dc5baa2
    port (
      b: in std_logic_vector(c_b_width - 1 downto 0);
      p: out std_logic_vector(c_output_width - 1 downto 0);
      clk: in std_logic;
      ce: in std_logic;
      sclr: in std_logic;
      a: in std_logic_vector(c_a_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of mult_11_2_603515128dc5baa2:
    component is true;
  attribute fpga_dont_touch of mult_11_2_603515128dc5baa2:
    component is "true";
  attribute box_type of mult_11_2_603515128dc5baa2:
    component  is "black_box";
  signal tmp_a: std_logic_vector(c_a_width - 1 downto 0);
  signal conv_a: std_logic_vector(c_a_width - 1 downto 0);
  signal tmp_b: std_logic_vector(c_b_width - 1 downto 0);
  signal conv_b: std_logic_vector(c_b_width - 1 downto 0);
  signal tmp_p: std_logic_vector(c_output_width - 1 downto 0);
  signal conv_p: std_logic_vector(p_width - 1 downto 0);
  -- synopsys translate_off
  signal real_a, real_b, real_p: real;
  -- synopsys translate_on
  signal rfd: std_logic;
  signal rdy: std_logic;
  signal nd: std_logic;
  signal internal_ce: std_logic;
  signal internal_clr: std_logic;
  signal internal_core_ce: std_logic;
begin
-- synopsys translate_off
-- synopsys translate_on
  internal_ce <= ce and en(0);
  internal_core_ce <= core_ce and en(0);
  internal_clr <= (clr or rst(0)) and ce;
  nd <= internal_ce;
  input_process:  process (a,b)
  begin
    tmp_a <= zero_ext(a, c_a_width);
    tmp_b <= zero_ext(b, c_b_width);
  end process;
  output_process: process (tmp_p)
  begin
    conv_p <= convert_type(tmp_p, c_output_width, a_bin_pt+b_bin_pt, multsign,
                           p_width, p_bin_pt, p_arith, quantization, overflow);
  end process;
  comp0: if ((core_name0 = "mult_11_2_bcc54b656f5ca805")) generate
    core_instance0: mult_11_2_bcc54b656f5ca805
      port map (
        a => tmp_a,
        clk => clk,
        ce => internal_ce,
        sclr => internal_clr,
        p => tmp_p,
        b => tmp_b
      );
  end generate;
  comp1: if ((core_name0 = "mult_11_2_d3611e41a47815a8")) generate
    core_instance1: mult_11_2_d3611e41a47815a8
      port map (
        a => tmp_a,
        clk => clk,
        ce => internal_ce,
        sclr => internal_clr,
        p => tmp_p,
        b => tmp_b
      );
  end generate;
  comp2: if ((core_name0 = "mult_11_2_0d4e928dcde39e83")) generate
    core_instance2: mult_11_2_0d4e928dcde39e83
      port map (
        a => tmp_a,
        clk => clk,
        ce => internal_ce,
        sclr => internal_clr,
        p => tmp_p,
        b => tmp_b
      );
  end generate;
  comp3: if ((core_name0 = "mult_11_2_645200e4043096c0")) generate
    core_instance3: mult_11_2_645200e4043096c0
      port map (
        a => tmp_a,
        clk => clk,
        ce => internal_ce,
        sclr => internal_clr,
        p => tmp_p,
        b => tmp_b
      );
  end generate;
  comp4: if ((core_name0 = "mult_11_2_025f89b693a36f98")) generate
    core_instance4: mult_11_2_025f89b693a36f98
      port map (
        a => tmp_a,
        clk => clk,
        ce => internal_ce,
        sclr => internal_clr,
        p => tmp_p,
        b => tmp_b
      );
  end generate;
  comp5: if ((core_name0 = "mult_11_2_603515128dc5baa2")) generate
    core_instance5: mult_11_2_603515128dc5baa2
      port map (
        a => tmp_a,
        clk => clk,
        ce => internal_ce,
        sclr => internal_clr,
        p => tmp_p,
        b => tmp_b
      );
  end generate;
  latency_gt_0: if (extra_registers > 0) generate
    reg: synth_reg
      generic map (
        width => p_width,
        latency => extra_registers
      )
      port map (
        i => conv_p,
        ce => internal_ce,
        clr => internal_clr,
        clk => clk,
        o => p
      );
  end generate;
  latency_eq_0: if (extra_registers = 0) generate
    p <= conv_p;
  end generate;
end architecture behavior;
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_8f5500aea5 is
  port (
    input_port : in std_logic_vector((12 - 1) downto 0);
    output_port : out std_logic_vector((12 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_8f5500aea5;


architecture behavior of reinterpret_8f5500aea5 is
  signal input_port_1_40: unsigned((12 - 1) downto 0);
  signal output_port_5_5_force: signed((12 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port_5_5_force <= unsigned_to_signed(input_port_1_40);
  output_port <= signed_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_edc0a9c61c is
  port (
    a : in std_logic_vector((28 - 1) downto 0);
    b : in std_logic_vector((28 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_edc0a9c61c;


architecture behavior of relational_edc0a9c61c is
  signal a_1_31: unsigned((28 - 1) downto 0);
  signal b_1_34: unsigned((28 - 1) downto 0);
  signal result_16_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  result_16_3_rel <= a_1_31 < b_1_34;
  op <= boolean_to_vector(result_16_3_rel);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_e4a0188a91 is
  port (
    a : in std_logic_vector((28 - 1) downto 0);
    b : in std_logic_vector((28 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_e4a0188a91;


architecture behavior of relational_e4a0188a91 is
  signal a_1_31: unsigned((28 - 1) downto 0);
  signal b_1_34: unsigned((28 - 1) downto 0);
  type array_type_op_mem_32_22 is array (0 to (1 - 1)) of boolean;
  signal op_mem_32_22: array_type_op_mem_32_22 := (
    0 => false);
  signal op_mem_32_22_front_din: boolean;
  signal op_mem_32_22_back: boolean;
  signal op_mem_32_22_push_front_pop_back_en: std_logic;
  signal result_22_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  op_mem_32_22_back <= op_mem_32_22(0);
  proc_op_mem_32_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_32_22_push_front_pop_back_en = '1')) then
        op_mem_32_22(0) <= op_mem_32_22_front_din;
      end if;
    end if;
  end process proc_op_mem_32_22;
  result_22_3_rel <= a_1_31 >= b_1_34;
  op_mem_32_22_front_din <= result_22_3_rel;
  op_mem_32_22_push_front_pop_back_en <= '1';
  op <= boolean_to_vector(op_mem_32_22_back);
end behavior;


-------------------------------------------------------------------
-- System Generator version 14.3 VHDL source file.
--
-- Copyright(C) 2012 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2012 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
-- synopsys translate_off
library XilinxCoreLib;
-- synopsys translate_on
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;
entity xlcounter_limit_darkquad29 is
  generic (
    core_name0: string := "";
    op_width: integer := 5;
    op_arith: integer := xlSigned;
    cnt_63_48: integer:= 0;
    cnt_47_32: integer:= 0;
    cnt_31_16: integer:= 0;
    cnt_15_0: integer:= 0;
    count_limited: integer := 0
  );
  port (
    ce: in std_logic;
    clr: in std_logic;
    clk: in std_logic;
    op: out std_logic_vector(op_width - 1 downto 0);
    up: in std_logic_vector(0 downto 0) := (others => '0');
    en: in std_logic_vector(0 downto 0);
    rst: in std_logic_vector(0 downto 0)
  );
end xlcounter_limit_darkquad29 ;
architecture behavior of xlcounter_limit_darkquad29 is
  signal high_cnt_to: std_logic_vector(31 downto 0);
  signal low_cnt_to: std_logic_vector(31 downto 0);
  signal cnt_to: std_logic_vector(63 downto 0);
  signal core_sinit, op_thresh0, core_ce: std_logic;
  signal rst_overrides_en: std_logic;
  signal op_net: std_logic_vector(op_width - 1 downto 0);
  -- synopsys translate_off
  signal real_op : real;
   -- synopsys translate_on
  function equals(op, cnt_to : std_logic_vector; width, arith : integer)
    return std_logic
  is
    variable signed_op, signed_cnt_to : signed (width - 1 downto 0);
    variable unsigned_op, unsigned_cnt_to : unsigned (width - 1 downto 0);
    variable result : std_logic;
  begin
    -- synopsys translate_off
    if ((is_XorU(op)) or (is_XorU(cnt_to)) ) then
      result := '0';
      return result;
    end if;
    -- synopsys translate_on
    if (op = cnt_to) then
      result := '1';
    else
      result := '0';
    end if;
    return result;
  end;
  component cntr_11_0_4d961a297cbb815e
    port (
      clk: in std_logic;
      ce: in std_logic;
      SCLR: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of cntr_11_0_4d961a297cbb815e:
    component is true;
  attribute fpga_dont_touch of cntr_11_0_4d961a297cbb815e:
    component is "true";
  attribute box_type of cntr_11_0_4d961a297cbb815e:
    component  is "black_box";
  component cntr_11_0_d1eeca027ba03819
    port (
      clk: in std_logic;
      ce: in std_logic;
      SCLR: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of cntr_11_0_d1eeca027ba03819:
    component is true;
  attribute fpga_dont_touch of cntr_11_0_d1eeca027ba03819:
    component is "true";
  attribute box_type of cntr_11_0_d1eeca027ba03819:
    component  is "black_box";
  component cntr_11_0_ca10e447a1c1c04f
    port (
      clk: in std_logic;
      ce: in std_logic;
      SCLR: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of cntr_11_0_ca10e447a1c1c04f:
    component is true;
  attribute fpga_dont_touch of cntr_11_0_ca10e447a1c1c04f:
    component is "true";
  attribute box_type of cntr_11_0_ca10e447a1c1c04f:
    component  is "black_box";
  component cntr_11_0_564d43d07a40ef72
    port (
      clk: in std_logic;
      ce: in std_logic;
      SINIT: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of cntr_11_0_564d43d07a40ef72:
    component is true;
  attribute fpga_dont_touch of cntr_11_0_564d43d07a40ef72:
    component is "true";
  attribute box_type of cntr_11_0_564d43d07a40ef72:
    component  is "black_box";
  component cntr_11_0_0e7aae3b0f9694f8
    port (
      clk: in std_logic;
      ce: in std_logic;
      SCLR: in std_logic;
      q: out std_logic_vector(op_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of cntr_11_0_0e7aae3b0f9694f8:
    component is true;
  attribute fpga_dont_touch of cntr_11_0_0e7aae3b0f9694f8:
    component is "true";
  attribute box_type of cntr_11_0_0e7aae3b0f9694f8:
    component  is "black_box";
-- synopsys translate_off
  constant zeroVec : std_logic_vector(op_width - 1 downto 0) := (others => '0');
  constant oneVec : std_logic_vector(op_width - 1 downto 0) := (others => '1');
  constant zeroStr : string(1 to op_width) :=
    std_logic_vector_to_bin_string(zeroVec);
  constant oneStr : string(1 to op_width) :=
    std_logic_vector_to_bin_string(oneVec);
-- synopsys translate_on
begin
  -- synopsys translate_off
  -- synopsys translate_on
  cnt_to(63 downto 48) <= integer_to_std_logic_vector(cnt_63_48, 16, op_arith);
  cnt_to(47 downto 32) <= integer_to_std_logic_vector(cnt_47_32, 16, op_arith);
  cnt_to(31 downto 16) <= integer_to_std_logic_vector(cnt_31_16, 16, op_arith);
  cnt_to(15 downto 0) <= integer_to_std_logic_vector(cnt_15_0, 16, op_arith);
  op <= op_net;
  core_ce <= ce and en(0);
  rst_overrides_en <= rst(0) or en(0);
  limit : if (count_limited = 1) generate
    eq_cnt_to : process (op_net, cnt_to)
    begin
      op_thresh0 <= equals(op_net, cnt_to(op_width - 1 downto 0),
                     op_width, op_arith);
    end process;
    core_sinit <= (op_thresh0 or clr or rst(0)) and ce and rst_overrides_en;
  end generate;
  no_limit : if (count_limited = 0) generate
    core_sinit <= (clr or rst(0)) and ce and rst_overrides_en;
  end generate;
  comp0: if ((core_name0 = "cntr_11_0_4d961a297cbb815e")) generate
    core_instance0: cntr_11_0_4d961a297cbb815e
      port map (
        clk => clk,
        ce => core_ce,
        SCLR => core_sinit,
        q => op_net
      );
  end generate;
  comp1: if ((core_name0 = "cntr_11_0_d1eeca027ba03819")) generate
    core_instance1: cntr_11_0_d1eeca027ba03819
      port map (
        clk => clk,
        ce => core_ce,
        SCLR => core_sinit,
        q => op_net
      );
  end generate;
  comp5: if ((core_name0 = "cntr_11_0_ca10e447a1c1c04f")) generate
    core_instance5: cntr_11_0_ca10e447a1c1c04f
      port map (
        clk => clk,
        ce => core_ce,
        SCLR => core_sinit,
        q => op_net
      );
  end generate;
  comp6: if ((core_name0 = "cntr_11_0_564d43d07a40ef72")) generate
    core_instance6: cntr_11_0_564d43d07a40ef72
      port map (
        clk => clk,
        ce => core_ce,
        SINIT => core_sinit,
        q => op_net
      );
  end generate;
  comp7: if ((core_name0 = "cntr_11_0_0e7aae3b0f9694f8")) generate
    core_instance7: cntr_11_0_0e7aae3b0f9694f8
      port map (
        clk => clk,
        ce => core_ce,
        SCLR => core_sinit,
        q => op_net
      );
  end generate;
end  behavior;
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_16dfebb8b2 is
  port (
    in0 : in std_logic_vector((64 - 1) downto 0);
    in1 : in std_logic_vector((64 - 1) downto 0);
    in2 : in std_logic_vector((64 - 1) downto 0);
    in3 : in std_logic_vector((64 - 1) downto 0);
    in4 : in std_logic_vector((20 - 1) downto 0);
    y : out std_logic_vector((276 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_16dfebb8b2;


architecture behavior of concat_16dfebb8b2 is
  signal in0_1_23: unsigned((64 - 1) downto 0);
  signal in1_1_27: unsigned((64 - 1) downto 0);
  signal in2_1_31: unsigned((64 - 1) downto 0);
  signal in3_1_35: unsigned((64 - 1) downto 0);
  signal in4_1_39: unsigned((20 - 1) downto 0);
  signal y_2_1_concat: unsigned((276 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  in2_1_31 <= std_logic_vector_to_unsigned(in2);
  in3_1_35 <= std_logic_vector_to_unsigned(in3);
  in4_1_39 <= std_logic_vector_to_unsigned(in4);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27) & unsigned_to_std_logic_vector(in2_1_31) & unsigned_to_std_logic_vector(in3_1_35) & unsigned_to_std_logic_vector(in4_1_39));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_713b6c5d29 is
  port (
    input_port : in std_logic_vector((20 - 1) downto 0);
    output_port : out std_logic_vector((20 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_713b6c5d29;


architecture behavior of reinterpret_713b6c5d29 is
  signal input_port_1_40: unsigned((20 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port <= unsigned_to_std_logic_vector(input_port_1_40);
end behavior;


-------------------------------------------------------------------
-- System Generator version 14.3 VHDL source file.
--
-- Copyright(C) 2012 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2012 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity xlspram_darkquad29 is
  generic (
    core_name0: string := "";
    c_width: integer := 12;
    c_address_width: integer := 4;
    latency: integer := 1
    );
  port (
    data_in: in std_logic_vector(c_width - 1 downto 0);
    addr: in std_logic_vector(c_address_width - 1 downto 0);
    we: in std_logic_vector(0 downto 0);
    en: in std_logic_vector(0 downto 0);
    rst: in std_logic_vector(0 downto 0);
    ce: in std_logic;
    clk: in std_logic;
    data_out: out std_logic_vector(c_width - 1 downto 0)
  );
end xlspram_darkquad29 ;
architecture behavior of xlspram_darkquad29 is
  component synth_reg
    generic (
      width: integer;
      latency: integer
    );
    port (
      i: in std_logic_vector(width - 1 downto 0);
      ce: in std_logic;
      clr: in std_logic;
      clk: in std_logic;
      o: out std_logic_vector(width - 1 downto 0)
    );
  end component;
  signal core_data_out, dly_data_out: std_logic_vector(c_width - 1 downto 0);
  signal core_we, core_ce, sinit: std_logic;
  component bmg_72_5886869123e35b2f
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      dina: in std_logic_vector(c_width - 1 downto 0);
      wea: in std_logic_vector(0 downto 0);
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of bmg_72_5886869123e35b2f:
    component is true;
  attribute fpga_dont_touch of bmg_72_5886869123e35b2f:
    component is "true";
  attribute box_type of bmg_72_5886869123e35b2f:
    component  is "black_box";
  component bmg_72_ccc293fe4d2b0f7a
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      dina: in std_logic_vector(c_width - 1 downto 0);
      wea: in std_logic_vector(0 downto 0);
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of bmg_72_ccc293fe4d2b0f7a:
    component is true;
  attribute fpga_dont_touch of bmg_72_ccc293fe4d2b0f7a:
    component is "true";
  attribute box_type of bmg_72_ccc293fe4d2b0f7a:
    component  is "black_box";
  component bmg_72_ee57e7186689376a
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      dina: in std_logic_vector(c_width - 1 downto 0);
      wea: in std_logic_vector(0 downto 0);
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of bmg_72_ee57e7186689376a:
    component is true;
  attribute fpga_dont_touch of bmg_72_ee57e7186689376a:
    component is "true";
  attribute box_type of bmg_72_ee57e7186689376a:
    component  is "black_box";
  component bmg_72_79627314d23ed512
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      dina: in std_logic_vector(c_width - 1 downto 0);
      wea: in std_logic_vector(0 downto 0);
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of bmg_72_79627314d23ed512:
    component is true;
  attribute fpga_dont_touch of bmg_72_79627314d23ed512:
    component is "true";
  attribute box_type of bmg_72_79627314d23ed512:
    component  is "black_box";
  component bmg_72_6496c8c9773931f5
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      dina: in std_logic_vector(c_width - 1 downto 0);
      wea: in std_logic_vector(0 downto 0);
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of bmg_72_6496c8c9773931f5:
    component is true;
  attribute fpga_dont_touch of bmg_72_6496c8c9773931f5:
    component is "true";
  attribute box_type of bmg_72_6496c8c9773931f5:
    component  is "black_box";
  component bmg_72_b851979848828b10
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      dina: in std_logic_vector(c_width - 1 downto 0);
      wea: in std_logic_vector(0 downto 0);
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of bmg_72_b851979848828b10:
    component is true;
  attribute fpga_dont_touch of bmg_72_b851979848828b10:
    component is "true";
  attribute box_type of bmg_72_b851979848828b10:
    component  is "black_box";
  component bmg_72_c89b8e32d1739de7
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      dina: in std_logic_vector(c_width - 1 downto 0);
      wea: in std_logic_vector(0 downto 0);
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of bmg_72_c89b8e32d1739de7:
    component is true;
  attribute fpga_dont_touch of bmg_72_c89b8e32d1739de7:
    component is "true";
  attribute box_type of bmg_72_c89b8e32d1739de7:
    component  is "black_box";
  component bmg_72_0164249481f978ca
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      dina: in std_logic_vector(c_width - 1 downto 0);
      wea: in std_logic_vector(0 downto 0);
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of bmg_72_0164249481f978ca:
    component is true;
  attribute fpga_dont_touch of bmg_72_0164249481f978ca:
    component is "true";
  attribute box_type of bmg_72_0164249481f978ca:
    component  is "black_box";
  component bmg_72_b40f882ae90aebcf
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      dina: in std_logic_vector(c_width - 1 downto 0);
      wea: in std_logic_vector(0 downto 0);
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of bmg_72_b40f882ae90aebcf:
    component is true;
  attribute fpga_dont_touch of bmg_72_b40f882ae90aebcf:
    component is "true";
  attribute box_type of bmg_72_b40f882ae90aebcf:
    component  is "black_box";
  component bmg_72_4ed81b7c7b802023
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      dina: in std_logic_vector(c_width - 1 downto 0);
      wea: in std_logic_vector(0 downto 0);
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of bmg_72_4ed81b7c7b802023:
    component is true;
  attribute fpga_dont_touch of bmg_72_4ed81b7c7b802023:
    component is "true";
  attribute box_type of bmg_72_4ed81b7c7b802023:
    component  is "black_box";
  component bmg_72_83f6efe890a72ff6
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      dina: in std_logic_vector(c_width - 1 downto 0);
      wea: in std_logic_vector(0 downto 0);
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of bmg_72_83f6efe890a72ff6:
    component is true;
  attribute fpga_dont_touch of bmg_72_83f6efe890a72ff6:
    component is "true";
  attribute box_type of bmg_72_83f6efe890a72ff6:
    component  is "black_box";
  component bmg_72_88f9a9ffe68f6b35
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      dina: in std_logic_vector(c_width - 1 downto 0);
      wea: in std_logic_vector(0 downto 0);
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of bmg_72_88f9a9ffe68f6b35:
    component is true;
  attribute fpga_dont_touch of bmg_72_88f9a9ffe68f6b35:
    component is "true";
  attribute box_type of bmg_72_88f9a9ffe68f6b35:
    component  is "black_box";
  component bmg_72_386cbab83765f0cd
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      dina: in std_logic_vector(c_width - 1 downto 0);
      wea: in std_logic_vector(0 downto 0);
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of bmg_72_386cbab83765f0cd:
    component is true;
  attribute fpga_dont_touch of bmg_72_386cbab83765f0cd:
    component is "true";
  attribute box_type of bmg_72_386cbab83765f0cd:
    component  is "black_box";
  component bmg_72_a5223615887f70b9
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      dina: in std_logic_vector(c_width - 1 downto 0);
      wea: in std_logic_vector(0 downto 0);
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of bmg_72_a5223615887f70b9:
    component is true;
  attribute fpga_dont_touch of bmg_72_a5223615887f70b9:
    component is "true";
  attribute box_type of bmg_72_a5223615887f70b9:
    component  is "black_box";
  component bmg_72_3b6e667e30cd6119
    port (
                              addra: in std_logic_vector(c_address_width - 1 downto 0);
      clka: in std_logic;
      dina: in std_logic_vector(c_width - 1 downto 0);
      wea: in std_logic_vector(0 downto 0);
      ena: in std_logic;
      douta: out std_logic_vector(c_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of bmg_72_3b6e667e30cd6119:
    component is true;
  attribute fpga_dont_touch of bmg_72_3b6e667e30cd6119:
    component is "true";
  attribute box_type of bmg_72_3b6e667e30cd6119:
    component  is "black_box";
begin
  data_out <= dly_data_out;
  core_we <= we(0);
  core_ce <= ce and en(0);
  sinit <= rst(0) and ce;
  comp0: if ((core_name0 = "bmg_72_5886869123e35b2f")) generate
    core_instance0: bmg_72_5886869123e35b2f
      port map (
                                        addra => addr,
        clka => clk,
        dina => data_in,
        wea(0) => core_we,
        ena => core_ce,
        douta => core_data_out
      );
  end generate;
  comp1: if ((core_name0 = "bmg_72_ccc293fe4d2b0f7a")) generate
    core_instance1: bmg_72_ccc293fe4d2b0f7a
      port map (
                                        addra => addr,
        clka => clk,
        dina => data_in,
        wea(0) => core_we,
        ena => core_ce,
        douta => core_data_out
      );
  end generate;
  comp2: if ((core_name0 = "bmg_72_ee57e7186689376a")) generate
    core_instance2: bmg_72_ee57e7186689376a
      port map (
                                        addra => addr,
        clka => clk,
        dina => data_in,
        wea(0) => core_we,
        ena => core_ce,
        douta => core_data_out
      );
  end generate;
  comp3: if ((core_name0 = "bmg_72_79627314d23ed512")) generate
    core_instance3: bmg_72_79627314d23ed512
      port map (
                                        addra => addr,
        clka => clk,
        dina => data_in,
        wea(0) => core_we,
        ena => core_ce,
        douta => core_data_out
      );
  end generate;
  comp4: if ((core_name0 = "bmg_72_6496c8c9773931f5")) generate
    core_instance4: bmg_72_6496c8c9773931f5
      port map (
                                        addra => addr,
        clka => clk,
        dina => data_in,
        wea(0) => core_we,
        ena => core_ce,
        douta => core_data_out
      );
  end generate;
  comp5: if ((core_name0 = "bmg_72_b851979848828b10")) generate
    core_instance5: bmg_72_b851979848828b10
      port map (
                                        addra => addr,
        clka => clk,
        dina => data_in,
        wea(0) => core_we,
        ena => core_ce,
        douta => core_data_out
      );
  end generate;
  comp6: if ((core_name0 = "bmg_72_c89b8e32d1739de7")) generate
    core_instance6: bmg_72_c89b8e32d1739de7
      port map (
                                        addra => addr,
        clka => clk,
        dina => data_in,
        wea(0) => core_we,
        ena => core_ce,
        douta => core_data_out
      );
  end generate;
  comp7: if ((core_name0 = "bmg_72_0164249481f978ca")) generate
    core_instance7: bmg_72_0164249481f978ca
      port map (
                                        addra => addr,
        clka => clk,
        dina => data_in,
        wea(0) => core_we,
        ena => core_ce,
        douta => core_data_out
      );
  end generate;
  comp8: if ((core_name0 = "bmg_72_b40f882ae90aebcf")) generate
    core_instance8: bmg_72_b40f882ae90aebcf
      port map (
                                        addra => addr,
        clka => clk,
        dina => data_in,
        wea(0) => core_we,
        ena => core_ce,
        douta => core_data_out
      );
  end generate;
  comp9: if ((core_name0 = "bmg_72_4ed81b7c7b802023")) generate
    core_instance9: bmg_72_4ed81b7c7b802023
      port map (
                                        addra => addr,
        clka => clk,
        dina => data_in,
        wea(0) => core_we,
        ena => core_ce,
        douta => core_data_out
      );
  end generate;
  comp10: if ((core_name0 = "bmg_72_83f6efe890a72ff6")) generate
    core_instance10: bmg_72_83f6efe890a72ff6
      port map (
                                        addra => addr,
        clka => clk,
        dina => data_in,
        wea(0) => core_we,
        ena => core_ce,
        douta => core_data_out
      );
  end generate;
  comp11: if ((core_name0 = "bmg_72_88f9a9ffe68f6b35")) generate
    core_instance11: bmg_72_88f9a9ffe68f6b35
      port map (
                                        addra => addr,
        clka => clk,
        dina => data_in,
        wea(0) => core_we,
        ena => core_ce,
        douta => core_data_out
      );
  end generate;
  comp12: if ((core_name0 = "bmg_72_386cbab83765f0cd")) generate
    core_instance12: bmg_72_386cbab83765f0cd
      port map (
                                        addra => addr,
        clka => clk,
        dina => data_in,
        wea(0) => core_we,
        ena => core_ce,
        douta => core_data_out
      );
  end generate;
  comp13: if ((core_name0 = "bmg_72_a5223615887f70b9")) generate
    core_instance13: bmg_72_a5223615887f70b9
      port map (
                                        addra => addr,
        clka => clk,
        dina => data_in,
        wea(0) => core_we,
        ena => core_ce,
        douta => core_data_out
      );
  end generate;
  comp14: if ((core_name0 = "bmg_72_3b6e667e30cd6119")) generate
    core_instance14: bmg_72_3b6e667e30cd6119
      port map (
                                        addra => addr,
        clka => clk,
        dina => data_in,
        wea(0) => core_we,
        ena => core_ce,
        douta => core_data_out
      );
  end generate;
  latency_test: if (latency > 1) generate
    reg: synth_reg
      generic map (
        width => c_width,
        latency => latency - 1
      )
      port map (
        i => core_data_out,
        ce => core_ce,
        clr => '0',
        clk => clk,
        o => dly_data_out
      );
  end generate;
  latency_1: if (latency <= 1) generate
    dly_data_out <= core_data_out;
  end generate;
end behavior;
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity logical_3f28e1f762 is
  port (
    d0 : in std_logic_vector((1 - 1) downto 0);
    d1 : in std_logic_vector((1 - 1) downto 0);
    d2 : in std_logic_vector((1 - 1) downto 0);
    d3 : in std_logic_vector((1 - 1) downto 0);
    d4 : in std_logic_vector((1 - 1) downto 0);
    d5 : in std_logic_vector((1 - 1) downto 0);
    d6 : in std_logic_vector((1 - 1) downto 0);
    d7 : in std_logic_vector((1 - 1) downto 0);
    d8 : in std_logic_vector((1 - 1) downto 0);
    d9 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end logical_3f28e1f762;


architecture behavior of logical_3f28e1f762 is
  signal d0_1_24: std_logic;
  signal d1_1_27: std_logic;
  signal d2_1_30: std_logic;
  signal d3_1_33: std_logic;
  signal d4_1_36: std_logic;
  signal d5_1_39: std_logic;
  signal d6_1_42: std_logic;
  signal d7_1_45: std_logic;
  signal d8_1_48: std_logic;
  signal d9_1_51: std_logic;
  type array_type_latency_pipe_5_26 is array (0 to (1 - 1)) of std_logic;
  signal latency_pipe_5_26: array_type_latency_pipe_5_26 := (
    0 => '0');
  signal latency_pipe_5_26_front_din: std_logic;
  signal latency_pipe_5_26_back: std_logic;
  signal latency_pipe_5_26_push_front_pop_back_en: std_logic;
  signal bit_2_26: std_logic;
  signal fully_2_1_bitnot: std_logic;
begin
  d0_1_24 <= d0(0);
  d1_1_27 <= d1(0);
  d2_1_30 <= d2(0);
  d3_1_33 <= d3(0);
  d4_1_36 <= d4(0);
  d5_1_39 <= d5(0);
  d6_1_42 <= d6(0);
  d7_1_45 <= d7(0);
  d8_1_48 <= d8(0);
  d9_1_51 <= d9(0);
  latency_pipe_5_26_back <= latency_pipe_5_26(0);
  proc_latency_pipe_5_26: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (latency_pipe_5_26_push_front_pop_back_en = '1')) then
        latency_pipe_5_26(0) <= latency_pipe_5_26_front_din;
      end if;
    end if;
  end process proc_latency_pipe_5_26;
  bit_2_26 <= d0_1_24 or d1_1_27 or d2_1_30 or d3_1_33 or d4_1_36 or d5_1_39 or d6_1_42 or d7_1_45 or d8_1_48 or d9_1_51;
  fully_2_1_bitnot <= not bit_2_26;
  latency_pipe_5_26_front_din <= fully_2_1_bitnot;
  latency_pipe_5_26_push_front_pop_back_en <= '1';
  y <= std_logic_to_vector(latency_pipe_5_26_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_0c8736a503 is
  port (
    op : out std_logic_vector((13 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_0c8736a503;


architecture behavior of constant_0c8736a503 is
begin
  op <= "0000000000000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_50be3b5040 is
  port (
    op : out std_logic_vector((13 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_50be3b5040;


architecture behavior of constant_50be3b5040 is
begin
  op <= "0000000000001";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_be3fbaeea3 is
  port (
    d : in std_logic_vector((1 - 1) downto 0);
    q : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_be3fbaeea3;


architecture behavior of delay_be3fbaeea3 is
  signal d_1_22: std_logic;
  type array_type_op_mem_20_24 is array (0 to (250 - 1)) of std_logic;
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0');
  signal op_mem_20_24_front_din: std_logic;
  signal op_mem_20_24_back: std_logic;
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d(0);
  op_mem_20_24_back <= op_mem_20_24(249);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 249 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= std_logic_to_vector(op_mem_20_24_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity logical_4239a88767 is
  port (
    d0 : in std_logic_vector((1 - 1) downto 0);
    d1 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end logical_4239a88767;


architecture behavior of logical_4239a88767 is
  signal d0_1_24: std_logic;
  signal d1_1_27: std_logic;
  type array_type_latency_pipe_5_26 is array (0 to (3 - 1)) of std_logic;
  signal latency_pipe_5_26: array_type_latency_pipe_5_26 := (
    '0',
    '0',
    '0');
  signal latency_pipe_5_26_front_din: std_logic;
  signal latency_pipe_5_26_back: std_logic;
  signal latency_pipe_5_26_push_front_pop_back_en: std_logic;
  signal fully_2_1_bit: std_logic;
begin
  d0_1_24 <= d0(0);
  d1_1_27 <= d1(0);
  latency_pipe_5_26_back <= latency_pipe_5_26(2);
  proc_latency_pipe_5_26: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (latency_pipe_5_26_push_front_pop_back_en = '1')) then
        for i in 2 downto 1 loop 
          latency_pipe_5_26(i) <= latency_pipe_5_26(i-1);
        end loop;
        latency_pipe_5_26(0) <= latency_pipe_5_26_front_din;
      end if;
    end if;
  end process proc_latency_pipe_5_26;
  fully_2_1_bit <= d0_1_24 and d1_1_27;
  latency_pipe_5_26_front_din <= fully_2_1_bit;
  latency_pipe_5_26_push_front_pop_back_en <= '1';
  y <= std_logic_to_vector(latency_pipe_5_26_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_7fc381b8fa is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((13 - 1) downto 0);
    d1 : in std_logic_vector((13 - 1) downto 0);
    y : out std_logic_vector((13 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_7fc381b8fa;


architecture behavior of mux_7fc381b8fa is
  signal sel_1_20: std_logic;
  signal d0_1_24: std_logic_vector((13 - 1) downto 0);
  signal d1_1_27: std_logic_vector((13 - 1) downto 0);
  type array_type_pipe_16_22 is array (0 to (1 - 1)) of std_logic_vector((13 - 1) downto 0);
  signal pipe_16_22: array_type_pipe_16_22 := (
    0 => "0000000000000");
  signal pipe_16_22_front_din: std_logic_vector((13 - 1) downto 0);
  signal pipe_16_22_back: std_logic_vector((13 - 1) downto 0);
  signal pipe_16_22_push_front_pop_back_en: std_logic;
  signal sel_internal_2_1_convert: std_logic_vector((1 - 1) downto 0);
  signal unregy_join_6_1: std_logic_vector((13 - 1) downto 0);
begin
  sel_1_20 <= sel(0);
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  pipe_16_22_back <= pipe_16_22(0);
  proc_pipe_16_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (pipe_16_22_push_front_pop_back_en = '1')) then
        pipe_16_22(0) <= pipe_16_22_front_din;
      end if;
    end if;
  end process proc_pipe_16_22;
  sel_internal_2_1_convert <= cast(std_logic_to_vector(sel_1_20), 0, 1, 0, xlUnsigned);
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_internal_2_1_convert)
  is
  begin
    case sel_internal_2_1_convert is 
      when "0" =>
        unregy_join_6_1 <= d0_1_24;
      when others =>
        unregy_join_6_1 <= d1_1_27;
    end case;
  end process proc_switch_6_1;
  pipe_16_22_front_din <= unregy_join_6_1;
  pipe_16_22_push_front_pop_back_en <= '1';
  y <= pipe_16_22_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_0ce8e2557d is
  port (
    a : in std_logic_vector((13 - 1) downto 0);
    b : in std_logic_vector((15 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_0ce8e2557d;


architecture behavior of relational_0ce8e2557d is
  signal a_1_31: unsigned((13 - 1) downto 0);
  signal b_1_34: unsigned((15 - 1) downto 0);
  type array_type_op_mem_32_22 is array (0 to (1 - 1)) of boolean;
  signal op_mem_32_22: array_type_op_mem_32_22 := (
    0 => false);
  signal op_mem_32_22_front_din: boolean;
  signal op_mem_32_22_back: boolean;
  signal op_mem_32_22_push_front_pop_back_en: std_logic;
  signal cast_20_12: unsigned((15 - 1) downto 0);
  signal result_20_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  op_mem_32_22_back <= op_mem_32_22(0);
  proc_op_mem_32_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_32_22_push_front_pop_back_en = '1')) then
        op_mem_32_22(0) <= op_mem_32_22_front_din;
      end if;
    end if;
  end process proc_op_mem_32_22;
  cast_20_12 <= u2u_cast(a_1_31, 0, 15, 0);
  result_20_3_rel <= cast_20_12 <= b_1_34;
  op_mem_32_22_front_din <= result_20_3_rel;
  op_mem_32_22_push_front_pop_back_en <= '1';
  op <= boolean_to_vector(op_mem_32_22_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_7093fd32f4 is
  port (
    input_port : in std_logic_vector((10 - 1) downto 0);
    output_port : out std_logic_vector((10 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_7093fd32f4;


architecture behavior of reinterpret_7093fd32f4 is
  signal input_port_1_40: unsigned((10 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port <= unsigned_to_std_logic_vector(input_port_1_40);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_fd28b32bf8 is
  port (
    op : out std_logic_vector((12 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_fd28b32bf8;


architecture behavior of constant_fd28b32bf8 is
begin
  op <= "000000000000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_ac4da3a0cc is
  port (
    op : out std_logic_vector((8 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_ac4da3a0cc;


architecture behavior of constant_ac4da3a0cc is
begin
  op <= "00001001";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity logical_ef735095f8 is
  port (
    d0 : in std_logic_vector((1 - 1) downto 0);
    d1 : in std_logic_vector((1 - 1) downto 0);
    d2 : in std_logic_vector((1 - 1) downto 0);
    d3 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end logical_ef735095f8;


architecture behavior of logical_ef735095f8 is
  signal d0_1_24: std_logic;
  signal d1_1_27: std_logic;
  signal d2_1_30: std_logic;
  signal d3_1_33: std_logic;
  type array_type_latency_pipe_5_26 is array (0 to (1 - 1)) of std_logic;
  signal latency_pipe_5_26: array_type_latency_pipe_5_26 := (
    0 => '0');
  signal latency_pipe_5_26_front_din: std_logic;
  signal latency_pipe_5_26_back: std_logic;
  signal latency_pipe_5_26_push_front_pop_back_en: std_logic;
  signal fully_2_1_bit: std_logic;
begin
  d0_1_24 <= d0(0);
  d1_1_27 <= d1(0);
  d2_1_30 <= d2(0);
  d3_1_33 <= d3(0);
  latency_pipe_5_26_back <= latency_pipe_5_26(0);
  proc_latency_pipe_5_26: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (latency_pipe_5_26_push_front_pop_back_en = '1')) then
        latency_pipe_5_26(0) <= latency_pipe_5_26_front_din;
      end if;
    end if;
  end process proc_latency_pipe_5_26;
  fully_2_1_bit <= d0_1_24 and d1_1_27 and d2_1_30 and d3_1_33;
  latency_pipe_5_26_front_din <= fully_2_1_bit;
  latency_pipe_5_26_push_front_pop_back_en <= '1';
  y <= std_logic_to_vector(latency_pipe_5_26_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_2705f2d4ec is
  port (
    a : in std_logic_vector((16 - 1) downto 0);
    b : in std_logic_vector((16 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_2705f2d4ec;


architecture behavior of relational_2705f2d4ec is
  signal a_1_31: signed((16 - 1) downto 0);
  signal b_1_34: signed((16 - 1) downto 0);
  type array_type_op_mem_32_22 is array (0 to (1 - 1)) of boolean;
  signal op_mem_32_22: array_type_op_mem_32_22 := (
    0 => false);
  signal op_mem_32_22_front_din: boolean;
  signal op_mem_32_22_back: boolean;
  signal op_mem_32_22_push_front_pop_back_en: std_logic;
  signal result_16_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_signed(a);
  b_1_34 <= std_logic_vector_to_signed(b);
  op_mem_32_22_back <= op_mem_32_22(0);
  proc_op_mem_32_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_32_22_push_front_pop_back_en = '1')) then
        op_mem_32_22(0) <= op_mem_32_22_front_din;
      end if;
    end if;
  end process proc_op_mem_32_22;
  result_16_3_rel <= a_1_31 < b_1_34;
  op_mem_32_22_front_din <= result_16_3_rel;
  op_mem_32_22_push_front_pop_back_en <= '1';
  op <= boolean_to_vector(op_mem_32_22_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_95e7a52777 is
  port (
    a : in std_logic_vector((16 - 1) downto 0);
    b : in std_logic_vector((12 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_95e7a52777;


architecture behavior of relational_95e7a52777 is
  signal a_1_31: signed((16 - 1) downto 0);
  signal b_1_34: signed((12 - 1) downto 0);
  type array_type_op_mem_32_22 is array (0 to (1 - 1)) of boolean;
  signal op_mem_32_22: array_type_op_mem_32_22 := (
    0 => false);
  signal op_mem_32_22_front_din: boolean;
  signal op_mem_32_22_back: boolean;
  signal op_mem_32_22_push_front_pop_back_en: std_logic;
  signal cast_20_17: signed((16 - 1) downto 0);
  signal result_20_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_signed(a);
  b_1_34 <= std_logic_vector_to_signed(b);
  op_mem_32_22_back <= op_mem_32_22(0);
  proc_op_mem_32_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_32_22_push_front_pop_back_en = '1')) then
        op_mem_32_22(0) <= op_mem_32_22_front_din;
      end if;
    end if;
  end process proc_op_mem_32_22;
  cast_20_17 <= s2s_cast(b_1_34, 9, 16, 13);
  result_20_3_rel <= a_1_31 <= cast_20_17;
  op_mem_32_22_front_din <= result_20_3_rel;
  op_mem_32_22_push_front_pop_back_en <= '1';
  op <= boolean_to_vector(op_mem_32_22_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_1af0fb0f38 is
  port (
    a : in std_logic_vector((10 - 1) downto 0);
    b : in std_logic_vector((8 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_1af0fb0f38;


architecture behavior of relational_1af0fb0f38 is
  signal a_1_31: unsigned((10 - 1) downto 0);
  signal b_1_34: unsigned((8 - 1) downto 0);
  type array_type_op_mem_32_22 is array (0 to (1 - 1)) of boolean;
  signal op_mem_32_22: array_type_op_mem_32_22 := (
    0 => false);
  signal op_mem_32_22_front_din: boolean;
  signal op_mem_32_22_back: boolean;
  signal op_mem_32_22_push_front_pop_back_en: std_logic;
  signal cast_22_17: unsigned((10 - 1) downto 0);
  signal result_22_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  op_mem_32_22_back <= op_mem_32_22(0);
  proc_op_mem_32_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_32_22_push_front_pop_back_en = '1')) then
        op_mem_32_22(0) <= op_mem_32_22_front_din;
      end if;
    end if;
  end process proc_op_mem_32_22;
  cast_22_17 <= u2u_cast(b_1_34, 0, 10, 0);
  result_22_3_rel <= a_1_31 >= cast_22_17;
  op_mem_32_22_front_din <= result_22_3_rel;
  op_mem_32_22_push_front_pop_back_en <= '1';
  op <= boolean_to_vector(op_mem_32_22_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_d7ce1ba691 is
  port (
    in0 : in std_logic_vector((20 - 1) downto 0);
    in1 : in std_logic_vector((9 - 1) downto 0);
    in2 : in std_logic_vector((18 - 1) downto 0);
    in3 : in std_logic_vector((17 - 1) downto 0);
    y : out std_logic_vector((64 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_d7ce1ba691;


architecture behavior of concat_d7ce1ba691 is
  signal in0_1_23: unsigned((20 - 1) downto 0);
  signal in1_1_27: unsigned((9 - 1) downto 0);
  signal in2_1_31: unsigned((18 - 1) downto 0);
  signal in3_1_35: unsigned((17 - 1) downto 0);
  signal y_2_1_concat: unsigned((64 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  in2_1_31 <= std_logic_vector_to_unsigned(in2);
  in3_1_35 <= std_logic_vector_to_unsigned(in3);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27) & unsigned_to_std_logic_vector(in2_1_31) & unsigned_to_std_logic_vector(in3_1_35));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_498bc68c14 is
  port (
    op : out std_logic_vector((10 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_498bc68c14;


architecture behavior of constant_498bc68c14 is
begin
  op <= "0000000000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_4246ea65a9 is
  port (
    d : in std_logic_vector((16 - 1) downto 0);
    q : out std_logic_vector((16 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_4246ea65a9;


architecture behavior of delay_4246ea65a9 is
  signal d_1_22: std_logic_vector((16 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (1 - 1)) of std_logic_vector((16 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    0 => "0000000000000000");
  signal op_mem_20_24_front_din: std_logic_vector((16 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((16 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(0);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_c53de546ea is
  port (
    d : in std_logic_vector((1 - 1) downto 0);
    q : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_c53de546ea;


architecture behavior of delay_c53de546ea is
  signal d_1_22: std_logic;
  type array_type_op_mem_20_24 is array (0 to (4 - 1)) of std_logic;
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    '0',
    '0',
    '0',
    '0');
  signal op_mem_20_24_front_din: std_logic;
  signal op_mem_20_24_back: std_logic;
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d(0);
  op_mem_20_24_back <= op_mem_20_24(3);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 3 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= std_logic_to_vector(op_mem_20_24_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_9701834818 is
  port (
    d : in std_logic_vector((1 - 1) downto 0);
    q : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_9701834818;


architecture behavior of delay_9701834818 is
  signal d_1_22: std_logic;
  type array_type_op_mem_20_24 is array (0 to (254 - 1)) of std_logic;
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0');
  signal op_mem_20_24_front_din: std_logic;
  signal op_mem_20_24_back: std_logic;
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d(0);
  op_mem_20_24_back <= op_mem_20_24(253);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 253 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= std_logic_to_vector(op_mem_20_24_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_ebec135d8a is
  port (
    d : in std_logic_vector((8 - 1) downto 0);
    q : out std_logic_vector((8 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_ebec135d8a;


architecture behavior of delay_ebec135d8a is
  signal d_1_22: std_logic_vector((8 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (1 - 1)) of std_logic_vector((8 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    0 => "00000000");
  signal op_mem_20_24_front_din: std_logic_vector((8 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((8 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(0);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_cc14a035dc is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((8 - 1) downto 0);
    d1 : in std_logic_vector((8 - 1) downto 0);
    y : out std_logic_vector((8 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_cc14a035dc;


architecture behavior of mux_cc14a035dc is
  signal sel_1_20: std_logic;
  signal d0_1_24: std_logic_vector((8 - 1) downto 0);
  signal d1_1_27: std_logic_vector((8 - 1) downto 0);
  type array_type_pipe_16_22 is array (0 to (1 - 1)) of std_logic_vector((8 - 1) downto 0);
  signal pipe_16_22: array_type_pipe_16_22 := (
    0 => "00000000");
  signal pipe_16_22_front_din: std_logic_vector((8 - 1) downto 0);
  signal pipe_16_22_back: std_logic_vector((8 - 1) downto 0);
  signal pipe_16_22_push_front_pop_back_en: std_logic;
  signal sel_internal_2_1_convert: std_logic_vector((1 - 1) downto 0);
  signal unregy_join_6_1: std_logic_vector((8 - 1) downto 0);
begin
  sel_1_20 <= sel(0);
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  pipe_16_22_back <= pipe_16_22(0);
  proc_pipe_16_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (pipe_16_22_push_front_pop_back_en = '1')) then
        pipe_16_22(0) <= pipe_16_22_front_din;
      end if;
    end if;
  end process proc_pipe_16_22;
  sel_internal_2_1_convert <= cast(std_logic_to_vector(sel_1_20), 0, 1, 0, xlUnsigned);
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_internal_2_1_convert)
  is
  begin
    case sel_internal_2_1_convert is 
      when "0" =>
        unregy_join_6_1 <= d0_1_24;
      when others =>
        unregy_join_6_1 <= d1_1_27;
    end case;
  end process proc_switch_6_1;
  pipe_16_22_front_din <= unregy_join_6_1;
  pipe_16_22_push_front_pop_back_en <= '1';
  y <= pipe_16_22_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_151459306d is
  port (
    input_port : in std_logic_vector((16 - 1) downto 0);
    output_port : out std_logic_vector((16 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_151459306d;


architecture behavior of reinterpret_151459306d is
  signal input_port_1_40: unsigned((16 - 1) downto 0);
  signal output_port_5_5_force: signed((16 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port_5_5_force <= unsigned_to_signed(input_port_1_40);
  output_port <= signed_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_9a0fa0f632 is
  port (
    input_port : in std_logic_vector((18 - 1) downto 0);
    output_port : out std_logic_vector((18 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_9a0fa0f632;


architecture behavior of reinterpret_9a0fa0f632 is
  signal input_port_1_40: unsigned((18 - 1) downto 0);
  signal output_port_5_5_force: signed((18 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port_5_5_force <= unsigned_to_signed(input_port_1_40);
  output_port <= signed_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_b754317574 is
  port (
    input_port : in std_logic_vector((9 - 1) downto 0);
    output_port : out std_logic_vector((9 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_b754317574;


architecture behavior of reinterpret_b754317574 is
  signal input_port_1_40: unsigned((9 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port <= unsigned_to_std_logic_vector(input_port_1_40);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_580feec131 is
  port (
    input_port : in std_logic_vector((18 - 1) downto 0);
    output_port : out std_logic_vector((18 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_580feec131;


architecture behavior of reinterpret_580feec131 is
  signal input_port_1_40: signed((18 - 1) downto 0);
  signal output_port_5_5_force: unsigned((18 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_signed(input_port);
  output_port_5_5_force <= signed_to_unsigned(input_port_1_40);
  output_port <= unsigned_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_573890e1c0 is
  port (
    input_port : in std_logic_vector((17 - 1) downto 0);
    output_port : out std_logic_vector((17 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_573890e1c0;


architecture behavior of reinterpret_573890e1c0 is
  signal input_port_1_40: signed((17 - 1) downto 0);
  signal output_port_5_5_force: unsigned((17 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_signed(input_port);
  output_port_5_5_force <= signed_to_unsigned(input_port_1_40);
  output_port <= unsigned_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_8aa53a854d is
  port (
    in0 : in std_logic_vector((11 - 1) downto 0);
    in1 : in std_logic_vector((11 - 1) downto 0);
    in2 : in std_logic_vector((11 - 1) downto 0);
    in3 : in std_logic_vector((11 - 1) downto 0);
    y : out std_logic_vector((44 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_8aa53a854d;


architecture behavior of concat_8aa53a854d is
  signal in0_1_23: unsigned((11 - 1) downto 0);
  signal in1_1_27: unsigned((11 - 1) downto 0);
  signal in2_1_31: unsigned((11 - 1) downto 0);
  signal in3_1_35: unsigned((11 - 1) downto 0);
  signal y_2_1_concat: unsigned((44 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  in2_1_31 <= std_logic_vector_to_unsigned(in2);
  in3_1_35 <= std_logic_vector_to_unsigned(in3);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27) & unsigned_to_std_logic_vector(in2_1_31) & unsigned_to_std_logic_vector(in3_1_35));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_6b1adb5d55 is
  port (
    input_port : in std_logic_vector((11 - 1) downto 0);
    output_port : out std_logic_vector((11 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_6b1adb5d55;


architecture behavior of reinterpret_6b1adb5d55 is
  signal input_port_1_40: unsigned((11 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port <= unsigned_to_std_logic_vector(input_port_1_40);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_8b4279cdc5 is
  port (
    input_port : in std_logic_vector((72 - 1) downto 0);
    output_port : out std_logic_vector((72 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_8b4279cdc5;


architecture behavior of reinterpret_8b4279cdc5 is
  signal input_port_1_40: unsigned((72 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port <= unsigned_to_std_logic_vector(input_port_1_40);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_c4fa12acb5 is
  port (
    input_port : in std_logic_vector((3 - 1) downto 0);
    output_port : out std_logic_vector((3 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_c4fa12acb5;


architecture behavior of reinterpret_c4fa12acb5 is
  signal input_port_1_40: unsigned((3 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port <= unsigned_to_std_logic_vector(input_port_1_40);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_c9e724c9c7 is
  port (
    sel : in std_logic_vector((3 - 1) downto 0);
    d0 : in std_logic_vector((72 - 1) downto 0);
    d1 : in std_logic_vector((72 - 1) downto 0);
    d2 : in std_logic_vector((72 - 1) downto 0);
    d3 : in std_logic_vector((72 - 1) downto 0);
    d4 : in std_logic_vector((72 - 1) downto 0);
    d5 : in std_logic_vector((72 - 1) downto 0);
    d6 : in std_logic_vector((72 - 1) downto 0);
    d7 : in std_logic_vector((72 - 1) downto 0);
    y : out std_logic_vector((72 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_c9e724c9c7;


architecture behavior of mux_c9e724c9c7 is
  signal sel_1_20: std_logic_vector((3 - 1) downto 0);
  signal d0_1_24: std_logic_vector((72 - 1) downto 0);
  signal d1_1_27: std_logic_vector((72 - 1) downto 0);
  signal d2_1_30: std_logic_vector((72 - 1) downto 0);
  signal d3_1_33: std_logic_vector((72 - 1) downto 0);
  signal d4_1_36: std_logic_vector((72 - 1) downto 0);
  signal d5_1_39: std_logic_vector((72 - 1) downto 0);
  signal d6_1_42: std_logic_vector((72 - 1) downto 0);
  signal d7_1_45: std_logic_vector((72 - 1) downto 0);
  type array_type_pipe_28_22 is array (0 to (1 - 1)) of std_logic_vector((72 - 1) downto 0);
  signal pipe_28_22: array_type_pipe_28_22 := (
    0 => "000000000000000000000000000000000000000000000000000000000000000000000000");
  signal pipe_28_22_front_din: std_logic_vector((72 - 1) downto 0);
  signal pipe_28_22_back: std_logic_vector((72 - 1) downto 0);
  signal pipe_28_22_push_front_pop_back_en: std_logic;
  signal unregy_join_6_1: std_logic_vector((72 - 1) downto 0);
begin
  sel_1_20 <= sel;
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  d2_1_30 <= d2;
  d3_1_33 <= d3;
  d4_1_36 <= d4;
  d5_1_39 <= d5;
  d6_1_42 <= d6;
  d7_1_45 <= d7;
  pipe_28_22_back <= pipe_28_22(0);
  proc_pipe_28_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (pipe_28_22_push_front_pop_back_en = '1')) then
        pipe_28_22(0) <= pipe_28_22_front_din;
      end if;
    end if;
  end process proc_pipe_28_22;
  proc_switch_6_1: process (d0_1_24, d1_1_27, d2_1_30, d3_1_33, d4_1_36, d5_1_39, d6_1_42, d7_1_45, sel_1_20)
  is
  begin
    case sel_1_20 is 
      when "000" =>
        unregy_join_6_1 <= d0_1_24;
      when "001" =>
        unregy_join_6_1 <= d1_1_27;
      when "010" =>
        unregy_join_6_1 <= d2_1_30;
      when "011" =>
        unregy_join_6_1 <= d3_1_33;
      when "100" =>
        unregy_join_6_1 <= d4_1_36;
      when "101" =>
        unregy_join_6_1 <= d5_1_39;
      when "110" =>
        unregy_join_6_1 <= d6_1_42;
      when others =>
        unregy_join_6_1 <= d7_1_45;
    end case;
  end process proc_switch_6_1;
  pipe_28_22_front_din <= unregy_join_6_1;
  pipe_28_22_push_front_pop_back_en <= '1';
  y <= pipe_28_22_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_e4625e6202 is
  port (
    in0 : in std_logic_vector((72 - 1) downto 0);
    in1 : in std_logic_vector((72 - 1) downto 0);
    in2 : in std_logic_vector((72 - 1) downto 0);
    in3 : in std_logic_vector((72 - 1) downto 0);
    y : out std_logic_vector((288 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_e4625e6202;


architecture behavior of concat_e4625e6202 is
  signal in0_1_23: unsigned((72 - 1) downto 0);
  signal in1_1_27: unsigned((72 - 1) downto 0);
  signal in2_1_31: unsigned((72 - 1) downto 0);
  signal in3_1_35: unsigned((72 - 1) downto 0);
  signal y_2_1_concat: unsigned((288 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  in2_1_31 <= std_logic_vector_to_unsigned(in2);
  in3_1_35 <= std_logic_vector_to_unsigned(in3);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27) & unsigned_to_std_logic_vector(in2_1_31) & unsigned_to_std_logic_vector(in3_1_35));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_2b46a879f8 is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((288 - 1) downto 0);
    d1 : in std_logic_vector((288 - 1) downto 0);
    y : out std_logic_vector((288 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_2b46a879f8;


architecture behavior of mux_2b46a879f8 is
  signal sel_1_20: std_logic;
  signal d0_1_24: std_logic_vector((288 - 1) downto 0);
  signal d1_1_27: std_logic_vector((288 - 1) downto 0);
  type array_type_pipe_16_22 is array (0 to (1 - 1)) of std_logic_vector((288 - 1) downto 0);
  signal pipe_16_22: array_type_pipe_16_22 := (
    0 => "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");
  signal pipe_16_22_front_din: std_logic_vector((288 - 1) downto 0);
  signal pipe_16_22_back: std_logic_vector((288 - 1) downto 0);
  signal pipe_16_22_push_front_pop_back_en: std_logic;
  signal sel_internal_2_1_convert: std_logic_vector((1 - 1) downto 0);
  signal unregy_join_6_1: std_logic_vector((288 - 1) downto 0);
begin
  sel_1_20 <= sel(0);
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  pipe_16_22_back <= pipe_16_22(0);
  proc_pipe_16_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (pipe_16_22_push_front_pop_back_en = '1')) then
        pipe_16_22(0) <= pipe_16_22_front_din;
      end if;
    end if;
  end process proc_pipe_16_22;
  sel_internal_2_1_convert <= cast(std_logic_to_vector(sel_1_20), 0, 1, 0, xlUnsigned);
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_internal_2_1_convert)
  is
  begin
    case sel_internal_2_1_convert is 
      when "0" =>
        unregy_join_6_1 <= d0_1_24;
      when others =>
        unregy_join_6_1 <= d1_1_27;
    end case;
  end process proc_switch_6_1;
  pipe_16_22_front_din <= unregy_join_6_1;
  pipe_16_22_push_front_pop_back_en <= '1';
  y <= pipe_16_22_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity counter_2943023fcf is
  port (
    en : in std_logic_vector((1 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end counter_2943023fcf;


architecture behavior of counter_2943023fcf is
  signal en_1_45: boolean;
  signal count_reg_20_23: unsigned((1 - 1) downto 0) := "0";
  signal count_reg_20_23_en: std_logic;
  signal count_reg_join_44_1: unsigned((2 - 1) downto 0);
  signal count_reg_join_44_1_en: std_logic;
begin
  en_1_45 <= ((en) = "1");
  proc_count_reg_20_23: process (clk)
  is
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (count_reg_20_23_en = '1')) then
        count_reg_20_23 <= count_reg_20_23 + std_logic_vector_to_unsigned("1");
      end if;
    end if;
  end process proc_count_reg_20_23;
  proc_if_44_1: process (count_reg_20_23, en_1_45)
  is
  begin
    if en_1_45 then
      count_reg_join_44_1_en <= '1';
    else 
      count_reg_join_44_1_en <= '0';
    end if;
  end process proc_if_44_1;
  count_reg_20_23_en <= count_reg_join_44_1_en;
  op <= unsigned_to_std_logic_vector(count_reg_20_23);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_d1b224f0a6 is
  port (
    d : in std_logic_vector((8 - 1) downto 0);
    q : out std_logic_vector((8 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_d1b224f0a6;


architecture behavior of delay_d1b224f0a6 is
  signal d_1_22: std_logic_vector((8 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (16 - 1)) of std_logic_vector((8 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000");
  signal op_mem_20_24_front_din: std_logic_vector((8 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((8 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(15);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 15 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_29899636e8 is
  port (
    d : in std_logic_vector((38 - 1) downto 0);
    q : out std_logic_vector((38 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_29899636e8;


architecture behavior of delay_29899636e8 is
  signal d_1_22: std_logic_vector((38 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (3 - 1)) of std_logic_vector((38 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "00000000000000000000000000000000000000",
    "00000000000000000000000000000000000000",
    "00000000000000000000000000000000000000");
  signal op_mem_20_24_front_din: std_logic_vector((38 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((38 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(2);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 2 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_9565135955 is
  port (
    d : in std_logic_vector((8 - 1) downto 0);
    q : out std_logic_vector((8 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_9565135955;


architecture behavior of delay_9565135955 is
  signal d_1_22: std_logic_vector((8 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (3 - 1)) of std_logic_vector((8 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "00000000",
    "00000000",
    "00000000");
  signal op_mem_20_24_front_din: std_logic_vector((8 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((8 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(2);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 2 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_d64b27fc5c is
  port (
    d : in std_logic_vector((38 - 1) downto 0);
    q : out std_logic_vector((38 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_d64b27fc5c;


architecture behavior of delay_d64b27fc5c is
  signal d_1_22: std_logic_vector((38 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (1 - 1)) of std_logic_vector((38 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    0 => "00000000000000000000000000000000000000");
  signal op_mem_20_24_front_din: std_logic_vector((38 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((38 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(0);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_3f9089a15b is
  port (
    input_port : in std_logic_vector((20 - 1) downto 0);
    output_port : out std_logic_vector((20 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_3f9089a15b;


architecture behavior of reinterpret_3f9089a15b is
  signal input_port_1_40: signed((20 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_signed(input_port);
  output_port <= signed_to_std_logic_vector(input_port_1_40);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity xlcordic_53adb7b8edc473345e768703dfed392e is 
  port(
    ce:in std_logic;
    clk:in std_logic;
    phase_out:out std_logic_vector(11 downto 0);
    x_in:in std_logic_vector(19 downto 0);
    y_in:in std_logic_vector(19 downto 0)
  );
end xlcordic_53adb7b8edc473345e768703dfed392e;


architecture behavior of xlcordic_53adb7b8edc473345e768703dfed392e  is
  component crdc_v4_0_75c75af685d34a44
    port(
      ce:in std_logic;
      clk:in std_logic;
      phase_out:out std_logic_vector(11 downto 0);
      x_in:in std_logic_vector(19 downto 0);
      y_in:in std_logic_vector(19 downto 0)
    );
end component;
begin
  crdc_v4_0_75c75af685d34a44_instance : crdc_v4_0_75c75af685d34a44
    port map(
      ce=>ce,
      clk=>clk,
      phase_out=>phase_out,
      x_in=>x_in,
      y_in=>y_in
    );
end  behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_5da0e88a67 is
  port (
    a : in std_logic_vector((9 - 1) downto 0);
    b : in std_logic_vector((9 - 1) downto 0);
    s : out std_logic_vector((9 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_5da0e88a67;


architecture behavior of addsub_5da0e88a67 is
  signal a_17_32: unsigned((9 - 1) downto 0);
  signal b_17_35: unsigned((9 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (1 - 1)) of unsigned((9 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    0 => "000000000");
  signal op_mem_91_20_front_din: unsigned((9 - 1) downto 0);
  signal op_mem_91_20_back: unsigned((9 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (1 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    0 => "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_71_18: signed((11 - 1) downto 0);
  signal cast_71_22: signed((11 - 1) downto 0);
  signal internal_s_71_5_addsub: signed((11 - 1) downto 0);
  signal cast_internal_s_83_3_convert: unsigned((9 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_unsigned(a);
  b_17_35 <= std_logic_vector_to_unsigned(b);
  op_mem_91_20_back <= op_mem_91_20(0);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(0);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_71_18 <= u2s_cast(a_17_32, 0, 11, 0);
  cast_71_22 <= u2s_cast(b_17_35, 0, 11, 0);
  internal_s_71_5_addsub <= cast_71_18 - cast_71_22;
  cast_internal_s_83_3_convert <= s2u_cast(internal_s_71_5_addsub, 0, 9, 0);
  op_mem_91_20_front_din <= cast_internal_s_83_3_convert;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= unsigned_to_std_logic_vector(op_mem_91_20_back);
end behavior;


-------------------------------------------------------------------
-- System Generator version 14.3 VHDL source file.
--
-- Copyright(C) 2012 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2012 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
-- synopsys translate_off
library XilinxCoreLib;
-- synopsys translate_on
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use work.conv_pkg.all;
entity xldpram_darkquad29 is
  generic (
    core_name0: string := "";
    c_width_a: integer := 13;
    c_address_width_a: integer := 4;
    c_width_b: integer := 13;
    c_address_width_b: integer := 4;
    c_has_sinita: integer := 0;
    c_has_sinitb: integer := 0;
    latency: integer := 1
  );
  port (
    dina: in std_logic_vector(c_width_a - 1 downto 0);
    addra: in std_logic_vector(c_address_width_a - 1 downto 0);
    wea: in std_logic_vector(0 downto 0);
    a_ce: in std_logic;
    a_clk: in std_logic;
    rsta: in std_logic_vector(0 downto 0) := (others => '0');
    ena: in std_logic_vector(0 downto 0) := (others => '1');
    douta: out std_logic_vector(c_width_a - 1 downto 0);
    dinb: in std_logic_vector(c_width_b - 1 downto 0);
    addrb: in std_logic_vector(c_address_width_b - 1 downto 0);
    web: in std_logic_vector(0 downto 0);
    b_ce: in std_logic;
    b_clk: in std_logic;
    rstb: in std_logic_vector(0 downto 0) := (others => '0');
    enb: in std_logic_vector(0 downto 0) := (others => '1');
    doutb: out std_logic_vector(c_width_b - 1 downto 0)
  );
end xldpram_darkquad29;
architecture behavior of xldpram_darkquad29 is
  component synth_reg
    generic (
      width: integer;
      latency: integer
    );
    port (
      i: in std_logic_vector(width - 1 downto 0);
      ce: in std_logic;
      clr: in std_logic;
      clk: in std_logic;
      o: out std_logic_vector(width - 1 downto 0)
    );
  end component;

  signal core_addra: std_logic_vector(c_address_width_a - 1 downto 0);
  signal core_addrb: std_logic_vector(c_address_width_b - 1 downto 0);
  signal core_dina, core_douta, dly_douta:
    std_logic_vector(c_width_a - 1 downto 0);
  signal core_dinb, core_doutb, dly_doutb:
    std_logic_vector(c_width_b - 1 downto 0);
  signal core_wea, core_web: std_logic;
  signal core_a_ce, core_b_ce: std_logic;
  signal sinita, sinitb: std_logic;

  component bmg_72_5200d17ea41d7d8d
    port (
        addra: in std_logic_vector(c_address_width_a - 1 downto 0);
      addrb: in std_logic_vector(c_address_width_b - 1 downto 0);
      dina: in std_logic_vector(c_width_a - 1 downto 0);
      dinb: in std_logic_vector(c_width_b - 1 downto 0);
      clka: in std_logic;
      clkb: in std_logic;
      wea: in std_logic_vector(0 downto 0);
      web: in std_logic_vector(0 downto 0);
      ena: in std_logic;
      enb: in std_logic;
      douta: out std_logic_vector(c_width_a - 1 downto 0);
      doutb: out std_logic_vector(c_width_b - 1 downto 0)
     );
  end component;

  attribute syn_black_box of bmg_72_5200d17ea41d7d8d:
    component is true;
  attribute fpga_dont_touch of bmg_72_5200d17ea41d7d8d:
    component is "true";
  attribute box_type of bmg_72_5200d17ea41d7d8d:
    component  is "black_box";
begin
  core_addra <= addra;
  core_dina <= dina;
  douta <= dly_douta;
  core_wea <= wea(0);
  core_a_ce <= a_ce and ena(0);
  sinita <= rsta(0) and a_ce;

  core_addrb <= addrb;
  core_dinb <= dinb;
  doutb <= dly_doutb;
  core_web <= web(0);
  core_b_ce <= b_ce and enb(0);
  sinitb <= rstb(0) and b_ce;
  comp0: if ((core_name0 = "bmg_72_5200d17ea41d7d8d")) generate
    core_instance0: bmg_72_5200d17ea41d7d8d
      port map (
          addra => core_addra,
        clka => a_clk,
        addrb => core_addrb,
        clkb => b_clk,
        dina => core_dina,
        wea(0) => core_wea,
        dinb => core_dinb,
        web(0) => core_web,
        ena => core_a_ce,
        enb => core_b_ce,
        douta => core_douta,
        doutb => core_doutb
      );
  end generate;
  latency_test: if (latency > 2) generate
    regA: synth_reg
      generic map (
        width => c_width_a,
        latency => latency - 2
      )
      port map (
        i => core_douta,
        ce => core_a_ce,
        clr => '0',
        clk => a_clk,
        o => dly_douta
      );
    regB: synth_reg
      generic map (
        width => c_width_b,
        latency => latency - 2
      )
      port map (
        i => core_doutb,
        ce => core_b_ce,
        clr => '0',
        clk => b_clk,
        o => dly_doutb
      );
  end generate;
  latency1: if (latency <= 2) generate
    dly_douta <= core_douta;
    dly_doutb <= core_doutb;
  end generate;
end  behavior;
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity bitbasher_7f79f7d703 is
  port (
    a : in std_logic_vector((72 - 1) downto 0);
    b : out std_logic_vector((72 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end bitbasher_7f79f7d703;


architecture behavior of bitbasher_7f79f7d703 is
  signal a_1_26: unsigned((72 - 1) downto 0);
  signal slice_5_28: unsigned((4 - 1) downto 0);
  signal slice_5_46: unsigned((4 - 1) downto 0);
  signal slice_5_64: unsigned((32 - 1) downto 0);
  signal slice_5_82: unsigned((32 - 1) downto 0);
  signal fullb_5_1_concat: unsigned((72 - 1) downto 0);
begin
  a_1_26 <= std_logic_vector_to_unsigned(a);
  slice_5_28 <= u2u_slice(a_1_26, 71, 68);
  slice_5_46 <= u2u_slice(a_1_26, 35, 32);
  slice_5_64 <= u2u_slice(a_1_26, 67, 36);
  slice_5_82 <= u2u_slice(a_1_26, 31, 0);
  fullb_5_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(slice_5_28) & unsigned_to_std_logic_vector(slice_5_46) & unsigned_to_std_logic_vector(slice_5_64) & unsigned_to_std_logic_vector(slice_5_82));
  b <= unsigned_to_std_logic_vector(fullb_5_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity bitbasher_34778e1824 is
  port (
    a : in std_logic_vector((72 - 1) downto 0);
    b : out std_logic_vector((72 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end bitbasher_34778e1824;


architecture behavior of bitbasher_34778e1824 is
  signal a_1_26: unsigned((72 - 1) downto 0);
  signal slice_5_28: unsigned((4 - 1) downto 0);
  signal slice_5_46: unsigned((32 - 1) downto 0);
  signal slice_5_64: unsigned((4 - 1) downto 0);
  signal slice_5_82: unsigned((32 - 1) downto 0);
  signal fullb_5_1_concat: unsigned((72 - 1) downto 0);
begin
  a_1_26 <= std_logic_vector_to_unsigned(a);
  slice_5_28 <= u2u_slice(a_1_26, 71, 68);
  slice_5_46 <= u2u_slice(a_1_26, 63, 32);
  slice_5_64 <= u2u_slice(a_1_26, 67, 64);
  slice_5_82 <= u2u_slice(a_1_26, 31, 0);
  fullb_5_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(slice_5_28) & unsigned_to_std_logic_vector(slice_5_46) & unsigned_to_std_logic_vector(slice_5_64) & unsigned_to_std_logic_vector(slice_5_82));
  b <= unsigned_to_std_logic_vector(fullb_5_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_19562ab42f is
  port (
    op : out std_logic_vector((8 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_19562ab42f;


architecture behavior of constant_19562ab42f is
begin
  op <= "11111111";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_1da3c4f87c is
  port (
    input_port : in std_logic_vector((38 - 1) downto 0);
    output_port : out std_logic_vector((38 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_1da3c4f87c;


architecture behavior of reinterpret_1da3c4f87c is
  signal input_port_1_40: unsigned((38 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port <= unsigned_to_std_logic_vector(input_port_1_40);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_f7543d22d5 is
  port (
    a : in std_logic_vector((35 - 1) downto 0);
    b : in std_logic_vector((35 - 1) downto 0);
    s : out std_logic_vector((36 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_f7543d22d5;


architecture behavior of addsub_f7543d22d5 is
  signal a_17_32: signed((35 - 1) downto 0);
  signal b_17_35: signed((35 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (3 - 1)) of signed((36 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000");
  signal op_mem_91_20_front_din: signed((36 - 1) downto 0);
  signal op_mem_91_20_back: signed((36 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (3 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    "0",
    "0",
    "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_69_18: signed((36 - 1) downto 0);
  signal cast_69_22: signed((36 - 1) downto 0);
  signal internal_s_69_5_addsub: signed((36 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(2);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        for i in 2 downto 1 loop 
          op_mem_91_20(i) <= op_mem_91_20(i-1);
        end loop;
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(2);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        for i_x_000000 in 2 downto 1 loop 
          cout_mem_92_22(i_x_000000) <= cout_mem_92_22(i_x_000000-1);
        end loop;
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_69_18 <= s2s_cast(a_17_32, 32, 36, 32);
  cast_69_22 <= s2s_cast(b_17_35, 32, 36, 32);
  internal_s_69_5_addsub <= cast_69_18 + cast_69_22;
  op_mem_91_20_front_din <= internal_s_69_5_addsub;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_4b00a70dea is
  port (
    d : in std_logic_vector((36 - 1) downto 0);
    q : out std_logic_vector((36 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_4b00a70dea;


architecture behavior of delay_4b00a70dea is
  signal d_1_22: std_logic_vector((36 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (3 - 1)) of std_logic_vector((36 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000",
    "000000000000000000000000000000000000");
  signal op_mem_20_24_front_din: std_logic_vector((36 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((36 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(2);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 2 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_5ffb58eb22 is
  port (
    op : out std_logic_vector((16 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_5ffb58eb22;


architecture behavior of constant_5ffb58eb22 is
begin
  op <= "0000011000010010";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_9bd90577fa is
  port (
    op : out std_logic_vector((16 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_9bd90577fa;


architecture behavior of constant_9bd90577fa is
begin
  op <= "0000110001001001";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_a6e8ddd940 is
  port (
    op : out std_logic_vector((16 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_a6e8ddd940;


architecture behavior of constant_a6e8ddd940 is
begin
  op <= "0001000000101101";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_70566a39ae is
  port (
    op : out std_logic_vector((16 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_70566a39ae;


architecture behavior of constant_70566a39ae is
begin
  op <= "0000100100110001";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_65987f1774 is
  port (
    op : out std_logic_vector((16 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_65987f1774;


architecture behavior of constant_65987f1774 is
begin
  op <= "0000001101101011";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_6f91815d31 is
  port (
    op : out std_logic_vector((16 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_6f91815d31;


architecture behavior of constant_6f91815d31 is
begin
  op <= "0000000110001010";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_b38f42a3c0 is
  port (
    op : out std_logic_vector((16 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_b38f42a3c0;


architecture behavior of constant_b38f42a3c0 is
begin
  op <= "0000000001111010";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_d7af782a82 is
  port (
    op : out std_logic_vector((16 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_d7af782a82;


architecture behavior of constant_d7af782a82 is
begin
  op <= "0000000000010000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_cc00e1f180 is
  port (
    op : out std_logic_vector((16 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_cc00e1f180;


architecture behavior of constant_cc00e1f180 is
begin
  op <= "0000111011001000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_396d62fe11 is
  port (
    d : in std_logic_vector((8 - 1) downto 0);
    q : out std_logic_vector((8 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_396d62fe11;


architecture behavior of delay_396d62fe11 is
  signal d_1_22: std_logic_vector((8 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (15 - 1)) of std_logic_vector((8 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000");
  signal op_mem_20_24_front_din: std_logic_vector((8 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((8 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(14);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 14 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_23f848c85b is
  port (
    d : in std_logic_vector((8 - 1) downto 0);
    q : out std_logic_vector((8 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_23f848c85b;


architecture behavior of delay_23f848c85b is
  signal d_1_22: std_logic_vector((8 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (2 - 1)) of std_logic_vector((8 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "00000000",
    "00000000");
  signal op_mem_20_24_front_din: std_logic_vector((8 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((8 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(1);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 1 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_5a12f8f9be is
  port (
    in0 : in std_logic_vector((19 - 1) downto 0);
    in1 : in std_logic_vector((19 - 1) downto 0);
    y : out std_logic_vector((38 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_5a12f8f9be;


architecture behavior of concat_5a12f8f9be is
  signal in0_1_23: unsigned((19 - 1) downto 0);
  signal in1_1_27: unsigned((19 - 1) downto 0);
  signal y_2_1_concat: unsigned((38 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_bc4405cd1e is
  port (
    input_port : in std_logic_vector((19 - 1) downto 0);
    output_port : out std_logic_vector((19 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_bc4405cd1e;


architecture behavior of reinterpret_bc4405cd1e is
  signal input_port_1_40: signed((19 - 1) downto 0);
  signal output_port_5_5_force: unsigned((19 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_signed(input_port);
  output_port_5_5_force <= signed_to_unsigned(input_port_1_40);
  output_port <= unsigned_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_145086465d is
  port (
    op : out std_logic_vector((4 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_145086465d;


architecture behavior of constant_145086465d is
begin
  op <= "1000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_d930162434 is
  port (
    a : in std_logic_vector((4 - 1) downto 0);
    b : in std_logic_vector((4 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_d930162434;


architecture behavior of relational_d930162434 is
  signal a_1_31: unsigned((4 - 1) downto 0);
  signal b_1_34: unsigned((4 - 1) downto 0);
  signal result_14_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  result_14_3_rel <= a_1_31 /= b_1_34;
  op <= boolean_to_vector(result_14_3_rel);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_263f209841 is
  port (
    op : out std_logic_vector((3 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_263f209841;


architecture behavior of constant_263f209841 is
begin
  op <= "110";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_47b317dab6 is
  port (
    a : in std_logic_vector((3 - 1) downto 0);
    b : in std_logic_vector((3 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_47b317dab6;


architecture behavior of relational_47b317dab6 is
  signal a_1_31: unsigned((3 - 1) downto 0);
  signal b_1_34: unsigned((3 - 1) downto 0);
  signal result_14_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  result_14_3_rel <= a_1_31 /= b_1_34;
  op <= boolean_to_vector(result_14_3_rel);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_91ba16440d is
  port (
    in0 : in std_logic_vector((64 - 1) downto 0);
    in1 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((65 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_91ba16440d;


architecture behavior of concat_91ba16440d is
  signal in0_1_23: unsigned((64 - 1) downto 0);
  signal in1_1_27: boolean;
  signal y_2_1_concat: unsigned((65 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= ((in1) = "1");
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & boolean_to_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_822933f89b is
  port (
    op : out std_logic_vector((3 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_822933f89b;


architecture behavior of constant_822933f89b is
begin
  op <= "000";
end behavior;


-------------------------------------------------------------------
-- System Generator version 14.3 VHDL source file.
--
-- Copyright(C) 2012 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2012 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
-- synopsys translate_off
library XilinxCoreLib;
-- synopsys translate_on
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use ieee.std_logic_unsigned.all;
use work.conv_pkg.all;
entity xlfifogen_darkquad29 is
  generic (
    core_name0: string := "";
    data_width: integer := -1;
    data_count_width: integer := -1;
    percent_full_width: integer := -1;
    has_ae : integer := 0;
    has_af : integer := 0
  );
  port (
    din: in std_logic_vector(data_width - 1 downto 0);
    we: in std_logic;
    we_ce: in std_logic;
    re: in std_logic;
    re_ce: in std_logic;
    rst: in std_logic;
    en: in std_logic;
    ce: in std_logic;
    clk: in std_logic;
    empty: out std_logic;
    full: out std_logic;
    percent_full: out std_logic_vector(percent_full_width - 1 downto 0);
    dcount: out std_logic_vector(data_count_width - 1 downto 0);
    ae: out std_logic;
    af: out std_logic;
    dout: out std_logic_vector(data_width - 1 downto 0)
  );
end xlfifogen_darkquad29 ;
architecture behavior of xlfifogen_darkquad29 is
  component fifo_fg92_722742878aa74e71
    port (
      clk: in std_logic;
      din: in std_logic_vector(data_width - 1 downto 0);
      wr_en: in std_logic;
      rd_en: in std_logic;
      dout: out std_logic_vector(data_width - 1 downto 0);
      full: out std_logic;
      empty: out std_logic
    );
  end component;

  attribute syn_black_box of fifo_fg92_722742878aa74e71:
    component is true;
  attribute fpga_dont_touch of fifo_fg92_722742878aa74e71:
    component is "true";
  attribute box_type of fifo_fg92_722742878aa74e71:
    component  is "black_box";
  component fifo_fg92_afda83fee974586a
    port (
      clk: in std_logic;
      din: in std_logic_vector(data_width - 1 downto 0);
      wr_en: in std_logic;
      rd_en: in std_logic;
      dout: out std_logic_vector(data_width - 1 downto 0);
      full: out std_logic;
      empty: out std_logic
    );
  end component;

  attribute syn_black_box of fifo_fg92_afda83fee974586a:
    component is true;
  attribute fpga_dont_touch of fifo_fg92_afda83fee974586a:
    component is "true";
  attribute box_type of fifo_fg92_afda83fee974586a:
    component  is "black_box";
  signal rd_en: std_logic;
  signal wr_en: std_logic;
  signal srst: std_logic;
  signal core_full: std_logic;
  signal core_dcount: std_logic_vector(data_count_width - 1 downto 0);
begin
  comp0: if ((core_name0 = "fifo_fg92_722742878aa74e71")) generate
    core_instance0: fifo_fg92_722742878aa74e71
      port map (
        clk => clk,
        din => din,
        wr_en => wr_en,
        rd_en => rd_en,
        dout => dout,
        full => core_full,
        empty => empty
      );
  end generate;
  comp1: if ((core_name0 = "fifo_fg92_afda83fee974586a")) generate
    core_instance1: fifo_fg92_afda83fee974586a
      port map (
        clk => clk,
        din => din,
        wr_en => wr_en,
        rd_en => rd_en,
        dout => dout,
        full => core_full,
        empty => empty
      );
  end generate;

  modify_count: process(core_full, core_dcount) is
  begin
    if core_full = '1' then
      percent_full <= (others => '1');
    else
      percent_full <= core_dcount(data_count_width-1 downto data_count_width-percent_full_width);
    end if;
  end process modify_count;

  rd_en <= re and en and re_ce;
  wr_en <= we and en and we_ce;
  full <= core_full;
  srst <= rst and ce;
  dcount <= core_dcount;

  terminate_core_ae: if has_ae /= 1 generate
  begin
    ae <= '0';
  end generate terminate_core_ae;
  terminate_core_af: if has_af /= 1 generate
  begin
    af <= '0';
  end generate terminate_core_af;
end  behavior;
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity logical_6cb8f0ce02 is
  port (
    d0 : in std_logic_vector((1 - 1) downto 0);
    d1 : in std_logic_vector((1 - 1) downto 0);
    d2 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end logical_6cb8f0ce02;


architecture behavior of logical_6cb8f0ce02 is
  signal d0_1_24: std_logic;
  signal d1_1_27: std_logic;
  signal d2_1_30: std_logic;
  signal fully_2_1_bit: std_logic;
begin
  d0_1_24 <= d0(0);
  d1_1_27 <= d1(0);
  d2_1_30 <= d2(0);
  fully_2_1_bit <= d0_1_24 or d1_1_27 or d2_1_30;
  y <= std_logic_to_vector(fully_2_1_bit);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_fd01d62b53 is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((64 - 1) downto 0);
    d1 : in std_logic_vector((64 - 1) downto 0);
    y : out std_logic_vector((64 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_fd01d62b53;


architecture behavior of mux_fd01d62b53 is
  signal sel_1_20: std_logic;
  signal d0_1_24: std_logic_vector((64 - 1) downto 0);
  signal d1_1_27: std_logic_vector((64 - 1) downto 0);
  type array_type_pipe_16_22 is array (0 to (1 - 1)) of std_logic_vector((64 - 1) downto 0);
  signal pipe_16_22: array_type_pipe_16_22 := (
    0 => "0000000000000000000000000000000000000000000000000000000000000000");
  signal pipe_16_22_front_din: std_logic_vector((64 - 1) downto 0);
  signal pipe_16_22_back: std_logic_vector((64 - 1) downto 0);
  signal pipe_16_22_push_front_pop_back_en: std_logic;
  signal sel_internal_2_1_convert: std_logic_vector((1 - 1) downto 0);
  signal unregy_join_6_1: std_logic_vector((64 - 1) downto 0);
begin
  sel_1_20 <= sel(0);
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  pipe_16_22_back <= pipe_16_22(0);
  proc_pipe_16_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (pipe_16_22_push_front_pop_back_en = '1')) then
        pipe_16_22(0) <= pipe_16_22_front_din;
      end if;
    end if;
  end process proc_pipe_16_22;
  sel_internal_2_1_convert <= cast(std_logic_to_vector(sel_1_20), 0, 1, 0, xlUnsigned);
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_internal_2_1_convert)
  is
  begin
    case sel_internal_2_1_convert is 
      when "0" =>
        unregy_join_6_1 <= d0_1_24;
      when others =>
        unregy_join_6_1 <= d1_1_27;
    end case;
  end process proc_switch_6_1;
  pipe_16_22_front_din <= unregy_join_6_1;
  pipe_16_22_push_front_pop_back_en <= '1';
  y <= pipe_16_22_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_e6c0d8ccf7 is
  port (
    a : in std_logic_vector((3 - 1) downto 0);
    b : in std_logic_vector((3 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_e6c0d8ccf7;


architecture behavior of relational_e6c0d8ccf7 is
  signal a_1_31: unsigned((3 - 1) downto 0);
  signal b_1_34: unsigned((3 - 1) downto 0);
  type array_type_op_mem_32_22 is array (0 to (1 - 1)) of boolean;
  signal op_mem_32_22: array_type_op_mem_32_22 := (
    0 => false);
  signal op_mem_32_22_front_din: boolean;
  signal op_mem_32_22_back: boolean;
  signal op_mem_32_22_push_front_pop_back_en: std_logic;
  signal result_12_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  op_mem_32_22_back <= op_mem_32_22(0);
  proc_op_mem_32_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_32_22_push_front_pop_back_en = '1')) then
        op_mem_32_22(0) <= op_mem_32_22_front_din;
      end if;
    end if;
  end process proc_op_mem_32_22;
  result_12_3_rel <= a_1_31 = b_1_34;
  op_mem_32_22_front_din <= result_12_3_rel;
  op_mem_32_22_push_front_pop_back_en <= '1';
  op <= boolean_to_vector(op_mem_32_22_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_faa984ef57 is
  port (
    a : in std_logic_vector((12 - 1) downto 0);
    b : in std_logic_vector((32 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_faa984ef57;


architecture behavior of relational_faa984ef57 is
  signal a_1_31: unsigned((12 - 1) downto 0);
  signal b_1_34: unsigned((32 - 1) downto 0);
  signal cast_22_12: unsigned((32 - 1) downto 0);
  signal result_22_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  cast_22_12 <= u2u_cast(a_1_31, 0, 32, 0);
  result_22_3_rel <= cast_22_12 >= b_1_34;
  op <= boolean_to_vector(result_22_3_rel);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_077deae217 is
  port (
    a : in std_logic_vector((36 - 1) downto 0);
    b : in std_logic_vector((36 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_077deae217;


architecture behavior of relational_077deae217 is
  signal a_1_31: unsigned((36 - 1) downto 0);
  signal b_1_34: unsigned((36 - 1) downto 0);
  type array_type_op_mem_32_22 is array (0 to (1 - 1)) of boolean;
  signal op_mem_32_22: array_type_op_mem_32_22 := (
    0 => false);
  signal op_mem_32_22_front_din: boolean;
  signal op_mem_32_22_back: boolean;
  signal op_mem_32_22_push_front_pop_back_en: std_logic;
  signal result_14_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  op_mem_32_22_back <= op_mem_32_22(0);
  proc_op_mem_32_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_32_22_push_front_pop_back_en = '1')) then
        op_mem_32_22(0) <= op_mem_32_22_front_din;
      end if;
    end if;
  end process proc_op_mem_32_22;
  result_14_3_rel <= a_1_31 /= b_1_34;
  op_mem_32_22_front_din <= result_14_3_rel;
  op_mem_32_22_push_front_pop_back_en <= '1';
  op <= boolean_to_vector(op_mem_32_22_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_754435d9c5 is
  port (
    op : out std_logic_vector((32 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_754435d9c5;


architecture behavior of constant_754435d9c5 is
begin
  op <= "11111111111111111111111111111111";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_38c2d03959 is
  port (
    op : out std_logic_vector((32 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_38c2d03959;


architecture behavior of constant_38c2d03959 is
begin
  op <= "01111111111111111111111111111111";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_4822199898 is
  port (
    in0 : in std_logic_vector((38 - 1) downto 0);
    in1 : in std_logic_vector((38 - 1) downto 0);
    y : out std_logic_vector((76 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_4822199898;


architecture behavior of concat_4822199898 is
  signal in0_1_23: unsigned((38 - 1) downto 0);
  signal in1_1_27: unsigned((38 - 1) downto 0);
  signal y_2_1_concat: unsigned((76 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_469094441c is
  port (
    op : out std_logic_vector((3 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_469094441c;


architecture behavior of constant_469094441c is
begin
  op <= "100";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_07eeecd0e3 is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((2 - 1) downto 0);
    d1 : in std_logic_vector((3 - 1) downto 0);
    y : out std_logic_vector((3 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_07eeecd0e3;


architecture behavior of mux_07eeecd0e3 is
  signal sel_1_20: std_logic;
  signal d0_1_24: std_logic_vector((2 - 1) downto 0);
  signal d1_1_27: std_logic_vector((3 - 1) downto 0);
  type array_type_pipe_16_22 is array (0 to (1 - 1)) of std_logic_vector((3 - 1) downto 0);
  signal pipe_16_22: array_type_pipe_16_22 := (
    0 => "000");
  signal pipe_16_22_front_din: std_logic_vector((3 - 1) downto 0);
  signal pipe_16_22_back: std_logic_vector((3 - 1) downto 0);
  signal pipe_16_22_push_front_pop_back_en: std_logic;
  signal sel_internal_2_1_convert: std_logic_vector((1 - 1) downto 0);
  signal unregy_join_6_1: std_logic_vector((3 - 1) downto 0);
begin
  sel_1_20 <= sel(0);
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  pipe_16_22_back <= pipe_16_22(0);
  proc_pipe_16_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (pipe_16_22_push_front_pop_back_en = '1')) then
        pipe_16_22(0) <= pipe_16_22_front_din;
      end if;
    end if;
  end process proc_pipe_16_22;
  sel_internal_2_1_convert <= cast(std_logic_to_vector(sel_1_20), 0, 1, 0, xlUnsigned);
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_internal_2_1_convert)
  is
  begin
    case sel_internal_2_1_convert is 
      when "0" =>
        unregy_join_6_1 <= cast(d0_1_24, 0, 3, 0, xlUnsigned);
      when others =>
        unregy_join_6_1 <= d1_1_27;
    end case;
  end process proc_switch_6_1;
  pipe_16_22_front_din <= unregy_join_6_1;
  pipe_16_22_push_front_pop_back_en <= '1';
  y <= pipe_16_22_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_c45d84fc35 is
  port (
    a : in std_logic_vector((3 - 1) downto 0);
    b : in std_logic_vector((2 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_c45d84fc35;


architecture behavior of relational_c45d84fc35 is
  signal a_1_31: unsigned((3 - 1) downto 0);
  signal b_1_34: unsigned((2 - 1) downto 0);
  type array_type_op_mem_32_22 is array (0 to (1 - 1)) of boolean;
  signal op_mem_32_22: array_type_op_mem_32_22 := (
    0 => false);
  signal op_mem_32_22_front_din: boolean;
  signal op_mem_32_22_back: boolean;
  signal op_mem_32_22_push_front_pop_back_en: std_logic;
  signal cast_12_17: unsigned((3 - 1) downto 0);
  signal result_12_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  op_mem_32_22_back <= op_mem_32_22(0);
  proc_op_mem_32_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_32_22_push_front_pop_back_en = '1')) then
        op_mem_32_22(0) <= op_mem_32_22_front_din;
      end if;
    end if;
  end process proc_op_mem_32_22;
  cast_12_17 <= u2u_cast(b_1_34, 0, 3, 0);
  result_12_3_rel <= a_1_31 = cast_12_17;
  op_mem_32_22_front_din <= result_12_3_rel;
  op_mem_32_22_push_front_pop_back_en <= '1';
  op <= boolean_to_vector(op_mem_32_22_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_457b832fd1 is
  port (
    sel : in std_logic_vector((2 - 1) downto 0);
    d0 : in std_logic_vector((64 - 1) downto 0);
    d1 : in std_logic_vector((64 - 1) downto 0);
    d2 : in std_logic_vector((64 - 1) downto 0);
    d3 : in std_logic_vector((64 - 1) downto 0);
    y : out std_logic_vector((64 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_457b832fd1;


architecture behavior of mux_457b832fd1 is
  signal sel_1_20: std_logic_vector((2 - 1) downto 0);
  signal d0_1_24: std_logic_vector((64 - 1) downto 0);
  signal d1_1_27: std_logic_vector((64 - 1) downto 0);
  signal d2_1_30: std_logic_vector((64 - 1) downto 0);
  signal d3_1_33: std_logic_vector((64 - 1) downto 0);
  type array_type_pipe_20_22 is array (0 to (1 - 1)) of std_logic_vector((64 - 1) downto 0);
  signal pipe_20_22: array_type_pipe_20_22 := (
    0 => "0000000000000000000000000000000000000000000000000000000000000000");
  signal pipe_20_22_front_din: std_logic_vector((64 - 1) downto 0);
  signal pipe_20_22_back: std_logic_vector((64 - 1) downto 0);
  signal pipe_20_22_push_front_pop_back_en: std_logic;
  signal unregy_join_6_1: std_logic_vector((64 - 1) downto 0);
begin
  sel_1_20 <= sel;
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  d2_1_30 <= d2;
  d3_1_33 <= d3;
  pipe_20_22_back <= pipe_20_22(0);
  proc_pipe_20_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (pipe_20_22_push_front_pop_back_en = '1')) then
        pipe_20_22(0) <= pipe_20_22_front_din;
      end if;
    end if;
  end process proc_pipe_20_22;
  proc_switch_6_1: process (d0_1_24, d1_1_27, d2_1_30, d3_1_33, sel_1_20)
  is
  begin
    case sel_1_20 is 
      when "00" =>
        unregy_join_6_1 <= d0_1_24;
      when "01" =>
        unregy_join_6_1 <= d1_1_27;
      when "10" =>
        unregy_join_6_1 <= d2_1_30;
      when others =>
        unregy_join_6_1 <= d3_1_33;
    end case;
  end process proc_switch_6_1;
  pipe_20_22_front_din <= unregy_join_6_1;
  pipe_20_22_push_front_pop_back_en <= '1';
  y <= pipe_20_22_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_629e82a6f2 is
  port (
    sel : in std_logic_vector((2 - 1) downto 0);
    d0 : in std_logic_vector((1 - 1) downto 0);
    d1 : in std_logic_vector((1 - 1) downto 0);
    d2 : in std_logic_vector((1 - 1) downto 0);
    d3 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_629e82a6f2;


architecture behavior of mux_629e82a6f2 is
  signal sel_1_20: std_logic_vector((2 - 1) downto 0);
  signal d0_1_24: std_logic;
  signal d1_1_27: std_logic;
  signal d2_1_30: std_logic;
  signal d3_1_33: std_logic;
  type array_type_pipe_20_22 is array (0 to (1 - 1)) of std_logic;
  signal pipe_20_22: array_type_pipe_20_22 := (
    0 => '0');
  signal pipe_20_22_front_din: std_logic;
  signal pipe_20_22_back: std_logic;
  signal pipe_20_22_push_front_pop_back_en: std_logic;
  signal unregy_join_6_1: std_logic;
begin
  sel_1_20 <= sel;
  d0_1_24 <= d0(0);
  d1_1_27 <= d1(0);
  d2_1_30 <= d2(0);
  d3_1_33 <= d3(0);
  pipe_20_22_back <= pipe_20_22(0);
  proc_pipe_20_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (pipe_20_22_push_front_pop_back_en = '1')) then
        pipe_20_22(0) <= pipe_20_22_front_din;
      end if;
    end if;
  end process proc_pipe_20_22;
  proc_switch_6_1: process (d0_1_24, d1_1_27, d2_1_30, d3_1_33, sel_1_20)
  is
  begin
    case sel_1_20 is 
      when "00" =>
        unregy_join_6_1 <= d0_1_24;
      when "01" =>
        unregy_join_6_1 <= d1_1_27;
      when "10" =>
        unregy_join_6_1 <= d2_1_30;
      when others =>
        unregy_join_6_1 <= d3_1_33;
    end case;
  end process proc_switch_6_1;
  pipe_20_22_front_din <= unregy_join_6_1;
  pipe_20_22_push_front_pop_back_en <= '1';
  y <= std_logic_to_vector(pipe_20_22_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_6767bfad71 is
  port (
    in0 : in std_logic_vector((36 - 1) downto 0);
    in1 : in std_logic_vector((36 - 1) downto 0);
    in2 : in std_logic_vector((36 - 1) downto 0);
    in3 : in std_logic_vector((36 - 1) downto 0);
    in4 : in std_logic_vector((36 - 1) downto 0);
    in5 : in std_logic_vector((36 - 1) downto 0);
    in6 : in std_logic_vector((36 - 1) downto 0);
    in7 : in std_logic_vector((36 - 1) downto 0);
    in8 : in std_logic_vector((36 - 1) downto 0);
    in9 : in std_logic_vector((36 - 1) downto 0);
    in10 : in std_logic_vector((36 - 1) downto 0);
    in11 : in std_logic_vector((36 - 1) downto 0);
    in12 : in std_logic_vector((36 - 1) downto 0);
    in13 : in std_logic_vector((36 - 1) downto 0);
    in14 : in std_logic_vector((36 - 1) downto 0);
    in15 : in std_logic_vector((36 - 1) downto 0);
    y : out std_logic_vector((576 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_6767bfad71;


architecture behavior of concat_6767bfad71 is
  signal in0_1_23: unsigned((36 - 1) downto 0);
  signal in1_1_27: unsigned((36 - 1) downto 0);
  signal in2_1_31: unsigned((36 - 1) downto 0);
  signal in3_1_35: unsigned((36 - 1) downto 0);
  signal in4_1_39: unsigned((36 - 1) downto 0);
  signal in5_1_43: unsigned((36 - 1) downto 0);
  signal in6_1_47: unsigned((36 - 1) downto 0);
  signal in7_1_51: unsigned((36 - 1) downto 0);
  signal in8_1_55: unsigned((36 - 1) downto 0);
  signal in9_1_59: unsigned((36 - 1) downto 0);
  signal in10_1_63: unsigned((36 - 1) downto 0);
  signal in11_1_68: unsigned((36 - 1) downto 0);
  signal in12_1_73: unsigned((36 - 1) downto 0);
  signal in13_1_78: unsigned((36 - 1) downto 0);
  signal in14_1_83: unsigned((36 - 1) downto 0);
  signal in15_1_88: unsigned((36 - 1) downto 0);
  signal y_2_1_concat: unsigned((576 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  in2_1_31 <= std_logic_vector_to_unsigned(in2);
  in3_1_35 <= std_logic_vector_to_unsigned(in3);
  in4_1_39 <= std_logic_vector_to_unsigned(in4);
  in5_1_43 <= std_logic_vector_to_unsigned(in5);
  in6_1_47 <= std_logic_vector_to_unsigned(in6);
  in7_1_51 <= std_logic_vector_to_unsigned(in7);
  in8_1_55 <= std_logic_vector_to_unsigned(in8);
  in9_1_59 <= std_logic_vector_to_unsigned(in9);
  in10_1_63 <= std_logic_vector_to_unsigned(in10);
  in11_1_68 <= std_logic_vector_to_unsigned(in11);
  in12_1_73 <= std_logic_vector_to_unsigned(in12);
  in13_1_78 <= std_logic_vector_to_unsigned(in13);
  in14_1_83 <= std_logic_vector_to_unsigned(in14);
  in15_1_88 <= std_logic_vector_to_unsigned(in15);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27) & unsigned_to_std_logic_vector(in2_1_31) & unsigned_to_std_logic_vector(in3_1_35) & unsigned_to_std_logic_vector(in4_1_39) & unsigned_to_std_logic_vector(in5_1_43) & unsigned_to_std_logic_vector(in6_1_47) & unsigned_to_std_logic_vector(in7_1_51) & unsigned_to_std_logic_vector(in8_1_55) & unsigned_to_std_logic_vector(in9_1_59) & unsigned_to_std_logic_vector(in10_1_63) & unsigned_to_std_logic_vector(in11_1_68) & unsigned_to_std_logic_vector(in12_1_73) & unsigned_to_std_logic_vector(in13_1_78) & unsigned_to_std_logic_vector(in14_1_83) & unsigned_to_std_logic_vector(in15_1_88));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_86b044698f is
  port (
    input_port : in std_logic_vector((36 - 1) downto 0);
    output_port : out std_logic_vector((36 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_86b044698f;


architecture behavior of reinterpret_86b044698f is
  signal input_port_1_40: unsigned((36 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port <= unsigned_to_std_logic_vector(input_port_1_40);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_4c449dd556 is
  port (
    op : out std_logic_vector((4 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_4c449dd556;


architecture behavior of constant_4c449dd556 is
begin
  op <= "0000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_7d31a93025 is
  port (
    a : in std_logic_vector((4 - 1) downto 0);
    b : in std_logic_vector((4 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_7d31a93025;


architecture behavior of relational_7d31a93025 is
  signal a_1_31: unsigned((4 - 1) downto 0);
  signal b_1_34: unsigned((4 - 1) downto 0);
  type array_type_op_mem_32_22 is array (0 to (1 - 1)) of boolean;
  signal op_mem_32_22: array_type_op_mem_32_22 := (
    0 => false);
  signal op_mem_32_22_front_din: boolean;
  signal op_mem_32_22_back: boolean;
  signal op_mem_32_22_push_front_pop_back_en: std_logic;
  signal result_18_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  op_mem_32_22_back <= op_mem_32_22(0);
  proc_op_mem_32_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_32_22_push_front_pop_back_en = '1')) then
        op_mem_32_22(0) <= op_mem_32_22_front_din;
      end if;
    end if;
  end process proc_op_mem_32_22;
  result_18_3_rel <= a_1_31 > b_1_34;
  op_mem_32_22_front_din <= result_18_3_rel;
  op_mem_32_22_push_front_pop_back_en <= '1';
  op <= boolean_to_vector(op_mem_32_22_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;

entity dark_pfb_core10 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    data0: in std_logic_vector(23 downto 0); 
    data1: in std_logic_vector(23 downto 0); 
    data2: in std_logic_vector(23 downto 0); 
    data3: in std_logic_vector(23 downto 0); 
    data4: in std_logic_vector(23 downto 0); 
    data5: in std_logic_vector(23 downto 0); 
    data6: in std_logic_vector(23 downto 0); 
    data7: in std_logic_vector(23 downto 0); 
    skip_pfb: in std_logic; 
    sync_in: in std_logic; 
    bin0_t0: out std_logic_vector(35 downto 0); 
    bin0_t1: out std_logic_vector(35 downto 0); 
    bin1_t0: out std_logic_vector(35 downto 0); 
    bin1_t1: out std_logic_vector(35 downto 0); 
    bin2_t0: out std_logic_vector(35 downto 0); 
    bin2_t1: out std_logic_vector(35 downto 0); 
    bin3_t0: out std_logic_vector(35 downto 0); 
    bin3_t1: out std_logic_vector(35 downto 0); 
    bin4_t0: out std_logic_vector(35 downto 0); 
    bin4_t1: out std_logic_vector(35 downto 0); 
    bin5_t0: out std_logic_vector(35 downto 0); 
    bin5_t1: out std_logic_vector(35 downto 0); 
    bin6_t0: out std_logic_vector(35 downto 0); 
    bin6_t1: out std_logic_vector(35 downto 0); 
    bin7_t0: out std_logic_vector(35 downto 0); 
    bin7_t1: out std_logic_vector(35 downto 0); 
    bin_ctr: out std_logic_vector(7 downto 0); 
    fft_rdy: out std_logic; 
    overflow: out std_logic_vector(3 downto 0)
  );
end dark_pfb_core10;

architecture structural of dark_pfb_core10 is
begin
end structural;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_b2d311b112 is
  port (
    in0 : in std_logic_vector((4 - 1) downto 0);
    in1 : in std_logic_vector((12 - 1) downto 0);
    in2 : in std_logic_vector((12 - 1) downto 0);
    in3 : in std_logic_vector((12 - 1) downto 0);
    in4 : in std_logic_vector((12 - 1) downto 0);
    in5 : in std_logic_vector((12 - 1) downto 0);
    y : out std_logic_vector((64 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_b2d311b112;


architecture behavior of concat_b2d311b112 is
  signal in0_1_23: unsigned((4 - 1) downto 0);
  signal in1_1_27: unsigned((12 - 1) downto 0);
  signal in2_1_31: unsigned((12 - 1) downto 0);
  signal in3_1_35: unsigned((12 - 1) downto 0);
  signal in4_1_39: unsigned((12 - 1) downto 0);
  signal in5_1_43: unsigned((12 - 1) downto 0);
  signal y_2_1_concat: unsigned((64 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  in2_1_31 <= std_logic_vector_to_unsigned(in2);
  in3_1_35 <= std_logic_vector_to_unsigned(in3);
  in4_1_39 <= std_logic_vector_to_unsigned(in4);
  in5_1_43 <= std_logic_vector_to_unsigned(in5);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27) & unsigned_to_std_logic_vector(in2_1_31) & unsigned_to_std_logic_vector(in3_1_35) & unsigned_to_std_logic_vector(in4_1_39) & unsigned_to_std_logic_vector(in5_1_43));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_d610556e85 is
  port (
    input_port : in std_logic_vector((4 - 1) downto 0);
    output_port : out std_logic_vector((4 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_d610556e85;


architecture behavior of reinterpret_d610556e85 is
  signal input_port_1_40: unsigned((4 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port <= unsigned_to_std_logic_vector(input_port_1_40);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_98c496058e is
  port (
    op : out std_logic_vector((4 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_98c496058e;


architecture behavior of constant_98c496058e is
begin
  op <= "0101";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_154cbccbb1 is
  port (
    sel : in std_logic_vector((2 - 1) downto 0);
    d0 : in std_logic_vector((12 - 1) downto 0);
    d1 : in std_logic_vector((12 - 1) downto 0);
    d2 : in std_logic_vector((12 - 1) downto 0);
    d3 : in std_logic_vector((12 - 1) downto 0);
    y : out std_logic_vector((12 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_154cbccbb1;


architecture behavior of mux_154cbccbb1 is
  signal sel_1_20: std_logic_vector((2 - 1) downto 0);
  signal d0_1_24: std_logic_vector((12 - 1) downto 0);
  signal d1_1_27: std_logic_vector((12 - 1) downto 0);
  signal d2_1_30: std_logic_vector((12 - 1) downto 0);
  signal d3_1_33: std_logic_vector((12 - 1) downto 0);
  type array_type_pipe_20_22 is array (0 to (1 - 1)) of std_logic_vector((12 - 1) downto 0);
  signal pipe_20_22: array_type_pipe_20_22 := (
    0 => "000000000000");
  signal pipe_20_22_front_din: std_logic_vector((12 - 1) downto 0);
  signal pipe_20_22_back: std_logic_vector((12 - 1) downto 0);
  signal pipe_20_22_push_front_pop_back_en: std_logic;
  signal unregy_join_6_1: std_logic_vector((12 - 1) downto 0);
begin
  sel_1_20 <= sel;
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  d2_1_30 <= d2;
  d3_1_33 <= d3;
  pipe_20_22_back <= pipe_20_22(0);
  proc_pipe_20_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (pipe_20_22_push_front_pop_back_en = '1')) then
        pipe_20_22(0) <= pipe_20_22_front_din;
      end if;
    end if;
  end process proc_pipe_20_22;
  proc_switch_6_1: process (d0_1_24, d1_1_27, d2_1_30, d3_1_33, sel_1_20)
  is
  begin
    case sel_1_20 is 
      when "00" =>
        unregy_join_6_1 <= d0_1_24;
      when "01" =>
        unregy_join_6_1 <= d1_1_27;
      when "10" =>
        unregy_join_6_1 <= d2_1_30;
      when others =>
        unregy_join_6_1 <= d3_1_33;
    end case;
  end process proc_switch_6_1;
  pipe_20_22_front_din <= unregy_join_6_1;
  pipe_20_22_push_front_pop_back_en <= '1';
  y <= pipe_20_22_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_588bf593b1 is
  port (
    a : in std_logic_vector((4 - 1) downto 0);
    b : in std_logic_vector((4 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_588bf593b1;


architecture behavior of relational_588bf593b1 is
  signal a_1_31: unsigned((4 - 1) downto 0);
  signal b_1_34: unsigned((4 - 1) downto 0);
  signal result_22_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  result_22_3_rel <= a_1_31 >= b_1_34;
  op <= boolean_to_vector(result_22_3_rel);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_15f77a5e60 is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_15f77a5e60;


architecture behavior of constant_15f77a5e60 is
begin
  op <= "110010";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_3b3085a060 is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((8 - 1) downto 0);
    d1 : in std_logic_vector((6 - 1) downto 0);
    y : out std_logic_vector((8 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_3b3085a060;


architecture behavior of mux_3b3085a060 is
  signal sel_1_20: std_logic;
  signal d0_1_24: std_logic_vector((8 - 1) downto 0);
  signal d1_1_27: std_logic_vector((6 - 1) downto 0);
  type array_type_pipe_16_22 is array (0 to (1 - 1)) of std_logic_vector((8 - 1) downto 0);
  signal pipe_16_22: array_type_pipe_16_22 := (
    0 => "00000000");
  signal pipe_16_22_front_din: std_logic_vector((8 - 1) downto 0);
  signal pipe_16_22_back: std_logic_vector((8 - 1) downto 0);
  signal pipe_16_22_push_front_pop_back_en: std_logic;
  signal sel_internal_2_1_convert: std_logic_vector((1 - 1) downto 0);
  signal unregy_join_6_1: std_logic_vector((8 - 1) downto 0);
begin
  sel_1_20 <= sel(0);
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  pipe_16_22_back <= pipe_16_22(0);
  proc_pipe_16_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (pipe_16_22_push_front_pop_back_en = '1')) then
        pipe_16_22(0) <= pipe_16_22_front_din;
      end if;
    end if;
  end process proc_pipe_16_22;
  sel_internal_2_1_convert <= cast(std_logic_to_vector(sel_1_20), 0, 1, 0, xlUnsigned);
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_internal_2_1_convert)
  is
  begin
    case sel_internal_2_1_convert is 
      when "0" =>
        unregy_join_6_1 <= d0_1_24;
      when others =>
        unregy_join_6_1 <= cast(d1_1_27, 0, 8, 0, xlUnsigned);
    end case;
  end process proc_switch_6_1;
  pipe_16_22_front_din <= unregy_join_6_1;
  pipe_16_22_push_front_pop_back_en <= '1';
  y <= pipe_16_22_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_7ea0f2fff7 is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_7ea0f2fff7;


architecture behavior of constant_7ea0f2fff7 is
begin
  op <= "000000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_a267c870be is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_a267c870be;


architecture behavior of constant_a267c870be is
begin
  op <= "000001";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_a28c2d1fea is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_a28c2d1fea;


architecture behavior of constant_a28c2d1fea is
begin
  op <= "001010";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_83bfa6ed5c is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_83bfa6ed5c;


architecture behavior of constant_83bfa6ed5c is
begin
  op <= "001011";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_867183d3c8 is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_867183d3c8;


architecture behavior of constant_867183d3c8 is
begin
  op <= "001100";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_ca26f59938 is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_ca26f59938;


architecture behavior of constant_ca26f59938 is
begin
  op <= "001101";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_f8030ea7db is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_f8030ea7db;


architecture behavior of constant_f8030ea7db is
begin
  op <= "001110";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_c11beaf011 is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_c11beaf011;


architecture behavior of constant_c11beaf011 is
begin
  op <= "001111";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_ce6cc530c8 is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_ce6cc530c8;


architecture behavior of constant_ce6cc530c8 is
begin
  op <= "010000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_5a107baba8 is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_5a107baba8;


architecture behavior of constant_5a107baba8 is
begin
  op <= "010001";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_6cb0cf84c0 is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_6cb0cf84c0;


architecture behavior of constant_6cb0cf84c0 is
begin
  op <= "010010";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_3bc8629db1 is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_3bc8629db1;


architecture behavior of constant_3bc8629db1 is
begin
  op <= "010011";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_dfb485d67e is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_dfb485d67e;


architecture behavior of constant_dfb485d67e is
begin
  op <= "000010";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_de3da86eed is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_de3da86eed;


architecture behavior of constant_de3da86eed is
begin
  op <= "010100";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_1f05b15a2d is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_1f05b15a2d;


architecture behavior of constant_1f05b15a2d is
begin
  op <= "010101";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_f36e0964bd is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_f36e0964bd;


architecture behavior of constant_f36e0964bd is
begin
  op <= "010110";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_78bff27356 is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_78bff27356;


architecture behavior of constant_78bff27356 is
begin
  op <= "010111";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_a0835b7af4 is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_a0835b7af4;


architecture behavior of constant_a0835b7af4 is
begin
  op <= "011000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_dadb07d1b2 is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_dadb07d1b2;


architecture behavior of constant_dadb07d1b2 is
begin
  op <= "011001";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_882e6dd45b is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_882e6dd45b;


architecture behavior of constant_882e6dd45b is
begin
  op <= "011010";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_cc8c690106 is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_cc8c690106;


architecture behavior of constant_cc8c690106 is
begin
  op <= "011011";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_bff4dd53be is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_bff4dd53be;


architecture behavior of constant_bff4dd53be is
begin
  op <= "011100";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_c51d3b69e7 is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_c51d3b69e7;


architecture behavior of constant_c51d3b69e7 is
begin
  op <= "011101";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_7838f1fc2f is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_7838f1fc2f;


architecture behavior of constant_7838f1fc2f is
begin
  op <= "000011";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_59f0bb8b82 is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_59f0bb8b82;


architecture behavior of constant_59f0bb8b82 is
begin
  op <= "011110";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_81c0b8ae9e is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_81c0b8ae9e;


architecture behavior of constant_81c0b8ae9e is
begin
  op <= "011111";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_961b61f8a1 is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_961b61f8a1;


architecture behavior of constant_961b61f8a1 is
begin
  op <= "100000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_876b8ff9e3 is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_876b8ff9e3;


architecture behavior of constant_876b8ff9e3 is
begin
  op <= "100001";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_b8537696ec is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_b8537696ec;


architecture behavior of constant_b8537696ec is
begin
  op <= "100010";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_26b082061e is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_26b082061e;


architecture behavior of constant_26b082061e is
begin
  op <= "100011";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_1bd990e6f6 is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_1bd990e6f6;


architecture behavior of constant_1bd990e6f6 is
begin
  op <= "100100";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_b75e4fee82 is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_b75e4fee82;


architecture behavior of constant_b75e4fee82 is
begin
  op <= "100101";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_9a9c207efc is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_9a9c207efc;


architecture behavior of constant_9a9c207efc is
begin
  op <= "100110";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_469b4baee5 is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_469b4baee5;


architecture behavior of constant_469b4baee5 is
begin
  op <= "100111";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_faaf314423 is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_faaf314423;


architecture behavior of constant_faaf314423 is
begin
  op <= "000100";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_bc23896e85 is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_bc23896e85;


architecture behavior of constant_bc23896e85 is
begin
  op <= "101000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_438191f757 is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_438191f757;


architecture behavior of constant_438191f757 is
begin
  op <= "101001";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_04d08db870 is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_04d08db870;


architecture behavior of constant_04d08db870 is
begin
  op <= "101010";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_8207020ee3 is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_8207020ee3;


architecture behavior of constant_8207020ee3 is
begin
  op <= "101011";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_da99e60c9f is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_da99e60c9f;


architecture behavior of constant_da99e60c9f is
begin
  op <= "101100";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_f108a6e809 is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_f108a6e809;


architecture behavior of constant_f108a6e809 is
begin
  op <= "101101";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_dc83107194 is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_dc83107194;


architecture behavior of constant_dc83107194 is
begin
  op <= "101110";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_ef95fb0eb4 is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_ef95fb0eb4;


architecture behavior of constant_ef95fb0eb4 is
begin
  op <= "101111";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_5c27e02321 is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_5c27e02321;


architecture behavior of constant_5c27e02321 is
begin
  op <= "110000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_0a4912b51f is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_0a4912b51f;


architecture behavior of constant_0a4912b51f is
begin
  op <= "110001";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_136a80e78d is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_136a80e78d;


architecture behavior of constant_136a80e78d is
begin
  op <= "000101";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_f934e043ef is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_f934e043ef;


architecture behavior of constant_f934e043ef is
begin
  op <= "000110";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_330e503d71 is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_330e503d71;


architecture behavior of constant_330e503d71 is
begin
  op <= "000111";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_5606c09bd1 is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_5606c09bd1;


architecture behavior of constant_5606c09bd1 is
begin
  op <= "001000";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_abe23f8d53 is
  port (
    op : out std_logic_vector((6 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_abe23f8d53;


architecture behavior of constant_abe23f8d53 is
begin
  op <= "001001";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_87bfab432c is
  port (
    a : in std_logic_vector((8 - 1) downto 0);
    b : in std_logic_vector((6 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_87bfab432c;


architecture behavior of relational_87bfab432c is
  signal a_1_31: unsigned((8 - 1) downto 0);
  signal b_1_34: unsigned((6 - 1) downto 0);
  type array_type_op_mem_32_22 is array (0 to (1 - 1)) of boolean;
  signal op_mem_32_22: array_type_op_mem_32_22 := (
    0 => false);
  signal op_mem_32_22_front_din: boolean;
  signal op_mem_32_22_back: boolean;
  signal op_mem_32_22_push_front_pop_back_en: std_logic;
  signal cast_12_17: unsigned((8 - 1) downto 0);
  signal result_12_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  op_mem_32_22_back <= op_mem_32_22(0);
  proc_op_mem_32_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_32_22_push_front_pop_back_en = '1')) then
        op_mem_32_22(0) <= op_mem_32_22_front_din;
      end if;
    end if;
  end process proc_op_mem_32_22;
  cast_12_17 <= u2u_cast(b_1_34, 0, 8, 0);
  result_12_3_rel <= a_1_31 = cast_12_17;
  op_mem_32_22_front_din <= result_12_3_rel;
  op_mem_32_22_push_front_pop_back_en <= '1';
  op <= boolean_to_vector(op_mem_32_22_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity addsub_7b135dcb24 is
  port (
    a : in std_logic_vector((24 - 1) downto 0);
    b : in std_logic_vector((24 - 1) downto 0);
    s : out std_logic_vector((25 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end addsub_7b135dcb24;


architecture behavior of addsub_7b135dcb24 is
  signal a_17_32: signed((24 - 1) downto 0);
  signal b_17_35: signed((24 - 1) downto 0);
  type array_type_op_mem_91_20 is array (0 to (3 - 1)) of signed((25 - 1) downto 0);
  signal op_mem_91_20: array_type_op_mem_91_20 := (
    "0000000000000000000000000",
    "0000000000000000000000000",
    "0000000000000000000000000");
  signal op_mem_91_20_front_din: signed((25 - 1) downto 0);
  signal op_mem_91_20_back: signed((25 - 1) downto 0);
  signal op_mem_91_20_push_front_pop_back_en: std_logic;
  type array_type_cout_mem_92_22 is array (0 to (3 - 1)) of unsigned((1 - 1) downto 0);
  signal cout_mem_92_22: array_type_cout_mem_92_22 := (
    "0",
    "0",
    "0");
  signal cout_mem_92_22_front_din: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_back: unsigned((1 - 1) downto 0);
  signal cout_mem_92_22_push_front_pop_back_en: std_logic;
  signal prev_mode_93_22_next: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22: unsigned((3 - 1) downto 0);
  signal prev_mode_93_22_reg_i: std_logic_vector((3 - 1) downto 0);
  signal prev_mode_93_22_reg_o: std_logic_vector((3 - 1) downto 0);
  signal cast_69_18: signed((25 - 1) downto 0);
  signal cast_69_22: signed((25 - 1) downto 0);
  signal internal_s_69_5_addsub: signed((25 - 1) downto 0);
begin
  a_17_32 <= std_logic_vector_to_signed(a);
  b_17_35 <= std_logic_vector_to_signed(b);
  op_mem_91_20_back <= op_mem_91_20(2);
  proc_op_mem_91_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_91_20_push_front_pop_back_en = '1')) then
        for i in 2 downto 1 loop 
          op_mem_91_20(i) <= op_mem_91_20(i-1);
        end loop;
        op_mem_91_20(0) <= op_mem_91_20_front_din;
      end if;
    end if;
  end process proc_op_mem_91_20;
  cout_mem_92_22_back <= cout_mem_92_22(2);
  proc_cout_mem_92_22: process (clk)
  is
    variable i_x_000000: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (cout_mem_92_22_push_front_pop_back_en = '1')) then
        for i_x_000000 in 2 downto 1 loop 
          cout_mem_92_22(i_x_000000) <= cout_mem_92_22(i_x_000000-1);
        end loop;
        cout_mem_92_22(0) <= cout_mem_92_22_front_din;
      end if;
    end if;
  end process proc_cout_mem_92_22;
  prev_mode_93_22_reg_i <= unsigned_to_std_logic_vector(prev_mode_93_22_next);
  prev_mode_93_22 <= std_logic_vector_to_unsigned(prev_mode_93_22_reg_o);
  prev_mode_93_22_reg_inst: entity work.synth_reg_w_init
    generic map (
      init_index => 2, 
      init_value => b"010", 
      latency => 1, 
      width => 3)
    port map (
      ce => ce, 
      clk => clk, 
      clr => clr, 
      i => prev_mode_93_22_reg_i, 
      o => prev_mode_93_22_reg_o);
  cast_69_18 <= s2s_cast(a_17_32, 18, 25, 18);
  cast_69_22 <= s2s_cast(b_17_35, 18, 25, 18);
  internal_s_69_5_addsub <= cast_69_18 + cast_69_22;
  op_mem_91_20_front_din <= internal_s_69_5_addsub;
  op_mem_91_20_push_front_pop_back_en <= '1';
  cout_mem_92_22_front_din <= std_logic_vector_to_unsigned("0");
  cout_mem_92_22_push_front_pop_back_en <= '1';
  prev_mode_93_22_next <= std_logic_vector_to_unsigned("000");
  s <= signed_to_std_logic_vector(op_mem_91_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_09169cf4fc is
  port (
    d : in std_logic_vector((25 - 1) downto 0);
    q : out std_logic_vector((25 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_09169cf4fc;


architecture behavior of delay_09169cf4fc is
  signal d_1_22: std_logic_vector((25 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (3 - 1)) of std_logic_vector((25 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "0000000000000000000000000",
    "0000000000000000000000000",
    "0000000000000000000000000");
  signal op_mem_20_24_front_din: std_logic_vector((25 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((25 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(2);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 2 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity delay_d9490c4c59 is
  port (
    d : in std_logic_vector((8 - 1) downto 0);
    q : out std_logic_vector((8 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end delay_d9490c4c59;


architecture behavior of delay_d9490c4c59 is
  signal d_1_22: std_logic_vector((8 - 1) downto 0);
  type array_type_op_mem_20_24 is array (0 to (18 - 1)) of std_logic_vector((8 - 1) downto 0);
  signal op_mem_20_24: array_type_op_mem_20_24 := (
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000",
    "00000000");
  signal op_mem_20_24_front_din: std_logic_vector((8 - 1) downto 0);
  signal op_mem_20_24_back: std_logic_vector((8 - 1) downto 0);
  signal op_mem_20_24_push_front_pop_back_en: std_logic;
begin
  d_1_22 <= d;
  op_mem_20_24_back <= op_mem_20_24(17);
  proc_op_mem_20_24: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_20_24_push_front_pop_back_en = '1')) then
        for i in 17 downto 1 loop 
          op_mem_20_24(i) <= op_mem_20_24(i-1);
        end loop;
        op_mem_20_24(0) <= op_mem_20_24_front_din;
      end if;
    end if;
  end process proc_op_mem_20_24;
  op_mem_20_24_front_din <= d_1_22;
  op_mem_20_24_push_front_pop_back_en <= '1';
  q <= op_mem_20_24_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity inverter_251f82b86b is
  port (
    ip : in std_logic_vector((1 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end inverter_251f82b86b;


architecture behavior of inverter_251f82b86b is
  signal ip_1_26: boolean;
  type array_type_op_mem_22_20 is array (0 to (2 - 1)) of boolean;
  signal op_mem_22_20: array_type_op_mem_22_20 := (
    false,
    false);
  signal op_mem_22_20_front_din: boolean;
  signal op_mem_22_20_back: boolean;
  signal op_mem_22_20_push_front_pop_back_en: std_logic;
  signal internal_ip_12_1_bitnot: boolean;
begin
  ip_1_26 <= ((ip) = "1");
  op_mem_22_20_back <= op_mem_22_20(1);
  proc_op_mem_22_20: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_22_20_push_front_pop_back_en = '1')) then
        for i in 1 downto 1 loop 
          op_mem_22_20(i) <= op_mem_22_20(i-1);
        end loop;
        op_mem_22_20(0) <= op_mem_22_20_front_din;
      end if;
    end if;
  end process proc_op_mem_22_20;
  internal_ip_12_1_bitnot <= ((not boolean_to_vector(ip_1_26)) = "1");
  op_mem_22_20_front_din <= internal_ip_12_1_bitnot;
  op_mem_22_20_push_front_pop_back_en <= '1';
  op <= boolean_to_vector(op_mem_22_20_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_066b498729 is
  port (
    in0 : in std_logic_vector((16 - 1) downto 0);
    in1 : in std_logic_vector((1 - 1) downto 0);
    y : out std_logic_vector((17 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_066b498729;


architecture behavior of concat_066b498729 is
  signal in0_1_23: unsigned((16 - 1) downto 0);
  signal in1_1_27: unsigned((1 - 1) downto 0);
  signal y_2_1_concat: unsigned((17 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_7025463ea8 is
  port (
    input_port : in std_logic_vector((16 - 1) downto 0);
    output_port : out std_logic_vector((16 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_7025463ea8;


architecture behavior of reinterpret_7025463ea8 is
  signal input_port_1_40: signed((16 - 1) downto 0);
  signal output_port_5_5_force: unsigned((16 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_signed(input_port);
  output_port_5_5_force <= signed_to_unsigned(input_port_1_40);
  output_port <= unsigned_to_std_logic_vector(output_port_5_5_force);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity reinterpret_d109c65ff6 is
  port (
    input_port : in std_logic_vector((17 - 1) downto 0);
    output_port : out std_logic_vector((17 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end reinterpret_d109c65ff6;


architecture behavior of reinterpret_d109c65ff6 is
  signal input_port_1_40: unsigned((17 - 1) downto 0);
begin
  input_port_1_40 <= std_logic_vector_to_unsigned(input_port);
  output_port <= unsigned_to_std_logic_vector(input_port_1_40);
end behavior;


-------------------------------------------------------------------
-- System Generator version 14.3 VHDL source file.
--
-- Copyright(C) 2012 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2012 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
-- synopsys translate_off
library XilinxCoreLib;
-- synopsys translate_on
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use work.conv_pkg.all;
entity xlcmult_darkquad29 is
  generic (
    core_name0: string := "";
    a_width: integer := 4;
    a_bin_pt: integer := 2;
    a_arith: integer := xlSigned;
    b_width: integer := 4;
    b_bin_pt: integer := 2;
    b_arith: integer := xlSigned;
    p_width: integer := 8;
    p_bin_pt: integer := 2;
    p_arith: integer := xlSigned;
    rst_width: integer := 1;
    rst_bin_pt: integer := 0;
    rst_arith: integer := xlUnsigned;
    en_width: integer := 1;
    en_bin_pt: integer := 0;
    en_arith: integer := xlUnsigned;
    multsign: integer := xlSigned;
    quantization: integer := xlTruncate;
    overflow: integer := xlWrap;
    extra_registers: integer := 0;
    c_a_width: integer := 7;
    c_b_width: integer := 7;
    c_a_type: integer := 0;
    c_b_type: integer := 0;
    c_type: integer := 0;
    const_bin_pt: integer := 1;
    zero_const : integer := 0;
    c_output_width: integer := 16
  );
  port (
    a: in std_logic_vector(a_width - 1 downto 0);
    ce: in std_logic;
    clr: in std_logic;
    clk: in std_logic;
    core_ce: in std_logic:= '0';
    core_clr: in std_logic:= '0';
    core_clk: in std_logic:= '0';
    rst: in std_logic_vector(rst_width - 1 downto 0);
    en: in std_logic_vector(en_width - 1 downto 0);
    p: out std_logic_vector(p_width - 1 downto 0)
  );
end xlcmult_darkquad29;
architecture behavior of xlcmult_darkquad29 is
  component synth_reg
    generic (
      width: integer := 16;
      latency: integer := 5
    );
    port (
      i: in std_logic_vector(width - 1 downto 0);
      ce: in std_logic;
      clr: in std_logic;
      clk: in std_logic;
      o: out std_logic_vector(width - 1 downto 0)
    );
  end component;
  signal tmp_a: std_logic_vector(c_a_width - 1 downto 0);
  signal tmp_p: std_logic_vector(c_output_width - 1 downto 0);
  signal conv_p: std_logic_vector(p_width - 1 downto 0);
  -- synopsys translate_off
  signal real_a, real_p: real;
  -- synopsys translate_on
  signal nd: std_logic;
  signal internal_ce: std_logic;
  signal internal_clr: std_logic;
  signal internal_core_ce: std_logic;
  component cmlt_11_2_4ea31a3fb6c988bc
    port (
      clk: in std_logic;
      ce: in std_logic;
      sclr: in std_logic;
      p: out std_logic_vector(c_output_width - 1 downto 0);
      a: in std_logic_vector(c_a_width - 1 downto 0)
    );
  end component;

  attribute syn_black_box of cmlt_11_2_4ea31a3fb6c988bc:
    component is true;
  attribute fpga_dont_touch of cmlt_11_2_4ea31a3fb6c988bc:
    component is "true";
  attribute box_type of cmlt_11_2_4ea31a3fb6c988bc:
    component  is "black_box";
begin
  -- synopsys translate_off
  -- synopsys translate_on
  input_process: process(a)
    variable tmp_p_bin_pt, tmp_p_arith: integer;
  begin
    tmp_a <= zero_ext(a, c_a_width);
  end process;
  output_process: process(tmp_p)
  begin
    conv_p <= convert_type(tmp_p, c_output_width, a_bin_pt+b_bin_pt, multsign,
                           p_width, p_bin_pt, p_arith, quantization, overflow);
  end process;
  internal_ce <= ce and en(0);
  internal_core_ce <= core_ce and en(0);
  internal_clr <= (clr or rst(0)) and ce;
  nd <= internal_ce;
  comp0: if ((core_name0 = "cmlt_11_2_4ea31a3fb6c988bc")) generate
    core_instance0: cmlt_11_2_4ea31a3fb6c988bc
      port map (
      sclr => internal_clr,
      clk => clk,
      ce => internal_ce,
      p => tmp_p,
      a => tmp_a
      );
  end generate;
  latency_gt_0: if (extra_registers > 0) and (zero_const = 0)
  generate
    reg: synth_reg
      generic map (
        width => p_width,
        latency => extra_registers
      )
      port map (
        i => conv_p,
        ce => internal_ce,
        clr => internal_clr,
        clk => clk,
        o => p
      );
  end generate;
  latency0: if ( (extra_registers = 0) and (zero_const = 0) )
  generate
    p <= conv_p;
  end generate latency0;
  zero_constant: if (zero_const = 1)
  generate
    p <= integer_to_std_logic_vector(0,p_width,p_arith);
  end generate zero_constant;
end architecture behavior;
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_7360ecf266 is
  port (
    op : out std_logic_vector((18 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_7360ecf266;


architecture behavior of constant_7360ecf266 is
begin
  op <= "011110100001000111";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_79d704dc19 is
  port (
    op : out std_logic_vector((18 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_79d704dc19;


architecture behavior of constant_79d704dc19 is
begin
  op <= "000000000011111001";
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity constant_95b0f967bc is
  port (
    op : out std_logic_vector((18 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end constant_95b0f967bc;


architecture behavior of constant_95b0f967bc is
begin
  op <= "000000000000000000";
end behavior;


-------------------------------------------------------------------
-- System Generator version 14.3 VHDL source file.
--
-- Copyright(C) 2012 by Xilinx, Inc.  All rights reserved.  This
-- text/file contains proprietary, confidential information of Xilinx,
-- Inc., is distributed under license from Xilinx, Inc., and may be used,
-- copied and/or disclosed only pursuant to the terms of a valid license
-- agreement with Xilinx, Inc.  Xilinx hereby grants you a license to use
-- this text/file solely for design, simulation, implementation and
-- creation of design files limited to Xilinx devices or technologies.
-- Use with non-Xilinx devices or technologies is expressly prohibited
-- and immediately terminates your license unless covered by a separate
-- agreement.
--
-- Xilinx is providing this design, code, or information "as is" solely
-- for use in developing programs and solutions for Xilinx devices.  By
-- providing this design, code, or information as one possible
-- implementation of this feature, application or standard, Xilinx is
-- making no representation that this implementation is free from any
-- claims of infringement.  You are responsible for obtaining any rights
-- you may require for your implementation.  Xilinx expressly disclaims
-- any warranty whatsoever with respect to the adequacy of the
-- implementation, including but not limited to warranties of
-- merchantability or fitness for a particular purpose.
--
-- Xilinx products are not intended for use in life support appliances,
-- devices, or systems.  Use in such applications is expressly prohibited.
--
-- Any modifications that are made to the source code are done at the user's
-- sole risk and will be unsupported.
--
-- This copyright and support notice must be retained as part of this
-- text at all times.  (c) Copyright 1995-2012 Xilinx, Inc.  All rights
-- reserved.
-------------------------------------------------------------------
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity convert_pipeline is
    generic (
        old_width   : integer := 16;
        old_bin_pt  : integer := 4;
        old_arith   : integer := xlUnsigned;
        new_width   : integer := 8;
        new_bin_pt  : integer := 2;
        new_arith   : integer := xlUnsigned;
        en_width    : integer := 1;
        en_bin_pt   : integer := 0;
        en_arith    : integer := xlUnsigned;
        quantization : integer := xlTruncate;
        overflow    : integer := xlWrap;
        latency     : integer := 1);
    port (
        din : in std_logic_vector (old_width-1 downto 0);
        en  : in std_logic_vector (en_width-1 downto 0);
        ce  : in std_logic;
        clr : in std_logic;
        clk : in std_logic;
        result : out std_logic_vector (new_width-1 downto 0));
end convert_pipeline;
architecture behavior of convert_pipeline is
    component synth_reg
        generic (width       : integer;
                 latency     : integer);
        port (i           : in std_logic_vector(width-1 downto 0);
              ce      : in std_logic;
              clr     : in std_logic;
              clk     : in std_logic;
              o       : out std_logic_vector(width-1 downto 0));
    end component;
    constant fp_width : integer := old_width + 2;
    constant fp_bin_pt : integer := old_bin_pt;
    constant fp_arith : integer := old_arith;
    constant q_width : integer := (old_width + 2) + (new_bin_pt - old_bin_pt);
    constant q_bin_pt : integer := new_bin_pt;
    constant q_arith : integer := old_arith;
    signal full_precision_result_in, full_precision_result_out
        : std_logic_vector(fp_width-1 downto 0);
    signal quantized_result_in, quantized_result_out
        : std_logic_vector(q_width-1 downto 0);
    signal result_in : std_logic_vector(new_width-1 downto 0):= (others => '0');
    signal internal_ce : std_logic;
begin
    internal_ce <= ce and en(0);

    fp_result : process (din)
    begin
        full_precision_result_in <= cast(din, old_bin_pt,
                                         fp_width, fp_bin_pt, fp_arith);
    end process;
    latency_fpr : if (latency > 2)
    generate
        reg_fpr : synth_reg
            generic map ( width => fp_width,
                          latency => 1)
            port map (i => full_precision_result_in,
                      ce => internal_ce,
                      clr => clr,
                      clk => clk,
                      o => full_precision_result_out);
    end generate;
    no_latency_fpr : if (latency < 3)
    generate
        full_precision_result_out <= full_precision_result_in;
    end generate;
    xlround_generate : if (quantization = xlRound)
    generate
      xlround_result : process (full_precision_result_out)
      begin
          quantized_result_in <= round_towards_inf(full_precision_result_out,
                                                   fp_width, fp_bin_pt,
                                                   fp_arith, q_width, q_bin_pt,
                                                   q_arith);
      end process;
    end generate;
    xlroundbanker_generate : if (quantization = xlRoundBanker)
    generate
      xlroundbanker_result : process (full_precision_result_out)
      begin
          quantized_result_in <= round_towards_even(full_precision_result_out,
                                                   fp_width, fp_bin_pt,
                                                   fp_arith, q_width, q_bin_pt,
                                                   q_arith);
      end process;
    end generate;
    xltruncate_generate : if (quantization = xlTruncate)
    generate
      xltruncate_result : process (full_precision_result_out)
      begin
          quantized_result_in <= trunc(full_precision_result_out,
                                       fp_width, fp_bin_pt,
                                       fp_arith, q_width, q_bin_pt,
                                       q_arith);
      end process;
    end generate;
    latency_qr : if (latency > 1)
    generate
        reg_qr : synth_reg
            generic map ( width => q_width,
                          latency => 1)
            port map (i => quantized_result_in,
                      ce => internal_ce,
                      clr => clr,
                      clk => clk,
                      o => quantized_result_out);
    end generate;
    no_latency_qr : if (latency < 2)
    generate
        quantized_result_out <= quantized_result_in;
    end generate;
    xlsaturate_generate : if (overflow = xlSaturate)
    generate
      xlsaturate_result : process (quantized_result_out)
      begin
          result_in <= saturation_arith(quantized_result_out, q_width, q_bin_pt,
                                       q_arith, new_width, new_bin_pt, new_arith);
      end process;
    end generate;
    xlwrap_generate : if (overflow = xlWrap)
    generate
      xlwrap_result : process (quantized_result_out)
      begin
          result_in <= wrap_arith(quantized_result_out, q_width, q_bin_pt,
                                  q_arith, new_width, new_bin_pt, new_arith);
      end process;
    end generate;
    latency_gt_3 : if (latency > 3)
    generate
        reg_out : synth_reg
            generic map ( width => new_width,
                          latency => latency-2)
            port map (i => result_in,
                      ce => internal_ce,
                      clr => clr,
                      clk => clk,
                      o => result);
    end generate;
    latency_lt_4 : if ((latency < 4) and (latency > 0))
    generate
        reg_out : synth_reg
            generic map ( width => new_width,
                          latency => 1)
            port map (i => result_in,
                      ce => internal_ce,
                      clr => clr,
                      clk => clk,
                      o => result);
    end generate;
    latency0 : if (latency = 0)
    generate
        result <= result_in;
    end generate latency0;
end behavior;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;
entity xlconvert_pipeline is
    generic (
        din_width    : integer := 16;
        din_bin_pt   : integer := 4;
        din_arith    : integer := xlUnsigned;
        dout_width   : integer := 8;
        dout_bin_pt  : integer := 2;
        dout_arith   : integer := xlUnsigned;
        en_width     : integer := 1;
        en_bin_pt    : integer := 0;
        en_arith     : integer := xlUnsigned;
        bool_conversion : integer :=0;
        latency      : integer := 0;
        quantization : integer := xlTruncate;
        overflow     : integer := xlWrap);
    port (
        din  : in std_logic_vector (din_width-1 downto 0);
        en   : in std_logic_vector (en_width-1 downto 0);
        ce   : in std_logic;
        clr  : in std_logic;
        clk  : in std_logic;
        dout : out std_logic_vector (dout_width-1 downto 0));
end xlconvert_pipeline;
architecture behavior of xlconvert_pipeline is
    component convert_pipeline
        generic (
            old_width    : integer := 16;
            old_bin_pt   : integer := 4;
            old_arith    : integer := xlUnsigned;
            new_width    : integer := 8;
            new_bin_pt   : integer := 2;
            new_arith    : integer := xlUnsigned;
            en_width     : integer := 1;
            en_bin_pt    : integer := 0;
            en_arith     : integer := xlUnsigned;
            quantization : integer := xlTruncate;
            overflow     : integer := xlWrap;
            latency      : integer := 1);
        port (
            din    : in std_logic_vector (din_width-1 downto 0);
            en     : in std_logic_vector (en_width-1 downto 0);
            ce     : in std_logic;
            clr    : in std_logic;
            clk    : in std_logic;
            result : out std_logic_vector (dout_width-1 downto 0));
    end component;
   begin
      convert : convert_pipeline
        generic map (
          old_width   => din_width,
          old_bin_pt  => din_bin_pt,
          old_arith   => din_arith,
          new_width   => dout_width,
          new_bin_pt  => dout_bin_pt,
          new_arith   => dout_arith,
          en_width    => en_width,
          en_bin_pt   => en_bin_pt,
          en_arith    => en_arith,
          quantization => quantization,
          overflow    => overflow,
          latency     => latency)
        port map (
          din => din,
          en => en,
          ce => ce,
          clr => clr,
          clk => clk,
          result => dout);
end  behavior;
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_14f77d7b05 is
  port (
    a : in std_logic_vector((32 - 1) downto 0);
    b : in std_logic_vector((32 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_14f77d7b05;


architecture behavior of relational_14f77d7b05 is
  signal a_1_31: unsigned((32 - 1) downto 0);
  signal b_1_34: unsigned((32 - 1) downto 0);
  signal result_14_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  result_14_3_rel <= a_1_31 /= b_1_34;
  op <= boolean_to_vector(result_14_3_rel);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_d7ca0c4e6b is
  port (
    a : in std_logic_vector((18 - 1) downto 0);
    b : in std_logic_vector((28 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_d7ca0c4e6b;


architecture behavior of relational_d7ca0c4e6b is
  signal a_1_31: signed((18 - 1) downto 0);
  signal b_1_34: unsigned((28 - 1) downto 0);
  signal cast_12_12: signed((29 - 1) downto 0);
  signal cast_12_17: signed((29 - 1) downto 0);
  signal result_12_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_signed(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  cast_12_12 <= s2s_cast(a_1_31, 0, 29, 0);
  cast_12_17 <= u2s_cast(b_1_34, 0, 29, 0);
  result_12_3_rel <= cast_12_12 = cast_12_17;
  op <= boolean_to_vector(result_12_3_rel);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_4a12466dac is
  port (
    a : in std_logic_vector((18 - 1) downto 0);
    b : in std_logic_vector((10 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_4a12466dac;


architecture behavior of relational_4a12466dac is
  signal a_1_31: signed((18 - 1) downto 0);
  signal b_1_34: unsigned((10 - 1) downto 0);
  signal cast_12_17: signed((18 - 1) downto 0);
  signal result_12_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_signed(a);
  b_1_34 <= std_logic_vector_to_unsigned(b);
  cast_12_17 <= u2s_cast(b_1_34, 0, 18, 0);
  result_12_3_rel <= a_1_31 = cast_12_17;
  op <= boolean_to_vector(result_12_3_rel);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_5aa7219969 is
  port (
    a : in std_logic_vector((28 - 1) downto 0);
    b : in std_logic_vector((18 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_5aa7219969;


architecture behavior of relational_5aa7219969 is
  signal a_1_31: unsigned((28 - 1) downto 0);
  signal b_1_34: signed((18 - 1) downto 0);
  type array_type_op_mem_32_22 is array (0 to (1 - 1)) of boolean;
  signal op_mem_32_22: array_type_op_mem_32_22 := (
    0 => false);
  signal op_mem_32_22_front_din: boolean;
  signal op_mem_32_22_back: boolean;
  signal op_mem_32_22_push_front_pop_back_en: std_logic;
  signal cast_12_12: signed((29 - 1) downto 0);
  signal cast_12_17: signed((29 - 1) downto 0);
  signal result_12_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_signed(b);
  op_mem_32_22_back <= op_mem_32_22(0);
  proc_op_mem_32_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_32_22_push_front_pop_back_en = '1')) then
        op_mem_32_22(0) <= op_mem_32_22_front_din;
      end if;
    end if;
  end process proc_op_mem_32_22;
  cast_12_12 <= u2s_cast(a_1_31, 0, 29, 0);
  cast_12_17 <= s2s_cast(b_1_34, 0, 29, 0);
  result_12_3_rel <= cast_12_12 = cast_12_17;
  op_mem_32_22_front_din <= result_12_3_rel;
  op_mem_32_22_push_front_pop_back_en <= '1';
  op <= boolean_to_vector(op_mem_32_22_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity relational_f4e3c98493 is
  port (
    a : in std_logic_vector((10 - 1) downto 0);
    b : in std_logic_vector((18 - 1) downto 0);
    op : out std_logic_vector((1 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end relational_f4e3c98493;


architecture behavior of relational_f4e3c98493 is
  signal a_1_31: unsigned((10 - 1) downto 0);
  signal b_1_34: signed((18 - 1) downto 0);
  type array_type_op_mem_32_22 is array (0 to (1 - 1)) of boolean;
  signal op_mem_32_22: array_type_op_mem_32_22 := (
    0 => false);
  signal op_mem_32_22_front_din: boolean;
  signal op_mem_32_22_back: boolean;
  signal op_mem_32_22_push_front_pop_back_en: std_logic;
  signal cast_12_12: signed((18 - 1) downto 0);
  signal result_12_3_rel: boolean;
begin
  a_1_31 <= std_logic_vector_to_unsigned(a);
  b_1_34 <= std_logic_vector_to_signed(b);
  op_mem_32_22_back <= op_mem_32_22(0);
  proc_op_mem_32_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (op_mem_32_22_push_front_pop_back_en = '1')) then
        op_mem_32_22(0) <= op_mem_32_22_front_din;
      end if;
    end if;
  end process proc_op_mem_32_22;
  cast_12_12 <= u2s_cast(a_1_31, 0, 18, 0);
  result_12_3_rel <= cast_12_12 = b_1_34;
  op_mem_32_22_front_din <= result_12_3_rel;
  op_mem_32_22_push_front_pop_back_en <= '1';
  op <= boolean_to_vector(op_mem_32_22_back);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity concat_5a376c5bcd is
  port (
    in0 : in std_logic_vector((8 - 1) downto 0);
    in1 : in std_logic_vector((8 - 1) downto 0);
    in2 : in std_logic_vector((12 - 1) downto 0);
    in3 : in std_logic_vector((36 - 1) downto 0);
    y : out std_logic_vector((64 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end concat_5a376c5bcd;


architecture behavior of concat_5a376c5bcd is
  signal in0_1_23: unsigned((8 - 1) downto 0);
  signal in1_1_27: unsigned((8 - 1) downto 0);
  signal in2_1_31: unsigned((12 - 1) downto 0);
  signal in3_1_35: unsigned((36 - 1) downto 0);
  signal y_2_1_concat: unsigned((64 - 1) downto 0);
begin
  in0_1_23 <= std_logic_vector_to_unsigned(in0);
  in1_1_27 <= std_logic_vector_to_unsigned(in1);
  in2_1_31 <= std_logic_vector_to_unsigned(in2);
  in3_1_35 <= std_logic_vector_to_unsigned(in3);
  y_2_1_concat <= std_logic_vector_to_unsigned(unsigned_to_std_logic_vector(in0_1_23) & unsigned_to_std_logic_vector(in1_1_27) & unsigned_to_std_logic_vector(in2_1_31) & unsigned_to_std_logic_vector(in3_1_35));
  y <= unsigned_to_std_logic_vector(y_2_1_concat);
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_bfe1d4f686 is
  port (
    sel : in std_logic_vector((1 - 1) downto 0);
    d0 : in std_logic_vector((16 - 1) downto 0);
    d1 : in std_logic_vector((16 - 1) downto 0);
    y : out std_logic_vector((16 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_bfe1d4f686;


architecture behavior of mux_bfe1d4f686 is
  signal sel_1_20: std_logic;
  signal d0_1_24: std_logic_vector((16 - 1) downto 0);
  signal d1_1_27: std_logic_vector((16 - 1) downto 0);
  type array_type_pipe_16_22 is array (0 to (1 - 1)) of std_logic_vector((16 - 1) downto 0);
  signal pipe_16_22: array_type_pipe_16_22 := (
    0 => "0000000000000000");
  signal pipe_16_22_front_din: std_logic_vector((16 - 1) downto 0);
  signal pipe_16_22_back: std_logic_vector((16 - 1) downto 0);
  signal pipe_16_22_push_front_pop_back_en: std_logic;
  signal sel_internal_2_1_convert: std_logic_vector((1 - 1) downto 0);
  signal unregy_join_6_1: std_logic_vector((16 - 1) downto 0);
begin
  sel_1_20 <= sel(0);
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  pipe_16_22_back <= pipe_16_22(0);
  proc_pipe_16_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (pipe_16_22_push_front_pop_back_en = '1')) then
        pipe_16_22(0) <= pipe_16_22_front_din;
      end if;
    end if;
  end process proc_pipe_16_22;
  sel_internal_2_1_convert <= cast(std_logic_to_vector(sel_1_20), 0, 1, 0, xlUnsigned);
  proc_switch_6_1: process (d0_1_24, d1_1_27, sel_internal_2_1_convert)
  is
  begin
    case sel_internal_2_1_convert is 
      when "0" =>
        unregy_join_6_1 <= d0_1_24;
      when others =>
        unregy_join_6_1 <= d1_1_27;
    end case;
  end process proc_switch_6_1;
  pipe_16_22_front_din <= unregy_join_6_1;
  pipe_16_22_push_front_pop_back_en <= '1';
  y <= pipe_16_22_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use work.conv_pkg.all;

entity mux_597bf1b21b is
  port (
    sel : in std_logic_vector((2 - 1) downto 0);
    d0 : in std_logic_vector((16 - 1) downto 0);
    d1 : in std_logic_vector((16 - 1) downto 0);
    d2 : in std_logic_vector((16 - 1) downto 0);
    d3 : in std_logic_vector((16 - 1) downto 0);
    y : out std_logic_vector((16 - 1) downto 0);
    clk : in std_logic;
    ce : in std_logic;
    clr : in std_logic);
end mux_597bf1b21b;


architecture behavior of mux_597bf1b21b is
  signal sel_1_20: std_logic_vector((2 - 1) downto 0);
  signal d0_1_24: std_logic_vector((16 - 1) downto 0);
  signal d1_1_27: std_logic_vector((16 - 1) downto 0);
  signal d2_1_30: std_logic_vector((16 - 1) downto 0);
  signal d3_1_33: std_logic_vector((16 - 1) downto 0);
  type array_type_pipe_20_22 is array (0 to (1 - 1)) of std_logic_vector((16 - 1) downto 0);
  signal pipe_20_22: array_type_pipe_20_22 := (
    0 => "0000000000000000");
  signal pipe_20_22_front_din: std_logic_vector((16 - 1) downto 0);
  signal pipe_20_22_back: std_logic_vector((16 - 1) downto 0);
  signal pipe_20_22_push_front_pop_back_en: std_logic;
  signal unregy_join_6_1: std_logic_vector((16 - 1) downto 0);
begin
  sel_1_20 <= sel;
  d0_1_24 <= d0;
  d1_1_27 <= d1;
  d2_1_30 <= d2;
  d3_1_33 <= d3;
  pipe_20_22_back <= pipe_20_22(0);
  proc_pipe_20_22: process (clk)
  is
    variable i: integer;
  begin
    if (clk'event and (clk = '1')) then
      if ((ce = '1') and (pipe_20_22_push_front_pop_back_en = '1')) then
        pipe_20_22(0) <= pipe_20_22_front_din;
      end if;
    end if;
  end process proc_pipe_20_22;
  proc_switch_6_1: process (d0_1_24, d1_1_27, d2_1_30, d3_1_33, sel_1_20)
  is
  begin
    case sel_1_20 is 
      when "00" =>
        unregy_join_6_1 <= d0_1_24;
      when "01" =>
        unregy_join_6_1 <= d1_1_27;
      when "10" =>
        unregy_join_6_1 <= d2_1_30;
      when others =>
        unregy_join_6_1 <= d3_1_33;
    end case;
  end process proc_switch_6_1;
  pipe_20_22_front_din <= unregy_join_6_1;
  pipe_20_22_push_front_pop_back_en <= '1';
  y <= pipe_20_22_back;
end behavior;

library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/a2g_ctrl/adcdac_2g_ctrl"

entity adcdac_2g_ctrl_entity_3417bb5b56 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    tx_data: in std_logic_vector(7 downto 0); 
    tx_rst: in std_logic; 
    tx_val: in std_logic; 
    convert1_x0: out std_logic; 
    convert3_x0: out std_logic_vector(7 downto 0); 
    convert4_x0: out std_logic; 
    convert5_x0: out std_logic
  );
end adcdac_2g_ctrl_entity_3417bb5b56;

architecture structural of adcdac_2g_ctrl_entity_3417bb5b56 is
  signal ce_1_sg_x0: std_logic;
  signal clk_1_sg_x0: std_logic;
  signal convert1_dout_net_x0: std_logic;
  signal convert3_dout_net_x0: std_logic_vector(7 downto 0);
  signal convert4_dout_net_x0: std_logic;
  signal convert5_dout_net_x0: std_logic;
  signal delay15_q_net_x0: std_logic;
  signal delay1_q_net_x0: std_logic_vector(7 downto 0);
  signal delay6_q_net_x0: std_logic;

begin
  ce_1_sg_x0 <= ce_1;
  clk_1_sg_x0 <= clk_1;
  delay1_q_net_x0 <= tx_data;
  delay15_q_net_x0 <= tx_rst;
  delay6_q_net_x0 <= tx_val;
  convert1_x0 <= convert1_dout_net_x0;
  convert3_x0 <= convert3_dout_net_x0;
  convert4_x0 <= convert4_dout_net_x0;
  convert5_x0 <= convert5_dout_net_x0;

  convert1: entity work.xlconvert
    generic map (
      bool_conversion => 1,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x0,
      clk => clk_1_sg_x0,
      clr => '0',
      din(0) => delay15_q_net_x0,
      en => "1",
      dout(0) => convert1_dout_net_x0
    );

  convert3: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 8,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 8,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x0,
      clk => clk_1_sg_x0,
      clr => '0',
      din => delay1_q_net_x0,
      en => "1",
      dout => convert3_dout_net_x0
    );

  convert4: entity work.xlconvert
    generic map (
      bool_conversion => 1,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x0,
      clk => clk_1_sg_x0,
      clr => '0',
      din(0) => delay15_q_net_x0,
      en => "1",
      dout(0) => convert4_dout_net_x0
    );

  convert5: entity work.xlconvert
    generic map (
      bool_conversion => 1,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x0,
      clk => clk_1_sg_x0,
      clr => '0',
      din(0) => delay6_q_net_x0,
      en => "1",
      dout(0) => convert5_dout_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/a2g_ctrl/edge_detect3"

entity edge_detect3_entity_2efb246ca9 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic; 
    out_x0: out std_logic
  );
end edge_detect3_entity_2efb246ca9;

architecture structural of edge_detect3_entity_2efb246ca9 is
  signal ce_1_sg_x1: std_logic;
  signal clk_1_sg_x1: std_logic;
  signal delay_q_net: std_logic;
  signal edge_op_y_net_x0: std_logic;
  signal inverter_op_net: std_logic;
  signal register1_q_net_x0: std_logic;

begin
  ce_1_sg_x1 <= ce_1;
  clk_1_sg_x1 <= clk_1;
  register1_q_net_x0 <= in_x0;
  out_x0 <= edge_op_y_net_x0;

  delay: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x1,
      clk => clk_1_sg_x1,
      d(0) => register1_q_net_x0,
      en => '1',
      rst => '1',
      q(0) => delay_q_net
    );

  edge_op: entity work.logical_dfe2dded7f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => inverter_op_net,
      d1(0) => delay_q_net,
      y(0) => edge_op_y_net_x0
    );

  inverter: entity work.inverter_e5b38cca3b
    port map (
      ce => ce_1_sg_x1,
      clk => clk_1_sg_x1,
      clr => '0',
      ip(0) => register1_q_net_x0,
      op(0) => inverter_op_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/a2g_ctrl/en_bram_dump"

entity en_bram_dump_entity_fbeb935a30 is
  port (
    darkquad29_a2g_ctrl_en_bram_dump_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end en_bram_dump_entity_fbeb935a30;

architecture structural of en_bram_dump_entity_fbeb935a30 is
  signal darkquad29_a2g_ctrl_en_bram_dump_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_a2g_ctrl_en_bram_dump_user_data_out_net_x0 <= darkquad29_a2g_ctrl_en_bram_dump_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_a2g_ctrl_en_bram_dump_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/a2g_ctrl/in_val"

entity in_val_entity_11b51ff9fe is
  port (
    darkquad29_a2g_ctrl_in_val_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end in_val_entity_11b51ff9fe;

architecture structural of in_val_entity_11b51ff9fe is
  signal darkquad29_a2g_ctrl_in_val_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_a2g_ctrl_in_val_user_data_out_net_x0 <= darkquad29_a2g_ctrl_in_val_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_a2g_ctrl_in_val_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/a2g_ctrl/last_tx_data"

entity last_tx_data_entity_4b5ba71046 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    out_reg: in std_logic_vector(31 downto 0); 
    cast_gw_x0: out std_logic_vector(31 downto 0)
  );
end last_tx_data_entity_4b5ba71046;

architecture structural of last_tx_data_entity_4b5ba71046 is
  signal assert_reg_dout_net: std_logic_vector(31 downto 0);
  signal cast_gw_dout_net_x0: std_logic_vector(31 downto 0);
  signal ce_1_sg_x2: std_logic;
  signal clk_1_sg_x2: std_logic;
  signal convert5_dout_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net: std_logic_vector(31 downto 0);

begin
  ce_1_sg_x2 <= ce_1;
  clk_1_sg_x2 <= clk_1;
  convert5_dout_net_x0 <= out_reg;
  cast_gw_x0 <= cast_gw_dout_net_x0;

  assert_reg: entity work.xlpassthrough
    generic map (
      din_width => 32,
      dout_width => 32
    )
    port map (
      din => convert5_dout_net_x0,
      dout => assert_reg_dout_net
    );

  cast_gw: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 32,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x2,
      clk => clk_1_sg_x2,
      clr => '0',
      din => io_delay_q_net,
      en => "1",
      dout => cast_gw_dout_net_x0
    );

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => reint1_output_port_net,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => assert_reg_dout_net,
      output_port => reint1_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/a2g_ctrl/lut_dump/buffer_size"

entity buffer_size_entity_527d8c4939 is
  port (
    darkquad29_a2g_ctrl_lut_dump_buffer_size_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end buffer_size_entity_527d8c4939;

architecture structural of buffer_size_entity_527d8c4939 is
  signal darkquad29_a2g_ctrl_lut_dump_buffer_size_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_a2g_ctrl_lut_dump_buffer_size_user_data_out_net_x0 <= darkquad29_a2g_ctrl_lut_dump_buffer_size_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_a2g_ctrl_lut_dump_buffer_size_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/a2g_ctrl/lut_dump/dac_lut_buffer/calc_add"

entity calc_add_entity_3c48ddb5fa is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(31 downto 0); 
    out_x0: out std_logic_vector(11 downto 0)
  );
end calc_add_entity_3c48ddb5fa;

architecture structural of calc_add_entity_3c48ddb5fa is
  signal add_sub_s_net: std_logic_vector(1 downto 0);
  signal ce_1_sg_x3: std_logic;
  signal clk_1_sg_x3: std_logic;
  signal concat_y_net: std_logic_vector(11 downto 0);
  signal const_op_net: std_logic_vector(1 downto 0);
  signal convert_addr_dout_net: std_logic_vector(11 downto 0);
  signal counter1_op_net_x0: std_logic_vector(31 downto 0);
  signal lsw_y_net: std_logic_vector(1 downto 0);
  signal manipulate_op_net: std_logic;
  signal msw_y_net: std_logic_vector(9 downto 0);
  signal mux_y_net_x0: std_logic_vector(11 downto 0);

begin
  ce_1_sg_x3 <= ce_1;
  clk_1_sg_x3 <= clk_1;
  counter1_op_net_x0 <= in_x0;
  out_x0 <= mux_y_net_x0;

  add_sub: entity work.addsub_fd757d4b63
    port map (
      a => const_op_net,
      b => lsw_y_net,
      ce => ce_1_sg_x3,
      clk => clk_1_sg_x3,
      clr => '0',
      s => add_sub_s_net
    );

  concat: entity work.concat_17ed0a7299
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => msw_y_net,
      in1 => add_sub_s_net,
      y => concat_y_net
    );

  const: entity work.constant_3a9a3daeb9
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const_op_net
    );

  convert_addr: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 32,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 12,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x3,
      clk => clk_1_sg_x3,
      clr => '0',
      din => counter1_op_net_x0,
      en => "1",
      dout => convert_addr_dout_net
    );

  lsw: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 1,
      x_width => 12,
      y_width => 2
    )
    port map (
      x => convert_addr_dout_net,
      y => lsw_y_net
    );

  manipulate: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => manipulate_op_net
    );

  msw: entity work.xlslice
    generic map (
      new_lsb => 2,
      new_msb => 11,
      x_width => 12,
      y_width => 10
    )
    port map (
      x => convert_addr_dout_net,
      y => msw_y_net
    );

  mux: entity work.mux_c3e1ddb86e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0 => convert_addr_dout_net,
      d1 => concat_y_net,
      sel(0) => manipulate_op_net,
      y => mux_y_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/a2g_ctrl/lut_dump/dac_lut_buffer/munge_in"

entity munge_in_entity_9341d54c73 is
  port (
    din: in std_logic_vector(31 downto 0); 
    dout: out std_logic_vector(31 downto 0)
  );
end munge_in_entity_9341d54c73;

architecture structural of munge_in_entity_9341d54c73 is
  signal constant4_op_net_x0: std_logic_vector(31 downto 0);
  signal reinterpret_out_output_port_net_x0: std_logic_vector(31 downto 0);

begin
  constant4_op_net_x0 <= din;
  dout <= reinterpret_out_output_port_net_x0;

  reinterpret_out: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => constant4_op_net_x0,
      output_port => reinterpret_out_output_port_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/a2g_ctrl/lut_dump/dac_lut_buffer/munge_out"

entity munge_out_entity_3d02ed9321 is
  port (
    din: in std_logic_vector(7 downto 0); 
    dout: out std_logic_vector(7 downto 0)
  );
end munge_out_entity_3d02ed9321;

architecture structural of munge_out_entity_3d02ed9321 is
  signal darkquad29_a2g_ctrl_lut_dump_dac_lut_buffer_data_out_net_x0: std_logic_vector(7 downto 0);
  signal reinterpret_out_output_port_net_x0: std_logic_vector(7 downto 0);

begin
  darkquad29_a2g_ctrl_lut_dump_dac_lut_buffer_data_out_net_x0 <= din;
  dout <= reinterpret_out_output_port_net_x0;

  reinterpret_out: entity work.reinterpret_f21e7f2ddf
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => darkquad29_a2g_ctrl_lut_dump_dac_lut_buffer_data_out_net_x0,
      output_port => reinterpret_out_output_port_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/a2g_ctrl/lut_dump/dac_lut_buffer"

entity dac_lut_buffer_entity_60dc54f53b is
  port (
    addr: in std_logic_vector(31 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    darkquad29_a2g_ctrl_lut_dump_dac_lut_buffer_data_out: in std_logic_vector(7 downto 0); 
    data_in: in std_logic_vector(31 downto 0); 
    we: in std_logic; 
    convert_addr_x0: out std_logic_vector(11 downto 0); 
    convert_din1_x0: out std_logic_vector(7 downto 0); 
    convert_we_x0: out std_logic; 
    data_out: out std_logic_vector(7 downto 0)
  );
end dac_lut_buffer_entity_60dc54f53b;

architecture structural of dac_lut_buffer_entity_60dc54f53b is
  signal ce_1_sg_x4: std_logic;
  signal clk_1_sg_x4: std_logic;
  signal constant2_op_net_x0: std_logic;
  signal constant4_op_net_x1: std_logic_vector(31 downto 0);
  signal convert_addr_dout_net_x0: std_logic_vector(11 downto 0);
  signal convert_din1_dout_net_x0: std_logic_vector(7 downto 0);
  signal convert_we_dout_net_x0: std_logic;
  signal counter1_op_net_x1: std_logic_vector(31 downto 0);
  signal darkquad29_a2g_ctrl_lut_dump_dac_lut_buffer_data_out_net_x1: std_logic_vector(7 downto 0);
  signal mux_y_net_x0: std_logic_vector(11 downto 0);
  signal reinterpret_out_output_port_net_x0: std_logic_vector(31 downto 0);
  signal reinterpret_out_output_port_net_x2: std_logic_vector(7 downto 0);

begin
  counter1_op_net_x1 <= addr;
  ce_1_sg_x4 <= ce_1;
  clk_1_sg_x4 <= clk_1;
  darkquad29_a2g_ctrl_lut_dump_dac_lut_buffer_data_out_net_x1 <= darkquad29_a2g_ctrl_lut_dump_dac_lut_buffer_data_out;
  constant4_op_net_x1 <= data_in;
  constant2_op_net_x0 <= we;
  convert_addr_x0 <= convert_addr_dout_net_x0;
  convert_din1_x0 <= convert_din1_dout_net_x0;
  convert_we_x0 <= convert_we_dout_net_x0;
  data_out <= reinterpret_out_output_port_net_x2;

  calc_add_3c48ddb5fa: entity work.calc_add_entity_3c48ddb5fa
    port map (
      ce_1 => ce_1_sg_x4,
      clk_1 => clk_1_sg_x4,
      in_x0 => counter1_op_net_x1,
      out_x0 => mux_y_net_x0
    );

  convert_addr: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 12,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 12,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x4,
      clk => clk_1_sg_x4,
      clr => '0',
      din => mux_y_net_x0,
      en => "1",
      dout => convert_addr_dout_net_x0
    );

  convert_din1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 32,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 8,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '1',
      clk => '1',
      clr => '0',
      din => reinterpret_out_output_port_net_x0,
      en => "1",
      dout => convert_din1_dout_net_x0
    );

  convert_we: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => '1',
      clk => '1',
      clr => '0',
      din(0) => constant2_op_net_x0,
      en => "1",
      dout(0) => convert_we_dout_net_x0
    );

  munge_in_9341d54c73: entity work.munge_in_entity_9341d54c73
    port map (
      din => constant4_op_net_x1,
      dout => reinterpret_out_output_port_net_x0
    );

  munge_out_3d02ed9321: entity work.munge_out_entity_3d02ed9321
    port map (
      din => darkquad29_a2g_ctrl_lut_dump_dac_lut_buffer_data_out_net_x1,
      dout => reinterpret_out_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/a2g_ctrl/lut_dump/data_period"

entity data_period_entity_a69bc93dcb is
  port (
    darkquad29_a2g_ctrl_lut_dump_data_period_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end data_period_entity_a69bc93dcb;

architecture structural of data_period_entity_a69bc93dcb is
  signal darkquad29_a2g_ctrl_lut_dump_data_period_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_a2g_ctrl_lut_dump_data_period_user_data_out_net_x0 <= darkquad29_a2g_ctrl_lut_dump_data_period_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_a2g_ctrl_lut_dump_data_period_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/a2g_ctrl/lut_dump/pipeline1"

entity pipeline1_entity_986e3344b8 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(31 downto 0); 
    q: out std_logic_vector(31 downto 0)
  );
end pipeline1_entity_986e3344b8;

architecture structural of pipeline1_entity_986e3344b8 is
  signal ce_1_sg_x5: std_logic;
  signal clk_1_sg_x5: std_logic;
  signal register0_q_net: std_logic_vector(31 downto 0);
  signal register1_q_net_x0: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);

begin
  ce_1_sg_x5 <= ce_1;
  clk_1_sg_x5 <= clk_1;
  reint1_output_port_net_x1 <= d;
  q <= register1_q_net_x0;

  register0: entity work.xlregister
    generic map (
      d_width => 32,
      init_value => b"00000000000000000000000000000000"
    )
    port map (
      ce => ce_1_sg_x5,
      clk => clk_1_sg_x5,
      d => reint1_output_port_net_x1,
      en => "1",
      rst => "0",
      q => register0_q_net
    );

  register1: entity work.xlregister
    generic map (
      d_width => 32,
      init_value => b"00000000000000000000000000000000"
    )
    port map (
      ce => ce_1_sg_x5,
      clk => clk_1_sg_x5,
      d => register0_q_net,
      en => "1",
      rst => "0",
      q => register1_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/a2g_ctrl/lut_dump/pipeline3"

entity pipeline3_entity_fb0a315a6d is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic; 
    q: out std_logic
  );
end pipeline3_entity_fb0a315a6d;

architecture structural of pipeline3_entity_fb0a315a6d is
  signal ce_1_sg_x7: std_logic;
  signal clk_1_sg_x7: std_logic;
  signal register0_q_net: std_logic;
  signal register1_q_net_x0: std_logic;
  signal register5_q_net_x0: std_logic;

begin
  ce_1_sg_x7 <= ce_1;
  clk_1_sg_x7 <= clk_1;
  register5_q_net_x0 <= d;
  q <= register1_q_net_x0;

  register0: entity work.xlregister
    generic map (
      d_width => 1,
      init_value => b"0"
    )
    port map (
      ce => ce_1_sg_x7,
      clk => clk_1_sg_x7,
      d(0) => register5_q_net_x0,
      en => "1",
      rst => "0",
      q(0) => register0_q_net
    );

  register1: entity work.xlregister
    generic map (
      d_width => 1,
      init_value => b"0"
    )
    port map (
      ce => ce_1_sg_x7,
      clk => clk_1_sg_x7,
      d(0) => register0_q_net,
      en => "1",
      rst => "0",
      q(0) => register1_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/a2g_ctrl/lut_dump/pipeline4"

entity pipeline4_entity_7ef90e571d is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(7 downto 0); 
    q: out std_logic_vector(7 downto 0)
  );
end pipeline4_entity_7ef90e571d;

architecture structural of pipeline4_entity_7ef90e571d is
  signal ce_1_sg_x8: std_logic;
  signal clk_1_sg_x8: std_logic;
  signal register0_q_net: std_logic_vector(7 downto 0);
  signal register1_q_net_x0: std_logic_vector(7 downto 0);
  signal reinterpret_out_output_port_net_x3: std_logic_vector(7 downto 0);

begin
  ce_1_sg_x8 <= ce_1;
  clk_1_sg_x8 <= clk_1;
  reinterpret_out_output_port_net_x3 <= d;
  q <= register1_q_net_x0;

  register0: entity work.xlregister
    generic map (
      d_width => 8,
      init_value => b"00000000"
    )
    port map (
      ce => ce_1_sg_x8,
      clk => clk_1_sg_x8,
      d => reinterpret_out_output_port_net_x3,
      en => "1",
      rst => "0",
      q => register0_q_net
    );

  register1: entity work.xlregister
    generic map (
      d_width => 8,
      init_value => b"00000000"
    )
    port map (
      ce => ce_1_sg_x8,
      clk => clk_1_sg_x8,
      d => register0_q_net,
      en => "1",
      rst => "0",
      q => register1_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/a2g_ctrl/lut_dump/sending_data"

entity sending_data_entity_bfe6edc6ce is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    out_reg: in std_logic; 
    cast_gw_x0: out std_logic_vector(31 downto 0)
  );
end sending_data_entity_bfe6edc6ce;

architecture structural of sending_data_entity_bfe6edc6ce is
  signal assert_reg_dout_net: std_logic;
  signal cast_gw_dout_net_x0: std_logic_vector(31 downto 0);
  signal ce_1_sg_x9: std_logic;
  signal clk_1_sg_x9: std_logic;
  signal io_delay_q_net: std_logic;
  signal register1_q_net_x1: std_logic;
  signal reint1_output_port_net: std_logic;

begin
  ce_1_sg_x9 <= ce_1;
  clk_1_sg_x9 <= clk_1;
  register1_q_net_x1 <= out_reg;
  cast_gw_x0 <= cast_gw_dout_net_x0;

  assert_reg: entity work.xlpassthrough
    generic map (
      din_width => 1,
      dout_width => 1
    )
    port map (
      din(0) => register1_q_net_x1,
      dout(0) => assert_reg_dout_net
    );

  cast_gw: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x9,
      clk => clk_1_sg_x9,
      clr => '0',
      din(0) => io_delay_q_net,
      en => "1",
      dout => cast_gw_dout_net_x0
    );

  io_delay: entity work.delay_21355083c1
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d(0) => reint1_output_port_net,
      q(0) => io_delay_q_net
    );

  reint1: entity work.reinterpret_112d91c147
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port(0) => assert_reg_dout_net,
      output_port(0) => reint1_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/a2g_ctrl/lut_dump"

entity lut_dump_entity_42803a5093 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    darkquad29_a2g_ctrl_lut_dump_buffer_size_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_a2g_ctrl_lut_dump_dac_lut_buffer_data_out: in std_logic_vector(7 downto 0); 
    darkquad29_a2g_ctrl_lut_dump_data_period_user_data_out: in std_logic_vector(31 downto 0); 
    tx_en_edge: in std_logic; 
    dac_lut_buffer: out std_logic_vector(11 downto 0); 
    dac_lut_buffer_x0: out std_logic_vector(7 downto 0); 
    dac_lut_buffer_x1: out std_logic; 
    data_out: out std_logic_vector(7 downto 0); 
    sending_data: out std_logic_vector(31 downto 0); 
    we_out: out std_logic
  );
end lut_dump_entity_42803a5093;

architecture structural of lut_dump_entity_42803a5093 is
  signal addsub_s_net: std_logic_vector(31 downto 0);
  signal cast_gw_dout_net_x1: std_logic_vector(31 downto 0);
  signal ce_1_sg_x10: std_logic;
  signal clk_1_sg_x10: std_logic;
  signal constant2_op_net_x0: std_logic;
  signal constant3_op_net: std_logic;
  signal constant4_op_net_x1: std_logic_vector(31 downto 0);
  signal constant5_op_net: std_logic_vector(31 downto 0);
  signal convert_addr_dout_net_x1: std_logic_vector(11 downto 0);
  signal convert_din1_dout_net_x1: std_logic_vector(7 downto 0);
  signal convert_we_dout_net_x1: std_logic;
  signal counter1_op_net_x1: std_logic_vector(31 downto 0);
  signal counter2_op_net: std_logic_vector(31 downto 0);
  signal darkquad29_a2g_ctrl_lut_dump_buffer_size_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal darkquad29_a2g_ctrl_lut_dump_dac_lut_buffer_data_out_net_x2: std_logic_vector(7 downto 0);
  signal darkquad29_a2g_ctrl_lut_dump_data_period_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal delay16_q_net: std_logic;
  signal delay19_q_net: std_logic;
  signal delay1_q_net: std_logic;
  signal delay2_q_net_x0: std_logic;
  signal delay3_q_net: std_logic;
  signal logical_y_net_x0: std_logic;
  signal logical_y_net_x1: std_logic;
  signal register1_q_net_x0: std_logic_vector(31 downto 0);
  signal register1_q_net_x1: std_logic_vector(31 downto 0);
  signal register1_q_net_x2: std_logic;
  signal register1_q_net_x4: std_logic_vector(7 downto 0);
  signal register5_q_net_x0: std_logic;
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x2: std_logic_vector(31 downto 0);
  signal reinterpret_out_output_port_net_x3: std_logic_vector(7 downto 0);
  signal relational1_op_net: std_logic;
  signal relational2_op_net: std_logic;

begin
  ce_1_sg_x10 <= ce_1;
  clk_1_sg_x10 <= clk_1;
  darkquad29_a2g_ctrl_lut_dump_buffer_size_user_data_out_net_x1 <= darkquad29_a2g_ctrl_lut_dump_buffer_size_user_data_out;
  darkquad29_a2g_ctrl_lut_dump_dac_lut_buffer_data_out_net_x2 <= darkquad29_a2g_ctrl_lut_dump_dac_lut_buffer_data_out;
  darkquad29_a2g_ctrl_lut_dump_data_period_user_data_out_net_x1 <= darkquad29_a2g_ctrl_lut_dump_data_period_user_data_out;
  logical_y_net_x1 <= tx_en_edge;
  dac_lut_buffer <= convert_addr_dout_net_x1;
  dac_lut_buffer_x0 <= convert_din1_dout_net_x1;
  dac_lut_buffer_x1 <= convert_we_dout_net_x1;
  data_out <= register1_q_net_x4;
  sending_data <= cast_gw_dout_net_x1;
  we_out <= delay2_q_net_x0;

  addsub: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlUnsigned,
      a_bin_pt => 0,
      a_width => 32,
      b_arith => xlUnsigned,
      b_bin_pt => 0,
      b_width => 32,
      c_has_c_out => 0,
      c_latency => 1,
      c_output_width => 33,
      core_name0 => "addsb_11_0_e7ad3a217b0e91ae",
      extra_registers => 0,
      full_s_arith => 2,
      full_s_width => 33,
      latency => 1,
      overflow => 1,
      quantization => 1,
      s_arith => xlUnsigned,
      s_bin_pt => 0,
      s_width => 32
    )
    port map (
      a => register1_q_net_x1,
      b => constant5_op_net,
      ce => ce_1_sg_x10,
      clk => clk_1_sg_x10,
      clr => '0',
      en => "1",
      s => addsub_s_net
    );

  buffer_size_527d8c4939: entity work.buffer_size_entity_527d8c4939
    port map (
      darkquad29_a2g_ctrl_lut_dump_buffer_size_user_data_out => darkquad29_a2g_ctrl_lut_dump_buffer_size_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x1
    );

  constant2: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant2_op_net_x0
    );

  constant3: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant3_op_net
    );

  constant4: entity work.constant_37567836aa
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant4_op_net_x1
    );

  constant5: entity work.constant_ebdfb0074f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant5_op_net
    );

  counter1: entity work.xlcounter_free_darkquad29
    generic map (
      core_name0 => "cntr_11_0_8fd3bf4fb2c5b76d",
      op_arith => xlUnsigned,
      op_width => 32
    )
    port map (
      ce => ce_1_sg_x10,
      clk => clk_1_sg_x10,
      clr => '0',
      en(0) => logical_y_net_x0,
      rst(0) => delay19_q_net,
      op => counter1_op_net_x1
    );

  counter2: entity work.xlcounter_free_darkquad29
    generic map (
      core_name0 => "cntr_11_0_1e48762428ed22e0",
      op_arith => xlUnsigned,
      op_width => 32
    )
    port map (
      ce => ce_1_sg_x10,
      clk => clk_1_sg_x10,
      clr => '0',
      en(0) => register5_q_net_x0,
      rst(0) => relational1_op_net,
      op => counter2_op_net
    );

  dac_lut_buffer_60dc54f53b: entity work.dac_lut_buffer_entity_60dc54f53b
    port map (
      addr => counter1_op_net_x1,
      ce_1 => ce_1_sg_x10,
      clk_1 => clk_1_sg_x10,
      darkquad29_a2g_ctrl_lut_dump_dac_lut_buffer_data_out => darkquad29_a2g_ctrl_lut_dump_dac_lut_buffer_data_out_net_x2,
      data_in => constant4_op_net_x1,
      we => constant2_op_net_x0,
      convert_addr_x0 => convert_addr_dout_net_x1,
      convert_din1_x0 => convert_din1_dout_net_x1,
      convert_we_x0 => convert_we_dout_net_x1,
      data_out => reinterpret_out_output_port_net_x3
    );

  data_period_a69bc93dcb: entity work.data_period_entity_a69bc93dcb
    port map (
      darkquad29_a2g_ctrl_lut_dump_data_period_user_data_out => darkquad29_a2g_ctrl_lut_dump_data_period_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x2
    );

  delay1: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x10,
      clk => clk_1_sg_x10,
      d(0) => relational1_op_net,
      en => '1',
      rst => '1',
      q(0) => delay1_q_net
    );

  delay16: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x10,
      clk => clk_1_sg_x10,
      d(0) => delay1_q_net,
      en => '1',
      rst => '1',
      q(0) => delay16_q_net
    );

  delay19: entity work.xldelay
    generic map (
      latency => 10,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x10,
      clk => clk_1_sg_x10,
      d(0) => relational2_op_net,
      en => '1',
      rst => '1',
      q(0) => delay19_q_net
    );

  delay2: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x10,
      clk => clk_1_sg_x10,
      d(0) => delay16_q_net,
      en => '1',
      rst => '1',
      q(0) => delay2_q_net_x0
    );

  delay3: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x10,
      clk => clk_1_sg_x10,
      d(0) => register5_q_net_x0,
      en => '1',
      rst => '1',
      q(0) => delay3_q_net
    );

  logical: entity work.logical_80f90b97d0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => relational1_op_net,
      d1(0) => delay3_q_net,
      y(0) => logical_y_net_x0
    );

  pipeline1_986e3344b8: entity work.pipeline1_entity_986e3344b8
    port map (
      ce_1 => ce_1_sg_x10,
      clk_1 => clk_1_sg_x10,
      d => reint1_output_port_net_x2,
      q => register1_q_net_x0
    );

  pipeline2_050f7fd9c0: entity work.pipeline1_entity_986e3344b8
    port map (
      ce_1 => ce_1_sg_x10,
      clk_1 => clk_1_sg_x10,
      d => reint1_output_port_net_x1,
      q => register1_q_net_x1
    );

  pipeline3_fb0a315a6d: entity work.pipeline3_entity_fb0a315a6d
    port map (
      ce_1 => ce_1_sg_x10,
      clk_1 => clk_1_sg_x10,
      d => register5_q_net_x0,
      q => register1_q_net_x2
    );

  pipeline4_7ef90e571d: entity work.pipeline4_entity_7ef90e571d
    port map (
      ce_1 => ce_1_sg_x10,
      clk_1 => clk_1_sg_x10,
      d => reinterpret_out_output_port_net_x3,
      q => register1_q_net_x4
    );

  register5: entity work.xlregister
    generic map (
      d_width => 1,
      init_value => b"0"
    )
    port map (
      ce => ce_1_sg_x10,
      clk => clk_1_sg_x10,
      d(0) => constant3_op_net,
      en(0) => logical_y_net_x1,
      rst(0) => relational2_op_net,
      q(0) => register5_q_net_x0
    );

  relational1: entity work.relational_3ffd1d0a40
    port map (
      a => counter2_op_net,
      b => register1_q_net_x0,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational1_op_net
    );

  relational2: entity work.relational_3ffd1d0a40
    port map (
      a => counter1_op_net_x1,
      b => addsub_s_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational2_op_net
    );

  sending_data_bfe6edc6ce: entity work.sending_data_entity_bfe6edc6ce
    port map (
      ce_1 => ce_1_sg_x10,
      clk_1 => clk_1_sg_x10,
      out_reg => register1_q_net_x2,
      cast_gw_x0 => cast_gw_dout_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/a2g_ctrl/rst"

entity rst_entity_36b69ed6d5 is
  port (
    darkquad29_a2g_ctrl_rst_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end rst_entity_36b69ed6d5;

architecture structural of rst_entity_36b69ed6d5 is
  signal darkquad29_a2g_ctrl_rst_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_a2g_ctrl_rst_user_data_out_net_x0 <= darkquad29_a2g_ctrl_rst_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_a2g_ctrl_rst_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/a2g_ctrl/tx_en"

entity tx_en_entity_9034699624 is
  port (
    darkquad29_a2g_ctrl_tx_en_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end tx_en_entity_9034699624;

architecture structural of tx_en_entity_9034699624 is
  signal darkquad29_a2g_ctrl_tx_en_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_a2g_ctrl_tx_en_user_data_out_net_x0 <= darkquad29_a2g_ctrl_tx_en_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_a2g_ctrl_tx_en_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/a2g_ctrl/v7_ready"

entity v7_ready_entity_d5f3d8453a is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    out_reg: in std_logic_vector(7 downto 0); 
    cast_gw_x0: out std_logic_vector(31 downto 0)
  );
end v7_ready_entity_d5f3d8453a;

architecture structural of v7_ready_entity_d5f3d8453a is
  signal assert_reg_dout_net: std_logic_vector(7 downto 0);
  signal cast_gw_dout_net_x0: std_logic_vector(31 downto 0);
  signal ce_1_sg_x21: std_logic;
  signal clk_1_sg_x21: std_logic;
  signal io_delay_q_net: std_logic_vector(7 downto 0);
  signal register1_q_net_x1: std_logic_vector(7 downto 0);
  signal reint1_output_port_net: std_logic_vector(7 downto 0);

begin
  ce_1_sg_x21 <= ce_1;
  clk_1_sg_x21 <= clk_1;
  register1_q_net_x1 <= out_reg;
  cast_gw_x0 <= cast_gw_dout_net_x0;

  assert_reg: entity work.xlpassthrough
    generic map (
      din_width => 8,
      dout_width => 8
    )
    port map (
      din => register1_q_net_x1,
      dout => assert_reg_dout_net
    );

  cast_gw: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 8,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x21,
      clk => clk_1_sg_x21,
      clr => '0',
      din => io_delay_q_net,
      en => "1",
      dout => cast_gw_dout_net_x0
    );

  io_delay: entity work.delay_423c6c1400
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => reint1_output_port_net,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_f21e7f2ddf
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => assert_reg_dout_net,
      output_port => reint1_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/a2g_ctrl"

entity a2g_ctrl_entity_bf2306676d is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_rx_data: in std_logic_vector(7 downto 0); 
    darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_rx_full: in std_logic; 
    darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_rx_val: in std_logic; 
    darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_tx_full: in std_logic; 
    darkquad29_a2g_ctrl_en_bram_dump_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_a2g_ctrl_in_val_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_a2g_ctrl_lut_dump_buffer_size_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_a2g_ctrl_lut_dump_dac_lut_buffer_data_out: in std_logic_vector(7 downto 0); 
    darkquad29_a2g_ctrl_lut_dump_data_period_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_a2g_ctrl_rst_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_a2g_ctrl_tx_en_user_data_out: in std_logic_vector(31 downto 0); 
    adcdac_2g_ctrl: out std_logic; 
    adcdac_2g_ctrl_x0: out std_logic_vector(7 downto 0); 
    adcdac_2g_ctrl_x1: out std_logic; 
    adcdac_2g_ctrl_x2: out std_logic; 
    last_tx_data: out std_logic_vector(31 downto 0); 
    lut_dump: out std_logic_vector(11 downto 0); 
    lut_dump_x0: out std_logic_vector(7 downto 0); 
    lut_dump_x1: out std_logic; 
    lut_dump_x2: out std_logic_vector(31 downto 0); 
    reg_rx_full: out std_logic_vector(31 downto 0); 
    reg_tx_full: out std_logic_vector(31 downto 0); 
    v7_ready: out std_logic_vector(31 downto 0)
  );
end a2g_ctrl_entity_bf2306676d;

architecture structural of a2g_ctrl_entity_bf2306676d is
  signal cast_gw_dout_net_x5: std_logic_vector(31 downto 0);
  signal cast_gw_dout_net_x6: std_logic_vector(31 downto 0);
  signal cast_gw_dout_net_x7: std_logic_vector(31 downto 0);
  signal cast_gw_dout_net_x8: std_logic_vector(31 downto 0);
  signal cast_gw_dout_net_x9: std_logic_vector(31 downto 0);
  signal ce_1_sg_x22: std_logic;
  signal clk_1_sg_x22: std_logic;
  signal convert1_dout_net_x1: std_logic;
  signal convert3_dout_net_x1: std_logic_vector(7 downto 0);
  signal convert4_dout_net_x1: std_logic;
  signal convert5_dout_net_x0: std_logic_vector(31 downto 0);
  signal convert5_dout_net_x2: std_logic;
  signal convert_addr_dout_net_x2: std_logic_vector(11 downto 0);
  signal convert_din1_dout_net_x2: std_logic_vector(7 downto 0);
  signal convert_we_dout_net_x2: std_logic;
  signal darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_rx_data_net_x0: std_logic_vector(7 downto 0);
  signal darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_rx_full_net_x0: std_logic;
  signal darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_rx_val_net_x0: std_logic;
  signal darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_tx_full_net_x0: std_logic;
  signal darkquad29_a2g_ctrl_en_bram_dump_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal darkquad29_a2g_ctrl_in_val_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal darkquad29_a2g_ctrl_lut_dump_buffer_size_user_data_out_net_x2: std_logic_vector(31 downto 0);
  signal darkquad29_a2g_ctrl_lut_dump_dac_lut_buffer_data_out_net_x3: std_logic_vector(7 downto 0);
  signal darkquad29_a2g_ctrl_lut_dump_data_period_user_data_out_net_x2: std_logic_vector(31 downto 0);
  signal darkquad29_a2g_ctrl_rst_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal darkquad29_a2g_ctrl_tx_en_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal delay10_q_net: std_logic;
  signal delay12_q_net: std_logic;
  signal delay13_q_net: std_logic;
  signal delay15_q_net_x0: std_logic;
  signal delay17_q_net: std_logic;
  signal delay18_q_net: std_logic;
  signal delay1_q_net_x0: std_logic_vector(7 downto 0);
  signal delay2_q_net_x0: std_logic;
  signal delay6_q_net_x0: std_logic;
  signal delay7_q_net: std_logic;
  signal delay8_q_net: std_logic_vector(7 downto 0);
  signal delay9_q_net_x0: std_logic;
  signal delay_q_net: std_logic;
  signal edge_op_y_net_x0: std_logic;
  signal logical_y_net_x1: std_logic;
  signal mux6_y_net: std_logic_vector(7 downto 0);
  signal mux7_y_net: std_logic;
  signal register1_q_net_x0: std_logic_vector(7 downto 0);
  signal register1_q_net_x1: std_logic;
  signal register1_q_net_x2: std_logic;
  signal register1_q_net_x3: std_logic;
  signal register1_q_net_x4: std_logic_vector(7 downto 0);
  signal register1_q_net_x5: std_logic;
  signal register1_q_net_x6: std_logic;
  signal register1_q_net_x7: std_logic_vector(7 downto 0);
  signal register1_q_net_x8: std_logic_vector(7 downto 0);
  signal register3_q_net_x0: std_logic_vector(7 downto 0);
  signal register4_q_net_x0: std_logic;
  signal register_q_net_x0: std_logic_vector(7 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x2: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x3: std_logic_vector(31 downto 0);
  signal slice10_y_net_x0: std_logic;
  signal slice12_y_net_x0: std_logic_vector(7 downto 0);
  signal slice5_y_net_x0: std_logic;
  signal slice9_y_net_x0: std_logic;

begin
  ce_1_sg_x22 <= ce_1;
  clk_1_sg_x22 <= clk_1;
  darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_rx_data_net_x0 <= darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_rx_data;
  darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_rx_full_net_x0 <= darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_rx_full;
  darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_rx_val_net_x0 <= darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_rx_val;
  darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_tx_full_net_x0 <= darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_tx_full;
  darkquad29_a2g_ctrl_en_bram_dump_user_data_out_net_x1 <= darkquad29_a2g_ctrl_en_bram_dump_user_data_out;
  darkquad29_a2g_ctrl_in_val_user_data_out_net_x1 <= darkquad29_a2g_ctrl_in_val_user_data_out;
  darkquad29_a2g_ctrl_lut_dump_buffer_size_user_data_out_net_x2 <= darkquad29_a2g_ctrl_lut_dump_buffer_size_user_data_out;
  darkquad29_a2g_ctrl_lut_dump_dac_lut_buffer_data_out_net_x3 <= darkquad29_a2g_ctrl_lut_dump_dac_lut_buffer_data_out;
  darkquad29_a2g_ctrl_lut_dump_data_period_user_data_out_net_x2 <= darkquad29_a2g_ctrl_lut_dump_data_period_user_data_out;
  darkquad29_a2g_ctrl_rst_user_data_out_net_x1 <= darkquad29_a2g_ctrl_rst_user_data_out;
  darkquad29_a2g_ctrl_tx_en_user_data_out_net_x1 <= darkquad29_a2g_ctrl_tx_en_user_data_out;
  adcdac_2g_ctrl <= convert1_dout_net_x1;
  adcdac_2g_ctrl_x0 <= convert3_dout_net_x1;
  adcdac_2g_ctrl_x1 <= convert4_dout_net_x1;
  adcdac_2g_ctrl_x2 <= convert5_dout_net_x2;
  last_tx_data <= cast_gw_dout_net_x5;
  lut_dump <= convert_addr_dout_net_x2;
  lut_dump_x0 <= convert_din1_dout_net_x2;
  lut_dump_x1 <= convert_we_dout_net_x2;
  lut_dump_x2 <= cast_gw_dout_net_x6;
  reg_rx_full <= cast_gw_dout_net_x7;
  reg_tx_full <= cast_gw_dout_net_x8;
  v7_ready <= cast_gw_dout_net_x9;

  adcdac_2g_ctrl_3417bb5b56: entity work.adcdac_2g_ctrl_entity_3417bb5b56
    port map (
      ce_1 => ce_1_sg_x22,
      clk_1 => clk_1_sg_x22,
      tx_data => delay1_q_net_x0,
      tx_rst => delay15_q_net_x0,
      tx_val => delay6_q_net_x0,
      convert1_x0 => convert1_dout_net_x1,
      convert3_x0 => convert3_dout_net_x1,
      convert4_x0 => convert4_dout_net_x1,
      convert5_x0 => convert5_dout_net_x2
    );

  convert5: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 8,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 2,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x22,
      clk => clk_1_sg_x22,
      clr => '0',
      din => register1_q_net_x8,
      en => "1",
      dout => convert5_dout_net_x0
    );

  delay: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x22,
      clk => clk_1_sg_x22,
      d(0) => delay10_q_net,
      en => '1',
      rst => '1',
      q(0) => delay_q_net
    );

  delay1: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x22,
      clk => clk_1_sg_x22,
      d => mux6_y_net,
      en => '1',
      rst => '1',
      q => delay1_q_net_x0
    );

  delay10: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x22,
      clk => clk_1_sg_x22,
      d(0) => register1_q_net_x2,
      en => '1',
      rst => '1',
      q(0) => delay10_q_net
    );

  delay12: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x22,
      clk => clk_1_sg_x22,
      d(0) => edge_op_y_net_x0,
      en => '1',
      rst => '1',
      q(0) => delay12_q_net
    );

  delay13: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x22,
      clk => clk_1_sg_x22,
      d(0) => register1_q_net_x3,
      en => '1',
      rst => '1',
      q(0) => delay13_q_net
    );

  delay15: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x22,
      clk => clk_1_sg_x22,
      d(0) => delay_q_net,
      en => '1',
      rst => '1',
      q(0) => delay15_q_net_x0
    );

  delay17: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x22,
      clk => clk_1_sg_x22,
      d(0) => darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_tx_full_net_x0,
      en => '1',
      rst => '1',
      q(0) => delay17_q_net
    );

  delay18: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x22,
      clk => clk_1_sg_x22,
      d(0) => delay15_q_net_x0,
      en => '1',
      rst => '1',
      q(0) => delay18_q_net
    );

  delay6: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x22,
      clk => clk_1_sg_x22,
      d(0) => mux7_y_net,
      en => '1',
      rst => '1',
      q(0) => delay6_q_net_x0
    );

  delay7: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x22,
      clk => clk_1_sg_x22,
      d(0) => darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_rx_val_net_x0,
      en => '1',
      rst => '1',
      q(0) => delay7_q_net
    );

  delay8: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x22,
      clk => clk_1_sg_x22,
      d => darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_rx_data_net_x0,
      en => '1',
      rst => '1',
      q => delay8_q_net
    );

  delay9: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x22,
      clk => clk_1_sg_x22,
      d(0) => darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_rx_full_net_x0,
      en => '1',
      rst => '1',
      q(0) => delay9_q_net_x0
    );

  edge_detect3_2efb246ca9: entity work.edge_detect3_entity_2efb246ca9
    port map (
      ce_1 => ce_1_sg_x22,
      clk_1 => clk_1_sg_x22,
      in_x0 => register1_q_net_x1,
      out_x0 => edge_op_y_net_x0
    );

  en_bram_dump_fbeb935a30: entity work.en_bram_dump_entity_fbeb935a30
    port map (
      darkquad29_a2g_ctrl_en_bram_dump_user_data_out => darkquad29_a2g_ctrl_en_bram_dump_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x0
    );

  in_val_11b51ff9fe: entity work.in_val_entity_11b51ff9fe
    port map (
      darkquad29_a2g_ctrl_in_val_user_data_out => darkquad29_a2g_ctrl_in_val_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x1
    );

  last_tx_data_4b5ba71046: entity work.last_tx_data_entity_4b5ba71046
    port map (
      ce_1 => ce_1_sg_x22,
      clk_1 => clk_1_sg_x22,
      out_reg => convert5_dout_net_x0,
      cast_gw_x0 => cast_gw_dout_net_x5
    );

  logical: entity work.logical_80f90b97d0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => edge_op_y_net_x0,
      d1(0) => register1_q_net_x3,
      y(0) => logical_y_net_x1
    );

  lut_dump_42803a5093: entity work.lut_dump_entity_42803a5093
    port map (
      ce_1 => ce_1_sg_x22,
      clk_1 => clk_1_sg_x22,
      darkquad29_a2g_ctrl_lut_dump_buffer_size_user_data_out => darkquad29_a2g_ctrl_lut_dump_buffer_size_user_data_out_net_x2,
      darkquad29_a2g_ctrl_lut_dump_dac_lut_buffer_data_out => darkquad29_a2g_ctrl_lut_dump_dac_lut_buffer_data_out_net_x3,
      darkquad29_a2g_ctrl_lut_dump_data_period_user_data_out => darkquad29_a2g_ctrl_lut_dump_data_period_user_data_out_net_x2,
      tx_en_edge => logical_y_net_x1,
      dac_lut_buffer => convert_addr_dout_net_x2,
      dac_lut_buffer_x0 => convert_din1_dout_net_x2,
      dac_lut_buffer_x1 => convert_we_dout_net_x2,
      data_out => register1_q_net_x4,
      sending_data => cast_gw_dout_net_x6,
      we_out => delay2_q_net_x0
    );

  mux6: entity work.mux_387191112d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0 => register1_q_net_x0,
      d1 => register1_q_net_x4,
      sel(0) => delay13_q_net,
      y => mux6_y_net
    );

  mux7: entity work.mux_d99e59b6d4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => delay12_q_net,
      d1(0) => delay2_q_net_x0,
      sel(0) => delay13_q_net,
      y(0) => mux7_y_net
    );

  pipeline1_72e03b01b3: entity work.pipeline4_entity_7ef90e571d
    port map (
      ce_1 => ce_1_sg_x22,
      clk_1 => clk_1_sg_x22,
      d => slice12_y_net_x0,
      q => register1_q_net_x0
    );

  pipeline23_9ff6358ba2: entity work.pipeline3_entity_fb0a315a6d
    port map (
      ce_1 => ce_1_sg_x22,
      clk_1 => clk_1_sg_x22,
      d => slice5_y_net_x0,
      q => register1_q_net_x2
    );

  pipeline2_1e55a131ba: entity work.pipeline3_entity_fb0a315a6d
    port map (
      ce_1 => ce_1_sg_x22,
      clk_1 => clk_1_sg_x22,
      d => slice10_y_net_x0,
      q => register1_q_net_x1
    );

  pipeline3_f62da10da0: entity work.pipeline3_entity_fb0a315a6d
    port map (
      ce_1 => ce_1_sg_x22,
      clk_1 => clk_1_sg_x22,
      d => slice9_y_net_x0,
      q => register1_q_net_x3
    );

  pipeline5_a74bbc2941: entity work.pipeline3_entity_fb0a315a6d
    port map (
      ce_1 => ce_1_sg_x22,
      clk_1 => clk_1_sg_x22,
      d => register4_q_net_x0,
      q => register1_q_net_x5
    );

  pipeline6_c52fc497d2: entity work.pipeline3_entity_fb0a315a6d
    port map (
      ce_1 => ce_1_sg_x22,
      clk_1 => clk_1_sg_x22,
      d => delay9_q_net_x0,
      q => register1_q_net_x6
    );

  pipeline7_b259a31307: entity work.pipeline4_entity_7ef90e571d
    port map (
      ce_1 => ce_1_sg_x22,
      clk_1 => clk_1_sg_x22,
      d => register_q_net_x0,
      q => register1_q_net_x7
    );

  pipeline8_38f782141e: entity work.pipeline4_entity_7ef90e571d
    port map (
      ce_1 => ce_1_sg_x22,
      clk_1 => clk_1_sg_x22,
      d => register3_q_net_x0,
      q => register1_q_net_x8
    );

  reg_rx_full_c47a3a6519: entity work.sending_data_entity_bfe6edc6ce
    port map (
      ce_1 => ce_1_sg_x22,
      clk_1 => clk_1_sg_x22,
      out_reg => register1_q_net_x6,
      cast_gw_x0 => cast_gw_dout_net_x7
    );

  reg_tx_full_a5a3f209c6: entity work.sending_data_entity_bfe6edc6ce
    port map (
      ce_1 => ce_1_sg_x22,
      clk_1 => clk_1_sg_x22,
      out_reg => register1_q_net_x5,
      cast_gw_x0 => cast_gw_dout_net_x8
    );

  register3: entity work.xlregister
    generic map (
      d_width => 8,
      init_value => b"00000000"
    )
    port map (
      ce => ce_1_sg_x22,
      clk => clk_1_sg_x22,
      d => mux6_y_net,
      en(0) => delay6_q_net_x0,
      rst => "0",
      q => register3_q_net_x0
    );

  register4: entity work.xlregister
    generic map (
      d_width => 1,
      init_value => b"0"
    )
    port map (
      ce => ce_1_sg_x22,
      clk => clk_1_sg_x22,
      d(0) => delay17_q_net,
      en(0) => delay17_q_net,
      rst(0) => delay18_q_net,
      q(0) => register4_q_net_x0
    );

  register_x0: entity work.xlregister
    generic map (
      d_width => 8,
      init_value => b"00000000"
    )
    port map (
      ce => ce_1_sg_x22,
      clk => clk_1_sg_x22,
      d => delay8_q_net,
      en(0) => delay7_q_net,
      rst(0) => edge_op_y_net_x0,
      q => register_q_net_x0
    );

  rst_36b69ed6d5: entity work.rst_entity_36b69ed6d5
    port map (
      darkquad29_a2g_ctrl_rst_user_data_out => darkquad29_a2g_ctrl_rst_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x2
    );

  slice10: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => reint1_output_port_net_x3,
      y(0) => slice10_y_net_x0
    );

  slice12: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 7,
      x_width => 32,
      y_width => 8
    )
    port map (
      x => reint1_output_port_net_x1,
      y => slice12_y_net_x0
    );

  slice5: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => reint1_output_port_net_x2,
      y(0) => slice5_y_net_x0
    );

  slice9: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => reint1_output_port_net_x0,
      y(0) => slice9_y_net_x0
    );

  tx_en_9034699624: entity work.tx_en_entity_9034699624
    port map (
      darkquad29_a2g_ctrl_tx_en_user_data_out => darkquad29_a2g_ctrl_tx_en_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x3
    );

  v7_ready_d5f3d8453a: entity work.v7_ready_entity_d5f3d8453a
    port map (
      ce_1 => ce_1_sg_x22,
      clk_1 => clk_1_sg_x22,
      out_reg => register1_q_net_x7,
      cast_gw_x0 => cast_gw_dout_net_x9
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/acc_iq/acc0/c_to_ri1"

entity c_to_ri1_entity_f17f9bae25 is
  port (
    c: in std_logic_vector(37 downto 0); 
    im: out std_logic_vector(18 downto 0); 
    re: out std_logic_vector(18 downto 0)
  );
end c_to_ri1_entity_f17f9bae25;

architecture structural of c_to_ri1_entity_f17f9bae25 is
  signal force_im_output_port_net_x0: std_logic_vector(18 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(18 downto 0);
  signal slice4_y_net_x0: std_logic_vector(37 downto 0);
  signal slice_im_y_net: std_logic_vector(18 downto 0);
  signal slice_re_y_net: std_logic_vector(18 downto 0);

begin
  slice4_y_net_x0 <= c;
  im <= force_im_output_port_net_x0;
  re <= force_re_output_port_net_x0;

  force_im: entity work.reinterpret_63700884f5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_im_y_net,
      output_port => force_im_output_port_net_x0
    );

  force_re: entity work.reinterpret_63700884f5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_re_y_net,
      output_port => force_re_output_port_net_x0
    );

  slice_im: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 18,
      x_width => 38,
      y_width => 19
    )
    port map (
      x => slice4_y_net_x0,
      y => slice_im_y_net
    );

  slice_re: entity work.xlslice
    generic map (
      new_lsb => 19,
      new_msb => 37,
      x_width => 38,
      y_width => 19
    )
    port map (
      x => slice4_y_net_x0,
      y => slice_re_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/acc_iq/acc0/pulse_ext/posedge"

entity posedge_entity_b890391632 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic; 
    out_x0: out std_logic
  );
end posedge_entity_b890391632;

architecture structural of posedge_entity_b890391632 is
  signal ce_1_sg_x23: std_logic;
  signal clk_1_sg_x23: std_logic;
  signal delay_q_net: std_logic;
  signal inverter_op_net: std_logic;
  signal logical_y_net_x0: std_logic;
  signal relational1_op_net_x0: std_logic;

begin
  ce_1_sg_x23 <= ce_1;
  clk_1_sg_x23 <= clk_1;
  relational1_op_net_x0 <= in_x0;
  out_x0 <= logical_y_net_x0;

  delay: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x23,
      clk => clk_1_sg_x23,
      d(0) => relational1_op_net_x0,
      en => '1',
      rst => '1',
      q(0) => delay_q_net
    );

  inverter: entity work.inverter_e5b38cca3b
    port map (
      ce => ce_1_sg_x23,
      clk => clk_1_sg_x23,
      clr => '0',
      ip(0) => delay_q_net,
      op(0) => inverter_op_net
    );

  logical: entity work.logical_80f90b97d0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => inverter_op_net,
      d1(0) => relational1_op_net_x0,
      y(0) => logical_y_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/acc_iq/acc0/pulse_ext"

entity pulse_ext_entity_a9f8db2fd2 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic; 
    out_x0: out std_logic
  );
end pulse_ext_entity_a9f8db2fd2;

architecture structural of pulse_ext_entity_a9f8db2fd2 is
  signal ce_1_sg_x24: std_logic;
  signal clk_1_sg_x24: std_logic;
  signal constant5_op_net: std_logic_vector(8 downto 0);
  signal counter3_op_net: std_logic_vector(8 downto 0);
  signal logical_y_net_x0: std_logic;
  signal relational1_op_net_x1: std_logic;
  signal relational5_op_net_x0: std_logic;

begin
  ce_1_sg_x24 <= ce_1;
  clk_1_sg_x24 <= clk_1;
  relational1_op_net_x1 <= in_x0;
  out_x0 <= relational5_op_net_x0;

  constant5: entity work.constant_4a391b9a0e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant5_op_net
    );

  counter3: entity work.xlcounter_free_darkquad29
    generic map (
      core_name0 => "cntr_11_0_198c863c3eaf9bde",
      op_arith => xlUnsigned,
      op_width => 9
    )
    port map (
      ce => ce_1_sg_x24,
      clk => clk_1_sg_x24,
      clr => '0',
      en(0) => relational5_op_net_x0,
      rst(0) => logical_y_net_x0,
      op => counter3_op_net
    );

  posedge_b890391632: entity work.posedge_entity_b890391632
    port map (
      ce_1 => ce_1_sg_x24,
      clk_1 => clk_1_sg_x24,
      in_x0 => relational1_op_net_x1,
      out_x0 => logical_y_net_x0
    );

  relational5: entity work.relational_78eac2928d
    port map (
      a => counter3_op_net,
      b => constant5_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational5_op_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/acc_iq/acc0"

entity acc0_entity_c70a84cfef is
  port (
    accum_en: in std_logic; 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    data_in: in std_logic_vector(75 downto 0); 
    data_out: out std_logic_vector(31 downto 0); 
    drdy: out std_logic
  );
end acc0_entity_c70a84cfef;

architecture structural of acc0_entity_c70a84cfef is
  signal addsub1_s_net: std_logic_vector(29 downto 0);
  signal addsub2_s_net: std_logic_vector(29 downto 0);
  signal addsub3_s_net: std_logic_vector(19 downto 0);
  signal addsub4_s_net: std_logic_vector(19 downto 0);
  signal ce_1_sg_x25: std_logic;
  signal clk_1_sg_x25: std_logic;
  signal constant1_op_net: std_logic_vector(29 downto 0);
  signal constant2_op_net: std_logic_vector(29 downto 0);
  signal constant9_op_net: std_logic_vector(17 downto 0);
  signal convert1_dout_net: std_logic_vector(31 downto 0);
  signal convert3_dout_net: std_logic_vector(31 downto 0);
  signal delay1_q_net: std_logic_vector(46 downto 0);
  signal delay2_q_net: std_logic_vector(29 downto 0);
  signal delay30_q_net_x0: std_logic_vector(75 downto 0);
  signal delay3_q_net: std_logic;
  signal delay4_q_net: std_logic;
  signal delay5_q_net: std_logic_vector(46 downto 0);
  signal delay6_q_net: std_logic_vector(31 downto 0);
  signal delay7_q_net: std_logic_vector(29 downto 0);
  signal force_im_output_port_net_x0: std_logic_vector(18 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(18 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(18 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(18 downto 0);
  signal inverter1_op_net: std_logic;
  signal inverter_op_net: std_logic;
  signal lut_counter1_op_net: std_logic_vector(17 downto 0);
  signal mux1_y_net: std_logic_vector(46 downto 0);
  signal mux2_y_net_x0: std_logic_vector(31 downto 0);
  signal mux3_y_net_x0: std_logic;
  signal mux_y_net: std_logic_vector(46 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(18 downto 0);
  signal reinterpret2_output_port_net: std_logic_vector(18 downto 0);
  signal reinterpret4_output_port_net: std_logic_vector(29 downto 0);
  signal reinterpret5_output_port_net: std_logic_vector(18 downto 0);
  signal reinterpret6_output_port_net: std_logic_vector(18 downto 0);
  signal reinterpret7_output_port_net: std_logic_vector(18 downto 0);
  signal reinterpret8_output_port_net: std_logic_vector(18 downto 0);
  signal relational1_op_net_x1: std_logic;
  signal relational5_op_net_x0: std_logic;
  signal relational5_op_net_x1: std_logic;
  signal slice1_y_net: std_logic_vector(18 downto 0);
  signal slice2_y_net: std_logic_vector(18 downto 0);
  signal slice4_y_net_x0: std_logic_vector(37 downto 0);
  signal slice6_y_net_x0: std_logic_vector(37 downto 0);

begin
  relational5_op_net_x1 <= accum_en;
  ce_1_sg_x25 <= ce_1;
  clk_1_sg_x25 <= clk_1;
  delay30_q_net_x0 <= data_in;
  data_out <= mux2_y_net_x0;
  drdy <= mux3_y_net_x0;

  addsub1: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 47,
      b_arith => xlSigned,
      b_bin_pt => 0,
      b_width => 20,
      c_has_c_out => 0,
      c_latency => 1,
      c_output_width => 48,
      core_name0 => "addsb_11_0_d9aaab7d6537213f",
      extra_registers => 0,
      full_s_arith => 2,
      full_s_width => 48,
      latency => 1,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 0,
      s_width => 30
    )
    port map (
      a => delay1_q_net,
      b => addsub4_s_net,
      ce => ce_1_sg_x25,
      clk => clk_1_sg_x25,
      clr => '0',
      en => "1",
      s => addsub1_s_net
    );

  addsub2: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 47,
      b_arith => xlSigned,
      b_bin_pt => 0,
      b_width => 20,
      c_has_c_out => 0,
      c_latency => 1,
      c_output_width => 48,
      core_name0 => "addsb_11_0_d9aaab7d6537213f",
      extra_registers => 0,
      full_s_arith => 2,
      full_s_width => 48,
      latency => 1,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 0,
      s_width => 30
    )
    port map (
      a => delay5_q_net,
      b => addsub3_s_net,
      ce => ce_1_sg_x25,
      clk => clk_1_sg_x25,
      clr => '0',
      en => "1",
      s => addsub2_s_net
    );

  addsub3: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 0,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 0,
      b_width => 19,
      c_has_c_out => 0,
      c_latency => 1,
      c_output_width => 20,
      core_name0 => "addsb_11_0_74c24ba8230946d7",
      extra_registers => 0,
      full_s_arith => 2,
      full_s_width => 20,
      latency => 1,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 0,
      s_width => 20
    )
    port map (
      a => reinterpret5_output_port_net,
      b => reinterpret8_output_port_net,
      ce => ce_1_sg_x25,
      clk => clk_1_sg_x25,
      clr => '0',
      en => "1",
      s => addsub3_s_net
    );

  addsub4: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 0,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 0,
      b_width => 19,
      c_has_c_out => 0,
      c_latency => 1,
      c_output_width => 20,
      core_name0 => "addsb_11_0_74c24ba8230946d7",
      extra_registers => 0,
      full_s_arith => 2,
      full_s_width => 20,
      latency => 1,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 0,
      s_width => 20
    )
    port map (
      a => reinterpret2_output_port_net,
      b => reinterpret7_output_port_net,
      ce => ce_1_sg_x25,
      clk => clk_1_sg_x25,
      clr => '0',
      en => "1",
      s => addsub4_s_net
    );

  c_to_ri1_f17f9bae25: entity work.c_to_ri1_entity_f17f9bae25
    port map (
      c => slice4_y_net_x0,
      im => force_im_output_port_net_x0,
      re => force_re_output_port_net_x0
    );

  c_to_ri2_7dcc0aca2d: entity work.c_to_ri1_entity_f17f9bae25
    port map (
      c => slice6_y_net_x0,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  constant1: entity work.constant_edea2790a5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant1_op_net
    );

  constant2: entity work.constant_edea2790a5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant2_op_net
    );

  constant9: entity work.constant_dd7b6fe6cd
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant9_op_net
    );

  convert1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 19,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x25,
      clk => clk_1_sg_x25,
      clr => '0',
      din => reinterpret6_output_port_net,
      en => "1",
      dout => convert1_dout_net
    );

  convert3: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 0,
      din_width => 19,
      dout_arith => 2,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x25,
      clk => clk_1_sg_x25,
      clr => '0',
      din => reinterpret1_output_port_net,
      en => "1",
      dout => convert3_dout_net
    );

  delay1: entity work.xldelay
    generic map (
      latency => 254,
      reg_retiming => 0,
      reset => 0,
      width => 47
    )
    port map (
      ce => ce_1_sg_x25,
      clk => clk_1_sg_x25,
      d => mux1_y_net,
      en => '1',
      rst => '1',
      q => delay1_q_net
    );

  delay2: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 30
    )
    port map (
      ce => ce_1_sg_x25,
      clk => clk_1_sg_x25,
      d => reinterpret4_output_port_net,
      en => '1',
      rst => '1',
      q => delay2_q_net
    );

  delay3: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x25,
      clk => clk_1_sg_x25,
      d(0) => relational5_op_net_x1,
      en => '1',
      rst => '1',
      q(0) => delay3_q_net
    );

  delay4: entity work.xldelay
    generic map (
      latency => 256,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x25,
      clk => clk_1_sg_x25,
      d(0) => relational5_op_net_x0,
      en => '1',
      rst => '1',
      q(0) => delay4_q_net
    );

  delay5: entity work.xldelay
    generic map (
      latency => 254,
      reg_retiming => 0,
      reset => 0,
      width => 47
    )
    port map (
      ce => ce_1_sg_x25,
      clk => clk_1_sg_x25,
      d => mux_y_net,
      en => '1',
      rst => '1',
      q => delay5_q_net
    );

  delay6: entity work.xldelay
    generic map (
      latency => 256,
      reg_retiming => 0,
      reset => 0,
      width => 32
    )
    port map (
      ce => ce_1_sg_x25,
      clk => clk_1_sg_x25,
      d => convert3_dout_net,
      en => '1',
      rst => '1',
      q => delay6_q_net
    );

  delay7: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 30
    )
    port map (
      ce => ce_1_sg_x25,
      clk => clk_1_sg_x25,
      d => addsub1_s_net,
      en => '1',
      rst => '1',
      q => delay7_q_net
    );

  inverter: entity work.inverter_e5b38cca3b
    port map (
      ce => ce_1_sg_x25,
      clk => clk_1_sg_x25,
      clr => '0',
      ip(0) => delay3_q_net,
      op(0) => inverter_op_net
    );

  inverter1: entity work.inverter_e5b38cca3b
    port map (
      ce => ce_1_sg_x25,
      clk => clk_1_sg_x25,
      clr => '0',
      ip(0) => relational5_op_net_x0,
      op(0) => inverter1_op_net
    );

  lut_counter1: entity work.xlcounter_free_darkquad29
    generic map (
      core_name0 => "cntr_11_0_8618faf08c8d27ff",
      op_arith => xlUnsigned,
      op_width => 18
    )
    port map (
      ce => ce_1_sg_x25,
      clk => clk_1_sg_x25,
      clr => '0',
      en(0) => delay3_q_net,
      rst(0) => inverter_op_net,
      op => lut_counter1_op_net
    );

  mux: entity work.mux_b54edc8403
    port map (
      ce => ce_1_sg_x25,
      clk => clk_1_sg_x25,
      clr => '0',
      d0 => constant1_op_net,
      d1 => addsub2_s_net,
      sel(0) => delay3_q_net,
      y => mux_y_net
    );

  mux1: entity work.mux_b54edc8403
    port map (
      ce => ce_1_sg_x25,
      clk => clk_1_sg_x25,
      clr => '0',
      d0 => constant2_op_net,
      d1 => addsub1_s_net,
      sel(0) => delay3_q_net,
      y => mux1_y_net
    );

  mux2: entity work.mux_86a34309e7
    port map (
      ce => ce_1_sg_x25,
      clk => clk_1_sg_x25,
      clr => '0',
      d0 => convert1_dout_net,
      d1 => delay6_q_net,
      sel(0) => inverter1_op_net,
      y => mux2_y_net_x0
    );

  mux3: entity work.mux_1e22c21d05
    port map (
      ce => ce_1_sg_x25,
      clk => clk_1_sg_x25,
      clr => '0',
      d0(0) => delay4_q_net,
      d1(0) => relational5_op_net_x0,
      sel(0) => relational5_op_net_x0,
      y(0) => mux3_y_net_x0
    );

  pulse_ext_a9f8db2fd2: entity work.pulse_ext_entity_a9f8db2fd2
    port map (
      ce_1 => ce_1_sg_x25,
      clk_1 => clk_1_sg_x25,
      in_x0 => relational1_op_net_x1,
      out_x0 => relational5_op_net_x0
    );

  reinterpret1: entity work.reinterpret_63700884f5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_29020b53d3
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => force_re_output_port_net_x0,
      output_port => reinterpret2_output_port_net
    );

  reinterpret4: entity work.reinterpret_46dd2ac081
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => addsub2_s_net,
      output_port => reinterpret4_output_port_net
    );

  reinterpret5: entity work.reinterpret_29020b53d3
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => force_im_output_port_net_x0,
      output_port => reinterpret5_output_port_net
    );

  reinterpret6: entity work.reinterpret_63700884f5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret6_output_port_net
    );

  reinterpret7: entity work.reinterpret_29020b53d3
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => force_re_output_port_net_x1,
      output_port => reinterpret7_output_port_net
    );

  reinterpret8: entity work.reinterpret_29020b53d3
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => force_im_output_port_net_x1,
      output_port => reinterpret8_output_port_net
    );

  relational1: entity work.relational_4e76b03051
    port map (
      a => lut_counter1_op_net,
      b => constant9_op_net,
      ce => ce_1_sg_x25,
      clk => clk_1_sg_x25,
      clr => '0',
      op(0) => relational1_op_net_x1
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 11,
      new_msb => 29,
      x_width => 30,
      y_width => 19
    )
    port map (
      x => delay2_q_net,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 11,
      new_msb => 29,
      x_width => 30,
      y_width => 19
    )
    port map (
      x => delay7_q_net,
      y => slice2_y_net
    );

  slice4: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 37,
      x_width => 76,
      y_width => 38
    )
    port map (
      x => delay30_q_net_x0,
      y => slice4_y_net_x0
    );

  slice6: entity work.xlslice
    generic map (
      new_lsb => 38,
      new_msb => 75,
      x_width => 76,
      y_width => 38
    )
    port map (
      x => delay30_q_net_x0,
      y => slice6_y_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/acc_iq/avg0/buscreate"

entity buscreate_entity_7ea6ca3fe1 is
  port (
    in1: in std_logic_vector(31 downto 0); 
    bus_out: out std_logic_vector(31 downto 0)
  );
end buscreate_entity_7ea6ca3fe1;

architecture structural of buscreate_entity_7ea6ca3fe1 is
  signal assert_iq_dout_net_x0: std_logic_vector(31 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(31 downto 0);

begin
  assert_iq_dout_net_x0 <= in1;
  bus_out <= reinterpret1_output_port_net_x0;

  reinterpret1: entity work.reinterpret_3f7e3674f6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => assert_iq_dout_net_x0,
      output_port => reinterpret1_output_port_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/acc_iq/avg0/ss/add_gen/edge_detect"

entity edge_detect_entity_cc793070c9 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic; 
    out_x0: out std_logic
  );
end edge_detect_entity_cc793070c9;

architecture structural of edge_detect_entity_cc793070c9 is
  signal ce_1_sg_x35: std_logic;
  signal clk_1_sg_x35: std_logic;
  signal delay_q_net: std_logic;
  signal edge_op_y_net_x0: std_logic;
  signal inverter_op_net: std_logic;
  signal slice3_y_net_x0: std_logic;

begin
  ce_1_sg_x35 <= ce_1;
  clk_1_sg_x35 <= clk_1;
  slice3_y_net_x0 <= in_x0;
  out_x0 <= edge_op_y_net_x0;

  delay: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x35,
      clk => clk_1_sg_x35,
      d(0) => slice3_y_net_x0,
      en => '1',
      rst => '1',
      q(0) => delay_q_net
    );

  edge_op: entity work.logical_f6397bdee1
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => inverter_op_net,
      d1(0) => delay_q_net,
      y(0) => edge_op_y_net_x0
    );

  inverter: entity work.inverter_e5b38cca3b
    port map (
      ce => ce_1_sg_x35,
      clk => clk_1_sg_x35,
      clr => '0',
      ip(0) => slice3_y_net_x0,
      op(0) => inverter_op_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/acc_iq/avg0/ss/add_gen"

entity add_gen_entity_cfd95544b0 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    cont: in std_logic; 
    din: in std_logic_vector(31 downto 0); 
    go: in std_logic; 
    init: in std_logic; 
    we: in std_logic; 
    add: out std_logic_vector(9 downto 0); 
    dout: out std_logic_vector(31 downto 0); 
    status: out std_logic_vector(31 downto 0); 
    we_o: out std_logic
  );
end add_gen_entity_cfd95544b0;

architecture structural of add_gen_entity_cfd95544b0 is
  signal add_gen_op_net: std_logic_vector(12 downto 0);
  signal ce_1_sg_x36: std_logic;
  signal clk_1_sg_x36: std_logic;
  signal concat_y_net_x0: std_logic_vector(31 downto 0);
  signal convert_dout_net: std_logic_vector(18 downto 0);
  signal data_choice_y_net_x0: std_logic_vector(31 downto 0);
  signal delay1_q_net: std_logic_vector(11 downto 0);
  signal delay3_q_net: std_logic;
  signal delay4_q_net: std_logic;
  signal delay6_q_net_x0: std_logic_vector(31 downto 0);
  signal delay_q_net: std_logic;
  signal edge_op_y_net_x0: std_logic;
  signal edge_op_y_net_x1: std_logic;
  signal inverter1_op_net: std_logic;
  signal inverter_op_net: std_logic;
  signal logical1_y_net: std_logic;
  signal logical4_y_net: std_logic;
  signal logical6_y_net_x0: std_logic;
  signal never_op_net_x0: std_logic;
  signal register5_q_net: std_logic;
  signal register6_q_net_x0: std_logic;
  signal shift_op_net: std_logic_vector(18 downto 0);
  signal slice1_y_net: std_logic_vector(11 downto 0);
  signal slice2_y_net_x0: std_logic_vector(9 downto 0);
  signal slice3_y_net_x0: std_logic;
  signal we_choice_y_net_x0: std_logic;

begin
  ce_1_sg_x36 <= ce_1;
  clk_1_sg_x36 <= clk_1;
  never_op_net_x0 <= cont;
  data_choice_y_net_x0 <= din;
  register6_q_net_x0 <= go;
  edge_op_y_net_x1 <= init;
  we_choice_y_net_x0 <= we;
  add <= slice2_y_net_x0;
  dout <= delay6_q_net_x0;
  status <= concat_y_net_x0;
  we_o <= logical6_y_net_x0;

  add_gen: entity work.xlcounter_free_darkquad29
    generic map (
      core_name0 => "cntr_11_0_dbe4e55db82481fa",
      op_arith => xlUnsigned,
      op_width => 13
    )
    port map (
      ce => ce_1_sg_x36,
      clk => clk_1_sg_x36,
      clr => '0',
      en(0) => logical6_y_net_x0,
      rst(0) => delay4_q_net,
      op => add_gen_op_net
    );

  concat: entity work.concat_1d665a7331
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => shift_op_net,
      in1(0) => inverter_op_net,
      in2 => delay1_q_net,
      y => concat_y_net_x0
    );

  convert: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 19,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x36,
      clk => clk_1_sg_x36,
      clr => '0',
      din(0) => register5_q_net,
      en => "1",
      dout => convert_dout_net
    );

  delay: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x36,
      clk => clk_1_sg_x36,
      clr => '0',
      d(0) => delay4_q_net,
      q(0) => delay_q_net
    );

  delay1: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 12
    )
    port map (
      ce => ce_1_sg_x36,
      clk => clk_1_sg_x36,
      d => slice1_y_net,
      en => '1',
      rst => '1',
      q => delay1_q_net
    );

  delay3: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x36,
      clk => clk_1_sg_x36,
      clr => '0',
      d(0) => never_op_net_x0,
      q(0) => delay3_q_net
    );

  delay4: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x36,
      clk => clk_1_sg_x36,
      clr => '0',
      d(0) => edge_op_y_net_x1,
      q(0) => delay4_q_net
    );

  delay6: entity work.delay_672d2b8d1e
    port map (
      ce => ce_1_sg_x36,
      clk => clk_1_sg_x36,
      clr => '0',
      d => data_choice_y_net_x0,
      q => delay6_q_net_x0
    );

  edge_detect_cc793070c9: entity work.edge_detect_entity_cc793070c9
    port map (
      ce_1 => ce_1_sg_x36,
      clk_1 => clk_1_sg_x36,
      in_x0 => slice3_y_net_x0,
      out_x0 => edge_op_y_net_x0
    );

  inverter: entity work.inverter_6844eee868
    port map (
      ce => ce_1_sg_x36,
      clk => clk_1_sg_x36,
      clr => '0',
      ip(0) => register5_q_net,
      op(0) => inverter_op_net
    );

  inverter1: entity work.inverter_e5b38cca3b
    port map (
      ce => ce_1_sg_x36,
      clk => clk_1_sg_x36,
      clr => '0',
      ip(0) => edge_op_y_net_x0,
      op(0) => inverter1_op_net
    );

  logical1: entity work.logical_799f62af22
    port map (
      ce => ce_1_sg_x36,
      clk => clk_1_sg_x36,
      clr => '0',
      d0(0) => we_choice_y_net_x0,
      d1(0) => register6_q_net_x0,
      y(0) => logical1_y_net
    );

  logical4: entity work.logical_aacf6e1b0e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => delay3_q_net,
      d1(0) => inverter1_op_net,
      y(0) => logical4_y_net
    );

  logical6: entity work.logical_954ee29728
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => register5_q_net,
      d1(0) => logical4_y_net,
      d2(0) => logical1_y_net,
      y(0) => logical6_y_net_x0
    );

  register5: entity work.xlregister
    generic map (
      d_width => 1,
      init_value => b"1"
    )
    port map (
      ce => ce_1_sg_x36,
      clk => clk_1_sg_x36,
      d(0) => delay3_q_net,
      en(0) => edge_op_y_net_x0,
      rst(0) => delay_q_net,
      q(0) => register5_q_net
    );

  shift: entity work.shift_892c2104f7
    port map (
      ce => ce_1_sg_x36,
      clk => clk_1_sg_x36,
      clr => '0',
      ip => convert_dout_net,
      op => shift_op_net
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 11,
      x_width => 13,
      y_width => 12
    )
    port map (
      x => add_gen_op_net,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 2,
      new_msb => 11,
      x_width => 13,
      y_width => 10
    )
    port map (
      x => add_gen_op_net,
      y => slice2_y_net_x0
    );

  slice3: entity work.xlslice
    generic map (
      new_lsb => 12,
      new_msb => 12,
      x_width => 13,
      y_width => 1
    )
    port map (
      x => add_gen_op_net,
      y(0) => slice3_y_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/acc_iq/avg0/ss/basic_ctrl/dram_munge"

entity dram_munge_entity_6cbd3ca775 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(31 downto 0); 
    init: in std_logic; 
    we: in std_logic; 
    dout: out std_logic_vector(31 downto 0); 
    we_o: out std_logic
  );
end dram_munge_entity_6cbd3ca775;

architecture structural of dram_munge_entity_6cbd3ca775 is
  signal cast_dout_net_x0: std_logic_vector(31 downto 0);
  signal ce_1_sg_x37: std_logic;
  signal clk_1_sg_x37: std_logic;
  signal con0_op_net: std_logic_vector(1 downto 0);
  signal con1_op_net: std_logic_vector(1 downto 0);
  signal con2_op_net: std_logic_vector(1 downto 0);
  signal con3_op_net: std_logic_vector(1 downto 0);
  signal concat1_y_net: std_logic_vector(79 downto 0);
  signal concat_y_net: std_logic_vector(79 downto 0);
  signal constant_op_net: std_logic_vector(7 downto 0);
  signal data_choice_y_net_x1: std_logic_vector(31 downto 0);
  signal delay1_q_net: std_logic;
  signal delay_q_net: std_logic;
  signal dout_count_op_net: std_logic;
  signal dram_op_net: std_logic;
  signal edge_op_y_net_x2: std_logic;
  signal input_count_op_net: std_logic_vector(1 downto 0);
  signal logical1_y_net: std_logic;
  signal logical_y_net: std_logic;
  signal mux1_y_net_x0: std_logic_vector(79 downto 0);
  signal mux1_y_net_x1: std_logic;
  signal register1_q_net: std_logic_vector(31 downto 0);
  signal register2_q_net: std_logic_vector(31 downto 0);
  signal register3_q_net: std_logic_vector(31 downto 0);
  signal register_q_net: std_logic_vector(31 downto 0);
  signal relational1_op_net: std_logic;
  signal relational2_op_net: std_logic;
  signal relational3_op_net: std_logic;
  signal relational_op_net: std_logic;
  signal we_choice_y_net_x1: std_logic;

begin
  ce_1_sg_x37 <= ce_1;
  clk_1_sg_x37 <= clk_1;
  cast_dout_net_x0 <= din;
  edge_op_y_net_x2 <= init;
  mux1_y_net_x1 <= we;
  dout <= data_choice_y_net_x1;
  we_o <= we_choice_y_net_x1;

  con0: entity work.constant_cda50df78a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => con0_op_net
    );

  con1: entity work.constant_a7e2bb9e12
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => con1_op_net
    );

  con2: entity work.constant_e8ddc079e9
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => con2_op_net
    );

  con3: entity work.constant_3a9a3daeb9
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => con3_op_net
    );

  concat: entity work.concat_762608f33d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => constant_op_net,
      in1 => register_q_net,
      in2 => constant_op_net,
      in3 => register1_q_net,
      y => concat_y_net
    );

  concat1: entity work.concat_762608f33d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => constant_op_net,
      in1 => register2_q_net,
      in2 => constant_op_net,
      in3 => register3_q_net,
      y => concat1_y_net
    );

  constant_x0: entity work.constant_91ef1678ca
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant_op_net
    );

  data_choice: entity work.mux_b4a3823c60
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0 => cast_dout_net_x0,
      d1 => mux1_y_net_x0,
      sel(0) => dram_op_net,
      y => data_choice_y_net_x1
    );

  delay: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x37,
      clk => clk_1_sg_x37,
      d(0) => logical_y_net,
      en => '1',
      rst => '1',
      q(0) => delay_q_net
    );

  delay1: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x37,
      clk => clk_1_sg_x37,
      d(0) => logical1_y_net,
      en => '1',
      rst => '1',
      q(0) => delay1_q_net
    );

  dout_count: entity work.counter_caa2b01eef
    port map (
      ce => ce_1_sg_x37,
      clk => clk_1_sg_x37,
      clr => '0',
      en(0) => logical1_y_net,
      rst(0) => edge_op_y_net_x2,
      op(0) => dout_count_op_net
    );

  dram: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => dram_op_net
    );

  input_count: entity work.xlcounter_free_darkquad29
    generic map (
      core_name0 => "cntr_11_0_10352c017544bebd",
      op_arith => xlUnsigned,
      op_width => 2
    )
    port map (
      ce => ce_1_sg_x37,
      clk => clk_1_sg_x37,
      clr => '0',
      en(0) => mux1_y_net_x1,
      rst(0) => edge_op_y_net_x2,
      op => input_count_op_net
    );

  logical: entity work.logical_799f62af22
    port map (
      ce => ce_1_sg_x37,
      clk => clk_1_sg_x37,
      clr => '0',
      d0(0) => relational3_op_net,
      d1(0) => mux1_y_net_x1,
      y(0) => logical_y_net
    );

  logical1: entity work.logical_aacf6e1b0e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => logical_y_net,
      d1(0) => delay_q_net,
      y(0) => logical1_y_net
    );

  mux1: entity work.mux_a575c74b27
    port map (
      ce => ce_1_sg_x37,
      clk => clk_1_sg_x37,
      clr => '0',
      d0 => concat_y_net,
      d1 => concat1_y_net,
      sel(0) => dout_count_op_net,
      y => mux1_y_net_x0
    );

  register1: entity work.xlregister
    generic map (
      d_width => 32,
      init_value => b"00000000000000000000000000000000"
    )
    port map (
      ce => ce_1_sg_x37,
      clk => clk_1_sg_x37,
      d => cast_dout_net_x0,
      en(0) => relational1_op_net,
      rst => "0",
      q => register1_q_net
    );

  register2: entity work.xlregister
    generic map (
      d_width => 32,
      init_value => b"00000000000000000000000000000000"
    )
    port map (
      ce => ce_1_sg_x37,
      clk => clk_1_sg_x37,
      d => cast_dout_net_x0,
      en(0) => relational2_op_net,
      rst => "0",
      q => register2_q_net
    );

  register3: entity work.xlregister
    generic map (
      d_width => 32,
      init_value => b"00000000000000000000000000000000"
    )
    port map (
      ce => ce_1_sg_x37,
      clk => clk_1_sg_x37,
      d => cast_dout_net_x0,
      en(0) => relational3_op_net,
      rst => "0",
      q => register3_q_net
    );

  register_x0: entity work.xlregister
    generic map (
      d_width => 32,
      init_value => b"00000000000000000000000000000000"
    )
    port map (
      ce => ce_1_sg_x37,
      clk => clk_1_sg_x37,
      d => cast_dout_net_x0,
      en(0) => relational_op_net,
      rst => "0",
      q => register_q_net
    );

  relational: entity work.relational_5f1eb17108
    port map (
      a => input_count_op_net,
      b => con0_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational_op_net
    );

  relational1: entity work.relational_5f1eb17108
    port map (
      a => input_count_op_net,
      b => con1_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational1_op_net
    );

  relational2: entity work.relational_5f1eb17108
    port map (
      a => input_count_op_net,
      b => con2_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational2_op_net
    );

  relational3: entity work.relational_5f1eb17108
    port map (
      a => input_count_op_net,
      b => con3_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational3_op_net
    );

  we_choice: entity work.mux_d99e59b6d4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => mux1_y_net_x1,
      d1(0) => delay1_q_net,
      sel(0) => dram_op_net,
      y(0) => we_choice_y_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/acc_iq/avg0/ss/basic_ctrl"

entity basic_ctrl_entity_e1fef81f73 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    ctrl: in std_logic_vector(31 downto 0); 
    din: in std_logic_vector(31 downto 0); 
    trig: in std_logic; 
    we: in std_logic; 
    dout: out std_logic_vector(31 downto 0); 
    go: out std_logic; 
    init: out std_logic; 
    we_o: out std_logic
  );
end basic_ctrl_entity_e1fef81f73;

architecture structural of basic_ctrl_entity_e1fef81f73 is
  signal cast_dout_net_x1: std_logic_vector(31 downto 0);
  signal ce_1_sg_x39: std_logic;
  signal clk_1_sg_x39: std_logic;
  signal constant1_op_net: std_logic;
  signal constant2_op_net: std_logic;
  signal constant_op_net: std_logic;
  signal data_choice_y_net_x2: std_logic_vector(31 downto 0);
  signal delay1_q_net_x0: std_logic;
  signal delay2_q_net: std_logic;
  signal delay3_q_net: std_logic;
  signal edge_op_y_net_x4: std_logic;
  signal enable_y_net: std_logic;
  signal inverter_op_net: std_logic;
  signal logical_y_net: std_logic;
  signal mux1_y_net_x1: std_logic;
  signal mux2_y_net: std_logic;
  signal mux3_y_net_x1: std_logic;
  signal register1_q_net: std_logic;
  signal register1_q_net_x1: std_logic;
  signal register6_q_net_x1: std_logic;
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal trig_src_y_net: std_logic;
  signal valid_src_y_net: std_logic;
  signal we_choice_y_net_x2: std_logic;

begin
  ce_1_sg_x39 <= ce_1;
  clk_1_sg_x39 <= clk_1;
  reint1_output_port_net_x0 <= ctrl;
  cast_dout_net_x1 <= din;
  register1_q_net_x1 <= trig;
  mux3_y_net_x1 <= we;
  dout <= data_choice_y_net_x2;
  go <= register6_q_net_x1;
  init <= edge_op_y_net_x4;
  we_o <= we_choice_y_net_x2;

  constant1: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant1_op_net
    );

  constant2: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant2_op_net
    );

  constant_x0: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant_op_net
    );

  delay1: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x39,
      clk => clk_1_sg_x39,
      d(0) => enable_y_net,
      en => '1',
      rst => '1',
      q(0) => delay1_q_net_x0
    );

  delay2: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x39,
      clk => clk_1_sg_x39,
      d(0) => trig_src_y_net,
      en => '1',
      rst => '1',
      q(0) => delay2_q_net
    );

  delay3: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x39,
      clk => clk_1_sg_x39,
      d(0) => valid_src_y_net,
      en => '1',
      rst => '1',
      q(0) => delay3_q_net
    );

  dram_munge_6cbd3ca775: entity work.dram_munge_entity_6cbd3ca775
    port map (
      ce_1 => ce_1_sg_x39,
      clk_1 => clk_1_sg_x39,
      din => cast_dout_net_x1,
      init => edge_op_y_net_x4,
      we => mux1_y_net_x1,
      dout => data_choice_y_net_x2,
      we_o => we_choice_y_net_x2
    );

  edge_detect_12f2268732: entity work.edge_detect3_entity_2efb246ca9
    port map (
      ce_1 => ce_1_sg_x39,
      clk_1 => clk_1_sg_x39,
      in_x0 => delay1_q_net_x0,
      out_x0 => edge_op_y_net_x4
    );

  enable: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => reint1_output_port_net_x0,
      y(0) => enable_y_net
    );

  inverter: entity work.inverter_e5b38cca3b
    port map (
      ce => ce_1_sg_x39,
      clk => clk_1_sg_x39,
      clr => '0',
      ip(0) => edge_op_y_net_x4,
      op(0) => inverter_op_net
    );

  logical: entity work.logical_80f90b97d0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => mux2_y_net,
      d1(0) => inverter_op_net,
      y(0) => logical_y_net
    );

  mux1: entity work.mux_d99e59b6d4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => mux3_y_net_x1,
      d1(0) => constant2_op_net,
      sel(0) => delay3_q_net,
      y(0) => mux1_y_net_x1
    );

  mux2: entity work.mux_d99e59b6d4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => register1_q_net_x1,
      d1(0) => constant1_op_net,
      sel(0) => delay2_q_net,
      y(0) => mux2_y_net
    );

  register1: entity work.xlregister
    generic map (
      d_width => 1,
      init_value => b"0"
    )
    port map (
      ce => ce_1_sg_x39,
      clk => clk_1_sg_x39,
      d(0) => constant_op_net,
      en(0) => edge_op_y_net_x4,
      rst(0) => logical_y_net,
      q(0) => register1_q_net
    );

  register6: entity work.xlregister
    generic map (
      d_width => 1,
      init_value => b"0"
    )
    port map (
      ce => ce_1_sg_x39,
      clk => clk_1_sg_x39,
      d(0) => mux2_y_net,
      en(0) => register1_q_net,
      rst(0) => edge_op_y_net_x4,
      q(0) => register6_q_net_x1
    );

  trig_src: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 1,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => reint1_output_port_net_x0,
      y(0) => trig_src_y_net
    );

  valid_src: entity work.xlslice
    generic map (
      new_lsb => 2,
      new_msb => 2,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => reint1_output_port_net_x0,
      y(0) => valid_src_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/acc_iq/avg0/ss/bram/calc_add"

entity calc_add_entity_1a48115d4e is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(9 downto 0); 
    out_x0: out std_logic_vector(9 downto 0)
  );
end calc_add_entity_1a48115d4e;

architecture structural of calc_add_entity_1a48115d4e is
  signal add_del_q_net_x0: std_logic_vector(9 downto 0);
  signal add_sub_s_net: std_logic;
  signal ce_1_sg_x40: std_logic;
  signal clk_1_sg_x40: std_logic;
  signal concat_y_net: std_logic_vector(9 downto 0);
  signal const_op_net: std_logic;
  signal convert_addr_dout_net: std_logic_vector(9 downto 0);
  signal lsw_y_net: std_logic;
  signal manipulate_op_net: std_logic;
  signal msw_y_net: std_logic_vector(8 downto 0);
  signal mux_y_net_x0: std_logic_vector(9 downto 0);

begin
  ce_1_sg_x40 <= ce_1;
  clk_1_sg_x40 <= clk_1;
  add_del_q_net_x0 <= in_x0;
  out_x0 <= mux_y_net_x0;

  add_sub: entity work.addsub_c13097e33e
    port map (
      a(0) => const_op_net,
      b(0) => lsw_y_net,
      ce => ce_1_sg_x40,
      clk => clk_1_sg_x40,
      clr => '0',
      s(0) => add_sub_s_net
    );

  concat: entity work.concat_1d98d96b58
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => msw_y_net,
      in1(0) => add_sub_s_net,
      y => concat_y_net
    );

  const: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => const_op_net
    );

  convert_addr: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 10,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 10,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x40,
      clk => clk_1_sg_x40,
      clr => '0',
      din => add_del_q_net_x0,
      en => "1",
      dout => convert_addr_dout_net
    );

  lsw: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 10,
      y_width => 1
    )
    port map (
      x => convert_addr_dout_net,
      y(0) => lsw_y_net
    );

  manipulate: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => manipulate_op_net
    );

  msw: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 9,
      x_width => 10,
      y_width => 9
    )
    port map (
      x => convert_addr_dout_net,
      y => msw_y_net
    );

  mux: entity work.mux_4fe5face7f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0 => convert_addr_dout_net,
      d1 => concat_y_net,
      sel(0) => manipulate_op_net,
      y => mux_y_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/acc_iq/avg0/ss/bram"

entity bram_entity_f0ce0d3c3e is
  port (
    addr: in std_logic_vector(9 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    data_in: in std_logic_vector(31 downto 0); 
    we: in std_logic; 
    convert_addr_x0: out std_logic_vector(9 downto 0); 
    convert_din1_x0: out std_logic_vector(31 downto 0); 
    convert_we_x0: out std_logic
  );
end bram_entity_f0ce0d3c3e;

architecture structural of bram_entity_f0ce0d3c3e is
  signal add_del_q_net_x1: std_logic_vector(9 downto 0);
  signal ce_1_sg_x41: std_logic;
  signal clk_1_sg_x41: std_logic;
  signal convert_addr_dout_net_x0: std_logic_vector(9 downto 0);
  signal convert_din1_dout_net_x0: std_logic_vector(31 downto 0);
  signal convert_we_dout_net_x0: std_logic;
  signal dat_del_q_net_x1: std_logic_vector(31 downto 0);
  signal mux_y_net_x0: std_logic_vector(9 downto 0);
  signal reinterpret_out_output_port_net_x0: std_logic_vector(31 downto 0);
  signal we_del_q_net_x0: std_logic;

begin
  add_del_q_net_x1 <= addr;
  ce_1_sg_x41 <= ce_1;
  clk_1_sg_x41 <= clk_1;
  dat_del_q_net_x1 <= data_in;
  we_del_q_net_x0 <= we;
  convert_addr_x0 <= convert_addr_dout_net_x0;
  convert_din1_x0 <= convert_din1_dout_net_x0;
  convert_we_x0 <= convert_we_dout_net_x0;

  calc_add_1a48115d4e: entity work.calc_add_entity_1a48115d4e
    port map (
      ce_1 => ce_1_sg_x41,
      clk_1 => clk_1_sg_x41,
      in_x0 => add_del_q_net_x1,
      out_x0 => mux_y_net_x0
    );

  convert_addr: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 10,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 10,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x41,
      clk => clk_1_sg_x41,
      clr => '0',
      din => mux_y_net_x0,
      en => "1",
      dout => convert_addr_dout_net_x0
    );

  convert_din1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 32,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x41,
      clk => clk_1_sg_x41,
      clr => '0',
      din => reinterpret_out_output_port_net_x0,
      en => "1",
      dout => convert_din1_dout_net_x0
    );

  convert_we: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x41,
      clk => clk_1_sg_x41,
      clr => '0',
      din(0) => we_del_q_net_x0,
      en => "1",
      dout(0) => convert_we_dout_net_x0
    );

  munge_in_2099deb209: entity work.munge_in_entity_9341d54c73
    port map (
      din => dat_del_q_net_x1,
      dout => reinterpret_out_output_port_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/acc_iq/avg0/ss/ctrl"

entity ctrl_entity_0c3788c076 is
  port (
    darkquad29_acc_iq_avg0_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end ctrl_entity_0c3788c076;

architecture structural of ctrl_entity_0c3788c076 is
  signal darkquad29_acc_iq_avg0_ss_ctrl_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_acc_iq_avg0_ss_ctrl_user_data_out_net_x0 <= darkquad29_acc_iq_avg0_ss_ctrl_user_data_out;
  in_reg <= reint1_output_port_net_x1;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_acc_iq_avg0_ss_ctrl_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x1
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/acc_iq/avg0/ss"

entity ss_entity_66b0f1afdc is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    darkquad29_acc_iq_avg0_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    din: in std_logic_vector(31 downto 0); 
    trig: in std_logic; 
    we: in std_logic; 
    bram: out std_logic_vector(9 downto 0); 
    bram_x0: out std_logic_vector(31 downto 0); 
    bram_x1: out std_logic; 
    status: out std_logic_vector(31 downto 0)
  );
end ss_entity_66b0f1afdc;

architecture structural of ss_entity_66b0f1afdc is
  signal add_del_q_net_x1: std_logic_vector(9 downto 0);
  signal cast_dout_net_x1: std_logic_vector(31 downto 0);
  signal cast_gw_dout_net_x1: std_logic_vector(31 downto 0);
  signal ce_1_sg_x43: std_logic;
  signal clk_1_sg_x43: std_logic;
  signal concat_y_net_x1: std_logic_vector(31 downto 0);
  signal convert_addr_dout_net_x1: std_logic_vector(9 downto 0);
  signal convert_din1_dout_net_x1: std_logic_vector(31 downto 0);
  signal convert_we_dout_net_x1: std_logic;
  signal darkquad29_acc_iq_avg0_ss_ctrl_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal dat_del_q_net_x1: std_logic_vector(31 downto 0);
  signal data_choice_y_net_x2: std_logic_vector(31 downto 0);
  signal delay6_q_net_x0: std_logic_vector(31 downto 0);
  signal edge_op_y_net_x4: std_logic;
  signal logical6_y_net_x0: std_logic;
  signal mux3_y_net_x2: std_logic;
  signal never_op_net_x0: std_logic;
  signal register1_q_net_x2: std_logic;
  signal register6_q_net_x1: std_logic;
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal reinterpret1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal ri_output_port_net: std_logic_vector(31 downto 0);
  signal slice2_y_net_x0: std_logic_vector(9 downto 0);
  signal we_choice_y_net_x2: std_logic;
  signal we_del_q_net_x0: std_logic;

begin
  ce_1_sg_x43 <= ce_1;
  clk_1_sg_x43 <= clk_1;
  darkquad29_acc_iq_avg0_ss_ctrl_user_data_out_net_x1 <= darkquad29_acc_iq_avg0_ss_ctrl_user_data_out;
  reinterpret1_output_port_net_x1 <= din;
  register1_q_net_x2 <= trig;
  mux3_y_net_x2 <= we;
  bram <= convert_addr_dout_net_x1;
  bram_x0 <= convert_din1_dout_net_x1;
  bram_x1 <= convert_we_dout_net_x1;
  status <= cast_gw_dout_net_x1;

  add_del: entity work.delay_cf4f99539f
    port map (
      ce => ce_1_sg_x43,
      clk => clk_1_sg_x43,
      clr => '0',
      d => slice2_y_net_x0,
      q => add_del_q_net_x1
    );

  add_gen_cfd95544b0: entity work.add_gen_entity_cfd95544b0
    port map (
      ce_1 => ce_1_sg_x43,
      clk_1 => clk_1_sg_x43,
      cont => never_op_net_x0,
      din => data_choice_y_net_x2,
      go => register6_q_net_x1,
      init => edge_op_y_net_x4,
      we => we_choice_y_net_x2,
      add => slice2_y_net_x0,
      dout => delay6_q_net_x0,
      status => concat_y_net_x1,
      we_o => logical6_y_net_x0
    );

  basic_ctrl_e1fef81f73: entity work.basic_ctrl_entity_e1fef81f73
    port map (
      ce_1 => ce_1_sg_x43,
      clk_1 => clk_1_sg_x43,
      ctrl => reint1_output_port_net_x1,
      din => cast_dout_net_x1,
      trig => register1_q_net_x2,
      we => mux3_y_net_x2,
      dout => data_choice_y_net_x2,
      go => register6_q_net_x1,
      init => edge_op_y_net_x4,
      we_o => we_choice_y_net_x2
    );

  bram_f0ce0d3c3e: entity work.bram_entity_f0ce0d3c3e
    port map (
      addr => add_del_q_net_x1,
      ce_1 => ce_1_sg_x43,
      clk_1 => clk_1_sg_x43,
      data_in => dat_del_q_net_x1,
      we => we_del_q_net_x0,
      convert_addr_x0 => convert_addr_dout_net_x1,
      convert_din1_x0 => convert_din1_dout_net_x1,
      convert_we_x0 => convert_we_dout_net_x1
    );

  cast: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 32,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x43,
      clk => clk_1_sg_x43,
      clr => '0',
      din => ri_output_port_net,
      en => "1",
      dout => cast_dout_net_x1
    );

  ctrl_0c3788c076: entity work.ctrl_entity_0c3788c076
    port map (
      darkquad29_acc_iq_avg0_ss_ctrl_user_data_out => darkquad29_acc_iq_avg0_ss_ctrl_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x1
    );

  dat_del: entity work.delay_672d2b8d1e
    port map (
      ce => ce_1_sg_x43,
      clk => clk_1_sg_x43,
      clr => '0',
      d => delay6_q_net_x0,
      q => dat_del_q_net_x1
    );

  never: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => never_op_net_x0
    );

  ri: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => reinterpret1_output_port_net_x1,
      output_port => ri_output_port_net
    );

  status_bc4868ef55: entity work.last_tx_data_entity_4b5ba71046
    port map (
      ce_1 => ce_1_sg_x43,
      clk_1 => clk_1_sg_x43,
      out_reg => concat_y_net_x1,
      cast_gw_x0 => cast_gw_dout_net_x1
    );

  we_del: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x43,
      clk => clk_1_sg_x43,
      clr => '0',
      d(0) => logical6_y_net_x0,
      q(0) => we_del_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/acc_iq/avg0"

entity avg0_entity_d122a9b10c is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    darkquad29_acc_iq_avg0_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    in_iq: in std_logic_vector(31 downto 0); 
    trig: in std_logic; 
    we: in std_logic; 
    ss: out std_logic_vector(9 downto 0); 
    ss_x0: out std_logic_vector(31 downto 0); 
    ss_x1: out std_logic; 
    ss_x2: out std_logic_vector(31 downto 0)
  );
end avg0_entity_d122a9b10c;

architecture structural of avg0_entity_d122a9b10c is
  signal assert_iq_dout_net_x0: std_logic_vector(31 downto 0);
  signal cast_gw_dout_net_x2: std_logic_vector(31 downto 0);
  signal ce_1_sg_x44: std_logic;
  signal clk_1_sg_x44: std_logic;
  signal convert_addr_dout_net_x2: std_logic_vector(9 downto 0);
  signal convert_din1_dout_net_x2: std_logic_vector(31 downto 0);
  signal convert_we_dout_net_x2: std_logic;
  signal darkquad29_acc_iq_avg0_ss_ctrl_user_data_out_net_x2: std_logic_vector(31 downto 0);
  signal mux2_y_net_x1: std_logic_vector(31 downto 0);
  signal mux3_y_net_x3: std_logic;
  signal register1_q_net_x3: std_logic;
  signal reinterpret1_output_port_net_x1: std_logic_vector(31 downto 0);

begin
  ce_1_sg_x44 <= ce_1;
  clk_1_sg_x44 <= clk_1;
  darkquad29_acc_iq_avg0_ss_ctrl_user_data_out_net_x2 <= darkquad29_acc_iq_avg0_ss_ctrl_user_data_out;
  mux2_y_net_x1 <= in_iq;
  register1_q_net_x3 <= trig;
  mux3_y_net_x3 <= we;
  ss <= convert_addr_dout_net_x2;
  ss_x0 <= convert_din1_dout_net_x2;
  ss_x1 <= convert_we_dout_net_x2;
  ss_x2 <= cast_gw_dout_net_x2;

  assert_iq: entity work.xlpassthrough
    generic map (
      din_width => 32,
      dout_width => 32
    )
    port map (
      din => mux2_y_net_x1,
      dout => assert_iq_dout_net_x0
    );

  buscreate_7ea6ca3fe1: entity work.buscreate_entity_7ea6ca3fe1
    port map (
      in1 => assert_iq_dout_net_x0,
      bus_out => reinterpret1_output_port_net_x1
    );

  ss_66b0f1afdc: entity work.ss_entity_66b0f1afdc
    port map (
      ce_1 => ce_1_sg_x44,
      clk_1 => clk_1_sg_x44,
      darkquad29_acc_iq_avg0_ss_ctrl_user_data_out => darkquad29_acc_iq_avg0_ss_ctrl_user_data_out_net_x2,
      din => reinterpret1_output_port_net_x1,
      trig => register1_q_net_x3,
      we => mux3_y_net_x3,
      bram => convert_addr_dout_net_x2,
      bram_x0 => convert_din1_dout_net_x2,
      bram_x1 => convert_we_dout_net_x2,
      status => cast_gw_dout_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/acc_iq/avg1/ss/ctrl"

entity ctrl_entity_2df84c4456 is
  port (
    darkquad29_acc_iq_avg1_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end ctrl_entity_2df84c4456;

architecture structural of ctrl_entity_2df84c4456 is
  signal darkquad29_acc_iq_avg1_ss_ctrl_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_acc_iq_avg1_ss_ctrl_user_data_out_net_x0 <= darkquad29_acc_iq_avg1_ss_ctrl_user_data_out;
  in_reg <= reint1_output_port_net_x1;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_acc_iq_avg1_ss_ctrl_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x1
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/acc_iq/avg1/ss"

entity ss_entity_d9aac7e9ea is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    darkquad29_acc_iq_avg1_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    din: in std_logic_vector(31 downto 0); 
    trig: in std_logic; 
    we: in std_logic; 
    bram: out std_logic_vector(9 downto 0); 
    bram_x0: out std_logic_vector(31 downto 0); 
    bram_x1: out std_logic; 
    status: out std_logic_vector(31 downto 0)
  );
end ss_entity_d9aac7e9ea;

architecture structural of ss_entity_d9aac7e9ea is
  signal add_del_q_net_x1: std_logic_vector(9 downto 0);
  signal cast_dout_net_x1: std_logic_vector(31 downto 0);
  signal cast_gw_dout_net_x1: std_logic_vector(31 downto 0);
  signal ce_1_sg_x53: std_logic;
  signal clk_1_sg_x53: std_logic;
  signal concat_y_net_x1: std_logic_vector(31 downto 0);
  signal convert_addr_dout_net_x1: std_logic_vector(9 downto 0);
  signal convert_din1_dout_net_x1: std_logic_vector(31 downto 0);
  signal convert_we_dout_net_x1: std_logic;
  signal darkquad29_acc_iq_avg1_ss_ctrl_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal dat_del_q_net_x1: std_logic_vector(31 downto 0);
  signal data_choice_y_net_x2: std_logic_vector(31 downto 0);
  signal delay6_q_net_x0: std_logic_vector(31 downto 0);
  signal edge_op_y_net_x4: std_logic;
  signal logical6_y_net_x0: std_logic;
  signal mux3_y_net_x2: std_logic;
  signal never_op_net_x0: std_logic;
  signal register1_q_net_x5: std_logic;
  signal register6_q_net_x1: std_logic;
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal reinterpret1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal ri_output_port_net: std_logic_vector(31 downto 0);
  signal slice2_y_net_x0: std_logic_vector(9 downto 0);
  signal we_choice_y_net_x2: std_logic;
  signal we_del_q_net_x0: std_logic;

begin
  ce_1_sg_x53 <= ce_1;
  clk_1_sg_x53 <= clk_1;
  darkquad29_acc_iq_avg1_ss_ctrl_user_data_out_net_x1 <= darkquad29_acc_iq_avg1_ss_ctrl_user_data_out;
  reinterpret1_output_port_net_x1 <= din;
  register1_q_net_x5 <= trig;
  mux3_y_net_x2 <= we;
  bram <= convert_addr_dout_net_x1;
  bram_x0 <= convert_din1_dout_net_x1;
  bram_x1 <= convert_we_dout_net_x1;
  status <= cast_gw_dout_net_x1;

  add_del: entity work.delay_cf4f99539f
    port map (
      ce => ce_1_sg_x53,
      clk => clk_1_sg_x53,
      clr => '0',
      d => slice2_y_net_x0,
      q => add_del_q_net_x1
    );

  add_gen_b69f479457: entity work.add_gen_entity_cfd95544b0
    port map (
      ce_1 => ce_1_sg_x53,
      clk_1 => clk_1_sg_x53,
      cont => never_op_net_x0,
      din => data_choice_y_net_x2,
      go => register6_q_net_x1,
      init => edge_op_y_net_x4,
      we => we_choice_y_net_x2,
      add => slice2_y_net_x0,
      dout => delay6_q_net_x0,
      status => concat_y_net_x1,
      we_o => logical6_y_net_x0
    );

  basic_ctrl_9dd7b8de25: entity work.basic_ctrl_entity_e1fef81f73
    port map (
      ce_1 => ce_1_sg_x53,
      clk_1 => clk_1_sg_x53,
      ctrl => reint1_output_port_net_x1,
      din => cast_dout_net_x1,
      trig => register1_q_net_x5,
      we => mux3_y_net_x2,
      dout => data_choice_y_net_x2,
      go => register6_q_net_x1,
      init => edge_op_y_net_x4,
      we_o => we_choice_y_net_x2
    );

  bram_8bbd09cf74: entity work.bram_entity_f0ce0d3c3e
    port map (
      addr => add_del_q_net_x1,
      ce_1 => ce_1_sg_x53,
      clk_1 => clk_1_sg_x53,
      data_in => dat_del_q_net_x1,
      we => we_del_q_net_x0,
      convert_addr_x0 => convert_addr_dout_net_x1,
      convert_din1_x0 => convert_din1_dout_net_x1,
      convert_we_x0 => convert_we_dout_net_x1
    );

  cast: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 32,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x53,
      clk => clk_1_sg_x53,
      clr => '0',
      din => ri_output_port_net,
      en => "1",
      dout => cast_dout_net_x1
    );

  ctrl_2df84c4456: entity work.ctrl_entity_2df84c4456
    port map (
      darkquad29_acc_iq_avg1_ss_ctrl_user_data_out => darkquad29_acc_iq_avg1_ss_ctrl_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x1
    );

  dat_del: entity work.delay_672d2b8d1e
    port map (
      ce => ce_1_sg_x53,
      clk => clk_1_sg_x53,
      clr => '0',
      d => delay6_q_net_x0,
      q => dat_del_q_net_x1
    );

  never: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => never_op_net_x0
    );

  ri: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => reinterpret1_output_port_net_x1,
      output_port => ri_output_port_net
    );

  status_5212e5be08: entity work.last_tx_data_entity_4b5ba71046
    port map (
      ce_1 => ce_1_sg_x53,
      clk_1 => clk_1_sg_x53,
      out_reg => concat_y_net_x1,
      cast_gw_x0 => cast_gw_dout_net_x1
    );

  we_del: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x53,
      clk => clk_1_sg_x53,
      clr => '0',
      d(0) => logical6_y_net_x0,
      q(0) => we_del_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/acc_iq/avg1"

entity avg1_entity_876a3da11a is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    darkquad29_acc_iq_avg1_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    in_iq: in std_logic_vector(31 downto 0); 
    trig: in std_logic; 
    we: in std_logic; 
    ss: out std_logic_vector(9 downto 0); 
    ss_x0: out std_logic_vector(31 downto 0); 
    ss_x1: out std_logic; 
    ss_x2: out std_logic_vector(31 downto 0)
  );
end avg1_entity_876a3da11a;

architecture structural of avg1_entity_876a3da11a is
  signal assert_iq_dout_net_x0: std_logic_vector(31 downto 0);
  signal cast_gw_dout_net_x2: std_logic_vector(31 downto 0);
  signal ce_1_sg_x54: std_logic;
  signal clk_1_sg_x54: std_logic;
  signal convert_addr_dout_net_x2: std_logic_vector(9 downto 0);
  signal convert_din1_dout_net_x2: std_logic_vector(31 downto 0);
  signal convert_we_dout_net_x2: std_logic;
  signal darkquad29_acc_iq_avg1_ss_ctrl_user_data_out_net_x2: std_logic_vector(31 downto 0);
  signal mux2_y_net_x1: std_logic_vector(31 downto 0);
  signal mux3_y_net_x3: std_logic;
  signal register1_q_net_x6: std_logic;
  signal reinterpret1_output_port_net_x1: std_logic_vector(31 downto 0);

begin
  ce_1_sg_x54 <= ce_1;
  clk_1_sg_x54 <= clk_1;
  darkquad29_acc_iq_avg1_ss_ctrl_user_data_out_net_x2 <= darkquad29_acc_iq_avg1_ss_ctrl_user_data_out;
  mux2_y_net_x1 <= in_iq;
  register1_q_net_x6 <= trig;
  mux3_y_net_x3 <= we;
  ss <= convert_addr_dout_net_x2;
  ss_x0 <= convert_din1_dout_net_x2;
  ss_x1 <= convert_we_dout_net_x2;
  ss_x2 <= cast_gw_dout_net_x2;

  assert_iq: entity work.xlpassthrough
    generic map (
      din_width => 32,
      dout_width => 32
    )
    port map (
      din => mux2_y_net_x1,
      dout => assert_iq_dout_net_x0
    );

  buscreate_6d6d385bc6: entity work.buscreate_entity_7ea6ca3fe1
    port map (
      in1 => assert_iq_dout_net_x0,
      bus_out => reinterpret1_output_port_net_x1
    );

  ss_d9aac7e9ea: entity work.ss_entity_d9aac7e9ea
    port map (
      ce_1 => ce_1_sg_x54,
      clk_1 => clk_1_sg_x54,
      darkquad29_acc_iq_avg1_ss_ctrl_user_data_out => darkquad29_acc_iq_avg1_ss_ctrl_user_data_out_net_x2,
      din => reinterpret1_output_port_net_x1,
      trig => register1_q_net_x6,
      we => mux3_y_net_x3,
      bram => convert_addr_dout_net_x2,
      bram_x0 => convert_din1_dout_net_x2,
      bram_x1 => convert_we_dout_net_x2,
      status => cast_gw_dout_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/acc_iq/avg2/ss/ctrl"

entity ctrl_entity_e14fbc9b11 is
  port (
    darkquad29_acc_iq_avg2_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end ctrl_entity_e14fbc9b11;

architecture structural of ctrl_entity_e14fbc9b11 is
  signal darkquad29_acc_iq_avg2_ss_ctrl_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_acc_iq_avg2_ss_ctrl_user_data_out_net_x0 <= darkquad29_acc_iq_avg2_ss_ctrl_user_data_out;
  in_reg <= reint1_output_port_net_x1;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_acc_iq_avg2_ss_ctrl_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x1
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/acc_iq/avg2/ss"

entity ss_entity_b593cb3d3f is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    darkquad29_acc_iq_avg2_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    din: in std_logic_vector(31 downto 0); 
    trig: in std_logic; 
    we: in std_logic; 
    bram: out std_logic_vector(9 downto 0); 
    bram_x0: out std_logic_vector(31 downto 0); 
    bram_x1: out std_logic; 
    status: out std_logic_vector(31 downto 0)
  );
end ss_entity_b593cb3d3f;

architecture structural of ss_entity_b593cb3d3f is
  signal add_del_q_net_x1: std_logic_vector(9 downto 0);
  signal cast_dout_net_x1: std_logic_vector(31 downto 0);
  signal cast_gw_dout_net_x1: std_logic_vector(31 downto 0);
  signal ce_1_sg_x63: std_logic;
  signal clk_1_sg_x63: std_logic;
  signal concat_y_net_x1: std_logic_vector(31 downto 0);
  signal convert_addr_dout_net_x1: std_logic_vector(9 downto 0);
  signal convert_din1_dout_net_x1: std_logic_vector(31 downto 0);
  signal convert_we_dout_net_x1: std_logic;
  signal darkquad29_acc_iq_avg2_ss_ctrl_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal dat_del_q_net_x1: std_logic_vector(31 downto 0);
  signal data_choice_y_net_x2: std_logic_vector(31 downto 0);
  signal delay6_q_net_x0: std_logic_vector(31 downto 0);
  signal edge_op_y_net_x4: std_logic;
  signal logical6_y_net_x0: std_logic;
  signal mux3_y_net_x2: std_logic;
  signal never_op_net_x0: std_logic;
  signal register1_q_net_x8: std_logic;
  signal register6_q_net_x1: std_logic;
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal reinterpret1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal ri_output_port_net: std_logic_vector(31 downto 0);
  signal slice2_y_net_x0: std_logic_vector(9 downto 0);
  signal we_choice_y_net_x2: std_logic;
  signal we_del_q_net_x0: std_logic;

begin
  ce_1_sg_x63 <= ce_1;
  clk_1_sg_x63 <= clk_1;
  darkquad29_acc_iq_avg2_ss_ctrl_user_data_out_net_x1 <= darkquad29_acc_iq_avg2_ss_ctrl_user_data_out;
  reinterpret1_output_port_net_x1 <= din;
  register1_q_net_x8 <= trig;
  mux3_y_net_x2 <= we;
  bram <= convert_addr_dout_net_x1;
  bram_x0 <= convert_din1_dout_net_x1;
  bram_x1 <= convert_we_dout_net_x1;
  status <= cast_gw_dout_net_x1;

  add_del: entity work.delay_cf4f99539f
    port map (
      ce => ce_1_sg_x63,
      clk => clk_1_sg_x63,
      clr => '0',
      d => slice2_y_net_x0,
      q => add_del_q_net_x1
    );

  add_gen_ce55050b60: entity work.add_gen_entity_cfd95544b0
    port map (
      ce_1 => ce_1_sg_x63,
      clk_1 => clk_1_sg_x63,
      cont => never_op_net_x0,
      din => data_choice_y_net_x2,
      go => register6_q_net_x1,
      init => edge_op_y_net_x4,
      we => we_choice_y_net_x2,
      add => slice2_y_net_x0,
      dout => delay6_q_net_x0,
      status => concat_y_net_x1,
      we_o => logical6_y_net_x0
    );

  basic_ctrl_31a146088b: entity work.basic_ctrl_entity_e1fef81f73
    port map (
      ce_1 => ce_1_sg_x63,
      clk_1 => clk_1_sg_x63,
      ctrl => reint1_output_port_net_x1,
      din => cast_dout_net_x1,
      trig => register1_q_net_x8,
      we => mux3_y_net_x2,
      dout => data_choice_y_net_x2,
      go => register6_q_net_x1,
      init => edge_op_y_net_x4,
      we_o => we_choice_y_net_x2
    );

  bram_abcaac55c2: entity work.bram_entity_f0ce0d3c3e
    port map (
      addr => add_del_q_net_x1,
      ce_1 => ce_1_sg_x63,
      clk_1 => clk_1_sg_x63,
      data_in => dat_del_q_net_x1,
      we => we_del_q_net_x0,
      convert_addr_x0 => convert_addr_dout_net_x1,
      convert_din1_x0 => convert_din1_dout_net_x1,
      convert_we_x0 => convert_we_dout_net_x1
    );

  cast: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 32,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x63,
      clk => clk_1_sg_x63,
      clr => '0',
      din => ri_output_port_net,
      en => "1",
      dout => cast_dout_net_x1
    );

  ctrl_e14fbc9b11: entity work.ctrl_entity_e14fbc9b11
    port map (
      darkquad29_acc_iq_avg2_ss_ctrl_user_data_out => darkquad29_acc_iq_avg2_ss_ctrl_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x1
    );

  dat_del: entity work.delay_672d2b8d1e
    port map (
      ce => ce_1_sg_x63,
      clk => clk_1_sg_x63,
      clr => '0',
      d => delay6_q_net_x0,
      q => dat_del_q_net_x1
    );

  never: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => never_op_net_x0
    );

  ri: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => reinterpret1_output_port_net_x1,
      output_port => ri_output_port_net
    );

  status_fc5e58a2ef: entity work.last_tx_data_entity_4b5ba71046
    port map (
      ce_1 => ce_1_sg_x63,
      clk_1 => clk_1_sg_x63,
      out_reg => concat_y_net_x1,
      cast_gw_x0 => cast_gw_dout_net_x1
    );

  we_del: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x63,
      clk => clk_1_sg_x63,
      clr => '0',
      d(0) => logical6_y_net_x0,
      q(0) => we_del_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/acc_iq/avg2"

entity avg2_entity_9a01e5c2bd is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    darkquad29_acc_iq_avg2_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    in_iq: in std_logic_vector(31 downto 0); 
    trig: in std_logic; 
    we: in std_logic; 
    ss: out std_logic_vector(9 downto 0); 
    ss_x0: out std_logic_vector(31 downto 0); 
    ss_x1: out std_logic; 
    ss_x2: out std_logic_vector(31 downto 0)
  );
end avg2_entity_9a01e5c2bd;

architecture structural of avg2_entity_9a01e5c2bd is
  signal assert_iq_dout_net_x0: std_logic_vector(31 downto 0);
  signal cast_gw_dout_net_x2: std_logic_vector(31 downto 0);
  signal ce_1_sg_x64: std_logic;
  signal clk_1_sg_x64: std_logic;
  signal convert_addr_dout_net_x2: std_logic_vector(9 downto 0);
  signal convert_din1_dout_net_x2: std_logic_vector(31 downto 0);
  signal convert_we_dout_net_x2: std_logic;
  signal darkquad29_acc_iq_avg2_ss_ctrl_user_data_out_net_x2: std_logic_vector(31 downto 0);
  signal mux2_y_net_x1: std_logic_vector(31 downto 0);
  signal mux3_y_net_x3: std_logic;
  signal register1_q_net_x9: std_logic;
  signal reinterpret1_output_port_net_x1: std_logic_vector(31 downto 0);

begin
  ce_1_sg_x64 <= ce_1;
  clk_1_sg_x64 <= clk_1;
  darkquad29_acc_iq_avg2_ss_ctrl_user_data_out_net_x2 <= darkquad29_acc_iq_avg2_ss_ctrl_user_data_out;
  mux2_y_net_x1 <= in_iq;
  register1_q_net_x9 <= trig;
  mux3_y_net_x3 <= we;
  ss <= convert_addr_dout_net_x2;
  ss_x0 <= convert_din1_dout_net_x2;
  ss_x1 <= convert_we_dout_net_x2;
  ss_x2 <= cast_gw_dout_net_x2;

  assert_iq: entity work.xlpassthrough
    generic map (
      din_width => 32,
      dout_width => 32
    )
    port map (
      din => mux2_y_net_x1,
      dout => assert_iq_dout_net_x0
    );

  buscreate_b1a61d2d28: entity work.buscreate_entity_7ea6ca3fe1
    port map (
      in1 => assert_iq_dout_net_x0,
      bus_out => reinterpret1_output_port_net_x1
    );

  ss_b593cb3d3f: entity work.ss_entity_b593cb3d3f
    port map (
      ce_1 => ce_1_sg_x64,
      clk_1 => clk_1_sg_x64,
      darkquad29_acc_iq_avg2_ss_ctrl_user_data_out => darkquad29_acc_iq_avg2_ss_ctrl_user_data_out_net_x2,
      din => reinterpret1_output_port_net_x1,
      trig => register1_q_net_x9,
      we => mux3_y_net_x3,
      bram => convert_addr_dout_net_x2,
      bram_x0 => convert_din1_dout_net_x2,
      bram_x1 => convert_we_dout_net_x2,
      status => cast_gw_dout_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/acc_iq/avg3/ss/ctrl"

entity ctrl_entity_b696af9094 is
  port (
    darkquad29_acc_iq_avg3_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end ctrl_entity_b696af9094;

architecture structural of ctrl_entity_b696af9094 is
  signal darkquad29_acc_iq_avg3_ss_ctrl_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_acc_iq_avg3_ss_ctrl_user_data_out_net_x0 <= darkquad29_acc_iq_avg3_ss_ctrl_user_data_out;
  in_reg <= reint1_output_port_net_x1;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_acc_iq_avg3_ss_ctrl_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x1
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/acc_iq/avg3/ss"

entity ss_entity_8229f65280 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    darkquad29_acc_iq_avg3_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    din: in std_logic_vector(31 downto 0); 
    trig: in std_logic; 
    we: in std_logic; 
    bram: out std_logic_vector(9 downto 0); 
    bram_x0: out std_logic_vector(31 downto 0); 
    bram_x1: out std_logic; 
    status: out std_logic_vector(31 downto 0)
  );
end ss_entity_8229f65280;

architecture structural of ss_entity_8229f65280 is
  signal add_del_q_net_x1: std_logic_vector(9 downto 0);
  signal cast_dout_net_x1: std_logic_vector(31 downto 0);
  signal cast_gw_dout_net_x1: std_logic_vector(31 downto 0);
  signal ce_1_sg_x73: std_logic;
  signal clk_1_sg_x73: std_logic;
  signal concat_y_net_x1: std_logic_vector(31 downto 0);
  signal convert_addr_dout_net_x1: std_logic_vector(9 downto 0);
  signal convert_din1_dout_net_x1: std_logic_vector(31 downto 0);
  signal convert_we_dout_net_x1: std_logic;
  signal darkquad29_acc_iq_avg3_ss_ctrl_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal dat_del_q_net_x1: std_logic_vector(31 downto 0);
  signal data_choice_y_net_x2: std_logic_vector(31 downto 0);
  signal delay6_q_net_x0: std_logic_vector(31 downto 0);
  signal edge_op_y_net_x4: std_logic;
  signal logical6_y_net_x0: std_logic;
  signal mux3_y_net_x2: std_logic;
  signal never_op_net_x0: std_logic;
  signal register1_q_net_x11: std_logic;
  signal register6_q_net_x1: std_logic;
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal reinterpret1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal ri_output_port_net: std_logic_vector(31 downto 0);
  signal slice2_y_net_x0: std_logic_vector(9 downto 0);
  signal we_choice_y_net_x2: std_logic;
  signal we_del_q_net_x0: std_logic;

begin
  ce_1_sg_x73 <= ce_1;
  clk_1_sg_x73 <= clk_1;
  darkquad29_acc_iq_avg3_ss_ctrl_user_data_out_net_x1 <= darkquad29_acc_iq_avg3_ss_ctrl_user_data_out;
  reinterpret1_output_port_net_x1 <= din;
  register1_q_net_x11 <= trig;
  mux3_y_net_x2 <= we;
  bram <= convert_addr_dout_net_x1;
  bram_x0 <= convert_din1_dout_net_x1;
  bram_x1 <= convert_we_dout_net_x1;
  status <= cast_gw_dout_net_x1;

  add_del: entity work.delay_cf4f99539f
    port map (
      ce => ce_1_sg_x73,
      clk => clk_1_sg_x73,
      clr => '0',
      d => slice2_y_net_x0,
      q => add_del_q_net_x1
    );

  add_gen_261b3b788b: entity work.add_gen_entity_cfd95544b0
    port map (
      ce_1 => ce_1_sg_x73,
      clk_1 => clk_1_sg_x73,
      cont => never_op_net_x0,
      din => data_choice_y_net_x2,
      go => register6_q_net_x1,
      init => edge_op_y_net_x4,
      we => we_choice_y_net_x2,
      add => slice2_y_net_x0,
      dout => delay6_q_net_x0,
      status => concat_y_net_x1,
      we_o => logical6_y_net_x0
    );

  basic_ctrl_b2cabe74f5: entity work.basic_ctrl_entity_e1fef81f73
    port map (
      ce_1 => ce_1_sg_x73,
      clk_1 => clk_1_sg_x73,
      ctrl => reint1_output_port_net_x1,
      din => cast_dout_net_x1,
      trig => register1_q_net_x11,
      we => mux3_y_net_x2,
      dout => data_choice_y_net_x2,
      go => register6_q_net_x1,
      init => edge_op_y_net_x4,
      we_o => we_choice_y_net_x2
    );

  bram_0214dda623: entity work.bram_entity_f0ce0d3c3e
    port map (
      addr => add_del_q_net_x1,
      ce_1 => ce_1_sg_x73,
      clk_1 => clk_1_sg_x73,
      data_in => dat_del_q_net_x1,
      we => we_del_q_net_x0,
      convert_addr_x0 => convert_addr_dout_net_x1,
      convert_din1_x0 => convert_din1_dout_net_x1,
      convert_we_x0 => convert_we_dout_net_x1
    );

  cast: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 32,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x73,
      clk => clk_1_sg_x73,
      clr => '0',
      din => ri_output_port_net,
      en => "1",
      dout => cast_dout_net_x1
    );

  ctrl_b696af9094: entity work.ctrl_entity_b696af9094
    port map (
      darkquad29_acc_iq_avg3_ss_ctrl_user_data_out => darkquad29_acc_iq_avg3_ss_ctrl_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x1
    );

  dat_del: entity work.delay_672d2b8d1e
    port map (
      ce => ce_1_sg_x73,
      clk => clk_1_sg_x73,
      clr => '0',
      d => delay6_q_net_x0,
      q => dat_del_q_net_x1
    );

  never: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => never_op_net_x0
    );

  ri: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => reinterpret1_output_port_net_x1,
      output_port => ri_output_port_net
    );

  status_0e12f18970: entity work.last_tx_data_entity_4b5ba71046
    port map (
      ce_1 => ce_1_sg_x73,
      clk_1 => clk_1_sg_x73,
      out_reg => concat_y_net_x1,
      cast_gw_x0 => cast_gw_dout_net_x1
    );

  we_del: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x73,
      clk => clk_1_sg_x73,
      clr => '0',
      d(0) => logical6_y_net_x0,
      q(0) => we_del_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/acc_iq/avg3"

entity avg3_entity_c9d57d1f87 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    darkquad29_acc_iq_avg3_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    in_iq: in std_logic_vector(31 downto 0); 
    trig: in std_logic; 
    we: in std_logic; 
    ss: out std_logic_vector(9 downto 0); 
    ss_x0: out std_logic_vector(31 downto 0); 
    ss_x1: out std_logic; 
    ss_x2: out std_logic_vector(31 downto 0)
  );
end avg3_entity_c9d57d1f87;

architecture structural of avg3_entity_c9d57d1f87 is
  signal assert_iq_dout_net_x0: std_logic_vector(31 downto 0);
  signal cast_gw_dout_net_x2: std_logic_vector(31 downto 0);
  signal ce_1_sg_x74: std_logic;
  signal clk_1_sg_x74: std_logic;
  signal convert_addr_dout_net_x2: std_logic_vector(9 downto 0);
  signal convert_din1_dout_net_x2: std_logic_vector(31 downto 0);
  signal convert_we_dout_net_x2: std_logic;
  signal darkquad29_acc_iq_avg3_ss_ctrl_user_data_out_net_x2: std_logic_vector(31 downto 0);
  signal mux2_y_net_x1: std_logic_vector(31 downto 0);
  signal mux3_y_net_x3: std_logic;
  signal register1_q_net_x12: std_logic;
  signal reinterpret1_output_port_net_x1: std_logic_vector(31 downto 0);

begin
  ce_1_sg_x74 <= ce_1;
  clk_1_sg_x74 <= clk_1;
  darkquad29_acc_iq_avg3_ss_ctrl_user_data_out_net_x2 <= darkquad29_acc_iq_avg3_ss_ctrl_user_data_out;
  mux2_y_net_x1 <= in_iq;
  register1_q_net_x12 <= trig;
  mux3_y_net_x3 <= we;
  ss <= convert_addr_dout_net_x2;
  ss_x0 <= convert_din1_dout_net_x2;
  ss_x1 <= convert_we_dout_net_x2;
  ss_x2 <= cast_gw_dout_net_x2;

  assert_iq: entity work.xlpassthrough
    generic map (
      din_width => 32,
      dout_width => 32
    )
    port map (
      din => mux2_y_net_x1,
      dout => assert_iq_dout_net_x0
    );

  buscreate_e742d7b4b6: entity work.buscreate_entity_7ea6ca3fe1
    port map (
      in1 => assert_iq_dout_net_x0,
      bus_out => reinterpret1_output_port_net_x1
    );

  ss_8229f65280: entity work.ss_entity_8229f65280
    port map (
      ce_1 => ce_1_sg_x74,
      clk_1 => clk_1_sg_x74,
      darkquad29_acc_iq_avg3_ss_ctrl_user_data_out => darkquad29_acc_iq_avg3_ss_ctrl_user_data_out_net_x2,
      din => reinterpret1_output_port_net_x1,
      trig => register1_q_net_x12,
      we => mux3_y_net_x3,
      bram => convert_addr_dout_net_x2,
      bram_x0 => convert_din1_dout_net_x2,
      bram_x1 => convert_we_dout_net_x2,
      status => cast_gw_dout_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/acc_iq/pulse_ext"

entity pulse_ext_entity_8d39882730 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic; 
    out_x0: out std_logic
  );
end pulse_ext_entity_8d39882730;

architecture structural of pulse_ext_entity_8d39882730 is
  signal ce_1_sg_x78: std_logic;
  signal clk_1_sg_x78: std_logic;
  signal constant5_op_net: std_logic_vector(18 downto 0);
  signal counter3_op_net: std_logic_vector(18 downto 0);
  signal logical4_y_net_x1: std_logic;
  signal logical_y_net_x0: std_logic;
  signal relational5_op_net_x5: std_logic;

begin
  ce_1_sg_x78 <= ce_1;
  clk_1_sg_x78 <= clk_1;
  logical4_y_net_x1 <= in_x0;
  out_x0 <= relational5_op_net_x5;

  constant5: entity work.constant_b713aad2a7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant5_op_net
    );

  counter3: entity work.xlcounter_free_darkquad29
    generic map (
      core_name0 => "cntr_11_0_71ab8bef543acf07",
      op_arith => xlUnsigned,
      op_width => 19
    )
    port map (
      ce => ce_1_sg_x78,
      clk => clk_1_sg_x78,
      clr => '0',
      en(0) => relational5_op_net_x5,
      rst(0) => logical_y_net_x0,
      op => counter3_op_net
    );

  posedge_fd0c19c890: entity work.posedge_entity_b890391632
    port map (
      ce_1 => ce_1_sg_x78,
      clk_1 => clk_1_sg_x78,
      in_x0 => logical4_y_net_x1,
      out_x0 => logical_y_net_x0
    );

  relational5: entity work.relational_502d6cf7c0
    port map (
      a => counter3_op_net,
      b => constant5_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational5_op_net_x5
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/acc_iq/pulse_ext5"

entity pulse_ext5_entity_e18c86550d is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic; 
    out_x0: out std_logic
  );
end pulse_ext5_entity_e18c86550d;

architecture structural of pulse_ext5_entity_e18c86550d is
  signal ce_1_sg_x80: std_logic;
  signal clk_1_sg_x80: std_logic;
  signal constant5_op_net: std_logic_vector(8 downto 0);
  signal counter3_op_net: std_logic_vector(8 downto 0);
  signal edge_op_y_net_x2: std_logic;
  signal logical_y_net_x0: std_logic;
  signal relational5_op_net_x0: std_logic;

begin
  ce_1_sg_x80 <= ce_1;
  clk_1_sg_x80 <= clk_1;
  edge_op_y_net_x2 <= in_x0;
  out_x0 <= relational5_op_net_x0;

  constant5: entity work.constant_4a391b9a0e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant5_op_net
    );

  counter3: entity work.xlcounter_free_darkquad29
    generic map (
      core_name0 => "cntr_11_0_ca10e447a1c1c04f",
      op_arith => xlUnsigned,
      op_width => 9
    )
    port map (
      ce => ce_1_sg_x80,
      clk => clk_1_sg_x80,
      clr => '0',
      en(0) => relational5_op_net_x0,
      rst(0) => logical_y_net_x0,
      op => counter3_op_net
    );

  posedge_47348d551a: entity work.posedge_entity_b890391632
    port map (
      ce_1 => ce_1_sg_x80,
      clk_1 => clk_1_sg_x80,
      in_x0 => edge_op_y_net_x2,
      out_x0 => logical_y_net_x0
    );

  relational5: entity work.relational_78eac2928d
    port map (
      a => counter3_op_net,
      b => constant5_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational5_op_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/acc_iq/start_acc"

entity start_acc_entity_bddfd1217d is
  port (
    darkquad29_acc_iq_start_acc_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end start_acc_entity_bddfd1217d;

architecture structural of start_acc_entity_bddfd1217d is
  signal darkquad29_acc_iq_start_acc_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_acc_iq_start_acc_user_data_out_net_x0 <= darkquad29_acc_iq_start_acc_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_acc_iq_start_acc_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/acc_iq"

entity acc_iq_entity_643c27e9df is
  port (
    ce_1: in std_logic; 
    ch_in: in std_logic_vector(7 downto 0); 
    clk_1: in std_logic; 
    darkquad29_acc_iq_avg0_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_acc_iq_avg1_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_acc_iq_avg2_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_acc_iq_avg3_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_acc_iq_start_acc_user_data_out: in std_logic_vector(31 downto 0); 
    din0: in std_logic_vector(75 downto 0); 
    din1: in std_logic_vector(75 downto 0); 
    din2: in std_logic_vector(75 downto 0); 
    din3: in std_logic_vector(75 downto 0); 
    avg0: out std_logic_vector(9 downto 0); 
    avg0_x0: out std_logic_vector(31 downto 0); 
    avg0_x1: out std_logic; 
    avg0_x2: out std_logic_vector(31 downto 0); 
    avg1: out std_logic_vector(9 downto 0); 
    avg1_x0: out std_logic_vector(31 downto 0); 
    avg1_x1: out std_logic; 
    avg1_x2: out std_logic_vector(31 downto 0); 
    avg2: out std_logic_vector(9 downto 0); 
    avg2_x0: out std_logic_vector(31 downto 0); 
    avg2_x1: out std_logic; 
    avg2_x2: out std_logic_vector(31 downto 0); 
    avg3: out std_logic_vector(9 downto 0); 
    avg3_x0: out std_logic_vector(31 downto 0); 
    avg3_x1: out std_logic; 
    avg3_x2: out std_logic_vector(31 downto 0)
  );
end acc_iq_entity_643c27e9df;

architecture structural of acc_iq_entity_643c27e9df is
  signal cast_gw_dout_net_x6: std_logic_vector(31 downto 0);
  signal cast_gw_dout_net_x7: std_logic_vector(31 downto 0);
  signal cast_gw_dout_net_x8: std_logic_vector(31 downto 0);
  signal cast_gw_dout_net_x9: std_logic_vector(31 downto 0);
  signal ce_1_sg_x81: std_logic;
  signal clk_1_sg_x81: std_logic;
  signal constant9_op_net: std_logic_vector(7 downto 0);
  signal convert_addr_dout_net_x6: std_logic_vector(9 downto 0);
  signal convert_addr_dout_net_x7: std_logic_vector(9 downto 0);
  signal convert_addr_dout_net_x8: std_logic_vector(9 downto 0);
  signal convert_addr_dout_net_x9: std_logic_vector(9 downto 0);
  signal convert_din1_dout_net_x6: std_logic_vector(31 downto 0);
  signal convert_din1_dout_net_x7: std_logic_vector(31 downto 0);
  signal convert_din1_dout_net_x8: std_logic_vector(31 downto 0);
  signal convert_din1_dout_net_x9: std_logic_vector(31 downto 0);
  signal convert_we_dout_net_x6: std_logic;
  signal convert_we_dout_net_x7: std_logic;
  signal convert_we_dout_net_x8: std_logic;
  signal convert_we_dout_net_x9: std_logic;
  signal darkquad29_acc_iq_avg0_ss_ctrl_user_data_out_net_x3: std_logic_vector(31 downto 0);
  signal darkquad29_acc_iq_avg1_ss_ctrl_user_data_out_net_x3: std_logic_vector(31 downto 0);
  signal darkquad29_acc_iq_avg2_ss_ctrl_user_data_out_net_x3: std_logic_vector(31 downto 0);
  signal darkquad29_acc_iq_avg3_ss_ctrl_user_data_out_net_x3: std_logic_vector(31 downto 0);
  signal darkquad29_acc_iq_start_acc_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal delay17_q_net: std_logic_vector(75 downto 0);
  signal delay1_q_net_x1: std_logic_vector(75 downto 0);
  signal delay26_q_net: std_logic_vector(75 downto 0);
  signal delay2_q_net_x1: std_logic_vector(75 downto 0);
  signal delay30_q_net_x0: std_logic_vector(75 downto 0);
  signal delay3_q_net_x1: std_logic_vector(75 downto 0);
  signal delay4_q_net: std_logic_vector(75 downto 0);
  signal delay5_q_net: std_logic_vector(75 downto 0);
  signal delay6_q_net: std_logic_vector(75 downto 0);
  signal delay7_q_net: std_logic_vector(75 downto 0);
  signal delay8_q_net: std_logic_vector(75 downto 0);
  signal delay9_q_net: std_logic_vector(75 downto 0);
  signal edge_op_y_net_x2: std_logic;
  signal logical4_y_net_x1: std_logic;
  signal mux2_y_net_x1: std_logic_vector(31 downto 0);
  signal mux2_y_net_x2: std_logic_vector(31 downto 0);
  signal mux2_y_net_x3: std_logic_vector(31 downto 0);
  signal mux2_y_net_x4: std_logic_vector(31 downto 0);
  signal mux3_y_net_x3: std_logic;
  signal mux3_y_net_x4: std_logic;
  signal mux3_y_net_x5: std_logic;
  signal mux3_y_net_x6: std_logic;
  signal register1_q_net_x14: std_logic;
  signal register1_q_net_x4: std_logic_vector(75 downto 0);
  signal register1_q_net_x5: std_logic_vector(75 downto 0);
  signal register1_q_net_x6: std_logic_vector(75 downto 0);
  signal register1_q_net_x7: std_logic_vector(7 downto 0);
  signal register1_q_net_x8: std_logic_vector(75 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal relational1_op_net: std_logic;
  signal relational5_op_net_x0: std_logic;
  signal relational5_op_net_x5: std_logic;
  signal slice2_y_net_x0: std_logic;

begin
  ce_1_sg_x81 <= ce_1;
  register1_q_net_x7 <= ch_in;
  clk_1_sg_x81 <= clk_1;
  darkquad29_acc_iq_avg0_ss_ctrl_user_data_out_net_x3 <= darkquad29_acc_iq_avg0_ss_ctrl_user_data_out;
  darkquad29_acc_iq_avg1_ss_ctrl_user_data_out_net_x3 <= darkquad29_acc_iq_avg1_ss_ctrl_user_data_out;
  darkquad29_acc_iq_avg2_ss_ctrl_user_data_out_net_x3 <= darkquad29_acc_iq_avg2_ss_ctrl_user_data_out;
  darkquad29_acc_iq_avg3_ss_ctrl_user_data_out_net_x3 <= darkquad29_acc_iq_avg3_ss_ctrl_user_data_out;
  darkquad29_acc_iq_start_acc_user_data_out_net_x1 <= darkquad29_acc_iq_start_acc_user_data_out;
  register1_q_net_x8 <= din0;
  register1_q_net_x4 <= din1;
  register1_q_net_x5 <= din2;
  register1_q_net_x6 <= din3;
  avg0 <= convert_addr_dout_net_x6;
  avg0_x0 <= convert_din1_dout_net_x6;
  avg0_x1 <= convert_we_dout_net_x6;
  avg0_x2 <= cast_gw_dout_net_x6;
  avg1 <= convert_addr_dout_net_x7;
  avg1_x0 <= convert_din1_dout_net_x7;
  avg1_x1 <= convert_we_dout_net_x7;
  avg1_x2 <= cast_gw_dout_net_x7;
  avg2 <= convert_addr_dout_net_x8;
  avg2_x0 <= convert_din1_dout_net_x8;
  avg2_x1 <= convert_we_dout_net_x8;
  avg2_x2 <= cast_gw_dout_net_x8;
  avg3 <= convert_addr_dout_net_x9;
  avg3_x0 <= convert_din1_dout_net_x9;
  avg3_x1 <= convert_we_dout_net_x9;
  avg3_x2 <= cast_gw_dout_net_x9;

  acc0_c70a84cfef: entity work.acc0_entity_c70a84cfef
    port map (
      accum_en => relational5_op_net_x5,
      ce_1 => ce_1_sg_x81,
      clk_1 => clk_1_sg_x81,
      data_in => delay30_q_net_x0,
      data_out => mux2_y_net_x1,
      drdy => mux3_y_net_x3
    );

  acc1_78be61582b: entity work.acc0_entity_c70a84cfef
    port map (
      accum_en => relational5_op_net_x5,
      ce_1 => ce_1_sg_x81,
      clk_1 => clk_1_sg_x81,
      data_in => delay1_q_net_x1,
      data_out => mux2_y_net_x2,
      drdy => mux3_y_net_x4
    );

  acc2_941fffc386: entity work.acc0_entity_c70a84cfef
    port map (
      accum_en => relational5_op_net_x5,
      ce_1 => ce_1_sg_x81,
      clk_1 => clk_1_sg_x81,
      data_in => delay2_q_net_x1,
      data_out => mux2_y_net_x3,
      drdy => mux3_y_net_x5
    );

  acc3_b60e890401: entity work.acc0_entity_c70a84cfef
    port map (
      accum_en => relational5_op_net_x5,
      ce_1 => ce_1_sg_x81,
      clk_1 => clk_1_sg_x81,
      data_in => delay3_q_net_x1,
      data_out => mux2_y_net_x4,
      drdy => mux3_y_net_x6
    );

  avg0_d122a9b10c: entity work.avg0_entity_d122a9b10c
    port map (
      ce_1 => ce_1_sg_x81,
      clk_1 => clk_1_sg_x81,
      darkquad29_acc_iq_avg0_ss_ctrl_user_data_out => darkquad29_acc_iq_avg0_ss_ctrl_user_data_out_net_x3,
      in_iq => mux2_y_net_x1,
      trig => register1_q_net_x14,
      we => mux3_y_net_x3,
      ss => convert_addr_dout_net_x6,
      ss_x0 => convert_din1_dout_net_x6,
      ss_x1 => convert_we_dout_net_x6,
      ss_x2 => cast_gw_dout_net_x6
    );

  avg1_876a3da11a: entity work.avg1_entity_876a3da11a
    port map (
      ce_1 => ce_1_sg_x81,
      clk_1 => clk_1_sg_x81,
      darkquad29_acc_iq_avg1_ss_ctrl_user_data_out => darkquad29_acc_iq_avg1_ss_ctrl_user_data_out_net_x3,
      in_iq => mux2_y_net_x2,
      trig => register1_q_net_x14,
      we => mux3_y_net_x4,
      ss => convert_addr_dout_net_x7,
      ss_x0 => convert_din1_dout_net_x7,
      ss_x1 => convert_we_dout_net_x7,
      ss_x2 => cast_gw_dout_net_x7
    );

  avg2_9a01e5c2bd: entity work.avg2_entity_9a01e5c2bd
    port map (
      ce_1 => ce_1_sg_x81,
      clk_1 => clk_1_sg_x81,
      darkquad29_acc_iq_avg2_ss_ctrl_user_data_out => darkquad29_acc_iq_avg2_ss_ctrl_user_data_out_net_x3,
      in_iq => mux2_y_net_x3,
      trig => register1_q_net_x14,
      we => mux3_y_net_x5,
      ss => convert_addr_dout_net_x8,
      ss_x0 => convert_din1_dout_net_x8,
      ss_x1 => convert_we_dout_net_x8,
      ss_x2 => cast_gw_dout_net_x8
    );

  avg3_c9d57d1f87: entity work.avg3_entity_c9d57d1f87
    port map (
      ce_1 => ce_1_sg_x81,
      clk_1 => clk_1_sg_x81,
      darkquad29_acc_iq_avg3_ss_ctrl_user_data_out => darkquad29_acc_iq_avg3_ss_ctrl_user_data_out_net_x3,
      in_iq => mux2_y_net_x4,
      trig => register1_q_net_x14,
      we => mux3_y_net_x6,
      ss => convert_addr_dout_net_x9,
      ss_x0 => convert_din1_dout_net_x9,
      ss_x1 => convert_we_dout_net_x9,
      ss_x2 => cast_gw_dout_net_x9
    );

  constant9: entity work.constant_91ef1678ca
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant9_op_net
    );

  delay1: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 76
    )
    port map (
      ce => ce_1_sg_x81,
      clk => clk_1_sg_x81,
      d => delay4_q_net,
      en => '1',
      rst => '1',
      q => delay1_q_net_x1
    );

  delay17: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 76
    )
    port map (
      ce => ce_1_sg_x81,
      clk => clk_1_sg_x81,
      d => delay26_q_net,
      en => '1',
      rst => '1',
      q => delay17_q_net
    );

  delay2: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 76
    )
    port map (
      ce => ce_1_sg_x81,
      clk => clk_1_sg_x81,
      d => delay6_q_net,
      en => '1',
      rst => '1',
      q => delay2_q_net_x1
    );

  delay26: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 76
    )
    port map (
      ce => ce_1_sg_x81,
      clk => clk_1_sg_x81,
      d => register1_q_net_x8,
      en => '1',
      rst => '1',
      q => delay26_q_net
    );

  delay3: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 76
    )
    port map (
      ce => ce_1_sg_x81,
      clk => clk_1_sg_x81,
      d => delay8_q_net,
      en => '1',
      rst => '1',
      q => delay3_q_net_x1
    );

  delay30: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 76
    )
    port map (
      ce => ce_1_sg_x81,
      clk => clk_1_sg_x81,
      d => delay17_q_net,
      en => '1',
      rst => '1',
      q => delay30_q_net_x0
    );

  delay4: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 76
    )
    port map (
      ce => ce_1_sg_x81,
      clk => clk_1_sg_x81,
      d => delay5_q_net,
      en => '1',
      rst => '1',
      q => delay4_q_net
    );

  delay5: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 76
    )
    port map (
      ce => ce_1_sg_x81,
      clk => clk_1_sg_x81,
      d => register1_q_net_x4,
      en => '1',
      rst => '1',
      q => delay5_q_net
    );

  delay6: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 76
    )
    port map (
      ce => ce_1_sg_x81,
      clk => clk_1_sg_x81,
      d => delay7_q_net,
      en => '1',
      rst => '1',
      q => delay6_q_net
    );

  delay7: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 76
    )
    port map (
      ce => ce_1_sg_x81,
      clk => clk_1_sg_x81,
      d => register1_q_net_x5,
      en => '1',
      rst => '1',
      q => delay7_q_net
    );

  delay8: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 76
    )
    port map (
      ce => ce_1_sg_x81,
      clk => clk_1_sg_x81,
      d => delay9_q_net,
      en => '1',
      rst => '1',
      q => delay8_q_net
    );

  delay9: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 76
    )
    port map (
      ce => ce_1_sg_x81,
      clk => clk_1_sg_x81,
      d => register1_q_net_x6,
      en => '1',
      rst => '1',
      q => delay9_q_net
    );

  logical4: entity work.logical_799f62af22
    port map (
      ce => ce_1_sg_x81,
      clk => clk_1_sg_x81,
      clr => '0',
      d0(0) => relational1_op_net,
      d1(0) => relational5_op_net_x0,
      y(0) => logical4_y_net_x1
    );

  pipeline17_3beec93768: entity work.pipeline3_entity_fb0a315a6d
    port map (
      ce_1 => ce_1_sg_x81,
      clk_1 => clk_1_sg_x81,
      d => slice2_y_net_x0,
      q => register1_q_net_x14
    );

  posedge_e5c16c6cf4: entity work.edge_detect3_entity_2efb246ca9
    port map (
      ce_1 => ce_1_sg_x81,
      clk_1 => clk_1_sg_x81,
      in_x0 => register1_q_net_x14,
      out_x0 => edge_op_y_net_x2
    );

  pulse_ext5_e18c86550d: entity work.pulse_ext5_entity_e18c86550d
    port map (
      ce_1 => ce_1_sg_x81,
      clk_1 => clk_1_sg_x81,
      in_x0 => edge_op_y_net_x2,
      out_x0 => relational5_op_net_x0
    );

  pulse_ext_8d39882730: entity work.pulse_ext_entity_8d39882730
    port map (
      ce_1 => ce_1_sg_x81,
      clk_1 => clk_1_sg_x81,
      in_x0 => logical4_y_net_x1,
      out_x0 => relational5_op_net_x5
    );

  relational1: entity work.relational_deb0401f42
    port map (
      a => register1_q_net_x7,
      b => constant9_op_net,
      ce => ce_1_sg_x81,
      clk => clk_1_sg_x81,
      clr => '0',
      op(0) => relational1_op_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => reint1_output_port_net_x0,
      y(0) => slice2_y_net_x0
    );

  start_acc_bddfd1217d: entity work.start_acc_entity_bddfd1217d
    port map (
      darkquad29_acc_iq_start_acc_user_data_out => darkquad29_acc_iq_start_acc_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/adc_in/adcdac_2g"

entity adcdac_2g_entity_3e40ca0595 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    dly_val: in std_logic_vector(4 downto 0); 
    inc_mmcm_phs: in std_logic; 
    load_dly0: in std_logic_vector(5 downto 0); 
    pos_mmcm_phs: in std_logic; 
    ready: in std_logic; 
    convert1_x0: out std_logic; 
    convert2_x0: out std_logic_vector(4 downto 0); 
    convert3_x0: out std_logic_vector(5 downto 0); 
    convert4_x0: out std_logic; 
    convert5_x0: out std_logic
  );
end adcdac_2g_entity_3e40ca0595;

architecture structural of adcdac_2g_entity_3e40ca0595 is
  signal ce_1_sg_x82: std_logic;
  signal clk_1_sg_x82: std_logic;
  signal convert1_dout_net_x0: std_logic;
  signal convert2_dout_net_x0: std_logic_vector(4 downto 0);
  signal convert3_dout_net_x0: std_logic_vector(5 downto 0);
  signal convert4_dout_net_x0: std_logic;
  signal convert5_dout_net_x0: std_logic;
  signal register1_q_net_x4: std_logic;
  signal register1_q_net_x5: std_logic_vector(4 downto 0);
  signal register1_q_net_x6: std_logic_vector(5 downto 0);
  signal register1_q_net_x7: std_logic;
  signal register1_q_net_x8: std_logic;

begin
  ce_1_sg_x82 <= ce_1;
  clk_1_sg_x82 <= clk_1;
  register1_q_net_x5 <= dly_val;
  register1_q_net_x8 <= inc_mmcm_phs;
  register1_q_net_x6 <= load_dly0;
  register1_q_net_x7 <= pos_mmcm_phs;
  register1_q_net_x4 <= ready;
  convert1_x0 <= convert1_dout_net_x0;
  convert2_x0 <= convert2_dout_net_x0;
  convert3_x0 <= convert3_dout_net_x0;
  convert4_x0 <= convert4_dout_net_x0;
  convert5_x0 <= convert5_dout_net_x0;

  convert1: entity work.xlconvert
    generic map (
      bool_conversion => 1,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x82,
      clk => clk_1_sg_x82,
      clr => '0',
      din(0) => register1_q_net_x4,
      en => "1",
      dout(0) => convert1_dout_net_x0
    );

  convert2: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 5,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 5,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x82,
      clk => clk_1_sg_x82,
      clr => '0',
      din => register1_q_net_x5,
      en => "1",
      dout => convert2_dout_net_x0
    );

  convert3: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 6,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 6,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x82,
      clk => clk_1_sg_x82,
      clr => '0',
      din => register1_q_net_x6,
      en => "1",
      dout => convert3_dout_net_x0
    );

  convert4: entity work.xlconvert
    generic map (
      bool_conversion => 1,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x82,
      clk => clk_1_sg_x82,
      clr => '0',
      din(0) => register1_q_net_x7,
      en => "1",
      dout(0) => convert4_dout_net_x0
    );

  convert5: entity work.xlconvert
    generic map (
      bool_conversion => 1,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x82,
      clk => clk_1_sg_x82,
      clr => '0',
      din(0) => register1_q_net_x8,
      en => "1",
      dout(0) => convert5_dout_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/adc_in/bus_create1"

entity bus_create1_entity_312fc00109 is
  port (
    in1: in std_logic_vector(23 downto 0); 
    in2: in std_logic_vector(23 downto 0); 
    in3: in std_logic_vector(23 downto 0); 
    in4: in std_logic_vector(23 downto 0); 
    in5: in std_logic_vector(23 downto 0); 
    in6: in std_logic_vector(23 downto 0); 
    in7: in std_logic_vector(23 downto 0); 
    in8: in std_logic_vector(23 downto 0); 
    bus_out: out std_logic_vector(191 downto 0)
  );
end bus_create1_entity_312fc00109;

architecture structural of bus_create1_entity_312fc00109 is
  signal concatenate_y_net_x0: std_logic_vector(191 downto 0);
  signal register1_q_net_x10: std_logic_vector(23 downto 0);
  signal register1_q_net_x11: std_logic_vector(23 downto 0);
  signal register1_q_net_x12: std_logic_vector(23 downto 0);
  signal register1_q_net_x13: std_logic_vector(23 downto 0);
  signal register1_q_net_x14: std_logic_vector(23 downto 0);
  signal register1_q_net_x7: std_logic_vector(23 downto 0);
  signal register1_q_net_x8: std_logic_vector(23 downto 0);
  signal register1_q_net_x9: std_logic_vector(23 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(23 downto 0);
  signal reinterpret2_output_port_net: std_logic_vector(23 downto 0);
  signal reinterpret3_output_port_net: std_logic_vector(23 downto 0);
  signal reinterpret4_output_port_net: std_logic_vector(23 downto 0);
  signal reinterpret5_output_port_net: std_logic_vector(23 downto 0);
  signal reinterpret6_output_port_net: std_logic_vector(23 downto 0);
  signal reinterpret7_output_port_net: std_logic_vector(23 downto 0);
  signal reinterpret8_output_port_net: std_logic_vector(23 downto 0);

begin
  register1_q_net_x8 <= in1;
  register1_q_net_x9 <= in2;
  register1_q_net_x10 <= in3;
  register1_q_net_x11 <= in4;
  register1_q_net_x12 <= in5;
  register1_q_net_x13 <= in6;
  register1_q_net_x14 <= in7;
  register1_q_net_x7 <= in8;
  bus_out <= concatenate_y_net_x0;

  concatenate: entity work.concat_f861ea8324
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret1_output_port_net,
      in1 => reinterpret2_output_port_net,
      in2 => reinterpret3_output_port_net,
      in3 => reinterpret4_output_port_net,
      in4 => reinterpret5_output_port_net,
      in5 => reinterpret6_output_port_net,
      in6 => reinterpret7_output_port_net,
      in7 => reinterpret8_output_port_net,
      y => concatenate_y_net_x0
    );

  reinterpret1: entity work.reinterpret_950635102d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => register1_q_net_x8,
      output_port => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_950635102d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => register1_q_net_x9,
      output_port => reinterpret2_output_port_net
    );

  reinterpret3: entity work.reinterpret_950635102d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => register1_q_net_x10,
      output_port => reinterpret3_output_port_net
    );

  reinterpret4: entity work.reinterpret_950635102d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => register1_q_net_x11,
      output_port => reinterpret4_output_port_net
    );

  reinterpret5: entity work.reinterpret_950635102d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => register1_q_net_x12,
      output_port => reinterpret5_output_port_net
    );

  reinterpret6: entity work.reinterpret_950635102d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => register1_q_net_x13,
      output_port => reinterpret6_output_port_net
    );

  reinterpret7: entity work.reinterpret_950635102d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => register1_q_net_x14,
      output_port => reinterpret7_output_port_net
    );

  reinterpret8: entity work.reinterpret_950635102d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => register1_q_net_x7,
      output_port => reinterpret8_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/adc_in/dly_val"

entity dly_val_entity_8b4f4075af is
  port (
    darkquad29_adc_in_dly_val_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end dly_val_entity_8b4f4075af;

architecture structural of dly_val_entity_8b4f4075af is
  signal darkquad29_adc_in_dly_val_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_adc_in_dly_val_user_data_out_net_x0 <= darkquad29_adc_in_dly_val_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_adc_in_dly_val_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/adc_in/i_scale"

entity i_scale_entity_62fca468be is
  port (
    darkquad29_adc_in_i_scale_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end i_scale_entity_62fca468be;

architecture structural of i_scale_entity_62fca468be is
  signal darkquad29_adc_in_i_scale_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_adc_in_i_scale_user_data_out_net_x0 <= darkquad29_adc_in_i_scale_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_adc_in_i_scale_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/adc_in/inc_phs"

entity inc_phs_entity_562186ef63 is
  port (
    darkquad29_adc_in_inc_phs_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end inc_phs_entity_562186ef63;

architecture structural of inc_phs_entity_562186ef63 is
  signal darkquad29_adc_in_inc_phs_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_adc_in_inc_phs_user_data_out_net_x0 <= darkquad29_adc_in_inc_phs_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_adc_in_inc_phs_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/adc_in/load_dly"

entity load_dly_entity_e25624efcb is
  port (
    darkquad29_adc_in_load_dly_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end load_dly_entity_e25624efcb;

architecture structural of load_dly_entity_e25624efcb is
  signal darkquad29_adc_in_load_dly_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_adc_in_load_dly_user_data_out_net_x0 <= darkquad29_adc_in_load_dly_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_adc_in_load_dly_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/adc_in/n_miss_pps"

entity n_miss_pps_entity_75e9ac9f26 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    out_reg: in std_logic_vector(14 downto 0); 
    cast_gw_x0: out std_logic_vector(31 downto 0)
  );
end n_miss_pps_entity_75e9ac9f26;

architecture structural of n_miss_pps_entity_75e9ac9f26 is
  signal assert_reg_dout_net: std_logic_vector(14 downto 0);
  signal cast_gw_dout_net_x0: std_logic_vector(31 downto 0);
  signal ce_1_sg_x86: std_logic;
  signal clk_1_sg_x86: std_logic;
  signal io_delay_q_net: std_logic_vector(14 downto 0);
  signal register0_q_net_x0: std_logic_vector(14 downto 0);
  signal reint1_output_port_net: std_logic_vector(14 downto 0);

begin
  ce_1_sg_x86 <= ce_1;
  clk_1_sg_x86 <= clk_1;
  register0_q_net_x0 <= out_reg;
  cast_gw_x0 <= cast_gw_dout_net_x0;

  assert_reg: entity work.xlpassthrough
    generic map (
      din_width => 15,
      dout_width => 15
    )
    port map (
      din => register0_q_net_x0,
      dout => assert_reg_dout_net
    );

  cast_gw: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 15,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x86,
      clk => clk_1_sg_x86,
      clr => '0',
      din => io_delay_q_net,
      en => "1",
      dout => cast_gw_dout_net_x0
    );

  io_delay: entity work.delay_915e90bb96
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => reint1_output_port_net,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_1001cf4171
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => assert_reg_dout_net,
      output_port => reint1_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/adc_in/pipeline10"

entity pipeline10_entity_04993e776c is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(23 downto 0); 
    q: out std_logic_vector(23 downto 0)
  );
end pipeline10_entity_04993e776c;

architecture structural of pipeline10_entity_04993e776c is
  signal ce_1_sg_x88: std_logic;
  signal clk_1_sg_x88: std_logic;
  signal concat_y_net_x0: std_logic_vector(23 downto 0);
  signal register0_q_net: std_logic_vector(23 downto 0);
  signal register1_q_net_x8: std_logic_vector(23 downto 0);

begin
  ce_1_sg_x88 <= ce_1;
  clk_1_sg_x88 <= clk_1;
  concat_y_net_x0 <= d;
  q <= register1_q_net_x8;

  register0: entity work.xlregister
    generic map (
      d_width => 24,
      init_value => b"000000000000000000000000"
    )
    port map (
      ce => ce_1_sg_x88,
      clk => clk_1_sg_x88,
      d => concat_y_net_x0,
      en => "1",
      rst => "0",
      q => register0_q_net
    );

  register1: entity work.xlregister
    generic map (
      d_width => 24,
      init_value => b"000000000000000000000000"
    )
    port map (
      ce => ce_1_sg_x88,
      clk => clk_1_sg_x88,
      d => register0_q_net,
      en => "1",
      rst => "0",
      q => register1_q_net_x8
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/adc_in/pipeline11"

entity pipeline11_entity_33fea3dbf5 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(11 downto 0); 
    q: out std_logic_vector(11 downto 0)
  );
end pipeline11_entity_33fea3dbf5;

architecture structural of pipeline11_entity_33fea3dbf5 is
  signal ce_1_sg_x89: std_logic;
  signal clk_1_sg_x89: std_logic;
  signal mult_p_net_x0: std_logic_vector(11 downto 0);
  signal register0_q_net: std_logic_vector(11 downto 0);
  signal register1_q_net_x0: std_logic_vector(11 downto 0);

begin
  ce_1_sg_x89 <= ce_1;
  clk_1_sg_x89 <= clk_1;
  mult_p_net_x0 <= d;
  q <= register1_q_net_x0;

  register0: entity work.xlregister
    generic map (
      d_width => 12,
      init_value => b"000000000000"
    )
    port map (
      ce => ce_1_sg_x89,
      clk => clk_1_sg_x89,
      d => mult_p_net_x0,
      en => "1",
      rst => "0",
      q => register0_q_net
    );

  register1: entity work.xlregister
    generic map (
      d_width => 12,
      init_value => b"000000000000"
    )
    port map (
      ce => ce_1_sg_x89,
      clk => clk_1_sg_x89,
      d => register0_q_net,
      en => "1",
      rst => "0",
      q => register1_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/adc_in/pipeline19"

entity pipeline19_entity_c83bf477c3 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(4 downto 0); 
    q: out std_logic_vector(4 downto 0)
  );
end pipeline19_entity_c83bf477c3;

architecture structural of pipeline19_entity_c83bf477c3 is
  signal ce_1_sg_x97: std_logic;
  signal clk_1_sg_x97: std_logic;
  signal register0_q_net: std_logic_vector(4 downto 0);
  signal register1_q_net_x6: std_logic_vector(4 downto 0);
  signal slice4_y_net_x0: std_logic_vector(4 downto 0);

begin
  ce_1_sg_x97 <= ce_1;
  clk_1_sg_x97 <= clk_1;
  slice4_y_net_x0 <= d;
  q <= register1_q_net_x6;

  register0: entity work.xlregister
    generic map (
      d_width => 5,
      init_value => b"00000"
    )
    port map (
      ce => ce_1_sg_x97,
      clk => clk_1_sg_x97,
      d => slice4_y_net_x0,
      en => "1",
      rst => "0",
      q => register0_q_net
    );

  register1: entity work.xlregister
    generic map (
      d_width => 5,
      init_value => b"00000"
    )
    port map (
      ce => ce_1_sg_x97,
      clk => clk_1_sg_x97,
      d => register0_q_net,
      en => "1",
      rst => "0",
      q => register1_q_net_x6
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/adc_in/pipeline2"

entity pipeline2_entity_1bdeb473d2 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic; 
    q: out std_logic
  );
end pipeline2_entity_1bdeb473d2;

architecture structural of pipeline2_entity_1bdeb473d2 is
  signal ce_1_sg_x98: std_logic;
  signal clk_1_sg_x98: std_logic;
  signal darkquad29_adc_in_adcdac_2g_user_valid_net_x0: std_logic;
  signal register0_q_net: std_logic;
  signal register1_q_net_x0: std_logic;

begin
  ce_1_sg_x98 <= ce_1;
  clk_1_sg_x98 <= clk_1;
  darkquad29_adc_in_adcdac_2g_user_valid_net_x0 <= d;
  q <= register1_q_net_x0;

  register0: entity work.xlregister
    generic map (
      d_width => 1,
      init_value => b"0"
    )
    port map (
      ce => ce_1_sg_x98,
      clk => clk_1_sg_x98,
      d(0) => darkquad29_adc_in_adcdac_2g_user_valid_net_x0,
      en => "1",
      rst => "0",
      q(0) => register0_q_net
    );

  register1: entity work.xlregister
    generic map (
      d_width => 1,
      init_value => b"0"
    )
    port map (
      ce => ce_1_sg_x98,
      clk => clk_1_sg_x98,
      d(0) => register0_q_net,
      en => "1",
      rst => "0",
      q(0) => register1_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/adc_in/pipeline20"

entity pipeline20_entity_bc26816ec8 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(5 downto 0); 
    q: out std_logic_vector(5 downto 0)
  );
end pipeline20_entity_bc26816ec8;

architecture structural of pipeline20_entity_bc26816ec8 is
  signal ce_1_sg_x99: std_logic;
  signal clk_1_sg_x99: std_logic;
  signal register0_q_net: std_logic_vector(5 downto 0);
  signal register1_q_net_x7: std_logic_vector(5 downto 0);
  signal slice5_y_net_x0: std_logic_vector(5 downto 0);

begin
  ce_1_sg_x99 <= ce_1;
  clk_1_sg_x99 <= clk_1;
  slice5_y_net_x0 <= d;
  q <= register1_q_net_x7;

  register0: entity work.xlregister
    generic map (
      d_width => 6,
      init_value => b"000000"
    )
    port map (
      ce => ce_1_sg_x99,
      clk => clk_1_sg_x99,
      d => slice5_y_net_x0,
      en => "1",
      rst => "0",
      q => register0_q_net
    );

  register1: entity work.xlregister
    generic map (
      d_width => 6,
      init_value => b"000000"
    )
    port map (
      ce => ce_1_sg_x99,
      clk => clk_1_sg_x99,
      d => register0_q_net,
      en => "1",
      rst => "0",
      q => register1_q_net_x7
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/adc_in/pipeline33"

entity pipeline33_entity_6309c37291 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(14 downto 0); 
    q: out std_logic_vector(14 downto 0)
  );
end pipeline33_entity_6309c37291;

architecture structural of pipeline33_entity_6309c37291 is
  signal ce_1_sg_x113: std_logic;
  signal clk_1_sg_x113: std_logic;
  signal counter3_op_net_x0: std_logic_vector(14 downto 0);
  signal register0_q_net_x1: std_logic_vector(14 downto 0);

begin
  ce_1_sg_x113 <= ce_1;
  clk_1_sg_x113 <= clk_1;
  counter3_op_net_x0 <= d;
  q <= register0_q_net_x1;

  register0: entity work.xlregister
    generic map (
      d_width => 15,
      init_value => b"000000000000000"
    )
    port map (
      ce => ce_1_sg_x113,
      clk => clk_1_sg_x113,
      d => counter3_op_net_x0,
      en => "1",
      rst => "0",
      q => register0_q_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/adc_in/pipeline34"

entity pipeline34_entity_cc1aaf53a8 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(11 downto 0); 
    q: out std_logic_vector(11 downto 0)
  );
end pipeline34_entity_cc1aaf53a8;

architecture structural of pipeline34_entity_cc1aaf53a8 is
  signal ce_1_sg_x114: std_logic;
  signal clk_1_sg_x114: std_logic;
  signal register0_q_net: std_logic_vector(11 downto 0);
  signal register1_q_net: std_logic_vector(11 downto 0);
  signal register2_q_net_x1: std_logic_vector(11 downto 0);
  signal reinterpret18_output_port_net_x0: std_logic_vector(11 downto 0);

begin
  ce_1_sg_x114 <= ce_1;
  clk_1_sg_x114 <= clk_1;
  reinterpret18_output_port_net_x0 <= d;
  q <= register2_q_net_x1;

  register0: entity work.xlregister
    generic map (
      d_width => 12,
      init_value => b"000000000000"
    )
    port map (
      ce => ce_1_sg_x114,
      clk => clk_1_sg_x114,
      d => reinterpret18_output_port_net_x0,
      en => "1",
      rst => "0",
      q => register0_q_net
    );

  register1: entity work.xlregister
    generic map (
      d_width => 12,
      init_value => b"000000000000"
    )
    port map (
      ce => ce_1_sg_x114,
      clk => clk_1_sg_x114,
      d => register0_q_net,
      en => "1",
      rst => "0",
      q => register1_q_net
    );

  register2: entity work.xlregister
    generic map (
      d_width => 12,
      init_value => b"000000000000"
    )
    port map (
      ce => ce_1_sg_x114,
      clk => clk_1_sg_x114,
      d => register1_q_net,
      en => "1",
      rst => "0",
      q => register2_q_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/adc_in/pipeline35"

entity pipeline35_entity_0c537af9bd is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic; 
    q: out std_logic
  );
end pipeline35_entity_0c537af9bd;

architecture structural of pipeline35_entity_0c537af9bd is
  signal ce_1_sg_x115: std_logic;
  signal clk_1_sg_x115: std_logic;
  signal darkquad29_adc_in_adcdac_2g_user_sync_net_x1: std_logic;
  signal register0_q_net_x0: std_logic;

begin
  ce_1_sg_x115 <= ce_1;
  clk_1_sg_x115 <= clk_1;
  darkquad29_adc_in_adcdac_2g_user_sync_net_x1 <= d;
  q <= register0_q_net_x0;

  register0: entity work.xlregister
    generic map (
      d_width => 1,
      init_value => b"0"
    )
    port map (
      ce => ce_1_sg_x115,
      clk => clk_1_sg_x115,
      d(0) => darkquad29_adc_in_adcdac_2g_user_sync_net_x1,
      en => "1",
      rst => "0",
      q(0) => register0_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/adc_in/pos_phs"

entity pos_phs_entity_15176b9079 is
  port (
    darkquad29_adc_in_pos_phs_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end pos_phs_entity_15176b9079;

architecture structural of pos_phs_entity_15176b9079 is
  signal darkquad29_adc_in_pos_phs_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_adc_in_pos_phs_user_data_out_net_x0 <= darkquad29_adc_in_pos_phs_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_adc_in_pos_phs_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/adc_in/ri_to_c"

entity ri_to_c_entity_58f9bb7fbe is
  port (
    im: in std_logic_vector(11 downto 0); 
    re: in std_logic_vector(11 downto 0); 
    c: out std_logic_vector(23 downto 0)
  );
end ri_to_c_entity_58f9bb7fbe;

architecture structural of ri_to_c_entity_58f9bb7fbe is
  signal concat_y_net_x1: std_logic_vector(23 downto 0);
  signal force_im_output_port_net: std_logic_vector(11 downto 0);
  signal force_re_output_port_net: std_logic_vector(11 downto 0);
  signal mult_p_net_x1: std_logic_vector(11 downto 0);
  signal register2_q_net_x2: std_logic_vector(11 downto 0);

begin
  register2_q_net_x2 <= im;
  mult_p_net_x1 <= re;
  c <= concat_y_net_x1;

  concat: entity work.concat_6188124172
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => force_re_output_port_net,
      in1 => force_im_output_port_net,
      y => concat_y_net_x1
    );

  force_im: entity work.reinterpret_a106f99236
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => register2_q_net_x2,
      output_port => force_im_output_port_net
    );

  force_re: entity work.reinterpret_a106f99236
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => mult_p_net_x1,
      output_port => force_re_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/adc_in/snp_cal0/buscreate"

entity buscreate_entity_03c8dd52e9 is
  port (
    in1: in std_logic_vector(11 downto 0); 
    in2: in std_logic_vector(11 downto 0); 
    in3: in std_logic_vector(11 downto 0); 
    in4: in std_logic_vector(11 downto 0); 
    bus_out: out std_logic_vector(47 downto 0)
  );
end buscreate_entity_03c8dd52e9;

architecture structural of buscreate_entity_03c8dd52e9 is
  signal assert_data_i0_dout_net_x0: std_logic_vector(11 downto 0);
  signal assert_data_i1_dout_net_x0: std_logic_vector(11 downto 0);
  signal assert_data_q0_dout_net_x0: std_logic_vector(11 downto 0);
  signal assert_data_q1_dout_net_x0: std_logic_vector(11 downto 0);
  signal concatenate_y_net_x0: std_logic_vector(47 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(11 downto 0);
  signal reinterpret2_output_port_net: std_logic_vector(11 downto 0);
  signal reinterpret3_output_port_net: std_logic_vector(11 downto 0);
  signal reinterpret4_output_port_net: std_logic_vector(11 downto 0);

begin
  assert_data_i0_dout_net_x0 <= in1;
  assert_data_q0_dout_net_x0 <= in2;
  assert_data_i1_dout_net_x0 <= in3;
  assert_data_q1_dout_net_x0 <= in4;
  bus_out <= concatenate_y_net_x0;

  concatenate: entity work.concat_08ed6107eb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret1_output_port_net,
      in1 => reinterpret2_output_port_net,
      in2 => reinterpret3_output_port_net,
      in3 => reinterpret4_output_port_net,
      y => concatenate_y_net_x0
    );

  reinterpret1: entity work.reinterpret_a106f99236
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => assert_data_i0_dout_net_x0,
      output_port => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_a106f99236
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => assert_data_q0_dout_net_x0,
      output_port => reinterpret2_output_port_net
    );

  reinterpret3: entity work.reinterpret_a106f99236
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => assert_data_i1_dout_net_x0,
      output_port => reinterpret3_output_port_net
    );

  reinterpret4: entity work.reinterpret_a106f99236
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => assert_data_q1_dout_net_x0,
      output_port => reinterpret4_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/adc_in/snp_cal0/ss/add_gen"

entity add_gen_entity_3bd86cf2a5 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    cont: in std_logic; 
    din: in std_logic_vector(63 downto 0); 
    go: in std_logic; 
    init: in std_logic; 
    we: in std_logic; 
    add: out std_logic_vector(8 downto 0); 
    dout: out std_logic_vector(63 downto 0); 
    status: out std_logic_vector(31 downto 0); 
    we_o: out std_logic
  );
end add_gen_entity_3bd86cf2a5;

architecture structural of add_gen_entity_3bd86cf2a5 is
  signal add_gen_op_net: std_logic_vector(12 downto 0);
  signal ce_1_sg_x134: std_logic;
  signal clk_1_sg_x134: std_logic;
  signal concat_y_net_x0: std_logic_vector(31 downto 0);
  signal convert_dout_net: std_logic_vector(18 downto 0);
  signal data_choice_y_net_x0: std_logic_vector(63 downto 0);
  signal delay1_q_net: std_logic_vector(11 downto 0);
  signal delay3_q_net: std_logic;
  signal delay4_q_net: std_logic;
  signal delay6_q_net_x0: std_logic_vector(63 downto 0);
  signal delay_q_net: std_logic;
  signal edge_op_y_net_x0: std_logic;
  signal edge_op_y_net_x1: std_logic;
  signal inverter1_op_net: std_logic;
  signal inverter_op_net: std_logic;
  signal logical1_y_net: std_logic;
  signal logical4_y_net: std_logic;
  signal logical6_y_net_x0: std_logic;
  signal never_op_net_x0: std_logic;
  signal register5_q_net: std_logic;
  signal register6_q_net_x0: std_logic;
  signal shift_op_net: std_logic_vector(18 downto 0);
  signal slice1_y_net: std_logic_vector(11 downto 0);
  signal slice2_y_net_x0: std_logic_vector(8 downto 0);
  signal slice3_y_net_x0: std_logic;
  signal we_choice_y_net_x0: std_logic;

begin
  ce_1_sg_x134 <= ce_1;
  clk_1_sg_x134 <= clk_1;
  never_op_net_x0 <= cont;
  data_choice_y_net_x0 <= din;
  register6_q_net_x0 <= go;
  edge_op_y_net_x1 <= init;
  we_choice_y_net_x0 <= we;
  add <= slice2_y_net_x0;
  dout <= delay6_q_net_x0;
  status <= concat_y_net_x0;
  we_o <= logical6_y_net_x0;

  add_gen: entity work.xlcounter_free_darkquad29
    generic map (
      core_name0 => "cntr_11_0_3e8a20e113de20bb",
      op_arith => xlUnsigned,
      op_width => 13
    )
    port map (
      ce => ce_1_sg_x134,
      clk => clk_1_sg_x134,
      clr => '0',
      en(0) => logical6_y_net_x0,
      rst(0) => delay4_q_net,
      op => add_gen_op_net
    );

  concat: entity work.concat_1d665a7331
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => shift_op_net,
      in1(0) => inverter_op_net,
      in2 => delay1_q_net,
      y => concat_y_net_x0
    );

  convert: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 19,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x134,
      clk => clk_1_sg_x134,
      clr => '0',
      din(0) => register5_q_net,
      en => "1",
      dout => convert_dout_net
    );

  delay: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x134,
      clk => clk_1_sg_x134,
      clr => '0',
      d(0) => delay4_q_net,
      q(0) => delay_q_net
    );

  delay1: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 12
    )
    port map (
      ce => ce_1_sg_x134,
      clk => clk_1_sg_x134,
      d => slice1_y_net,
      en => '1',
      rst => '1',
      q => delay1_q_net
    );

  delay3: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x134,
      clk => clk_1_sg_x134,
      clr => '0',
      d(0) => never_op_net_x0,
      q(0) => delay3_q_net
    );

  delay4: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x134,
      clk => clk_1_sg_x134,
      clr => '0',
      d(0) => edge_op_y_net_x1,
      q(0) => delay4_q_net
    );

  delay6: entity work.delay_e2d047c154
    port map (
      ce => ce_1_sg_x134,
      clk => clk_1_sg_x134,
      clr => '0',
      d => data_choice_y_net_x0,
      q => delay6_q_net_x0
    );

  edge_detect_db587df9af: entity work.edge_detect_entity_cc793070c9
    port map (
      ce_1 => ce_1_sg_x134,
      clk_1 => clk_1_sg_x134,
      in_x0 => slice3_y_net_x0,
      out_x0 => edge_op_y_net_x0
    );

  inverter: entity work.inverter_6844eee868
    port map (
      ce => ce_1_sg_x134,
      clk => clk_1_sg_x134,
      clr => '0',
      ip(0) => register5_q_net,
      op(0) => inverter_op_net
    );

  inverter1: entity work.inverter_e5b38cca3b
    port map (
      ce => ce_1_sg_x134,
      clk => clk_1_sg_x134,
      clr => '0',
      ip(0) => edge_op_y_net_x0,
      op(0) => inverter1_op_net
    );

  logical1: entity work.logical_799f62af22
    port map (
      ce => ce_1_sg_x134,
      clk => clk_1_sg_x134,
      clr => '0',
      d0(0) => we_choice_y_net_x0,
      d1(0) => register6_q_net_x0,
      y(0) => logical1_y_net
    );

  logical4: entity work.logical_aacf6e1b0e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => delay3_q_net,
      d1(0) => inverter1_op_net,
      y(0) => logical4_y_net
    );

  logical6: entity work.logical_954ee29728
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => register5_q_net,
      d1(0) => logical4_y_net,
      d2(0) => logical1_y_net,
      y(0) => logical6_y_net_x0
    );

  register5: entity work.xlregister
    generic map (
      d_width => 1,
      init_value => b"1"
    )
    port map (
      ce => ce_1_sg_x134,
      clk => clk_1_sg_x134,
      d(0) => delay3_q_net,
      en(0) => edge_op_y_net_x0,
      rst(0) => delay_q_net,
      q(0) => register5_q_net
    );

  shift: entity work.shift_892c2104f7
    port map (
      ce => ce_1_sg_x134,
      clk => clk_1_sg_x134,
      clr => '0',
      ip => convert_dout_net,
      op => shift_op_net
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 11,
      x_width => 13,
      y_width => 12
    )
    port map (
      x => add_gen_op_net,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 3,
      new_msb => 11,
      x_width => 13,
      y_width => 9
    )
    port map (
      x => add_gen_op_net,
      y => slice2_y_net_x0
    );

  slice3: entity work.xlslice
    generic map (
      new_lsb => 12,
      new_msb => 12,
      x_width => 13,
      y_width => 1
    )
    port map (
      x => add_gen_op_net,
      y(0) => slice3_y_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/adc_in/snp_cal0/ss/basic_ctrl/dram_munge"

entity dram_munge_entity_7cc9fa7a39 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(63 downto 0); 
    init: in std_logic; 
    we: in std_logic; 
    dout: out std_logic_vector(63 downto 0); 
    we_o: out std_logic
  );
end dram_munge_entity_7cc9fa7a39;

architecture structural of dram_munge_entity_7cc9fa7a39 is
  signal cast_dout_net_x0: std_logic_vector(63 downto 0);
  signal ce_1_sg_x135: std_logic;
  signal clk_1_sg_x135: std_logic;
  signal con0_op_net: std_logic_vector(1 downto 0);
  signal con1_op_net: std_logic_vector(1 downto 0);
  signal con2_op_net: std_logic_vector(1 downto 0);
  signal con3_op_net: std_logic_vector(1 downto 0);
  signal concat1_y_net: std_logic_vector(143 downto 0);
  signal concat_y_net: std_logic_vector(143 downto 0);
  signal constant_op_net: std_logic_vector(7 downto 0);
  signal data_choice_y_net_x1: std_logic_vector(63 downto 0);
  signal delay1_q_net: std_logic;
  signal delay_q_net: std_logic;
  signal dout_count_op_net: std_logic;
  signal dram_op_net: std_logic;
  signal edge_op_y_net_x2: std_logic;
  signal input_count_op_net: std_logic_vector(1 downto 0);
  signal logical1_y_net: std_logic;
  signal logical_y_net: std_logic;
  signal mux1_y_net_x0: std_logic_vector(143 downto 0);
  signal mux1_y_net_x1: std_logic;
  signal register1_q_net: std_logic_vector(63 downto 0);
  signal register2_q_net: std_logic_vector(63 downto 0);
  signal register3_q_net: std_logic_vector(63 downto 0);
  signal register_q_net: std_logic_vector(63 downto 0);
  signal relational1_op_net: std_logic;
  signal relational2_op_net: std_logic;
  signal relational3_op_net: std_logic;
  signal relational_op_net: std_logic;
  signal we_choice_y_net_x1: std_logic;

begin
  ce_1_sg_x135 <= ce_1;
  clk_1_sg_x135 <= clk_1;
  cast_dout_net_x0 <= din;
  edge_op_y_net_x2 <= init;
  mux1_y_net_x1 <= we;
  dout <= data_choice_y_net_x1;
  we_o <= we_choice_y_net_x1;

  con0: entity work.constant_cda50df78a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => con0_op_net
    );

  con1: entity work.constant_a7e2bb9e12
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => con1_op_net
    );

  con2: entity work.constant_e8ddc079e9
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => con2_op_net
    );

  con3: entity work.constant_3a9a3daeb9
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => con3_op_net
    );

  concat: entity work.concat_1cf6dd7a8c
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => constant_op_net,
      in1 => register_q_net,
      in2 => constant_op_net,
      in3 => register1_q_net,
      y => concat_y_net
    );

  concat1: entity work.concat_1cf6dd7a8c
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => constant_op_net,
      in1 => register2_q_net,
      in2 => constant_op_net,
      in3 => register3_q_net,
      y => concat1_y_net
    );

  constant_x0: entity work.constant_91ef1678ca
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant_op_net
    );

  data_choice: entity work.mux_5b4e0018fe
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0 => cast_dout_net_x0,
      d1 => mux1_y_net_x0,
      sel(0) => dram_op_net,
      y => data_choice_y_net_x1
    );

  delay: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x135,
      clk => clk_1_sg_x135,
      d(0) => logical_y_net,
      en => '1',
      rst => '1',
      q(0) => delay_q_net
    );

  delay1: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x135,
      clk => clk_1_sg_x135,
      d(0) => logical1_y_net,
      en => '1',
      rst => '1',
      q(0) => delay1_q_net
    );

  dout_count: entity work.counter_caa2b01eef
    port map (
      ce => ce_1_sg_x135,
      clk => clk_1_sg_x135,
      clr => '0',
      en(0) => logical1_y_net,
      rst(0) => edge_op_y_net_x2,
      op(0) => dout_count_op_net
    );

  dram: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => dram_op_net
    );

  input_count: entity work.xlcounter_free_darkquad29
    generic map (
      core_name0 => "cntr_11_0_10352c017544bebd",
      op_arith => xlUnsigned,
      op_width => 2
    )
    port map (
      ce => ce_1_sg_x135,
      clk => clk_1_sg_x135,
      clr => '0',
      en(0) => mux1_y_net_x1,
      rst(0) => edge_op_y_net_x2,
      op => input_count_op_net
    );

  logical: entity work.logical_799f62af22
    port map (
      ce => ce_1_sg_x135,
      clk => clk_1_sg_x135,
      clr => '0',
      d0(0) => relational3_op_net,
      d1(0) => mux1_y_net_x1,
      y(0) => logical_y_net
    );

  logical1: entity work.logical_aacf6e1b0e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => logical_y_net,
      d1(0) => delay_q_net,
      y(0) => logical1_y_net
    );

  mux1: entity work.mux_d10510a905
    port map (
      ce => ce_1_sg_x135,
      clk => clk_1_sg_x135,
      clr => '0',
      d0 => concat_y_net,
      d1 => concat1_y_net,
      sel(0) => dout_count_op_net,
      y => mux1_y_net_x0
    );

  register1: entity work.xlregister
    generic map (
      d_width => 64,
      init_value => b"0000000000000000000000000000000000000000000000000000000000000000"
    )
    port map (
      ce => ce_1_sg_x135,
      clk => clk_1_sg_x135,
      d => cast_dout_net_x0,
      en(0) => relational1_op_net,
      rst => "0",
      q => register1_q_net
    );

  register2: entity work.xlregister
    generic map (
      d_width => 64,
      init_value => b"0000000000000000000000000000000000000000000000000000000000000000"
    )
    port map (
      ce => ce_1_sg_x135,
      clk => clk_1_sg_x135,
      d => cast_dout_net_x0,
      en(0) => relational2_op_net,
      rst => "0",
      q => register2_q_net
    );

  register3: entity work.xlregister
    generic map (
      d_width => 64,
      init_value => b"0000000000000000000000000000000000000000000000000000000000000000"
    )
    port map (
      ce => ce_1_sg_x135,
      clk => clk_1_sg_x135,
      d => cast_dout_net_x0,
      en(0) => relational3_op_net,
      rst => "0",
      q => register3_q_net
    );

  register_x0: entity work.xlregister
    generic map (
      d_width => 64,
      init_value => b"0000000000000000000000000000000000000000000000000000000000000000"
    )
    port map (
      ce => ce_1_sg_x135,
      clk => clk_1_sg_x135,
      d => cast_dout_net_x0,
      en(0) => relational_op_net,
      rst => "0",
      q => register_q_net
    );

  relational: entity work.relational_5f1eb17108
    port map (
      a => input_count_op_net,
      b => con0_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational_op_net
    );

  relational1: entity work.relational_5f1eb17108
    port map (
      a => input_count_op_net,
      b => con1_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational1_op_net
    );

  relational2: entity work.relational_5f1eb17108
    port map (
      a => input_count_op_net,
      b => con2_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational2_op_net
    );

  relational3: entity work.relational_5f1eb17108
    port map (
      a => input_count_op_net,
      b => con3_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational3_op_net
    );

  we_choice: entity work.mux_d99e59b6d4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => mux1_y_net_x1,
      d1(0) => delay1_q_net,
      sel(0) => dram_op_net,
      y(0) => we_choice_y_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/adc_in/snp_cal0/ss/basic_ctrl"

entity basic_ctrl_entity_877c836a9e is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    ctrl: in std_logic_vector(31 downto 0); 
    din: in std_logic_vector(63 downto 0); 
    trig: in std_logic; 
    we: in std_logic; 
    dout: out std_logic_vector(63 downto 0); 
    go: out std_logic; 
    init: out std_logic; 
    we_o: out std_logic
  );
end basic_ctrl_entity_877c836a9e;

architecture structural of basic_ctrl_entity_877c836a9e is
  signal cast_dout_net_x1: std_logic_vector(63 downto 0);
  signal ce_1_sg_x137: std_logic;
  signal clk_1_sg_x137: std_logic;
  signal constant1_op_net_x0: std_logic;
  signal constant1_op_net_x1: std_logic;
  signal constant2_op_net: std_logic;
  signal constant_op_net: std_logic;
  signal data_choice_y_net_x2: std_logic_vector(63 downto 0);
  signal delay1_q_net_x0: std_logic;
  signal delay2_q_net: std_logic;
  signal delay3_q_net: std_logic;
  signal edge_op_y_net_x4: std_logic;
  signal enable_y_net: std_logic;
  signal inverter_op_net: std_logic;
  signal logical_y_net: std_logic;
  signal mux1_y_net_x1: std_logic;
  signal mux2_y_net: std_logic;
  signal register1_q_net: std_logic;
  signal register1_q_net_x1: std_logic;
  signal register6_q_net_x1: std_logic;
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal trig_src_y_net: std_logic;
  signal valid_src_y_net: std_logic;
  signal we_choice_y_net_x2: std_logic;

begin
  ce_1_sg_x137 <= ce_1;
  clk_1_sg_x137 <= clk_1;
  reint1_output_port_net_x0 <= ctrl;
  cast_dout_net_x1 <= din;
  register1_q_net_x1 <= trig;
  constant1_op_net_x1 <= we;
  dout <= data_choice_y_net_x2;
  go <= register6_q_net_x1;
  init <= edge_op_y_net_x4;
  we_o <= we_choice_y_net_x2;

  constant1: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant1_op_net_x0
    );

  constant2: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant2_op_net
    );

  constant_x0: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant_op_net
    );

  delay1: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x137,
      clk => clk_1_sg_x137,
      d(0) => enable_y_net,
      en => '1',
      rst => '1',
      q(0) => delay1_q_net_x0
    );

  delay2: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x137,
      clk => clk_1_sg_x137,
      d(0) => trig_src_y_net,
      en => '1',
      rst => '1',
      q(0) => delay2_q_net
    );

  delay3: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x137,
      clk => clk_1_sg_x137,
      d(0) => valid_src_y_net,
      en => '1',
      rst => '1',
      q(0) => delay3_q_net
    );

  dram_munge_7cc9fa7a39: entity work.dram_munge_entity_7cc9fa7a39
    port map (
      ce_1 => ce_1_sg_x137,
      clk_1 => clk_1_sg_x137,
      din => cast_dout_net_x1,
      init => edge_op_y_net_x4,
      we => mux1_y_net_x1,
      dout => data_choice_y_net_x2,
      we_o => we_choice_y_net_x2
    );

  edge_detect_44998772f2: entity work.edge_detect3_entity_2efb246ca9
    port map (
      ce_1 => ce_1_sg_x137,
      clk_1 => clk_1_sg_x137,
      in_x0 => delay1_q_net_x0,
      out_x0 => edge_op_y_net_x4
    );

  enable: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => reint1_output_port_net_x0,
      y(0) => enable_y_net
    );

  inverter: entity work.inverter_e5b38cca3b
    port map (
      ce => ce_1_sg_x137,
      clk => clk_1_sg_x137,
      clr => '0',
      ip(0) => edge_op_y_net_x4,
      op(0) => inverter_op_net
    );

  logical: entity work.logical_80f90b97d0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => mux2_y_net,
      d1(0) => inverter_op_net,
      y(0) => logical_y_net
    );

  mux1: entity work.mux_d99e59b6d4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => constant1_op_net_x1,
      d1(0) => constant2_op_net,
      sel(0) => delay3_q_net,
      y(0) => mux1_y_net_x1
    );

  mux2: entity work.mux_d99e59b6d4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => register1_q_net_x1,
      d1(0) => constant1_op_net_x0,
      sel(0) => delay2_q_net,
      y(0) => mux2_y_net
    );

  register1: entity work.xlregister
    generic map (
      d_width => 1,
      init_value => b"0"
    )
    port map (
      ce => ce_1_sg_x137,
      clk => clk_1_sg_x137,
      d(0) => constant_op_net,
      en(0) => edge_op_y_net_x4,
      rst(0) => logical_y_net,
      q(0) => register1_q_net
    );

  register6: entity work.xlregister
    generic map (
      d_width => 1,
      init_value => b"0"
    )
    port map (
      ce => ce_1_sg_x137,
      clk => clk_1_sg_x137,
      d(0) => mux2_y_net,
      en(0) => register1_q_net,
      rst(0) => edge_op_y_net_x4,
      q(0) => register6_q_net_x1
    );

  trig_src: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 1,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => reint1_output_port_net_x0,
      y(0) => trig_src_y_net
    );

  valid_src: entity work.xlslice
    generic map (
      new_lsb => 2,
      new_msb => 2,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => reint1_output_port_net_x0,
      y(0) => valid_src_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/adc_in/snp_cal0/ss/bram/calc_add"

entity calc_add_entity_6b7433b2a8 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(8 downto 0); 
    out_x0: out std_logic_vector(8 downto 0)
  );
end calc_add_entity_6b7433b2a8;

architecture structural of calc_add_entity_6b7433b2a8 is
  signal add_del_q_net_x0: std_logic_vector(8 downto 0);
  signal add_sub_s_net: std_logic;
  signal ce_1_sg_x138: std_logic;
  signal clk_1_sg_x138: std_logic;
  signal concat_y_net: std_logic_vector(8 downto 0);
  signal const_op_net: std_logic;
  signal convert_addr_dout_net: std_logic_vector(8 downto 0);
  signal lsw_y_net: std_logic;
  signal manipulate_op_net: std_logic;
  signal msw_y_net: std_logic_vector(7 downto 0);
  signal mux_y_net_x0: std_logic_vector(8 downto 0);

begin
  ce_1_sg_x138 <= ce_1;
  clk_1_sg_x138 <= clk_1;
  add_del_q_net_x0 <= in_x0;
  out_x0 <= mux_y_net_x0;

  add_sub: entity work.addsub_c13097e33e
    port map (
      a(0) => const_op_net,
      b(0) => lsw_y_net,
      ce => ce_1_sg_x138,
      clk => clk_1_sg_x138,
      clr => '0',
      s(0) => add_sub_s_net
    );

  concat: entity work.concat_e27c8b361a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => msw_y_net,
      in1(0) => add_sub_s_net,
      y => concat_y_net
    );

  const: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => const_op_net
    );

  convert_addr: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 9,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 9,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x138,
      clk => clk_1_sg_x138,
      clr => '0',
      din => add_del_q_net_x0,
      en => "1",
      dout => convert_addr_dout_net
    );

  lsw: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 9,
      y_width => 1
    )
    port map (
      x => convert_addr_dout_net,
      y(0) => lsw_y_net
    );

  manipulate: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => manipulate_op_net
    );

  msw: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 8,
      x_width => 9,
      y_width => 8
    )
    port map (
      x => convert_addr_dout_net,
      y => msw_y_net
    );

  mux: entity work.mux_1c9c15de9c
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0 => convert_addr_dout_net,
      d1 => concat_y_net,
      sel(0) => manipulate_op_net,
      y => mux_y_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/adc_in/snp_cal0/ss/bram/munge_in/join"

entity join_entity_6dda6816e4 is
  port (
    in1: in std_logic_vector(31 downto 0); 
    in2: in std_logic_vector(31 downto 0); 
    bus_out: out std_logic_vector(63 downto 0)
  );
end join_entity_6dda6816e4;

architecture structural of join_entity_6dda6816e4 is
  signal concatenate_y_net_x0: std_logic_vector(63 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(31 downto 0);
  signal reinterpret1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal reinterpret2_output_port_net: std_logic_vector(31 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(31 downto 0);

begin
  reinterpret1_output_port_net_x1 <= in1;
  reinterpret2_output_port_net_x1 <= in2;
  bus_out <= concatenate_y_net_x0;

  concatenate: entity work.concat_62c4475a80
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret1_output_port_net,
      in1 => reinterpret2_output_port_net,
      y => concatenate_y_net_x0
    );

  reinterpret1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => reinterpret1_output_port_net_x1,
      output_port => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => reinterpret2_output_port_net_x1,
      output_port => reinterpret2_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/adc_in/snp_cal0/ss/bram/munge_in/split"

entity split_entity_7012dae3c0 is
  port (
    bus_in: in std_logic_vector(63 downto 0); 
    lsb_out1: out std_logic_vector(31 downto 0); 
    msb_out2: out std_logic_vector(31 downto 0)
  );
end split_entity_7012dae3c0;

architecture structural of split_entity_7012dae3c0 is
  signal reinterpret1_output_port_net_x2: std_logic_vector(31 downto 0);
  signal reinterpret2_output_port_net_x2: std_logic_vector(31 downto 0);
  signal reinterpret_output_port_net_x0: std_logic_vector(63 downto 0);
  signal slice1_y_net: std_logic_vector(31 downto 0);
  signal slice2_y_net: std_logic_vector(31 downto 0);

begin
  reinterpret_output_port_net_x0 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x2;
  msb_out2 <= reinterpret2_output_port_net_x2;

  reinterpret1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x2
    );

  reinterpret2: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret2_output_port_net_x2
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 64,
      y_width => 32
    )
    port map (
      x => reinterpret_output_port_net_x0,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 32,
      new_msb => 63,
      x_width => 64,
      y_width => 32
    )
    port map (
      x => reinterpret_output_port_net_x0,
      y => slice2_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/adc_in/snp_cal0/ss/bram/munge_in"

entity munge_in_entity_bf91674daf is
  port (
    din: in std_logic_vector(63 downto 0); 
    dout: out std_logic_vector(63 downto 0)
  );
end munge_in_entity_bf91674daf;

architecture structural of munge_in_entity_bf91674daf is
  signal concatenate_y_net_x0: std_logic_vector(63 downto 0);
  signal dat_del_q_net_x0: std_logic_vector(63 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(31 downto 0);
  signal reinterpret2_output_port_net_x2: std_logic_vector(31 downto 0);
  signal reinterpret_out_output_port_net_x0: std_logic_vector(63 downto 0);
  signal reinterpret_output_port_net_x0: std_logic_vector(63 downto 0);

begin
  dat_del_q_net_x0 <= din;
  dout <= reinterpret_out_output_port_net_x0;

  join_6dda6816e4: entity work.join_entity_6dda6816e4
    port map (
      in1 => reinterpret1_output_port_net_x2,
      in2 => reinterpret2_output_port_net_x2,
      bus_out => concatenate_y_net_x0
    );

  reinterpret: entity work.reinterpret_9a13f6a2a0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => dat_del_q_net_x0,
      output_port => reinterpret_output_port_net_x0
    );

  reinterpret_out: entity work.reinterpret_9a13f6a2a0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => concatenate_y_net_x0,
      output_port => reinterpret_out_output_port_net_x0
    );

  split_7012dae3c0: entity work.split_entity_7012dae3c0
    port map (
      bus_in => reinterpret_output_port_net_x0,
      lsb_out1 => reinterpret1_output_port_net_x2,
      msb_out2 => reinterpret2_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/adc_in/snp_cal0/ss/bram"

entity bram_entity_2be072e628 is
  port (
    addr: in std_logic_vector(8 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    data_in: in std_logic_vector(63 downto 0); 
    we: in std_logic; 
    convert_addr_x0: out std_logic_vector(8 downto 0); 
    convert_din1_x0: out std_logic_vector(63 downto 0); 
    convert_we_x0: out std_logic
  );
end bram_entity_2be072e628;

architecture structural of bram_entity_2be072e628 is
  signal add_del_q_net_x1: std_logic_vector(8 downto 0);
  signal ce_1_sg_x139: std_logic;
  signal clk_1_sg_x139: std_logic;
  signal convert_addr_dout_net_x0: std_logic_vector(8 downto 0);
  signal convert_din1_dout_net_x0: std_logic_vector(63 downto 0);
  signal convert_we_dout_net_x0: std_logic;
  signal dat_del_q_net_x1: std_logic_vector(63 downto 0);
  signal mux_y_net_x0: std_logic_vector(8 downto 0);
  signal reinterpret_out_output_port_net_x0: std_logic_vector(63 downto 0);
  signal we_del_q_net_x0: std_logic;

begin
  add_del_q_net_x1 <= addr;
  ce_1_sg_x139 <= ce_1;
  clk_1_sg_x139 <= clk_1;
  dat_del_q_net_x1 <= data_in;
  we_del_q_net_x0 <= we;
  convert_addr_x0 <= convert_addr_dout_net_x0;
  convert_din1_x0 <= convert_din1_dout_net_x0;
  convert_we_x0 <= convert_we_dout_net_x0;

  calc_add_6b7433b2a8: entity work.calc_add_entity_6b7433b2a8
    port map (
      ce_1 => ce_1_sg_x139,
      clk_1 => clk_1_sg_x139,
      in_x0 => add_del_q_net_x1,
      out_x0 => mux_y_net_x0
    );

  convert_addr: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 9,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 9,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x139,
      clk => clk_1_sg_x139,
      clr => '0',
      din => mux_y_net_x0,
      en => "1",
      dout => convert_addr_dout_net_x0
    );

  convert_din1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 64,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 64,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x139,
      clk => clk_1_sg_x139,
      clr => '0',
      din => reinterpret_out_output_port_net_x0,
      en => "1",
      dout => convert_din1_dout_net_x0
    );

  convert_we: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x139,
      clk => clk_1_sg_x139,
      clr => '0',
      din(0) => we_del_q_net_x0,
      en => "1",
      dout(0) => convert_we_dout_net_x0
    );

  munge_in_bf91674daf: entity work.munge_in_entity_bf91674daf
    port map (
      din => dat_del_q_net_x1,
      dout => reinterpret_out_output_port_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/adc_in/snp_cal0/ss/ctrl"

entity ctrl_entity_5c70850e50 is
  port (
    darkquad29_adc_in_snp_cal0_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end ctrl_entity_5c70850e50;

architecture structural of ctrl_entity_5c70850e50 is
  signal darkquad29_adc_in_snp_cal0_ss_ctrl_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_adc_in_snp_cal0_ss_ctrl_user_data_out_net_x0 <= darkquad29_adc_in_snp_cal0_ss_ctrl_user_data_out;
  in_reg <= reint1_output_port_net_x1;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_adc_in_snp_cal0_ss_ctrl_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x1
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/adc_in/snp_cal0/ss"

entity ss_entity_7c95cee977 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    darkquad29_adc_in_snp_cal0_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    din: in std_logic_vector(47 downto 0); 
    trig: in std_logic; 
    we: in std_logic; 
    bram: out std_logic_vector(8 downto 0); 
    bram_x0: out std_logic_vector(63 downto 0); 
    bram_x1: out std_logic; 
    status: out std_logic_vector(31 downto 0)
  );
end ss_entity_7c95cee977;

architecture structural of ss_entity_7c95cee977 is
  signal add_del_q_net_x1: std_logic_vector(8 downto 0);
  signal cast_dout_net_x1: std_logic_vector(63 downto 0);
  signal cast_gw_dout_net_x1: std_logic_vector(31 downto 0);
  signal ce_1_sg_x141: std_logic;
  signal clk_1_sg_x141: std_logic;
  signal concat_y_net_x1: std_logic_vector(31 downto 0);
  signal concatenate_y_net_x1: std_logic_vector(47 downto 0);
  signal constant1_op_net_x2: std_logic;
  signal convert_addr_dout_net_x1: std_logic_vector(8 downto 0);
  signal convert_din1_dout_net_x1: std_logic_vector(63 downto 0);
  signal convert_we_dout_net_x1: std_logic;
  signal darkquad29_adc_in_snp_cal0_ss_ctrl_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal dat_del_q_net_x1: std_logic_vector(63 downto 0);
  signal data_choice_y_net_x2: std_logic_vector(63 downto 0);
  signal delay6_q_net_x0: std_logic_vector(63 downto 0);
  signal edge_op_y_net_x4: std_logic;
  signal logical6_y_net_x0: std_logic;
  signal never_op_net_x0: std_logic;
  signal register1_q_net_x2: std_logic;
  signal register6_q_net_x1: std_logic;
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal ri_output_port_net: std_logic_vector(47 downto 0);
  signal slice2_y_net_x0: std_logic_vector(8 downto 0);
  signal we_choice_y_net_x2: std_logic;
  signal we_del_q_net_x0: std_logic;

begin
  ce_1_sg_x141 <= ce_1;
  clk_1_sg_x141 <= clk_1;
  darkquad29_adc_in_snp_cal0_ss_ctrl_user_data_out_net_x1 <= darkquad29_adc_in_snp_cal0_ss_ctrl_user_data_out;
  concatenate_y_net_x1 <= din;
  register1_q_net_x2 <= trig;
  constant1_op_net_x2 <= we;
  bram <= convert_addr_dout_net_x1;
  bram_x0 <= convert_din1_dout_net_x1;
  bram_x1 <= convert_we_dout_net_x1;
  status <= cast_gw_dout_net_x1;

  add_del: entity work.delay_09771002d6
    port map (
      ce => ce_1_sg_x141,
      clk => clk_1_sg_x141,
      clr => '0',
      d => slice2_y_net_x0,
      q => add_del_q_net_x1
    );

  add_gen_3bd86cf2a5: entity work.add_gen_entity_3bd86cf2a5
    port map (
      ce_1 => ce_1_sg_x141,
      clk_1 => clk_1_sg_x141,
      cont => never_op_net_x0,
      din => data_choice_y_net_x2,
      go => register6_q_net_x1,
      init => edge_op_y_net_x4,
      we => we_choice_y_net_x2,
      add => slice2_y_net_x0,
      dout => delay6_q_net_x0,
      status => concat_y_net_x1,
      we_o => logical6_y_net_x0
    );

  basic_ctrl_877c836a9e: entity work.basic_ctrl_entity_877c836a9e
    port map (
      ce_1 => ce_1_sg_x141,
      clk_1 => clk_1_sg_x141,
      ctrl => reint1_output_port_net_x1,
      din => cast_dout_net_x1,
      trig => register1_q_net_x2,
      we => constant1_op_net_x2,
      dout => data_choice_y_net_x2,
      go => register6_q_net_x1,
      init => edge_op_y_net_x4,
      we_o => we_choice_y_net_x2
    );

  bram_2be072e628: entity work.bram_entity_2be072e628
    port map (
      addr => add_del_q_net_x1,
      ce_1 => ce_1_sg_x141,
      clk_1 => clk_1_sg_x141,
      data_in => dat_del_q_net_x1,
      we => we_del_q_net_x0,
      convert_addr_x0 => convert_addr_dout_net_x1,
      convert_din1_x0 => convert_din1_dout_net_x1,
      convert_we_x0 => convert_we_dout_net_x1
    );

  cast: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 48,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 64,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x141,
      clk => clk_1_sg_x141,
      clr => '0',
      din => ri_output_port_net,
      en => "1",
      dout => cast_dout_net_x1
    );

  ctrl_5c70850e50: entity work.ctrl_entity_5c70850e50
    port map (
      darkquad29_adc_in_snp_cal0_ss_ctrl_user_data_out => darkquad29_adc_in_snp_cal0_ss_ctrl_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x1
    );

  dat_del: entity work.delay_e2d047c154
    port map (
      ce => ce_1_sg_x141,
      clk => clk_1_sg_x141,
      clr => '0',
      d => delay6_q_net_x0,
      q => dat_del_q_net_x1
    );

  never: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => never_op_net_x0
    );

  ri: entity work.reinterpret_b0553f3acc
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => concatenate_y_net_x1,
      output_port => ri_output_port_net
    );

  status_669866f1d3: entity work.last_tx_data_entity_4b5ba71046
    port map (
      ce_1 => ce_1_sg_x141,
      clk_1 => clk_1_sg_x141,
      out_reg => concat_y_net_x1,
      cast_gw_x0 => cast_gw_dout_net_x1
    );

  we_del: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x141,
      clk => clk_1_sg_x141,
      clr => '0',
      d(0) => logical6_y_net_x0,
      q(0) => we_del_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/adc_in/snp_cal0"

entity snp_cal0_entity_2f39237f1b is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    darkquad29_adc_in_snp_cal0_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    in_data_i0: in std_logic_vector(11 downto 0); 
    in_data_i1: in std_logic_vector(11 downto 0); 
    in_data_q0: in std_logic_vector(11 downto 0); 
    in_data_q1: in std_logic_vector(11 downto 0); 
    trig: in std_logic; 
    we: in std_logic; 
    ss: out std_logic_vector(8 downto 0); 
    ss_x0: out std_logic_vector(63 downto 0); 
    ss_x1: out std_logic; 
    ss_x2: out std_logic_vector(31 downto 0)
  );
end snp_cal0_entity_2f39237f1b;

architecture structural of snp_cal0_entity_2f39237f1b is
  signal assert_data_i0_dout_net_x0: std_logic_vector(11 downto 0);
  signal assert_data_i1_dout_net_x0: std_logic_vector(11 downto 0);
  signal assert_data_q0_dout_net_x0: std_logic_vector(11 downto 0);
  signal assert_data_q1_dout_net_x0: std_logic_vector(11 downto 0);
  signal cast_gw_dout_net_x2: std_logic_vector(31 downto 0);
  signal ce_1_sg_x142: std_logic;
  signal clk_1_sg_x142: std_logic;
  signal concatenate_y_net_x1: std_logic_vector(47 downto 0);
  signal constant1_op_net_x3: std_logic;
  signal convert_addr_dout_net_x2: std_logic_vector(8 downto 0);
  signal convert_din1_dout_net_x2: std_logic_vector(63 downto 0);
  signal convert_we_dout_net_x2: std_logic;
  signal darkquad29_adc_in_snp_cal0_ss_ctrl_user_data_out_net_x2: std_logic_vector(31 downto 0);
  signal register1_q_net_x5: std_logic_vector(11 downto 0);
  signal register1_q_net_x6: std_logic_vector(11 downto 0);
  signal register1_q_net_x7: std_logic_vector(11 downto 0);
  signal register1_q_net_x8: std_logic;
  signal register1_q_net_x9: std_logic_vector(11 downto 0);

begin
  ce_1_sg_x142 <= ce_1;
  clk_1_sg_x142 <= clk_1;
  darkquad29_adc_in_snp_cal0_ss_ctrl_user_data_out_net_x2 <= darkquad29_adc_in_snp_cal0_ss_ctrl_user_data_out;
  register1_q_net_x5 <= in_data_i0;
  register1_q_net_x7 <= in_data_i1;
  register1_q_net_x6 <= in_data_q0;
  register1_q_net_x9 <= in_data_q1;
  register1_q_net_x8 <= trig;
  constant1_op_net_x3 <= we;
  ss <= convert_addr_dout_net_x2;
  ss_x0 <= convert_din1_dout_net_x2;
  ss_x1 <= convert_we_dout_net_x2;
  ss_x2 <= cast_gw_dout_net_x2;

  assert_data_i0: entity work.xlpassthrough
    generic map (
      din_width => 12,
      dout_width => 12
    )
    port map (
      din => register1_q_net_x5,
      dout => assert_data_i0_dout_net_x0
    );

  assert_data_i1: entity work.xlpassthrough
    generic map (
      din_width => 12,
      dout_width => 12
    )
    port map (
      din => register1_q_net_x7,
      dout => assert_data_i1_dout_net_x0
    );

  assert_data_q0: entity work.xlpassthrough
    generic map (
      din_width => 12,
      dout_width => 12
    )
    port map (
      din => register1_q_net_x6,
      dout => assert_data_q0_dout_net_x0
    );

  assert_data_q1: entity work.xlpassthrough
    generic map (
      din_width => 12,
      dout_width => 12
    )
    port map (
      din => register1_q_net_x9,
      dout => assert_data_q1_dout_net_x0
    );

  buscreate_03c8dd52e9: entity work.buscreate_entity_03c8dd52e9
    port map (
      in1 => assert_data_i0_dout_net_x0,
      in2 => assert_data_q0_dout_net_x0,
      in3 => assert_data_i1_dout_net_x0,
      in4 => assert_data_q1_dout_net_x0,
      bus_out => concatenate_y_net_x1
    );

  ss_7c95cee977: entity work.ss_entity_7c95cee977
    port map (
      ce_1 => ce_1_sg_x142,
      clk_1 => clk_1_sg_x142,
      darkquad29_adc_in_snp_cal0_ss_ctrl_user_data_out => darkquad29_adc_in_snp_cal0_ss_ctrl_user_data_out_net_x2,
      din => concatenate_y_net_x1,
      trig => register1_q_net_x8,
      we => constant1_op_net_x3,
      bram => convert_addr_dout_net_x2,
      bram_x0 => convert_din1_dout_net_x2,
      bram_x1 => convert_we_dout_net_x2,
      status => cast_gw_dout_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/adc_in/snp_cal1/ss/ctrl"

entity ctrl_entity_104b01f516 is
  port (
    darkquad29_adc_in_snp_cal1_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end ctrl_entity_104b01f516;

architecture structural of ctrl_entity_104b01f516 is
  signal darkquad29_adc_in_snp_cal1_ss_ctrl_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_adc_in_snp_cal1_ss_ctrl_user_data_out_net_x0 <= darkquad29_adc_in_snp_cal1_ss_ctrl_user_data_out;
  in_reg <= reint1_output_port_net_x1;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_adc_in_snp_cal1_ss_ctrl_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x1
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/adc_in/snp_cal1/ss"

entity ss_entity_d066921faf is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    darkquad29_adc_in_snp_cal1_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    din: in std_logic_vector(47 downto 0); 
    trig: in std_logic; 
    we: in std_logic; 
    bram: out std_logic_vector(8 downto 0); 
    bram_x0: out std_logic_vector(63 downto 0); 
    bram_x1: out std_logic; 
    status: out std_logic_vector(31 downto 0)
  );
end ss_entity_d066921faf;

architecture structural of ss_entity_d066921faf is
  signal add_del_q_net_x1: std_logic_vector(8 downto 0);
  signal cast_dout_net_x1: std_logic_vector(63 downto 0);
  signal cast_gw_dout_net_x1: std_logic_vector(31 downto 0);
  signal ce_1_sg_x151: std_logic;
  signal clk_1_sg_x151: std_logic;
  signal concat_y_net_x1: std_logic_vector(31 downto 0);
  signal concatenate_y_net_x1: std_logic_vector(47 downto 0);
  signal constant1_op_net_x5: std_logic;
  signal convert_addr_dout_net_x1: std_logic_vector(8 downto 0);
  signal convert_din1_dout_net_x1: std_logic_vector(63 downto 0);
  signal convert_we_dout_net_x1: std_logic;
  signal darkquad29_adc_in_snp_cal1_ss_ctrl_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal dat_del_q_net_x1: std_logic_vector(63 downto 0);
  signal data_choice_y_net_x2: std_logic_vector(63 downto 0);
  signal delay6_q_net_x0: std_logic_vector(63 downto 0);
  signal edge_op_y_net_x4: std_logic;
  signal logical6_y_net_x0: std_logic;
  signal never_op_net_x0: std_logic;
  signal register1_q_net_x10: std_logic;
  signal register6_q_net_x1: std_logic;
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal ri_output_port_net: std_logic_vector(47 downto 0);
  signal slice2_y_net_x0: std_logic_vector(8 downto 0);
  signal we_choice_y_net_x2: std_logic;
  signal we_del_q_net_x0: std_logic;

begin
  ce_1_sg_x151 <= ce_1;
  clk_1_sg_x151 <= clk_1;
  darkquad29_adc_in_snp_cal1_ss_ctrl_user_data_out_net_x1 <= darkquad29_adc_in_snp_cal1_ss_ctrl_user_data_out;
  concatenate_y_net_x1 <= din;
  register1_q_net_x10 <= trig;
  constant1_op_net_x5 <= we;
  bram <= convert_addr_dout_net_x1;
  bram_x0 <= convert_din1_dout_net_x1;
  bram_x1 <= convert_we_dout_net_x1;
  status <= cast_gw_dout_net_x1;

  add_del: entity work.delay_09771002d6
    port map (
      ce => ce_1_sg_x151,
      clk => clk_1_sg_x151,
      clr => '0',
      d => slice2_y_net_x0,
      q => add_del_q_net_x1
    );

  add_gen_ab1c2d24d4: entity work.add_gen_entity_3bd86cf2a5
    port map (
      ce_1 => ce_1_sg_x151,
      clk_1 => clk_1_sg_x151,
      cont => never_op_net_x0,
      din => data_choice_y_net_x2,
      go => register6_q_net_x1,
      init => edge_op_y_net_x4,
      we => we_choice_y_net_x2,
      add => slice2_y_net_x0,
      dout => delay6_q_net_x0,
      status => concat_y_net_x1,
      we_o => logical6_y_net_x0
    );

  basic_ctrl_1c54a5bb3d: entity work.basic_ctrl_entity_877c836a9e
    port map (
      ce_1 => ce_1_sg_x151,
      clk_1 => clk_1_sg_x151,
      ctrl => reint1_output_port_net_x1,
      din => cast_dout_net_x1,
      trig => register1_q_net_x10,
      we => constant1_op_net_x5,
      dout => data_choice_y_net_x2,
      go => register6_q_net_x1,
      init => edge_op_y_net_x4,
      we_o => we_choice_y_net_x2
    );

  bram_c5576f1ecc: entity work.bram_entity_2be072e628
    port map (
      addr => add_del_q_net_x1,
      ce_1 => ce_1_sg_x151,
      clk_1 => clk_1_sg_x151,
      data_in => dat_del_q_net_x1,
      we => we_del_q_net_x0,
      convert_addr_x0 => convert_addr_dout_net_x1,
      convert_din1_x0 => convert_din1_dout_net_x1,
      convert_we_x0 => convert_we_dout_net_x1
    );

  cast: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 48,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 64,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x151,
      clk => clk_1_sg_x151,
      clr => '0',
      din => ri_output_port_net,
      en => "1",
      dout => cast_dout_net_x1
    );

  ctrl_104b01f516: entity work.ctrl_entity_104b01f516
    port map (
      darkquad29_adc_in_snp_cal1_ss_ctrl_user_data_out => darkquad29_adc_in_snp_cal1_ss_ctrl_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x1
    );

  dat_del: entity work.delay_e2d047c154
    port map (
      ce => ce_1_sg_x151,
      clk => clk_1_sg_x151,
      clr => '0',
      d => delay6_q_net_x0,
      q => dat_del_q_net_x1
    );

  never: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => never_op_net_x0
    );

  ri: entity work.reinterpret_b0553f3acc
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => concatenate_y_net_x1,
      output_port => ri_output_port_net
    );

  status_d41d86ad95: entity work.last_tx_data_entity_4b5ba71046
    port map (
      ce_1 => ce_1_sg_x151,
      clk_1 => clk_1_sg_x151,
      out_reg => concat_y_net_x1,
      cast_gw_x0 => cast_gw_dout_net_x1
    );

  we_del: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x151,
      clk => clk_1_sg_x151,
      clr => '0',
      d(0) => logical6_y_net_x0,
      q(0) => we_del_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/adc_in/snp_cal1"

entity snp_cal1_entity_169a1f2d92 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    darkquad29_adc_in_snp_cal1_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    in_data_i2: in std_logic_vector(11 downto 0); 
    in_data_i3: in std_logic_vector(11 downto 0); 
    in_data_q2: in std_logic_vector(11 downto 0); 
    in_data_q3: in std_logic_vector(11 downto 0); 
    trig: in std_logic; 
    we: in std_logic; 
    ss: out std_logic_vector(8 downto 0); 
    ss_x0: out std_logic_vector(63 downto 0); 
    ss_x1: out std_logic; 
    ss_x2: out std_logic_vector(31 downto 0)
  );
end snp_cal1_entity_169a1f2d92;

architecture structural of snp_cal1_entity_169a1f2d92 is
  signal assert_data_i2_dout_net_x0: std_logic_vector(11 downto 0);
  signal assert_data_i3_dout_net_x0: std_logic_vector(11 downto 0);
  signal assert_data_q2_dout_net_x0: std_logic_vector(11 downto 0);
  signal assert_data_q3_dout_net_x0: std_logic_vector(11 downto 0);
  signal cast_gw_dout_net_x2: std_logic_vector(31 downto 0);
  signal ce_1_sg_x152: std_logic;
  signal clk_1_sg_x152: std_logic;
  signal concatenate_y_net_x1: std_logic_vector(47 downto 0);
  signal constant1_op_net_x6: std_logic;
  signal convert_addr_dout_net_x2: std_logic_vector(8 downto 0);
  signal convert_din1_dout_net_x2: std_logic_vector(63 downto 0);
  signal convert_we_dout_net_x2: std_logic;
  signal darkquad29_adc_in_snp_cal1_ss_ctrl_user_data_out_net_x2: std_logic_vector(31 downto 0);
  signal register1_q_net_x11: std_logic;
  signal register1_q_net_x12: std_logic_vector(11 downto 0);
  signal register1_q_net_x4: std_logic_vector(11 downto 0);
  signal register1_q_net_x5: std_logic_vector(11 downto 0);
  signal register1_q_net_x6: std_logic_vector(11 downto 0);

begin
  ce_1_sg_x152 <= ce_1;
  clk_1_sg_x152 <= clk_1;
  darkquad29_adc_in_snp_cal1_ss_ctrl_user_data_out_net_x2 <= darkquad29_adc_in_snp_cal1_ss_ctrl_user_data_out;
  register1_q_net_x4 <= in_data_i2;
  register1_q_net_x6 <= in_data_i3;
  register1_q_net_x5 <= in_data_q2;
  register1_q_net_x12 <= in_data_q3;
  register1_q_net_x11 <= trig;
  constant1_op_net_x6 <= we;
  ss <= convert_addr_dout_net_x2;
  ss_x0 <= convert_din1_dout_net_x2;
  ss_x1 <= convert_we_dout_net_x2;
  ss_x2 <= cast_gw_dout_net_x2;

  assert_data_i2: entity work.xlpassthrough
    generic map (
      din_width => 12,
      dout_width => 12
    )
    port map (
      din => register1_q_net_x4,
      dout => assert_data_i2_dout_net_x0
    );

  assert_data_i3: entity work.xlpassthrough
    generic map (
      din_width => 12,
      dout_width => 12
    )
    port map (
      din => register1_q_net_x6,
      dout => assert_data_i3_dout_net_x0
    );

  assert_data_q2: entity work.xlpassthrough
    generic map (
      din_width => 12,
      dout_width => 12
    )
    port map (
      din => register1_q_net_x5,
      dout => assert_data_q2_dout_net_x0
    );

  assert_data_q3: entity work.xlpassthrough
    generic map (
      din_width => 12,
      dout_width => 12
    )
    port map (
      din => register1_q_net_x12,
      dout => assert_data_q3_dout_net_x0
    );

  buscreate_7fa8878163: entity work.buscreate_entity_03c8dd52e9
    port map (
      in1 => assert_data_i2_dout_net_x0,
      in2 => assert_data_q2_dout_net_x0,
      in3 => assert_data_i3_dout_net_x0,
      in4 => assert_data_q3_dout_net_x0,
      bus_out => concatenate_y_net_x1
    );

  ss_d066921faf: entity work.ss_entity_d066921faf
    port map (
      ce_1 => ce_1_sg_x152,
      clk_1 => clk_1_sg_x152,
      darkquad29_adc_in_snp_cal1_ss_ctrl_user_data_out => darkquad29_adc_in_snp_cal1_ss_ctrl_user_data_out_net_x2,
      din => concatenate_y_net_x1,
      trig => register1_q_net_x11,
      we => constant1_op_net_x6,
      bram => convert_addr_dout_net_x2,
      bram_x0 => convert_din1_dout_net_x2,
      bram_x1 => convert_we_dout_net_x2,
      status => cast_gw_dout_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/adc_in/snp_cal2/ss/ctrl"

entity ctrl_entity_6953b85de6 is
  port (
    darkquad29_adc_in_snp_cal2_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end ctrl_entity_6953b85de6;

architecture structural of ctrl_entity_6953b85de6 is
  signal darkquad29_adc_in_snp_cal2_ss_ctrl_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_adc_in_snp_cal2_ss_ctrl_user_data_out_net_x0 <= darkquad29_adc_in_snp_cal2_ss_ctrl_user_data_out;
  in_reg <= reint1_output_port_net_x1;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_adc_in_snp_cal2_ss_ctrl_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x1
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/adc_in/snp_cal2/ss"

entity ss_entity_cffeb93481 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    darkquad29_adc_in_snp_cal2_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    din: in std_logic_vector(47 downto 0); 
    trig: in std_logic; 
    we: in std_logic; 
    bram: out std_logic_vector(8 downto 0); 
    bram_x0: out std_logic_vector(63 downto 0); 
    bram_x1: out std_logic; 
    status: out std_logic_vector(31 downto 0)
  );
end ss_entity_cffeb93481;

architecture structural of ss_entity_cffeb93481 is
  signal add_del_q_net_x1: std_logic_vector(8 downto 0);
  signal cast_dout_net_x1: std_logic_vector(63 downto 0);
  signal cast_gw_dout_net_x1: std_logic_vector(31 downto 0);
  signal ce_1_sg_x161: std_logic;
  signal clk_1_sg_x161: std_logic;
  signal concat_y_net_x1: std_logic_vector(31 downto 0);
  signal concatenate_y_net_x1: std_logic_vector(47 downto 0);
  signal constant1_op_net_x8: std_logic;
  signal convert_addr_dout_net_x1: std_logic_vector(8 downto 0);
  signal convert_din1_dout_net_x1: std_logic_vector(63 downto 0);
  signal convert_we_dout_net_x1: std_logic;
  signal darkquad29_adc_in_snp_cal2_ss_ctrl_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal dat_del_q_net_x1: std_logic_vector(63 downto 0);
  signal data_choice_y_net_x2: std_logic_vector(63 downto 0);
  signal delay6_q_net_x0: std_logic_vector(63 downto 0);
  signal edge_op_y_net_x4: std_logic;
  signal logical6_y_net_x0: std_logic;
  signal never_op_net_x0: std_logic;
  signal register1_q_net_x13: std_logic;
  signal register6_q_net_x1: std_logic;
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal ri_output_port_net: std_logic_vector(47 downto 0);
  signal slice2_y_net_x0: std_logic_vector(8 downto 0);
  signal we_choice_y_net_x2: std_logic;
  signal we_del_q_net_x0: std_logic;

begin
  ce_1_sg_x161 <= ce_1;
  clk_1_sg_x161 <= clk_1;
  darkquad29_adc_in_snp_cal2_ss_ctrl_user_data_out_net_x1 <= darkquad29_adc_in_snp_cal2_ss_ctrl_user_data_out;
  concatenate_y_net_x1 <= din;
  register1_q_net_x13 <= trig;
  constant1_op_net_x8 <= we;
  bram <= convert_addr_dout_net_x1;
  bram_x0 <= convert_din1_dout_net_x1;
  bram_x1 <= convert_we_dout_net_x1;
  status <= cast_gw_dout_net_x1;

  add_del: entity work.delay_09771002d6
    port map (
      ce => ce_1_sg_x161,
      clk => clk_1_sg_x161,
      clr => '0',
      d => slice2_y_net_x0,
      q => add_del_q_net_x1
    );

  add_gen_1982f9af7f: entity work.add_gen_entity_3bd86cf2a5
    port map (
      ce_1 => ce_1_sg_x161,
      clk_1 => clk_1_sg_x161,
      cont => never_op_net_x0,
      din => data_choice_y_net_x2,
      go => register6_q_net_x1,
      init => edge_op_y_net_x4,
      we => we_choice_y_net_x2,
      add => slice2_y_net_x0,
      dout => delay6_q_net_x0,
      status => concat_y_net_x1,
      we_o => logical6_y_net_x0
    );

  basic_ctrl_9e3af5be64: entity work.basic_ctrl_entity_877c836a9e
    port map (
      ce_1 => ce_1_sg_x161,
      clk_1 => clk_1_sg_x161,
      ctrl => reint1_output_port_net_x1,
      din => cast_dout_net_x1,
      trig => register1_q_net_x13,
      we => constant1_op_net_x8,
      dout => data_choice_y_net_x2,
      go => register6_q_net_x1,
      init => edge_op_y_net_x4,
      we_o => we_choice_y_net_x2
    );

  bram_3e79c1c01e: entity work.bram_entity_2be072e628
    port map (
      addr => add_del_q_net_x1,
      ce_1 => ce_1_sg_x161,
      clk_1 => clk_1_sg_x161,
      data_in => dat_del_q_net_x1,
      we => we_del_q_net_x0,
      convert_addr_x0 => convert_addr_dout_net_x1,
      convert_din1_x0 => convert_din1_dout_net_x1,
      convert_we_x0 => convert_we_dout_net_x1
    );

  cast: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 48,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 64,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x161,
      clk => clk_1_sg_x161,
      clr => '0',
      din => ri_output_port_net,
      en => "1",
      dout => cast_dout_net_x1
    );

  ctrl_6953b85de6: entity work.ctrl_entity_6953b85de6
    port map (
      darkquad29_adc_in_snp_cal2_ss_ctrl_user_data_out => darkquad29_adc_in_snp_cal2_ss_ctrl_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x1
    );

  dat_del: entity work.delay_e2d047c154
    port map (
      ce => ce_1_sg_x161,
      clk => clk_1_sg_x161,
      clr => '0',
      d => delay6_q_net_x0,
      q => dat_del_q_net_x1
    );

  never: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => never_op_net_x0
    );

  ri: entity work.reinterpret_b0553f3acc
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => concatenate_y_net_x1,
      output_port => ri_output_port_net
    );

  status_f144fe816b: entity work.last_tx_data_entity_4b5ba71046
    port map (
      ce_1 => ce_1_sg_x161,
      clk_1 => clk_1_sg_x161,
      out_reg => concat_y_net_x1,
      cast_gw_x0 => cast_gw_dout_net_x1
    );

  we_del: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x161,
      clk => clk_1_sg_x161,
      clr => '0',
      d(0) => logical6_y_net_x0,
      q(0) => we_del_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/adc_in/snp_cal2"

entity snp_cal2_entity_58da2c4a2e is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    darkquad29_adc_in_snp_cal2_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    in_data_i4: in std_logic_vector(11 downto 0); 
    in_data_i5: in std_logic_vector(11 downto 0); 
    in_data_q4: in std_logic_vector(11 downto 0); 
    in_data_q5: in std_logic_vector(11 downto 0); 
    trig: in std_logic; 
    we: in std_logic; 
    ss: out std_logic_vector(8 downto 0); 
    ss_x0: out std_logic_vector(63 downto 0); 
    ss_x1: out std_logic; 
    ss_x2: out std_logic_vector(31 downto 0)
  );
end snp_cal2_entity_58da2c4a2e;

architecture structural of snp_cal2_entity_58da2c4a2e is
  signal assert_data_i4_dout_net_x0: std_logic_vector(11 downto 0);
  signal assert_data_i5_dout_net_x0: std_logic_vector(11 downto 0);
  signal assert_data_q4_dout_net_x0: std_logic_vector(11 downto 0);
  signal assert_data_q5_dout_net_x0: std_logic_vector(11 downto 0);
  signal cast_gw_dout_net_x2: std_logic_vector(31 downto 0);
  signal ce_1_sg_x162: std_logic;
  signal clk_1_sg_x162: std_logic;
  signal concatenate_y_net_x1: std_logic_vector(47 downto 0);
  signal constant1_op_net_x9: std_logic;
  signal convert_addr_dout_net_x2: std_logic_vector(8 downto 0);
  signal convert_din1_dout_net_x2: std_logic_vector(63 downto 0);
  signal convert_we_dout_net_x2: std_logic;
  signal darkquad29_adc_in_snp_cal2_ss_ctrl_user_data_out_net_x2: std_logic_vector(31 downto 0);
  signal register1_q_net_x14: std_logic;
  signal register1_q_net_x4: std_logic_vector(11 downto 0);
  signal register1_q_net_x5: std_logic_vector(11 downto 0);
  signal register1_q_net_x6: std_logic_vector(11 downto 0);
  signal register1_q_net_x7: std_logic_vector(11 downto 0);

begin
  ce_1_sg_x162 <= ce_1;
  clk_1_sg_x162 <= clk_1;
  darkquad29_adc_in_snp_cal2_ss_ctrl_user_data_out_net_x2 <= darkquad29_adc_in_snp_cal2_ss_ctrl_user_data_out;
  register1_q_net_x4 <= in_data_i4;
  register1_q_net_x6 <= in_data_i5;
  register1_q_net_x5 <= in_data_q4;
  register1_q_net_x7 <= in_data_q5;
  register1_q_net_x14 <= trig;
  constant1_op_net_x9 <= we;
  ss <= convert_addr_dout_net_x2;
  ss_x0 <= convert_din1_dout_net_x2;
  ss_x1 <= convert_we_dout_net_x2;
  ss_x2 <= cast_gw_dout_net_x2;

  assert_data_i4: entity work.xlpassthrough
    generic map (
      din_width => 12,
      dout_width => 12
    )
    port map (
      din => register1_q_net_x4,
      dout => assert_data_i4_dout_net_x0
    );

  assert_data_i5: entity work.xlpassthrough
    generic map (
      din_width => 12,
      dout_width => 12
    )
    port map (
      din => register1_q_net_x6,
      dout => assert_data_i5_dout_net_x0
    );

  assert_data_q4: entity work.xlpassthrough
    generic map (
      din_width => 12,
      dout_width => 12
    )
    port map (
      din => register1_q_net_x5,
      dout => assert_data_q4_dout_net_x0
    );

  assert_data_q5: entity work.xlpassthrough
    generic map (
      din_width => 12,
      dout_width => 12
    )
    port map (
      din => register1_q_net_x7,
      dout => assert_data_q5_dout_net_x0
    );

  buscreate_1af7032910: entity work.buscreate_entity_03c8dd52e9
    port map (
      in1 => assert_data_i4_dout_net_x0,
      in2 => assert_data_q4_dout_net_x0,
      in3 => assert_data_i5_dout_net_x0,
      in4 => assert_data_q5_dout_net_x0,
      bus_out => concatenate_y_net_x1
    );

  ss_cffeb93481: entity work.ss_entity_cffeb93481
    port map (
      ce_1 => ce_1_sg_x162,
      clk_1 => clk_1_sg_x162,
      darkquad29_adc_in_snp_cal2_ss_ctrl_user_data_out => darkquad29_adc_in_snp_cal2_ss_ctrl_user_data_out_net_x2,
      din => concatenate_y_net_x1,
      trig => register1_q_net_x14,
      we => constant1_op_net_x9,
      bram => convert_addr_dout_net_x2,
      bram_x0 => convert_din1_dout_net_x2,
      bram_x1 => convert_we_dout_net_x2,
      status => cast_gw_dout_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/adc_in/snp_cal3/ss/ctrl"

entity ctrl_entity_bef622365c is
  port (
    darkquad29_adc_in_snp_cal3_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end ctrl_entity_bef622365c;

architecture structural of ctrl_entity_bef622365c is
  signal darkquad29_adc_in_snp_cal3_ss_ctrl_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_adc_in_snp_cal3_ss_ctrl_user_data_out_net_x0 <= darkquad29_adc_in_snp_cal3_ss_ctrl_user_data_out;
  in_reg <= reint1_output_port_net_x1;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_adc_in_snp_cal3_ss_ctrl_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x1
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/adc_in/snp_cal3/ss"

entity ss_entity_51d7b800a8 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    darkquad29_adc_in_snp_cal3_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    din: in std_logic_vector(47 downto 0); 
    trig: in std_logic; 
    we: in std_logic; 
    bram: out std_logic_vector(8 downto 0); 
    bram_x0: out std_logic_vector(63 downto 0); 
    bram_x1: out std_logic; 
    status: out std_logic_vector(31 downto 0)
  );
end ss_entity_51d7b800a8;

architecture structural of ss_entity_51d7b800a8 is
  signal add_del_q_net_x1: std_logic_vector(8 downto 0);
  signal cast_dout_net_x1: std_logic_vector(63 downto 0);
  signal cast_gw_dout_net_x1: std_logic_vector(31 downto 0);
  signal ce_1_sg_x171: std_logic;
  signal clk_1_sg_x171: std_logic;
  signal concat_y_net_x1: std_logic_vector(31 downto 0);
  signal concatenate_y_net_x1: std_logic_vector(47 downto 0);
  signal constant1_op_net_x11: std_logic;
  signal convert_addr_dout_net_x1: std_logic_vector(8 downto 0);
  signal convert_din1_dout_net_x1: std_logic_vector(63 downto 0);
  signal convert_we_dout_net_x1: std_logic;
  signal darkquad29_adc_in_snp_cal3_ss_ctrl_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal dat_del_q_net_x1: std_logic_vector(63 downto 0);
  signal data_choice_y_net_x2: std_logic_vector(63 downto 0);
  signal delay6_q_net_x0: std_logic_vector(63 downto 0);
  signal edge_op_y_net_x4: std_logic;
  signal logical6_y_net_x0: std_logic;
  signal never_op_net_x0: std_logic;
  signal register1_q_net_x16: std_logic;
  signal register6_q_net_x1: std_logic;
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal ri_output_port_net: std_logic_vector(47 downto 0);
  signal slice2_y_net_x0: std_logic_vector(8 downto 0);
  signal we_choice_y_net_x2: std_logic;
  signal we_del_q_net_x0: std_logic;

begin
  ce_1_sg_x171 <= ce_1;
  clk_1_sg_x171 <= clk_1;
  darkquad29_adc_in_snp_cal3_ss_ctrl_user_data_out_net_x1 <= darkquad29_adc_in_snp_cal3_ss_ctrl_user_data_out;
  concatenate_y_net_x1 <= din;
  register1_q_net_x16 <= trig;
  constant1_op_net_x11 <= we;
  bram <= convert_addr_dout_net_x1;
  bram_x0 <= convert_din1_dout_net_x1;
  bram_x1 <= convert_we_dout_net_x1;
  status <= cast_gw_dout_net_x1;

  add_del: entity work.delay_09771002d6
    port map (
      ce => ce_1_sg_x171,
      clk => clk_1_sg_x171,
      clr => '0',
      d => slice2_y_net_x0,
      q => add_del_q_net_x1
    );

  add_gen_e6d8ef94c9: entity work.add_gen_entity_3bd86cf2a5
    port map (
      ce_1 => ce_1_sg_x171,
      clk_1 => clk_1_sg_x171,
      cont => never_op_net_x0,
      din => data_choice_y_net_x2,
      go => register6_q_net_x1,
      init => edge_op_y_net_x4,
      we => we_choice_y_net_x2,
      add => slice2_y_net_x0,
      dout => delay6_q_net_x0,
      status => concat_y_net_x1,
      we_o => logical6_y_net_x0
    );

  basic_ctrl_1030f342eb: entity work.basic_ctrl_entity_877c836a9e
    port map (
      ce_1 => ce_1_sg_x171,
      clk_1 => clk_1_sg_x171,
      ctrl => reint1_output_port_net_x1,
      din => cast_dout_net_x1,
      trig => register1_q_net_x16,
      we => constant1_op_net_x11,
      dout => data_choice_y_net_x2,
      go => register6_q_net_x1,
      init => edge_op_y_net_x4,
      we_o => we_choice_y_net_x2
    );

  bram_8d515ccc70: entity work.bram_entity_2be072e628
    port map (
      addr => add_del_q_net_x1,
      ce_1 => ce_1_sg_x171,
      clk_1 => clk_1_sg_x171,
      data_in => dat_del_q_net_x1,
      we => we_del_q_net_x0,
      convert_addr_x0 => convert_addr_dout_net_x1,
      convert_din1_x0 => convert_din1_dout_net_x1,
      convert_we_x0 => convert_we_dout_net_x1
    );

  cast: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 48,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 64,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x171,
      clk => clk_1_sg_x171,
      clr => '0',
      din => ri_output_port_net,
      en => "1",
      dout => cast_dout_net_x1
    );

  ctrl_bef622365c: entity work.ctrl_entity_bef622365c
    port map (
      darkquad29_adc_in_snp_cal3_ss_ctrl_user_data_out => darkquad29_adc_in_snp_cal3_ss_ctrl_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x1
    );

  dat_del: entity work.delay_e2d047c154
    port map (
      ce => ce_1_sg_x171,
      clk => clk_1_sg_x171,
      clr => '0',
      d => delay6_q_net_x0,
      q => dat_del_q_net_x1
    );

  never: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => never_op_net_x0
    );

  ri: entity work.reinterpret_b0553f3acc
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => concatenate_y_net_x1,
      output_port => ri_output_port_net
    );

  status_7983ceb4f2: entity work.last_tx_data_entity_4b5ba71046
    port map (
      ce_1 => ce_1_sg_x171,
      clk_1 => clk_1_sg_x171,
      out_reg => concat_y_net_x1,
      cast_gw_x0 => cast_gw_dout_net_x1
    );

  we_del: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x171,
      clk => clk_1_sg_x171,
      clr => '0',
      d(0) => logical6_y_net_x0,
      q(0) => we_del_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/adc_in/snp_cal3"

entity snp_cal3_entity_2b6fda8a9c is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    darkquad29_adc_in_snp_cal3_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    in_data_i6: in std_logic_vector(11 downto 0); 
    in_data_i7: in std_logic_vector(11 downto 0); 
    in_data_q6: in std_logic_vector(11 downto 0); 
    in_data_q7: in std_logic_vector(11 downto 0); 
    trig: in std_logic; 
    we: in std_logic; 
    ss: out std_logic_vector(8 downto 0); 
    ss_x0: out std_logic_vector(63 downto 0); 
    ss_x1: out std_logic; 
    ss_x2: out std_logic_vector(31 downto 0)
  );
end snp_cal3_entity_2b6fda8a9c;

architecture structural of snp_cal3_entity_2b6fda8a9c is
  signal assert_data_i6_dout_net_x0: std_logic_vector(11 downto 0);
  signal assert_data_i7_dout_net_x0: std_logic_vector(11 downto 0);
  signal assert_data_q6_dout_net_x0: std_logic_vector(11 downto 0);
  signal assert_data_q7_dout_net_x0: std_logic_vector(11 downto 0);
  signal cast_gw_dout_net_x2: std_logic_vector(31 downto 0);
  signal ce_1_sg_x172: std_logic;
  signal clk_1_sg_x172: std_logic;
  signal concatenate_y_net_x1: std_logic_vector(47 downto 0);
  signal constant1_op_net_x12: std_logic;
  signal convert_addr_dout_net_x2: std_logic_vector(8 downto 0);
  signal convert_din1_dout_net_x2: std_logic_vector(63 downto 0);
  signal convert_we_dout_net_x2: std_logic;
  signal darkquad29_adc_in_snp_cal3_ss_ctrl_user_data_out_net_x2: std_logic_vector(31 downto 0);
  signal register1_q_net_x17: std_logic_vector(11 downto 0);
  signal register1_q_net_x18: std_logic_vector(11 downto 0);
  signal register1_q_net_x19: std_logic_vector(11 downto 0);
  signal register1_q_net_x20: std_logic;
  signal register1_q_net_x4: std_logic_vector(11 downto 0);

begin
  ce_1_sg_x172 <= ce_1;
  clk_1_sg_x172 <= clk_1;
  darkquad29_adc_in_snp_cal3_ss_ctrl_user_data_out_net_x2 <= darkquad29_adc_in_snp_cal3_ss_ctrl_user_data_out;
  register1_q_net_x4 <= in_data_i6;
  register1_q_net_x18 <= in_data_i7;
  register1_q_net_x17 <= in_data_q6;
  register1_q_net_x19 <= in_data_q7;
  register1_q_net_x20 <= trig;
  constant1_op_net_x12 <= we;
  ss <= convert_addr_dout_net_x2;
  ss_x0 <= convert_din1_dout_net_x2;
  ss_x1 <= convert_we_dout_net_x2;
  ss_x2 <= cast_gw_dout_net_x2;

  assert_data_i6: entity work.xlpassthrough
    generic map (
      din_width => 12,
      dout_width => 12
    )
    port map (
      din => register1_q_net_x4,
      dout => assert_data_i6_dout_net_x0
    );

  assert_data_i7: entity work.xlpassthrough
    generic map (
      din_width => 12,
      dout_width => 12
    )
    port map (
      din => register1_q_net_x18,
      dout => assert_data_i7_dout_net_x0
    );

  assert_data_q6: entity work.xlpassthrough
    generic map (
      din_width => 12,
      dout_width => 12
    )
    port map (
      din => register1_q_net_x17,
      dout => assert_data_q6_dout_net_x0
    );

  assert_data_q7: entity work.xlpassthrough
    generic map (
      din_width => 12,
      dout_width => 12
    )
    port map (
      din => register1_q_net_x19,
      dout => assert_data_q7_dout_net_x0
    );

  buscreate_22e6caaa54: entity work.buscreate_entity_03c8dd52e9
    port map (
      in1 => assert_data_i6_dout_net_x0,
      in2 => assert_data_q6_dout_net_x0,
      in3 => assert_data_i7_dout_net_x0,
      in4 => assert_data_q7_dout_net_x0,
      bus_out => concatenate_y_net_x1
    );

  ss_51d7b800a8: entity work.ss_entity_51d7b800a8
    port map (
      ce_1 => ce_1_sg_x172,
      clk_1 => clk_1_sg_x172,
      darkquad29_adc_in_snp_cal3_ss_ctrl_user_data_out => darkquad29_adc_in_snp_cal3_ss_ctrl_user_data_out_net_x2,
      din => concatenate_y_net_x1,
      trig => register1_q_net_x20,
      we => constant1_op_net_x12,
      bram => convert_addr_dout_net_x2,
      bram_x0 => convert_din1_dout_net_x2,
      bram_x1 => convert_we_dout_net_x2,
      status => cast_gw_dout_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/adc_in/trig"

entity trig_entity_67979a96da is
  port (
    darkquad29_adc_in_trig_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end trig_entity_67979a96da;

architecture structural of trig_entity_67979a96da is
  signal darkquad29_adc_in_trig_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_adc_in_trig_user_data_out_net_x0 <= darkquad29_adc_in_trig_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_adc_in_trig_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/adc_in"

entity adc_in_entity_b5ae14177c is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    darkquad29_adc_in_adcdac_2g_user_data_i0: in std_logic_vector(11 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_data_i1: in std_logic_vector(11 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_data_i2: in std_logic_vector(11 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_data_i3: in std_logic_vector(11 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_data_i4: in std_logic_vector(11 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_data_i5: in std_logic_vector(11 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_data_i6: in std_logic_vector(11 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_data_i7: in std_logic_vector(11 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_data_q0: in std_logic_vector(11 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_data_q1: in std_logic_vector(11 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_data_q2: in std_logic_vector(11 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_data_q3: in std_logic_vector(11 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_data_q4: in std_logic_vector(11 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_data_q5: in std_logic_vector(11 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_data_q6: in std_logic_vector(11 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_data_q7: in std_logic_vector(11 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_mmcm_locked: in std_logic; 
    darkquad29_adc_in_adcdac_2g_user_sync: in std_logic; 
    darkquad29_adc_in_adcdac_2g_user_valid: in std_logic; 
    darkquad29_adc_in_dly_val_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_adc_in_i_scale_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_adc_in_inc_phs_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_adc_in_load_dly_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_adc_in_pos_phs_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_adc_in_snp_cal0_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_adc_in_snp_cal1_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_adc_in_snp_cal2_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_adc_in_snp_cal3_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_adc_in_trig_user_data_out: in std_logic_vector(31 downto 0); 
    run: in std_logic; 
    sync_in: in std_logic; 
    adcdac_2g: out std_logic; 
    adcdac_2g_x0: out std_logic_vector(4 downto 0); 
    adcdac_2g_x1: out std_logic_vector(5 downto 0); 
    adcdac_2g_x2: out std_logic; 
    adcdac_2g_x3: out std_logic; 
    dout: out std_logic_vector(191 downto 0); 
    locked: out std_logic_vector(31 downto 0); 
    n_miss_pps: out std_logic_vector(31 downto 0); 
    pps_out: out std_logic; 
    raw_pps: out std_logic_vector(31 downto 0); 
    snp_cal0: out std_logic_vector(8 downto 0); 
    snp_cal0_x0: out std_logic_vector(63 downto 0); 
    snp_cal0_x1: out std_logic; 
    snp_cal0_x2: out std_logic_vector(31 downto 0); 
    snp_cal1: out std_logic_vector(8 downto 0); 
    snp_cal1_x0: out std_logic_vector(63 downto 0); 
    snp_cal1_x1: out std_logic; 
    snp_cal1_x2: out std_logic_vector(31 downto 0); 
    snp_cal2: out std_logic_vector(8 downto 0); 
    snp_cal2_x0: out std_logic_vector(63 downto 0); 
    snp_cal2_x1: out std_logic; 
    snp_cal2_x2: out std_logic_vector(31 downto 0); 
    snp_cal3: out std_logic_vector(8 downto 0); 
    snp_cal3_x0: out std_logic_vector(63 downto 0); 
    snp_cal3_x1: out std_logic; 
    snp_cal3_x2: out std_logic_vector(31 downto 0); 
    ts0: out std_logic_vector(31 downto 0); 
    ts1: out std_logic_vector(31 downto 0); 
    ts2: out std_logic_vector(31 downto 0); 
    ts3: out std_logic_vector(31 downto 0); 
    valid: out std_logic_vector(31 downto 0)
  );
end adc_in_entity_b5ae14177c;

architecture structural of adc_in_entity_b5ae14177c is
  signal cast_gw_dout_net_x12: std_logic_vector(31 downto 0);
  signal cast_gw_dout_net_x13: std_logic_vector(31 downto 0);
  signal cast_gw_dout_net_x14: std_logic_vector(31 downto 0);
  signal cast_gw_dout_net_x15: std_logic_vector(31 downto 0);
  signal cast_gw_dout_net_x16: std_logic_vector(31 downto 0);
  signal cast_gw_dout_net_x17: std_logic_vector(31 downto 0);
  signal cast_gw_dout_net_x18: std_logic_vector(31 downto 0);
  signal cast_gw_dout_net_x19: std_logic_vector(31 downto 0);
  signal cast_gw_dout_net_x20: std_logic_vector(31 downto 0);
  signal cast_gw_dout_net_x21: std_logic_vector(31 downto 0);
  signal cast_gw_dout_net_x22: std_logic_vector(31 downto 0);
  signal cast_gw_dout_net_x23: std_logic_vector(31 downto 0);
  signal ce_1_sg_x178: std_logic;
  signal clk_1_sg_x178: std_logic;
  signal concat_y_net_x1: std_logic_vector(23 downto 0);
  signal concat_y_net_x2: std_logic_vector(23 downto 0);
  signal concat_y_net_x3: std_logic_vector(23 downto 0);
  signal concat_y_net_x4: std_logic_vector(23 downto 0);
  signal concat_y_net_x5: std_logic_vector(23 downto 0);
  signal concat_y_net_x6: std_logic_vector(23 downto 0);
  signal concat_y_net_x7: std_logic_vector(23 downto 0);
  signal concat_y_net_x8: std_logic_vector(23 downto 0);
  signal concatenate_y_net_x1: std_logic_vector(191 downto 0);
  signal constant1_op_net_x12: std_logic;
  signal constant2_op_net: std_logic_vector(27 downto 0);
  signal constant3_op_net: std_logic_vector(27 downto 0);
  signal convert1_dout_net_x0: std_logic_vector(31 downto 0);
  signal convert1_dout_net_x2: std_logic;
  signal convert2_dout_net_x0: std_logic_vector(31 downto 0);
  signal convert2_dout_net_x2: std_logic_vector(4 downto 0);
  signal convert3_dout_net_x1: std_logic_vector(5 downto 0);
  signal convert4_dout_net_x1: std_logic;
  signal convert5_dout_net_x1: std_logic;
  signal convert_addr_dout_net_x6: std_logic_vector(8 downto 0);
  signal convert_addr_dout_net_x7: std_logic_vector(8 downto 0);
  signal convert_addr_dout_net_x8: std_logic_vector(8 downto 0);
  signal convert_addr_dout_net_x9: std_logic_vector(8 downto 0);
  signal convert_din1_dout_net_x6: std_logic_vector(63 downto 0);
  signal convert_din1_dout_net_x7: std_logic_vector(63 downto 0);
  signal convert_din1_dout_net_x8: std_logic_vector(63 downto 0);
  signal convert_din1_dout_net_x9: std_logic_vector(63 downto 0);
  signal convert_we_dout_net_x6: std_logic;
  signal convert_we_dout_net_x7: std_logic;
  signal convert_we_dout_net_x8: std_logic;
  signal convert_we_dout_net_x9: std_logic;
  signal counter3_op_net_x0: std_logic_vector(14 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_data_i0_net_x0: std_logic_vector(11 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_data_i1_net_x0: std_logic_vector(11 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_data_i2_net_x0: std_logic_vector(11 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_data_i3_net_x0: std_logic_vector(11 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_data_i4_net_x0: std_logic_vector(11 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_data_i5_net_x0: std_logic_vector(11 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_data_i6_net_x0: std_logic_vector(11 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_data_i7_net_x0: std_logic_vector(11 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_data_q0_net_x0: std_logic_vector(11 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_data_q1_net_x0: std_logic_vector(11 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_data_q2_net_x0: std_logic_vector(11 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_data_q3_net_x0: std_logic_vector(11 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_data_q4_net_x0: std_logic_vector(11 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_data_q5_net_x0: std_logic_vector(11 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_data_q6_net_x0: std_logic_vector(11 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_data_q7_net_x0: std_logic_vector(11 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_mmcm_locked_net_x1: std_logic;
  signal darkquad29_adc_in_adcdac_2g_user_sync_net_x2: std_logic;
  signal darkquad29_adc_in_adcdac_2g_user_valid_net_x1: std_logic;
  signal darkquad29_adc_in_dly_val_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal darkquad29_adc_in_i_scale_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal darkquad29_adc_in_inc_phs_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal darkquad29_adc_in_load_dly_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal darkquad29_adc_in_pos_phs_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal darkquad29_adc_in_snp_cal0_ss_ctrl_user_data_out_net_x3: std_logic_vector(31 downto 0);
  signal darkquad29_adc_in_snp_cal1_ss_ctrl_user_data_out_net_x3: std_logic_vector(31 downto 0);
  signal darkquad29_adc_in_snp_cal2_ss_ctrl_user_data_out_net_x3: std_logic_vector(31 downto 0);
  signal darkquad29_adc_in_snp_cal3_ss_ctrl_user_data_out_net_x3: std_logic_vector(31 downto 0);
  signal darkquad29_adc_in_trig_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal delay1_q_net: std_logic;
  signal delay2_q_net: std_logic;
  signal delay3_q_net: std_logic;
  signal delay6_q_net: std_logic;
  signal edge_op_y_net_x0: std_logic;
  signal edge_op_y_net_x1: std_logic;
  signal edge_op_y_net_x3: std_logic;
  signal logical1_y_net_x0: std_logic;
  signal logical_y_net_x0: std_logic;
  signal mult1_p_net_x1: std_logic_vector(11 downto 0);
  signal mult2_p_net_x1: std_logic_vector(11 downto 0);
  signal mult3_p_net_x1: std_logic_vector(11 downto 0);
  signal mult4_p_net_x1: std_logic_vector(11 downto 0);
  signal mult5_p_net_x1: std_logic_vector(11 downto 0);
  signal mult6_p_net_x1: std_logic_vector(11 downto 0);
  signal mult7_p_net_x1: std_logic_vector(11 downto 0);
  signal mult_p_net_x1: std_logic_vector(11 downto 0);
  signal pps_deadtime_ctr_op_net: std_logic_vector(27 downto 0);
  signal pps_wait_ctr1_op_net: std_logic_vector(27 downto 0);
  signal pps_wait_ctr2_op_net: std_logic_vector(31 downto 0);
  signal register0_q_net_x0: std_logic_vector(31 downto 0);
  signal register0_q_net_x1: std_logic_vector(14 downto 0);
  signal register0_q_net_x2: std_logic;
  signal register0_q_net_x3: std_logic;
  signal register0_q_net_x4: std_logic;
  signal register1_q_net_x0: std_logic_vector(31 downto 0);
  signal register1_q_net_x1: std_logic;
  signal register1_q_net_x10: std_logic_vector(11 downto 0);
  signal register1_q_net_x11: std_logic;
  signal register1_q_net_x12: std_logic_vector(4 downto 0);
  signal register1_q_net_x13: std_logic;
  signal register1_q_net_x14: std_logic_vector(5 downto 0);
  signal register1_q_net_x15: std_logic;
  signal register1_q_net_x16: std_logic;
  signal register1_q_net_x17: std_logic_vector(11 downto 0);
  signal register1_q_net_x18: std_logic_vector(11 downto 0);
  signal register1_q_net_x19: std_logic_vector(11 downto 0);
  signal register1_q_net_x20: std_logic_vector(11 downto 0);
  signal register1_q_net_x21: std_logic_vector(11 downto 0);
  signal register1_q_net_x22: std_logic;
  signal register1_q_net_x23: std_logic_vector(11 downto 0);
  signal register1_q_net_x24: std_logic_vector(11 downto 0);
  signal register1_q_net_x25: std_logic_vector(23 downto 0);
  signal register1_q_net_x26: std_logic_vector(11 downto 0);
  signal register1_q_net_x27: std_logic_vector(11 downto 0);
  signal register1_q_net_x28: std_logic_vector(11 downto 0);
  signal register1_q_net_x29: std_logic_vector(23 downto 0);
  signal register1_q_net_x30: std_logic_vector(31 downto 0);
  signal register1_q_net_x31: std_logic_vector(23 downto 0);
  signal register1_q_net_x32: std_logic_vector(23 downto 0);
  signal register1_q_net_x33: std_logic_vector(23 downto 0);
  signal register1_q_net_x34: std_logic_vector(23 downto 0);
  signal register1_q_net_x35: std_logic_vector(23 downto 0);
  signal register1_q_net_x36: std_logic;
  signal register1_q_net_x4: std_logic_vector(11 downto 0);
  signal register1_q_net_x5: std_logic_vector(11 downto 0);
  signal register1_q_net_x6: std_logic_vector(11 downto 0);
  signal register1_q_net_x7: std_logic_vector(11 downto 0);
  signal register1_q_net_x8: std_logic_vector(23 downto 0);
  signal register1_q_net_x9: std_logic_vector(11 downto 0);
  signal register2_q_net_x0: std_logic_vector(31 downto 0);
  signal register2_q_net_x2: std_logic_vector(11 downto 0);
  signal register2_q_net_x3: std_logic_vector(11 downto 0);
  signal register2_q_net_x4: std_logic_vector(11 downto 0);
  signal register2_q_net_x5: std_logic_vector(11 downto 0);
  signal register2_q_net_x6: std_logic_vector(11 downto 0);
  signal register2_q_net_x7: std_logic_vector(11 downto 0);
  signal register2_q_net_x8: std_logic_vector(11 downto 0);
  signal register2_q_net_x9: std_logic_vector(11 downto 0);
  signal register3_q_net_x0: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x2: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x3: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x4: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x5: std_logic_vector(31 downto 0);
  signal reinterpret16_output_port_net: std_logic_vector(7 downto 0);
  signal reinterpret17_output_port_net: std_logic_vector(11 downto 0);
  signal reinterpret18_output_port_net_x0: std_logic_vector(11 downto 0);
  signal reinterpret19_output_port_net: std_logic_vector(11 downto 0);
  signal reinterpret20_output_port_net_x0: std_logic_vector(11 downto 0);
  signal reinterpret21_output_port_net: std_logic_vector(11 downto 0);
  signal reinterpret22_output_port_net_x0: std_logic_vector(11 downto 0);
  signal reinterpret23_output_port_net: std_logic_vector(11 downto 0);
  signal reinterpret24_output_port_net_x0: std_logic_vector(11 downto 0);
  signal reinterpret25_output_port_net: std_logic_vector(11 downto 0);
  signal reinterpret26_output_port_net_x0: std_logic_vector(11 downto 0);
  signal reinterpret27_output_port_net: std_logic_vector(11 downto 0);
  signal reinterpret28_output_port_net_x0: std_logic_vector(11 downto 0);
  signal reinterpret29_output_port_net: std_logic_vector(11 downto 0);
  signal reinterpret30_output_port_net_x0: std_logic_vector(11 downto 0);
  signal reinterpret31_output_port_net: std_logic_vector(11 downto 0);
  signal reinterpret32_output_port_net_x0: std_logic_vector(11 downto 0);
  signal relational2_op_net_x0: std_logic;
  signal relational_op_net: std_logic;
  signal slice1_y_net_x0: std_logic;
  signal slice2_y_net_x0: std_logic;
  signal slice3_y_net: std_logic_vector(7 downto 0);
  signal slice4_y_net_x0: std_logic_vector(4 downto 0);
  signal slice5_y_net_x0: std_logic_vector(5 downto 0);
  signal slice7_y_net_x0: std_logic;
  signal slice_y_net_x0: std_logic;

begin
  ce_1_sg_x178 <= ce_1;
  clk_1_sg_x178 <= clk_1;
  darkquad29_adc_in_adcdac_2g_user_data_i0_net_x0 <= darkquad29_adc_in_adcdac_2g_user_data_i0;
  darkquad29_adc_in_adcdac_2g_user_data_i1_net_x0 <= darkquad29_adc_in_adcdac_2g_user_data_i1;
  darkquad29_adc_in_adcdac_2g_user_data_i2_net_x0 <= darkquad29_adc_in_adcdac_2g_user_data_i2;
  darkquad29_adc_in_adcdac_2g_user_data_i3_net_x0 <= darkquad29_adc_in_adcdac_2g_user_data_i3;
  darkquad29_adc_in_adcdac_2g_user_data_i4_net_x0 <= darkquad29_adc_in_adcdac_2g_user_data_i4;
  darkquad29_adc_in_adcdac_2g_user_data_i5_net_x0 <= darkquad29_adc_in_adcdac_2g_user_data_i5;
  darkquad29_adc_in_adcdac_2g_user_data_i6_net_x0 <= darkquad29_adc_in_adcdac_2g_user_data_i6;
  darkquad29_adc_in_adcdac_2g_user_data_i7_net_x0 <= darkquad29_adc_in_adcdac_2g_user_data_i7;
  darkquad29_adc_in_adcdac_2g_user_data_q0_net_x0 <= darkquad29_adc_in_adcdac_2g_user_data_q0;
  darkquad29_adc_in_adcdac_2g_user_data_q1_net_x0 <= darkquad29_adc_in_adcdac_2g_user_data_q1;
  darkquad29_adc_in_adcdac_2g_user_data_q2_net_x0 <= darkquad29_adc_in_adcdac_2g_user_data_q2;
  darkquad29_adc_in_adcdac_2g_user_data_q3_net_x0 <= darkquad29_adc_in_adcdac_2g_user_data_q3;
  darkquad29_adc_in_adcdac_2g_user_data_q4_net_x0 <= darkquad29_adc_in_adcdac_2g_user_data_q4;
  darkquad29_adc_in_adcdac_2g_user_data_q5_net_x0 <= darkquad29_adc_in_adcdac_2g_user_data_q5;
  darkquad29_adc_in_adcdac_2g_user_data_q6_net_x0 <= darkquad29_adc_in_adcdac_2g_user_data_q6;
  darkquad29_adc_in_adcdac_2g_user_data_q7_net_x0 <= darkquad29_adc_in_adcdac_2g_user_data_q7;
  darkquad29_adc_in_adcdac_2g_user_mmcm_locked_net_x1 <= darkquad29_adc_in_adcdac_2g_user_mmcm_locked;
  darkquad29_adc_in_adcdac_2g_user_sync_net_x2 <= darkquad29_adc_in_adcdac_2g_user_sync;
  darkquad29_adc_in_adcdac_2g_user_valid_net_x1 <= darkquad29_adc_in_adcdac_2g_user_valid;
  darkquad29_adc_in_dly_val_user_data_out_net_x1 <= darkquad29_adc_in_dly_val_user_data_out;
  darkquad29_adc_in_i_scale_user_data_out_net_x1 <= darkquad29_adc_in_i_scale_user_data_out;
  darkquad29_adc_in_inc_phs_user_data_out_net_x1 <= darkquad29_adc_in_inc_phs_user_data_out;
  darkquad29_adc_in_load_dly_user_data_out_net_x1 <= darkquad29_adc_in_load_dly_user_data_out;
  darkquad29_adc_in_pos_phs_user_data_out_net_x1 <= darkquad29_adc_in_pos_phs_user_data_out;
  darkquad29_adc_in_snp_cal0_ss_ctrl_user_data_out_net_x3 <= darkquad29_adc_in_snp_cal0_ss_ctrl_user_data_out;
  darkquad29_adc_in_snp_cal1_ss_ctrl_user_data_out_net_x3 <= darkquad29_adc_in_snp_cal1_ss_ctrl_user_data_out;
  darkquad29_adc_in_snp_cal2_ss_ctrl_user_data_out_net_x3 <= darkquad29_adc_in_snp_cal2_ss_ctrl_user_data_out;
  darkquad29_adc_in_snp_cal3_ss_ctrl_user_data_out_net_x3 <= darkquad29_adc_in_snp_cal3_ss_ctrl_user_data_out;
  darkquad29_adc_in_trig_user_data_out_net_x1 <= darkquad29_adc_in_trig_user_data_out;
  register1_q_net_x36 <= run;
  edge_op_y_net_x3 <= sync_in;
  adcdac_2g <= convert1_dout_net_x2;
  adcdac_2g_x0 <= convert2_dout_net_x2;
  adcdac_2g_x1 <= convert3_dout_net_x1;
  adcdac_2g_x2 <= convert4_dout_net_x1;
  adcdac_2g_x3 <= convert5_dout_net_x1;
  dout <= concatenate_y_net_x1;
  locked <= cast_gw_dout_net_x12;
  n_miss_pps <= cast_gw_dout_net_x13;
  pps_out <= logical1_y_net_x0;
  raw_pps <= cast_gw_dout_net_x14;
  snp_cal0 <= convert_addr_dout_net_x6;
  snp_cal0_x0 <= convert_din1_dout_net_x6;
  snp_cal0_x1 <= convert_we_dout_net_x6;
  snp_cal0_x2 <= cast_gw_dout_net_x15;
  snp_cal1 <= convert_addr_dout_net_x7;
  snp_cal1_x0 <= convert_din1_dout_net_x7;
  snp_cal1_x1 <= convert_we_dout_net_x7;
  snp_cal1_x2 <= cast_gw_dout_net_x16;
  snp_cal2 <= convert_addr_dout_net_x8;
  snp_cal2_x0 <= convert_din1_dout_net_x8;
  snp_cal2_x1 <= convert_we_dout_net_x8;
  snp_cal2_x2 <= cast_gw_dout_net_x17;
  snp_cal3 <= convert_addr_dout_net_x9;
  snp_cal3_x0 <= convert_din1_dout_net_x9;
  snp_cal3_x1 <= convert_we_dout_net_x9;
  snp_cal3_x2 <= cast_gw_dout_net_x18;
  ts0 <= cast_gw_dout_net_x19;
  ts1 <= cast_gw_dout_net_x20;
  ts2 <= cast_gw_dout_net_x21;
  ts3 <= cast_gw_dout_net_x22;
  valid <= cast_gw_dout_net_x23;

  adcdac_2g_3e40ca0595: entity work.adcdac_2g_entity_3e40ca0595
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      dly_val => register1_q_net_x12,
      inc_mmcm_phs => register1_q_net_x16,
      load_dly0 => register1_q_net_x14,
      pos_mmcm_phs => register1_q_net_x15,
      ready => register1_q_net_x11,
      convert1_x0 => convert1_dout_net_x2,
      convert2_x0 => convert2_dout_net_x2,
      convert3_x0 => convert3_dout_net_x1,
      convert4_x0 => convert4_dout_net_x1,
      convert5_x0 => convert5_dout_net_x1
    );

  bus_create1_312fc00109: entity work.bus_create1_entity_312fc00109
    port map (
      in1 => register1_q_net_x25,
      in2 => register1_q_net_x29,
      in3 => register1_q_net_x31,
      in4 => register1_q_net_x32,
      in5 => register1_q_net_x33,
      in6 => register1_q_net_x34,
      in7 => register1_q_net_x35,
      in8 => register1_q_net_x8,
      bus_out => concatenate_y_net_x1
    );

  constant1: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant1_op_net_x12
    );

  constant2: entity work.constant_c50603e098
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant2_op_net
    );

  constant3: entity work.constant_32693f9bda
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant3_op_net
    );

  convert1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 2,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x178,
      clk => clk_1_sg_x178,
      clr => '0',
      din(0) => register1_q_net_x1,
      en => "1",
      dout => convert1_dout_net_x0
    );

  convert2: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 2,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x178,
      clk => clk_1_sg_x178,
      clr => '0',
      din(0) => register1_q_net_x13,
      en => "1",
      dout => convert2_dout_net_x0
    );

  counter3: entity work.xlcounter_free_darkquad29
    generic map (
      core_name0 => "cntr_11_0_c0e13dbe8d12400d",
      op_arith => xlUnsigned,
      op_width => 15
    )
    port map (
      ce => ce_1_sg_x178,
      clk => clk_1_sg_x178,
      clr => '0',
      en(0) => delay6_q_net,
      rst(0) => register0_q_net_x3,
      op => counter3_op_net_x0
    );

  delay1: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x178,
      clk => clk_1_sg_x178,
      d(0) => delay3_q_net,
      en => '1',
      rst => '1',
      q(0) => delay1_q_net
    );

  delay2: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x178,
      clk => clk_1_sg_x178,
      d(0) => logical_y_net_x0,
      en => '1',
      rst => '1',
      q(0) => delay2_q_net
    );

  delay3: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x178,
      clk => clk_1_sg_x178,
      d(0) => edge_op_y_net_x0,
      en => '1',
      rst => '1',
      q(0) => delay3_q_net
    );

  delay6: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x178,
      clk => clk_1_sg_x178,
      d(0) => edge_op_y_net_x1,
      en => '1',
      rst => '1',
      q(0) => delay6_q_net
    );

  dly_val_8b4f4075af: entity work.dly_val_entity_8b4f4075af
    port map (
      darkquad29_adc_in_dly_val_user_data_out => darkquad29_adc_in_dly_val_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x0
    );

  edge_detect1_bd9c2244cb: entity work.edge_detect3_entity_2efb246ca9
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      in_x0 => darkquad29_adc_in_adcdac_2g_user_sync_net_x2,
      out_x0 => edge_op_y_net_x0
    );

  edge_detect3_5025a822a2: entity work.edge_detect3_entity_2efb246ca9
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      in_x0 => relational2_op_net_x0,
      out_x0 => edge_op_y_net_x1
    );

  i_scale_62fca468be: entity work.i_scale_entity_62fca468be
    port map (
      darkquad29_adc_in_i_scale_user_data_out => darkquad29_adc_in_i_scale_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x1
    );

  inc_phs_562186ef63: entity work.inc_phs_entity_562186ef63
    port map (
      darkquad29_adc_in_inc_phs_user_data_out => darkquad29_adc_in_inc_phs_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x2
    );

  load_dly_e25624efcb: entity work.load_dly_entity_e25624efcb
    port map (
      darkquad29_adc_in_load_dly_user_data_out => darkquad29_adc_in_load_dly_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x3
    );

  locked_6e82e1e073: entity work.last_tx_data_entity_4b5ba71046
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      out_reg => convert1_dout_net_x0,
      cast_gw_x0 => cast_gw_dout_net_x12
    );

  logical: entity work.logical_444d3f5046
    port map (
      ce => ce_1_sg_x178,
      clk => clk_1_sg_x178,
      clr => '0',
      d0(0) => delay1_q_net,
      d1(0) => edge_op_y_net_x1,
      y(0) => logical_y_net_x0
    );

  logical1: entity work.logical_799f62af22
    port map (
      ce => ce_1_sg_x178,
      clk => clk_1_sg_x178,
      clr => '0',
      d0(0) => logical_y_net_x0,
      d1(0) => relational_op_net,
      y(0) => logical1_y_net_x0
    );

  mult: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlUnsigned,
      a_bin_pt => 7,
      a_width => 8,
      b_arith => xlSigned,
      b_bin_pt => 0,
      b_width => 12,
      c_a_type => 1,
      c_a_width => 8,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 8,
      c_output_width => 20,
      c_type => 0,
      core_name0 => "mult_11_2_bcc54b656f5ca805",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 0,
      p_width => 12,
      quantization => 1
    )
    port map (
      a => reinterpret16_output_port_net,
      b => reinterpret17_output_port_net,
      ce => ce_1_sg_x178,
      clk => clk_1_sg_x178,
      clr => '0',
      core_ce => ce_1_sg_x178,
      core_clk => clk_1_sg_x178,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult_p_net_x1
    );

  mult1: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlUnsigned,
      a_bin_pt => 7,
      a_width => 8,
      b_arith => xlSigned,
      b_bin_pt => 0,
      b_width => 12,
      c_a_type => 1,
      c_a_width => 8,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 8,
      c_output_width => 20,
      c_type => 0,
      core_name0 => "mult_11_2_bcc54b656f5ca805",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 0,
      p_width => 12,
      quantization => 1
    )
    port map (
      a => reinterpret16_output_port_net,
      b => reinterpret19_output_port_net,
      ce => ce_1_sg_x178,
      clk => clk_1_sg_x178,
      clr => '0',
      core_ce => ce_1_sg_x178,
      core_clk => clk_1_sg_x178,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult1_p_net_x1
    );

  mult2: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlUnsigned,
      a_bin_pt => 7,
      a_width => 8,
      b_arith => xlSigned,
      b_bin_pt => 0,
      b_width => 12,
      c_a_type => 1,
      c_a_width => 8,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 8,
      c_output_width => 20,
      c_type => 0,
      core_name0 => "mult_11_2_bcc54b656f5ca805",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 0,
      p_width => 12,
      quantization => 1
    )
    port map (
      a => reinterpret16_output_port_net,
      b => reinterpret21_output_port_net,
      ce => ce_1_sg_x178,
      clk => clk_1_sg_x178,
      clr => '0',
      core_ce => ce_1_sg_x178,
      core_clk => clk_1_sg_x178,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult2_p_net_x1
    );

  mult3: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlUnsigned,
      a_bin_pt => 7,
      a_width => 8,
      b_arith => xlSigned,
      b_bin_pt => 0,
      b_width => 12,
      c_a_type => 1,
      c_a_width => 8,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 8,
      c_output_width => 20,
      c_type => 0,
      core_name0 => "mult_11_2_bcc54b656f5ca805",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 0,
      p_width => 12,
      quantization => 1
    )
    port map (
      a => reinterpret16_output_port_net,
      b => reinterpret23_output_port_net,
      ce => ce_1_sg_x178,
      clk => clk_1_sg_x178,
      clr => '0',
      core_ce => ce_1_sg_x178,
      core_clk => clk_1_sg_x178,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult3_p_net_x1
    );

  mult4: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlUnsigned,
      a_bin_pt => 7,
      a_width => 8,
      b_arith => xlSigned,
      b_bin_pt => 0,
      b_width => 12,
      c_a_type => 1,
      c_a_width => 8,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 8,
      c_output_width => 20,
      c_type => 0,
      core_name0 => "mult_11_2_bcc54b656f5ca805",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 0,
      p_width => 12,
      quantization => 1
    )
    port map (
      a => reinterpret16_output_port_net,
      b => reinterpret25_output_port_net,
      ce => ce_1_sg_x178,
      clk => clk_1_sg_x178,
      clr => '0',
      core_ce => ce_1_sg_x178,
      core_clk => clk_1_sg_x178,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult4_p_net_x1
    );

  mult5: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlUnsigned,
      a_bin_pt => 7,
      a_width => 8,
      b_arith => xlSigned,
      b_bin_pt => 0,
      b_width => 12,
      c_a_type => 1,
      c_a_width => 8,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 8,
      c_output_width => 20,
      c_type => 0,
      core_name0 => "mult_11_2_bcc54b656f5ca805",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 0,
      p_width => 12,
      quantization => 1
    )
    port map (
      a => reinterpret16_output_port_net,
      b => reinterpret27_output_port_net,
      ce => ce_1_sg_x178,
      clk => clk_1_sg_x178,
      clr => '0',
      core_ce => ce_1_sg_x178,
      core_clk => clk_1_sg_x178,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult5_p_net_x1
    );

  mult6: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlUnsigned,
      a_bin_pt => 7,
      a_width => 8,
      b_arith => xlSigned,
      b_bin_pt => 0,
      b_width => 12,
      c_a_type => 1,
      c_a_width => 8,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 8,
      c_output_width => 20,
      c_type => 0,
      core_name0 => "mult_11_2_bcc54b656f5ca805",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 0,
      p_width => 12,
      quantization => 1
    )
    port map (
      a => reinterpret16_output_port_net,
      b => reinterpret29_output_port_net,
      ce => ce_1_sg_x178,
      clk => clk_1_sg_x178,
      clr => '0',
      core_ce => ce_1_sg_x178,
      core_clk => clk_1_sg_x178,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult6_p_net_x1
    );

  mult7: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlUnsigned,
      a_bin_pt => 7,
      a_width => 8,
      b_arith => xlSigned,
      b_bin_pt => 0,
      b_width => 12,
      c_a_type => 1,
      c_a_width => 8,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 8,
      c_output_width => 20,
      c_type => 0,
      core_name0 => "mult_11_2_bcc54b656f5ca805",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 0,
      p_width => 12,
      quantization => 1
    )
    port map (
      a => reinterpret16_output_port_net,
      b => reinterpret31_output_port_net,
      ce => ce_1_sg_x178,
      clk => clk_1_sg_x178,
      clr => '0',
      core_ce => ce_1_sg_x178,
      core_clk => clk_1_sg_x178,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult7_p_net_x1
    );

  n_miss_pps_75e9ac9f26: entity work.n_miss_pps_entity_75e9ac9f26
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      out_reg => register0_q_net_x1,
      cast_gw_x0 => cast_gw_dout_net_x13
    );

  pipeline10_04993e776c: entity work.pipeline10_entity_04993e776c
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => concat_y_net_x8,
      q => register1_q_net_x8
    );

  pipeline11_33fea3dbf5: entity work.pipeline11_entity_33fea3dbf5
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => mult_p_net_x1,
      q => register1_q_net_x5
    );

  pipeline12_921a8cdaba: entity work.pipeline11_entity_33fea3dbf5
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => mult4_p_net_x1,
      q => register1_q_net_x4
    );

  pipeline13_3f0b9f2287: entity work.pipeline11_entity_33fea3dbf5
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => register2_q_net_x6,
      q => register1_q_net_x9
    );

  pipeline14_52e83d158e: entity work.pipeline11_entity_33fea3dbf5
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => mult5_p_net_x1,
      q => register1_q_net_x6
    );

  pipeline15_d6e01655f0: entity work.pipeline11_entity_33fea3dbf5
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => register2_q_net_x7,
      q => register1_q_net_x7
    );

  pipeline16_8f4eaf6ee7: entity work.pipeline11_entity_33fea3dbf5
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => mult6_p_net_x1,
      q => register1_q_net_x10
    );

  pipeline17_fa578097ad: entity work.pipeline11_entity_33fea3dbf5
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => register2_q_net_x8,
      q => register1_q_net_x17
    );

  pipeline18_7ca549efe1: entity work.pipeline3_entity_fb0a315a6d
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => slice_y_net_x0,
      q => register1_q_net_x11
    );

  pipeline19_c83bf477c3: entity work.pipeline19_entity_c83bf477c3
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => slice4_y_net_x0,
      q => register1_q_net_x12
    );

  pipeline1_a705dd731e: entity work.pipeline3_entity_fb0a315a6d
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => darkquad29_adc_in_adcdac_2g_user_mmcm_locked_net_x1,
      q => register1_q_net_x1
    );

  pipeline20_bc26816ec8: entity work.pipeline20_entity_bc26816ec8
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => slice5_y_net_x0,
      q => register1_q_net_x14
    );

  pipeline21_b2becd5819: entity work.pipeline3_entity_fb0a315a6d
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => slice1_y_net_x0,
      q => register1_q_net_x15
    );

  pipeline22_1fade79c35: entity work.pipeline3_entity_fb0a315a6d
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => slice2_y_net_x0,
      q => register1_q_net_x16
    );

  pipeline23_d029633981: entity work.pipeline11_entity_33fea3dbf5
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => mult7_p_net_x1,
      q => register1_q_net_x18
    );

  pipeline24_aaa1034fb3: entity work.pipeline11_entity_33fea3dbf5
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => register2_q_net_x9,
      q => register1_q_net_x19
    );

  pipeline25_c2432ad3c8: entity work.pipeline11_entity_33fea3dbf5
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => register2_q_net_x2,
      q => register1_q_net_x20
    );

  pipeline26_b784f20021: entity work.pipeline11_entity_33fea3dbf5
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => mult1_p_net_x1,
      q => register1_q_net_x21
    );

  pipeline27_da630a52bc: entity work.pipeline3_entity_fb0a315a6d
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => slice7_y_net_x0,
      q => register1_q_net_x22
    );

  pipeline28_61e2879be3: entity work.pipeline11_entity_33fea3dbf5
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => register2_q_net_x3,
      q => register1_q_net_x23
    );

  pipeline29_f9765e563f: entity work.pipeline11_entity_33fea3dbf5
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => mult2_p_net_x1,
      q => register1_q_net_x24
    );

  pipeline2_1bdeb473d2: entity work.pipeline2_entity_1bdeb473d2
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => darkquad29_adc_in_adcdac_2g_user_valid_net_x1,
      q => register1_q_net_x13
    );

  pipeline30_ccc6a64e80: entity work.pipeline11_entity_33fea3dbf5
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => register2_q_net_x4,
      q => register1_q_net_x26
    );

  pipeline31_7dd17cd465: entity work.pipeline11_entity_33fea3dbf5
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => mult3_p_net_x1,
      q => register1_q_net_x27
    );

  pipeline32_b17494b23e: entity work.pipeline11_entity_33fea3dbf5
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => register2_q_net_x5,
      q => register1_q_net_x28
    );

  pipeline33_6309c37291: entity work.pipeline33_entity_6309c37291
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => counter3_op_net_x0,
      q => register0_q_net_x1
    );

  pipeline34_cc1aaf53a8: entity work.pipeline34_entity_cc1aaf53a8
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => reinterpret18_output_port_net_x0,
      q => register2_q_net_x2
    );

  pipeline35_0c537af9bd: entity work.pipeline35_entity_0c537af9bd
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => darkquad29_adc_in_adcdac_2g_user_sync_net_x2,
      q => register0_q_net_x2
    );

  pipeline36_a5ed25d209: entity work.pipeline35_entity_0c537af9bd
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => edge_op_y_net_x3,
      q => register0_q_net_x3
    );

  pipeline37_b51f91fe93: entity work.pipeline34_entity_cc1aaf53a8
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => reinterpret20_output_port_net_x0,
      q => register2_q_net_x3
    );

  pipeline38_5cce0fa5e5: entity work.pipeline34_entity_cc1aaf53a8
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => reinterpret22_output_port_net_x0,
      q => register2_q_net_x4
    );

  pipeline39_25bab7a335: entity work.pipeline34_entity_cc1aaf53a8
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => reinterpret24_output_port_net_x0,
      q => register2_q_net_x5
    );

  pipeline3_b23d4d65c2: entity work.pipeline10_entity_04993e776c
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => concat_y_net_x1,
      q => register1_q_net_x25
    );

  pipeline40_fe72294530: entity work.pipeline34_entity_cc1aaf53a8
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => reinterpret26_output_port_net_x0,
      q => register2_q_net_x6
    );

  pipeline41_02e62ffcd5: entity work.pipeline34_entity_cc1aaf53a8
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => reinterpret28_output_port_net_x0,
      q => register2_q_net_x7
    );

  pipeline42_6deaa87489: entity work.pipeline34_entity_cc1aaf53a8
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => reinterpret30_output_port_net_x0,
      q => register2_q_net_x8
    );

  pipeline43_e8fc05d881: entity work.pipeline34_entity_cc1aaf53a8
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => reinterpret32_output_port_net_x0,
      q => register2_q_net_x9
    );

  pipeline44_6414bac78b: entity work.pipeline1_entity_986e3344b8
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => reint1_output_port_net_x1,
      q => register1_q_net_x30
    );

  pipeline45_a48ec60c29: entity work.pipeline35_entity_0c537af9bd
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => logical_y_net_x0,
      q => register0_q_net_x4
    );

  pipeline4_872d359c19: entity work.pipeline10_entity_04993e776c
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => concat_y_net_x2,
      q => register1_q_net_x29
    );

  pipeline5_3d85ab592d: entity work.pipeline10_entity_04993e776c
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => concat_y_net_x3,
      q => register1_q_net_x31
    );

  pipeline6_d4ada09c00: entity work.pipeline10_entity_04993e776c
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => concat_y_net_x4,
      q => register1_q_net_x32
    );

  pipeline7_4130f9b383: entity work.pipeline10_entity_04993e776c
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => concat_y_net_x5,
      q => register1_q_net_x33
    );

  pipeline8_d609ee0d2f: entity work.pipeline10_entity_04993e776c
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => concat_y_net_x6,
      q => register1_q_net_x34
    );

  pipeline9_c909af6f99: entity work.pipeline10_entity_04993e776c
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      d => concat_y_net_x7,
      q => register1_q_net_x35
    );

  pos_phs_15176b9079: entity work.pos_phs_entity_15176b9079
    port map (
      darkquad29_adc_in_pos_phs_user_data_out => darkquad29_adc_in_pos_phs_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x4
    );

  pps_deadtime_ctr: entity work.xlcounter_limit_darkquad29
    generic map (
      cnt_15_0 => 18688,
      cnt_31_16 => 3967,
      cnt_47_32 => 0,
      cnt_63_48 => 0,
      core_name0 => "cntr_11_0_4d961a297cbb815e",
      count_limited => 1,
      op_arith => xlUnsigned,
      op_width => 28
    )
    port map (
      ce => ce_1_sg_x178,
      clk => clk_1_sg_x178,
      clr => '0',
      en => "1",
      rst(0) => register0_q_net_x4,
      op => pps_deadtime_ctr_op_net
    );

  pps_wait_ctr1: entity work.xlcounter_free_darkquad29
    generic map (
      core_name0 => "cntr_11_0_4d961a297cbb815e",
      op_arith => xlUnsigned,
      op_width => 28
    )
    port map (
      ce => ce_1_sg_x178,
      clk => clk_1_sg_x178,
      clr => '0',
      en => "1",
      rst(0) => delay2_q_net,
      op => pps_wait_ctr1_op_net
    );

  pps_wait_ctr2: entity work.xlcounter_free_darkquad29
    generic map (
      core_name0 => "cntr_11_0_9ca51386af2c7a71",
      op_arith => xlUnsigned,
      op_width => 32
    )
    port map (
      ce => ce_1_sg_x178,
      clk => clk_1_sg_x178,
      clr => '0',
      en => "1",
      rst(0) => register0_q_net_x3,
      op => pps_wait_ctr2_op_net
    );

  raw_pps_b93fd5b268: entity work.sending_data_entity_bfe6edc6ce
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      out_reg => register0_q_net_x2,
      cast_gw_x0 => cast_gw_dout_net_x14
    );

  register0: entity work.xlregister
    generic map (
      d_width => 32,
      init_value => b"00000000000000000000000000000000"
    )
    port map (
      ce => ce_1_sg_x178,
      clk => clk_1_sg_x178,
      d => pps_wait_ctr2_op_net,
      en(0) => logical1_y_net_x0,
      rst => "0",
      q => register0_q_net_x0
    );

  register1: entity work.xlregister
    generic map (
      d_width => 32,
      init_value => b"00000000000000000000000000000000"
    )
    port map (
      ce => ce_1_sg_x178,
      clk => clk_1_sg_x178,
      d => register0_q_net_x0,
      en(0) => logical1_y_net_x0,
      rst => "0",
      q => register1_q_net_x0
    );

  register2: entity work.xlregister
    generic map (
      d_width => 32,
      init_value => b"00000000000000000000000000000000"
    )
    port map (
      ce => ce_1_sg_x178,
      clk => clk_1_sg_x178,
      d => register1_q_net_x0,
      en(0) => logical1_y_net_x0,
      rst => "0",
      q => register2_q_net_x0
    );

  register3: entity work.xlregister
    generic map (
      d_width => 32,
      init_value => b"00000000000000000000000000000000"
    )
    port map (
      ce => ce_1_sg_x178,
      clk => clk_1_sg_x178,
      d => register2_q_net_x0,
      en(0) => logical1_y_net_x0,
      rst => "0",
      q => register3_q_net_x0
    );

  reinterpret16: entity work.reinterpret_f21e7f2ddf
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice3_y_net,
      output_port => reinterpret16_output_port_net
    );

  reinterpret17: entity work.reinterpret_8f5500aea5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => darkquad29_adc_in_adcdac_2g_user_data_i0_net_x0,
      output_port => reinterpret17_output_port_net
    );

  reinterpret18: entity work.reinterpret_8f5500aea5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => darkquad29_adc_in_adcdac_2g_user_data_q0_net_x0,
      output_port => reinterpret18_output_port_net_x0
    );

  reinterpret19: entity work.reinterpret_8f5500aea5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => darkquad29_adc_in_adcdac_2g_user_data_i1_net_x0,
      output_port => reinterpret19_output_port_net
    );

  reinterpret20: entity work.reinterpret_8f5500aea5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => darkquad29_adc_in_adcdac_2g_user_data_q1_net_x0,
      output_port => reinterpret20_output_port_net_x0
    );

  reinterpret21: entity work.reinterpret_8f5500aea5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => darkquad29_adc_in_adcdac_2g_user_data_i2_net_x0,
      output_port => reinterpret21_output_port_net
    );

  reinterpret22: entity work.reinterpret_8f5500aea5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => darkquad29_adc_in_adcdac_2g_user_data_q2_net_x0,
      output_port => reinterpret22_output_port_net_x0
    );

  reinterpret23: entity work.reinterpret_8f5500aea5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => darkquad29_adc_in_adcdac_2g_user_data_i3_net_x0,
      output_port => reinterpret23_output_port_net
    );

  reinterpret24: entity work.reinterpret_8f5500aea5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => darkquad29_adc_in_adcdac_2g_user_data_q3_net_x0,
      output_port => reinterpret24_output_port_net_x0
    );

  reinterpret25: entity work.reinterpret_8f5500aea5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => darkquad29_adc_in_adcdac_2g_user_data_i4_net_x0,
      output_port => reinterpret25_output_port_net
    );

  reinterpret26: entity work.reinterpret_8f5500aea5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => darkquad29_adc_in_adcdac_2g_user_data_q4_net_x0,
      output_port => reinterpret26_output_port_net_x0
    );

  reinterpret27: entity work.reinterpret_8f5500aea5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => darkquad29_adc_in_adcdac_2g_user_data_i5_net_x0,
      output_port => reinterpret27_output_port_net
    );

  reinterpret28: entity work.reinterpret_8f5500aea5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => darkquad29_adc_in_adcdac_2g_user_data_q5_net_x0,
      output_port => reinterpret28_output_port_net_x0
    );

  reinterpret29: entity work.reinterpret_8f5500aea5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => darkquad29_adc_in_adcdac_2g_user_data_i6_net_x0,
      output_port => reinterpret29_output_port_net
    );

  reinterpret30: entity work.reinterpret_8f5500aea5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => darkquad29_adc_in_adcdac_2g_user_data_q6_net_x0,
      output_port => reinterpret30_output_port_net_x0
    );

  reinterpret31: entity work.reinterpret_8f5500aea5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => darkquad29_adc_in_adcdac_2g_user_data_i7_net_x0,
      output_port => reinterpret31_output_port_net
    );

  reinterpret32: entity work.reinterpret_8f5500aea5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => darkquad29_adc_in_adcdac_2g_user_data_q7_net_x0,
      output_port => reinterpret32_output_port_net_x0
    );

  relational: entity work.relational_edc0a9c61c
    port map (
      a => constant2_op_net,
      b => pps_deadtime_ctr_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational_op_net
    );

  relational2: entity work.relational_e4a0188a91
    port map (
      a => pps_wait_ctr1_op_net,
      b => constant3_op_net,
      ce => ce_1_sg_x178,
      clk => clk_1_sg_x178,
      clr => '0',
      op(0) => relational2_op_net_x0
    );

  ri_to_c1_7420b893fa: entity work.ri_to_c_entity_58f9bb7fbe
    port map (
      im => register2_q_net_x3,
      re => mult1_p_net_x1,
      c => concat_y_net_x2
    );

  ri_to_c2_8fe1e43753: entity work.ri_to_c_entity_58f9bb7fbe
    port map (
      im => register2_q_net_x4,
      re => mult2_p_net_x1,
      c => concat_y_net_x3
    );

  ri_to_c3_97cb41c34b: entity work.ri_to_c_entity_58f9bb7fbe
    port map (
      im => register2_q_net_x5,
      re => mult3_p_net_x1,
      c => concat_y_net_x4
    );

  ri_to_c4_2551df97b2: entity work.ri_to_c_entity_58f9bb7fbe
    port map (
      im => register2_q_net_x6,
      re => mult4_p_net_x1,
      c => concat_y_net_x5
    );

  ri_to_c5_b4d6d923b0: entity work.ri_to_c_entity_58f9bb7fbe
    port map (
      im => register2_q_net_x7,
      re => mult5_p_net_x1,
      c => concat_y_net_x6
    );

  ri_to_c6_ffc4037194: entity work.ri_to_c_entity_58f9bb7fbe
    port map (
      im => register2_q_net_x8,
      re => mult6_p_net_x1,
      c => concat_y_net_x7
    );

  ri_to_c7_1241bcc138: entity work.ri_to_c_entity_58f9bb7fbe
    port map (
      im => register2_q_net_x9,
      re => mult7_p_net_x1,
      c => concat_y_net_x8
    );

  ri_to_c_58f9bb7fbe: entity work.ri_to_c_entity_58f9bb7fbe
    port map (
      im => register2_q_net_x2,
      re => mult_p_net_x1,
      c => concat_y_net_x1
    );

  slice: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 1,
      y_width => 1
    )
    port map (
      x(0) => register1_q_net_x36,
      y(0) => slice_y_net_x0
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => reint1_output_port_net_x4,
      y(0) => slice1_y_net_x0
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => reint1_output_port_net_x2,
      y(0) => slice2_y_net_x0
    );

  slice3: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 7,
      x_width => 32,
      y_width => 8
    )
    port map (
      x => register1_q_net_x30,
      y => slice3_y_net
    );

  slice4: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 4,
      x_width => 32,
      y_width => 5
    )
    port map (
      x => reint1_output_port_net_x0,
      y => slice4_y_net_x0
    );

  slice5: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 5,
      x_width => 32,
      y_width => 6
    )
    port map (
      x => reint1_output_port_net_x3,
      y => slice5_y_net_x0
    );

  slice7: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => reint1_output_port_net_x5,
      y(0) => slice7_y_net_x0
    );

  snp_cal0_2f39237f1b: entity work.snp_cal0_entity_2f39237f1b
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      darkquad29_adc_in_snp_cal0_ss_ctrl_user_data_out => darkquad29_adc_in_snp_cal0_ss_ctrl_user_data_out_net_x3,
      in_data_i0 => register1_q_net_x5,
      in_data_i1 => register1_q_net_x21,
      in_data_q0 => register1_q_net_x20,
      in_data_q1 => register1_q_net_x23,
      trig => register1_q_net_x22,
      we => constant1_op_net_x12,
      ss => convert_addr_dout_net_x6,
      ss_x0 => convert_din1_dout_net_x6,
      ss_x1 => convert_we_dout_net_x6,
      ss_x2 => cast_gw_dout_net_x15
    );

  snp_cal1_169a1f2d92: entity work.snp_cal1_entity_169a1f2d92
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      darkquad29_adc_in_snp_cal1_ss_ctrl_user_data_out => darkquad29_adc_in_snp_cal1_ss_ctrl_user_data_out_net_x3,
      in_data_i2 => register1_q_net_x24,
      in_data_i3 => register1_q_net_x27,
      in_data_q2 => register1_q_net_x26,
      in_data_q3 => register1_q_net_x28,
      trig => register1_q_net_x22,
      we => constant1_op_net_x12,
      ss => convert_addr_dout_net_x7,
      ss_x0 => convert_din1_dout_net_x7,
      ss_x1 => convert_we_dout_net_x7,
      ss_x2 => cast_gw_dout_net_x16
    );

  snp_cal2_58da2c4a2e: entity work.snp_cal2_entity_58da2c4a2e
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      darkquad29_adc_in_snp_cal2_ss_ctrl_user_data_out => darkquad29_adc_in_snp_cal2_ss_ctrl_user_data_out_net_x3,
      in_data_i4 => register1_q_net_x4,
      in_data_i5 => register1_q_net_x6,
      in_data_q4 => register1_q_net_x9,
      in_data_q5 => register1_q_net_x7,
      trig => register1_q_net_x22,
      we => constant1_op_net_x12,
      ss => convert_addr_dout_net_x8,
      ss_x0 => convert_din1_dout_net_x8,
      ss_x1 => convert_we_dout_net_x8,
      ss_x2 => cast_gw_dout_net_x17
    );

  snp_cal3_2b6fda8a9c: entity work.snp_cal3_entity_2b6fda8a9c
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      darkquad29_adc_in_snp_cal3_ss_ctrl_user_data_out => darkquad29_adc_in_snp_cal3_ss_ctrl_user_data_out_net_x3,
      in_data_i6 => register1_q_net_x10,
      in_data_i7 => register1_q_net_x18,
      in_data_q6 => register1_q_net_x17,
      in_data_q7 => register1_q_net_x19,
      trig => register1_q_net_x22,
      we => constant1_op_net_x12,
      ss => convert_addr_dout_net_x9,
      ss_x0 => convert_din1_dout_net_x9,
      ss_x1 => convert_we_dout_net_x9,
      ss_x2 => cast_gw_dout_net_x18
    );

  trig_67979a96da: entity work.trig_entity_67979a96da
    port map (
      darkquad29_adc_in_trig_user_data_out => darkquad29_adc_in_trig_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x5
    );

  ts0_7a94437712: entity work.last_tx_data_entity_4b5ba71046
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      out_reg => register3_q_net_x0,
      cast_gw_x0 => cast_gw_dout_net_x19
    );

  ts1_3accfa7d13: entity work.last_tx_data_entity_4b5ba71046
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      out_reg => register2_q_net_x0,
      cast_gw_x0 => cast_gw_dout_net_x20
    );

  ts2_42f3c3863c: entity work.last_tx_data_entity_4b5ba71046
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      out_reg => register1_q_net_x0,
      cast_gw_x0 => cast_gw_dout_net_x21
    );

  ts3_9fce5dc00b: entity work.last_tx_data_entity_4b5ba71046
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      out_reg => register0_q_net_x0,
      cast_gw_x0 => cast_gw_dout_net_x22
    );

  valid_4ebf17c015: entity work.last_tx_data_entity_4b5ba71046
    port map (
      ce_1 => ce_1_sg_x178,
      clk_1 => clk_1_sg_x178,
      out_reg => convert2_dout_net_x0,
      cast_gw_x0 => cast_gw_dout_net_x23
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/board_num"

entity board_num_entity_00082f664f is
  port (
    darkquad29_board_num_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end board_num_entity_00082f664f;

architecture structural of board_num_entity_00082f664f is
  signal darkquad29_board_num_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_board_num_user_data_out_net_x0 <= darkquad29_board_num_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_board_num_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/bus_create"

entity bus_create_entity_1645e0fabf is
  port (
    in1: in std_logic_vector(63 downto 0); 
    in2: in std_logic_vector(63 downto 0); 
    in3: in std_logic_vector(63 downto 0); 
    in4: in std_logic_vector(63 downto 0); 
    in5: in std_logic_vector(19 downto 0); 
    bus_out: out std_logic_vector(275 downto 0)
  );
end bus_create_entity_1645e0fabf;

architecture structural of bus_create_entity_1645e0fabf is
  signal concatenate_y_net_x0: std_logic_vector(275 downto 0);
  signal convert3_dout_net_x0: std_logic_vector(63 downto 0);
  signal convert4_dout_net_x0: std_logic_vector(63 downto 0);
  signal convert6_dout_net_x0: std_logic_vector(63 downto 0);
  signal convert9_dout_net_x0: std_logic_vector(63 downto 0);
  signal delay76_q_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(63 downto 0);
  signal reinterpret2_output_port_net: std_logic_vector(63 downto 0);
  signal reinterpret3_output_port_net: std_logic_vector(63 downto 0);
  signal reinterpret4_output_port_net: std_logic_vector(63 downto 0);
  signal reinterpret5_output_port_net: std_logic_vector(19 downto 0);

begin
  convert9_dout_net_x0 <= in1;
  convert3_dout_net_x0 <= in2;
  convert4_dout_net_x0 <= in3;
  convert6_dout_net_x0 <= in4;
  delay76_q_net_x0 <= in5;
  bus_out <= concatenate_y_net_x0;

  concatenate: entity work.concat_16dfebb8b2
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret1_output_port_net,
      in1 => reinterpret2_output_port_net,
      in2 => reinterpret3_output_port_net,
      in3 => reinterpret4_output_port_net,
      in4 => reinterpret5_output_port_net,
      y => concatenate_y_net_x0
    );

  reinterpret1: entity work.reinterpret_9a13f6a2a0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => convert9_dout_net_x0,
      output_port => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_9a13f6a2a0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => convert3_dout_net_x0,
      output_port => reinterpret2_output_port_net
    );

  reinterpret3: entity work.reinterpret_9a13f6a2a0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => convert4_dout_net_x0,
      output_port => reinterpret3_output_port_net
    );

  reinterpret4: entity work.reinterpret_9a13f6a2a0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => convert6_dout_net_x0,
      output_port => reinterpret4_output_port_net
    );

  reinterpret5: entity work.reinterpret_713b6c5d29
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => delay76_q_net_x0,
      output_port => reinterpret5_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/bus_expand1"

entity bus_expand1_entity_44b59daeff is
  port (
    bus_in: in std_logic_vector(275 downto 0); 
    lsb_out1: out std_logic_vector(19 downto 0); 
    msb_out5: out std_logic_vector(63 downto 0); 
    out2: out std_logic_vector(63 downto 0); 
    out3: out std_logic_vector(63 downto 0); 
    out4: out std_logic_vector(63 downto 0)
  );
end bus_expand1_entity_44b59daeff;

architecture structural of bus_expand1_entity_44b59daeff is
  signal register1_q_net_x0: std_logic_vector(275 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(19 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(63 downto 0);
  signal reinterpret3_output_port_net_x0: std_logic_vector(63 downto 0);
  signal reinterpret4_output_port_net_x0: std_logic_vector(63 downto 0);
  signal reinterpret5_output_port_net_x0: std_logic_vector(63 downto 0);
  signal slice1_y_net: std_logic_vector(19 downto 0);
  signal slice2_y_net: std_logic_vector(63 downto 0);
  signal slice3_y_net: std_logic_vector(63 downto 0);
  signal slice4_y_net: std_logic_vector(63 downto 0);
  signal slice5_y_net: std_logic_vector(63 downto 0);

begin
  register1_q_net_x0 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x0;
  msb_out5 <= reinterpret5_output_port_net_x0;
  out2 <= reinterpret2_output_port_net_x0;
  out3 <= reinterpret3_output_port_net_x0;
  out4 <= reinterpret4_output_port_net_x0;

  reinterpret1: entity work.reinterpret_713b6c5d29
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x0
    );

  reinterpret2: entity work.reinterpret_9a13f6a2a0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret2_output_port_net_x0
    );

  reinterpret3: entity work.reinterpret_9a13f6a2a0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice3_y_net,
      output_port => reinterpret3_output_port_net_x0
    );

  reinterpret4: entity work.reinterpret_9a13f6a2a0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice4_y_net,
      output_port => reinterpret4_output_port_net_x0
    );

  reinterpret5: entity work.reinterpret_9a13f6a2a0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice5_y_net,
      output_port => reinterpret5_output_port_net_x0
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 19,
      x_width => 276,
      y_width => 20
    )
    port map (
      x => register1_q_net_x0,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 20,
      new_msb => 83,
      x_width => 276,
      y_width => 64
    )
    port map (
      x => register1_q_net_x0,
      y => slice2_y_net
    );

  slice3: entity work.xlslice
    generic map (
      new_lsb => 84,
      new_msb => 147,
      x_width => 276,
      y_width => 64
    )
    port map (
      x => register1_q_net_x0,
      y => slice3_y_net
    );

  slice4: entity work.xlslice
    generic map (
      new_lsb => 148,
      new_msb => 211,
      x_width => 276,
      y_width => 64
    )
    port map (
      x => register1_q_net_x0,
      y => slice4_y_net
    );

  slice5: entity work.xlslice
    generic map (
      new_lsb => 212,
      new_msb => 275,
      x_width => 276,
      y_width => 64
    )
    port map (
      x => register1_q_net_x0,
      y => slice5_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture0/base_kf"

entity base_kf_entity_d3a106f79b is
  port (
    darkquad29_capture0_base_kf_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end base_kf_entity_d3a106f79b;

architecture structural of base_kf_entity_d3a106f79b is
  signal darkquad29_capture0_base_kf_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_capture0_base_kf_user_data_out_net_x0 <= darkquad29_capture0_base_kf_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_capture0_base_kf_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture0/base_kq"

entity base_kq_entity_bfd3a04c3b is
  port (
    darkquad29_capture0_base_kq_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end base_kq_entity_bfd3a04c3b;

architecture structural of base_kq_entity_bfd3a04c3b is
  signal darkquad29_capture0_base_kq_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_capture0_base_kq_user_data_out_net_x0 <= darkquad29_capture0_base_kq_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_capture0_base_kq_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture0/cps_lim"

entity cps_lim_entity_d70c5caf8d is
  port (
    darkquad29_capture0_cps_lim_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end cps_lim_entity_d70c5caf8d;

architecture structural of cps_lim_entity_d70c5caf8d is
  signal darkquad29_capture0_cps_lim_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_capture0_cps_lim_user_data_out_net_x0 <= darkquad29_capture0_cps_lim_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_capture0_cps_lim_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture0/deadtime/delay_bram1"

entity delay_bram1_entity_80069f2a19 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic; 
    dout: out std_logic
  );
end delay_bram1_entity_80069f2a19;

architecture structural of delay_bram1_entity_80069f2a19 is
  signal ce_1_sg_x179: std_logic;
  signal clk_1_sg_x179: std_logic;
  signal constant_op_net: std_logic;
  signal counter_op_net: std_logic_vector(7 downto 0);
  signal ram_data_out_net_x1: std_logic;
  signal ram_data_out_net_x2: std_logic;

begin
  ce_1_sg_x179 <= ce_1;
  clk_1_sg_x179 <= clk_1;
  ram_data_out_net_x1 <= din;
  dout <= ram_data_out_net_x2;

  constant_x0: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant_op_net
    );

  counter: entity work.xlcounter_limit_darkquad29
    generic map (
      cnt_15_0 => 253,
      cnt_31_16 => 0,
      cnt_47_32 => 0,
      cnt_63_48 => 0,
      core_name0 => "cntr_11_0_d1eeca027ba03819",
      count_limited => 1,
      op_arith => xlUnsigned,
      op_width => 8
    )
    port map (
      ce => ce_1_sg_x179,
      clk => clk_1_sg_x179,
      clr => '0',
      en => "1",
      rst => "0",
      op => counter_op_net
    );

  ram: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 1,
      core_name0 => "bmg_72_5886869123e35b2f",
      latency => 1
    )
    port map (
      addr => counter_op_net,
      ce => ce_1_sg_x179,
      clk => clk_1_sg_x179,
      data_in(0) => ram_data_out_net_x1,
      en => "1",
      rst => "0",
      we(0) => constant_op_net,
      data_out(0) => ram_data_out_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture0/deadtime"

entity deadtime_entity_87d78ea2d1 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic; 
    out_x0: out std_logic
  );
end deadtime_entity_87d78ea2d1;

architecture structural of deadtime_entity_87d78ea2d1 is
  signal ce_1_sg_x188: std_logic;
  signal clk_1_sg_x188: std_logic;
  signal delay14_q_net_x1: std_logic;
  signal logical7_y_net_x0: std_logic;
  signal ram_data_out_net_x0: std_logic;
  signal ram_data_out_net_x1: std_logic;
  signal ram_data_out_net_x2: std_logic;
  signal ram_data_out_net_x3: std_logic;
  signal ram_data_out_net_x4: std_logic;
  signal ram_data_out_net_x5: std_logic;
  signal ram_data_out_net_x6: std_logic;
  signal ram_data_out_net_x7: std_logic;
  signal ram_data_out_net_x8: std_logic;

begin
  ce_1_sg_x188 <= ce_1;
  clk_1_sg_x188 <= clk_1;
  delay14_q_net_x1 <= in_x0;
  out_x0 <= logical7_y_net_x0;

  delay_bram10_fb3ace0b61: entity work.delay_bram1_entity_80069f2a19
    port map (
      ce_1 => ce_1_sg_x188,
      clk_1 => clk_1_sg_x188,
      din => delay14_q_net_x1,
      dout => ram_data_out_net_x2
    );

  delay_bram1_80069f2a19: entity work.delay_bram1_entity_80069f2a19
    port map (
      ce_1 => ce_1_sg_x188,
      clk_1 => clk_1_sg_x188,
      din => ram_data_out_net_x2,
      dout => ram_data_out_net_x3
    );

  delay_bram2_d3c9dcb2b7: entity work.delay_bram1_entity_80069f2a19
    port map (
      ce_1 => ce_1_sg_x188,
      clk_1 => clk_1_sg_x188,
      din => ram_data_out_net_x3,
      dout => ram_data_out_net_x1
    );

  delay_bram3_b59347a484: entity work.delay_bram1_entity_80069f2a19
    port map (
      ce_1 => ce_1_sg_x188,
      clk_1 => clk_1_sg_x188,
      din => ram_data_out_net_x1,
      dout => ram_data_out_net_x4
    );

  delay_bram4_e8654e695f: entity work.delay_bram1_entity_80069f2a19
    port map (
      ce_1 => ce_1_sg_x188,
      clk_1 => clk_1_sg_x188,
      din => ram_data_out_net_x4,
      dout => ram_data_out_net_x5
    );

  delay_bram5_271ea0bb21: entity work.delay_bram1_entity_80069f2a19
    port map (
      ce_1 => ce_1_sg_x188,
      clk_1 => clk_1_sg_x188,
      din => ram_data_out_net_x5,
      dout => ram_data_out_net_x6
    );

  delay_bram6_e62afae030: entity work.delay_bram1_entity_80069f2a19
    port map (
      ce_1 => ce_1_sg_x188,
      clk_1 => clk_1_sg_x188,
      din => ram_data_out_net_x6,
      dout => ram_data_out_net_x7
    );

  delay_bram7_1404297361: entity work.delay_bram1_entity_80069f2a19
    port map (
      ce_1 => ce_1_sg_x188,
      clk_1 => clk_1_sg_x188,
      din => ram_data_out_net_x7,
      dout => ram_data_out_net_x8
    );

  delay_bram8_2f4dbb56c2: entity work.delay_bram1_entity_80069f2a19
    port map (
      ce_1 => ce_1_sg_x188,
      clk_1 => clk_1_sg_x188,
      din => ram_data_out_net_x8,
      dout => ram_data_out_net_x0
    );

  logical7: entity work.logical_3f28e1f762
    port map (
      ce => ce_1_sg_x188,
      clk => clk_1_sg_x188,
      clr => '0',
      d0(0) => delay14_q_net_x1,
      d1(0) => ram_data_out_net_x2,
      d2(0) => ram_data_out_net_x3,
      d3(0) => ram_data_out_net_x1,
      d4(0) => ram_data_out_net_x4,
      d5(0) => ram_data_out_net_x5,
      d6(0) => ram_data_out_net_x6,
      d7(0) => ram_data_out_net_x7,
      d8(0) => ram_data_out_net_x8,
      d9(0) => ram_data_out_net_x0,
      y(0) => logical7_y_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture0/filter/delay_bram1"

entity delay_bram1_entity_35767b457f is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(20 downto 0); 
    dout: out std_logic_vector(20 downto 0)
  );
end delay_bram1_entity_35767b457f;

architecture structural of delay_bram1_entity_35767b457f is
  signal ce_1_sg_x189: std_logic;
  signal clk_1_sg_x189: std_logic;
  signal constant_op_net: std_logic;
  signal convert3_dout_net_x0: std_logic_vector(20 downto 0);
  signal counter_op_net: std_logic_vector(7 downto 0);
  signal ram_data_out_net_x0: std_logic_vector(20 downto 0);

begin
  ce_1_sg_x189 <= ce_1;
  clk_1_sg_x189 <= clk_1;
  convert3_dout_net_x0 <= din;
  dout <= ram_data_out_net_x0;

  constant_x0: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant_op_net
    );

  counter: entity work.xlcounter_limit_darkquad29
    generic map (
      cnt_15_0 => 252,
      cnt_31_16 => 0,
      cnt_47_32 => 0,
      cnt_63_48 => 0,
      core_name0 => "cntr_11_0_d1eeca027ba03819",
      count_limited => 1,
      op_arith => xlUnsigned,
      op_width => 8
    )
    port map (
      ce => ce_1_sg_x189,
      clk => clk_1_sg_x189,
      clr => '0',
      en => "1",
      rst => "0",
      op => counter_op_net
    );

  ram: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 21,
      core_name0 => "bmg_72_ccc293fe4d2b0f7a",
      latency => 1
    )
    port map (
      addr => counter_op_net,
      ce => ce_1_sg_x189,
      clk => clk_1_sg_x189,
      data_in => convert3_dout_net_x0,
      en => "1",
      rst => "0",
      we(0) => constant_op_net,
      data_out => ram_data_out_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture0/filter/delay_bram2"

entity delay_bram2_entity_42e727bcea is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(20 downto 0); 
    dout: out std_logic_vector(20 downto 0)
  );
end delay_bram2_entity_42e727bcea;

architecture structural of delay_bram2_entity_42e727bcea is
  signal ce_1_sg_x190: std_logic;
  signal clk_1_sg_x190: std_logic;
  signal constant_op_net: std_logic;
  signal convert3_dout_net_x1: std_logic_vector(20 downto 0);
  signal counter_op_net: std_logic_vector(7 downto 0);
  signal ram_data_out_net_x0: std_logic_vector(20 downto 0);

begin
  ce_1_sg_x190 <= ce_1;
  clk_1_sg_x190 <= clk_1;
  convert3_dout_net_x1 <= din;
  dout <= ram_data_out_net_x0;

  constant_x0: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant_op_net
    );

  counter: entity work.xlcounter_limit_darkquad29
    generic map (
      cnt_15_0 => 244,
      cnt_31_16 => 0,
      cnt_47_32 => 0,
      cnt_63_48 => 0,
      core_name0 => "cntr_11_0_d1eeca027ba03819",
      count_limited => 1,
      op_arith => xlUnsigned,
      op_width => 8
    )
    port map (
      ce => ce_1_sg_x190,
      clk => clk_1_sg_x190,
      clr => '0',
      en => "1",
      rst => "0",
      op => counter_op_net
    );

  ram: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 21,
      core_name0 => "bmg_72_ccc293fe4d2b0f7a",
      latency => 1
    )
    port map (
      addr => counter_op_net,
      ce => ce_1_sg_x190,
      clk => clk_1_sg_x190,
      data_in => convert3_dout_net_x1,
      en => "1",
      rst => "0",
      we(0) => constant_op_net,
      data_out => ram_data_out_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture0/filter/delay_bram5"

entity delay_bram5_entity_7bed078602 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(20 downto 0); 
    dout: out std_logic_vector(20 downto 0)
  );
end delay_bram5_entity_7bed078602;

architecture structural of delay_bram5_entity_7bed078602 is
  signal ce_1_sg_x192: std_logic;
  signal clk_1_sg_x192: std_logic;
  signal constant_op_net: std_logic;
  signal convert1_dout_net_x1: std_logic_vector(20 downto 0);
  signal counter_op_net: std_logic_vector(7 downto 0);
  signal ram_data_out_net_x0: std_logic_vector(20 downto 0);

begin
  ce_1_sg_x192 <= ce_1;
  clk_1_sg_x192 <= clk_1;
  convert1_dout_net_x1 <= din;
  dout <= ram_data_out_net_x0;

  constant_x0: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant_op_net
    );

  counter: entity work.xlcounter_limit_darkquad29
    generic map (
      cnt_15_0 => 240,
      cnt_31_16 => 0,
      cnt_47_32 => 0,
      cnt_63_48 => 0,
      core_name0 => "cntr_11_0_d1eeca027ba03819",
      count_limited => 1,
      op_arith => xlUnsigned,
      op_width => 8
    )
    port map (
      ce => ce_1_sg_x192,
      clk => clk_1_sg_x192,
      clr => '0',
      en => "1",
      rst => "0",
      op => counter_op_net
    );

  ram: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 21,
      core_name0 => "bmg_72_ccc293fe4d2b0f7a",
      latency => 1
    )
    port map (
      addr => counter_op_net,
      ce => ce_1_sg_x192,
      clk => clk_1_sg_x192,
      data_in => convert1_dout_net_x1,
      en => "1",
      rst => "0",
      we(0) => constant_op_net,
      data_out => ram_data_out_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture0/filter"

entity filter_entity_c79fa858fb is
  port (
    ce_1: in std_logic; 
    ch_in: in std_logic_vector(7 downto 0); 
    clk_1: in std_logic; 
    kf: in std_logic_vector(17 downto 0); 
    kq: in std_logic_vector(17 downto 0); 
    raw_in: in std_logic_vector(15 downto 0); 
    ch_out: out std_logic_vector(7 downto 0); 
    filtered_out: out std_logic_vector(15 downto 0); 
    raw_out: out std_logic_vector(15 downto 0); 
    res_out: out std_logic_vector(15 downto 0)
  );
end filter_entity_c79fa858fb;

architecture structural of filter_entity_c79fa858fb is
  signal addsub1_s_net: std_logic_vector(21 downto 0);
  signal addsub3_s_net: std_logic_vector(39 downto 0);
  signal addsub4_s_net: std_logic_vector(58 downto 0);
  signal addsub5_s_net: std_logic_vector(39 downto 0);
  signal addsub_s_net: std_logic_vector(16 downto 0);
  signal ce_1_sg_x193: std_logic;
  signal clk_1_sg_x193: std_logic;
  signal convert1_dout_net_x1: std_logic_vector(20 downto 0);
  signal convert2_dout_net: std_logic_vector(15 downto 0);
  signal convert3_dout_net_x1: std_logic_vector(20 downto 0);
  signal convert_dout_net_x0: std_logic_vector(15 downto 0);
  signal delay10_q_net: std_logic_vector(7 downto 0);
  signal delay11_q_net: std_logic_vector(15 downto 0);
  signal delay12_q_net: std_logic_vector(7 downto 0);
  signal delay13_q_net: std_logic_vector(15 downto 0);
  signal delay14_q_net: std_logic_vector(7 downto 0);
  signal delay15_q_net: std_logic_vector(7 downto 0);
  signal delay16_q_net: std_logic_vector(7 downto 0);
  signal delay17_q_net: std_logic_vector(15 downto 0);
  signal delay18_q_net: std_logic_vector(7 downto 0);
  signal delay19_q_net_x0: std_logic_vector(15 downto 0);
  signal delay20_q_net_x0: std_logic_vector(15 downto 0);
  signal delay21_q_net_x0: std_logic_vector(7 downto 0);
  signal delay25_q_net_x0: std_logic_vector(7 downto 0);
  signal delay27_q_net_x0: std_logic_vector(15 downto 0);
  signal delay3_q_net: std_logic_vector(15 downto 0);
  signal delay4_q_net: std_logic_vector(15 downto 0);
  signal delay5_q_net: std_logic_vector(15 downto 0);
  signal delay6_q_net: std_logic_vector(15 downto 0);
  signal delay7_q_net: std_logic_vector(15 downto 0);
  signal delay8_q_net: std_logic_vector(15 downto 0);
  signal delay9_q_net: std_logic_vector(15 downto 0);
  signal mult1_p_net: std_logic_vector(38 downto 0);
  signal mult2_p_net: std_logic_vector(57 downto 0);
  signal mult3_p_net: std_logic_vector(38 downto 0);
  signal ram_data_out_net_x0: std_logic_vector(20 downto 0);
  signal ram_data_out_net_x1: std_logic_vector(20 downto 0);
  signal ram_data_out_net_x2: std_logic_vector(20 downto 0);
  signal ram_data_out_net_x3: std_logic_vector(20 downto 0);
  signal register1_q_net_x1: std_logic_vector(17 downto 0);
  signal register1_q_net_x2: std_logic_vector(17 downto 0);

begin
  ce_1_sg_x193 <= ce_1;
  delay25_q_net_x0 <= ch_in;
  clk_1_sg_x193 <= clk_1;
  register1_q_net_x2 <= kf;
  register1_q_net_x1 <= kq;
  delay27_q_net_x0 <= raw_in;
  ch_out <= delay21_q_net_x0;
  filtered_out <= delay19_q_net_x0;
  raw_out <= delay20_q_net_x0;
  res_out <= convert_dout_net_x0;

  addsub: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 13,
      a_width => 16,
      b_arith => xlSigned,
      b_bin_pt => 13,
      b_width => 16,
      c_has_c_out => 0,
      c_latency => 1,
      c_output_width => 17,
      core_name0 => "addsb_11_0_c326c4567b3c5b63",
      extra_registers => 0,
      full_s_arith => 2,
      full_s_width => 17,
      latency => 1,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 13,
      s_width => 17
    )
    port map (
      a => delay9_q_net,
      b => delay8_q_net,
      ce => ce_1_sg_x193,
      clk => clk_1_sg_x193,
      clr => '0',
      en => "1",
      s => addsub_s_net
    );

  addsub1: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 13,
      a_width => 16,
      b_arith => xlSigned,
      b_bin_pt => 18,
      b_width => 21,
      c_has_c_out => 0,
      c_latency => 1,
      c_output_width => 22,
      core_name0 => "addsb_11_0_d5c2386c66db1f8d",
      extra_registers => 2,
      full_s_arith => 2,
      full_s_width => 22,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 18,
      s_width => 22
    )
    port map (
      a => delay27_q_net_x0,
      b => ram_data_out_net_x3,
      ce => ce_1_sg_x193,
      clk => clk_1_sg_x193,
      clr => '0',
      en => "1",
      s => addsub1_s_net
    );

  addsub3: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 18,
      a_width => 22,
      b_arith => xlSigned,
      b_bin_pt => 34,
      b_width => 39,
      c_has_c_out => 0,
      c_latency => 1,
      c_output_width => 40,
      core_name0 => "addsb_11_0_905959d61544ac3e",
      extra_registers => 0,
      full_s_arith => 2,
      full_s_width => 40,
      latency => 1,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 34,
      s_width => 40
    )
    port map (
      a => addsub1_s_net,
      b => mult1_p_net,
      ce => ce_1_sg_x193,
      clk => clk_1_sg_x193,
      clr => '0',
      en => "1",
      s => addsub3_s_net
    );

  addsub4: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 50,
      a_width => 58,
      b_arith => xlSigned,
      b_bin_pt => 18,
      b_width => 21,
      c_has_c_out => 0,
      c_latency => 1,
      c_output_width => 59,
      core_name0 => "addsb_11_0_d58a8e32191e1b22",
      extra_registers => 0,
      full_s_arith => 2,
      full_s_width => 59,
      latency => 1,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 50,
      s_width => 59
    )
    port map (
      a => mult2_p_net,
      b => ram_data_out_net_x0,
      ce => ce_1_sg_x193,
      clk => clk_1_sg_x193,
      clr => '0',
      en => "1",
      s => addsub4_s_net
    );

  addsub5: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 34,
      a_width => 39,
      b_arith => xlSigned,
      b_bin_pt => 18,
      b_width => 21,
      c_has_c_out => 0,
      c_latency => 1,
      c_output_width => 40,
      core_name0 => "addsb_11_0_18c07b39a9f6c777",
      extra_registers => 0,
      full_s_arith => 2,
      full_s_width => 40,
      latency => 1,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 34,
      s_width => 40
    )
    port map (
      a => mult3_p_net,
      b => ram_data_out_net_x2,
      ce => ce_1_sg_x193,
      clk => clk_1_sg_x193,
      clr => '0',
      en => "1",
      s => addsub5_s_net
    );

  convert: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 13,
      din_width => 17,
      dout_arith => 2,
      dout_bin_pt => 13,
      dout_width => 16,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x193,
      clk => clk_1_sg_x193,
      clr => '0',
      din => addsub_s_net,
      en => "1",
      dout => convert_dout_net_x0
    );

  convert1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 34,
      din_width => 40,
      dout_arith => 2,
      dout_bin_pt => 18,
      dout_width => 21,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x193,
      clk => clk_1_sg_x193,
      clr => '0',
      din => addsub5_s_net,
      en => "1",
      dout => convert1_dout_net_x1
    );

  convert2: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 34,
      din_width => 40,
      dout_arith => 2,
      dout_bin_pt => 13,
      dout_width => 16,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x193,
      clk => clk_1_sg_x193,
      clr => '0',
      din => addsub3_s_net,
      en => "1",
      dout => convert2_dout_net
    );

  convert3: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 50,
      din_width => 59,
      dout_arith => 2,
      dout_bin_pt => 18,
      dout_width => 21,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x193,
      clk => clk_1_sg_x193,
      clr => '0',
      din => addsub4_s_net,
      en => "1",
      dout => convert3_dout_net_x1
    );

  delay10: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x193,
      clk => clk_1_sg_x193,
      d => delay12_q_net,
      en => '1',
      rst => '1',
      q => delay10_q_net
    );

  delay11: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x193,
      clk => clk_1_sg_x193,
      d => delay13_q_net,
      en => '1',
      rst => '1',
      q => delay11_q_net
    );

  delay12: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x193,
      clk => clk_1_sg_x193,
      d => delay14_q_net,
      en => '1',
      rst => '1',
      q => delay12_q_net
    );

  delay13: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x193,
      clk => clk_1_sg_x193,
      d => delay4_q_net,
      en => '1',
      rst => '1',
      q => delay13_q_net
    );

  delay14: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x193,
      clk => clk_1_sg_x193,
      d => delay15_q_net,
      en => '1',
      rst => '1',
      q => delay14_q_net
    );

  delay15: entity work.xldelay
    generic map (
      latency => 4,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x193,
      clk => clk_1_sg_x193,
      d => delay18_q_net,
      en => '1',
      rst => '1',
      q => delay15_q_net
    );

  delay16: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x193,
      clk => clk_1_sg_x193,
      d => delay25_q_net_x0,
      en => '1',
      rst => '1',
      q => delay16_q_net
    );

  delay17: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x193,
      clk => clk_1_sg_x193,
      d => delay5_q_net,
      en => '1',
      rst => '1',
      q => delay17_q_net
    );

  delay18: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x193,
      clk => clk_1_sg_x193,
      d => delay16_q_net,
      en => '1',
      rst => '1',
      q => delay18_q_net
    );

  delay19: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x193,
      clk => clk_1_sg_x193,
      d => delay8_q_net,
      en => '1',
      rst => '1',
      q => delay19_q_net_x0
    );

  delay20: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x193,
      clk => clk_1_sg_x193,
      d => delay9_q_net,
      en => '1',
      rst => '1',
      q => delay20_q_net_x0
    );

  delay21: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x193,
      clk => clk_1_sg_x193,
      d => delay10_q_net,
      en => '1',
      rst => '1',
      q => delay21_q_net_x0
    );

  delay3: entity work.xldelay
    generic map (
      latency => 4,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x193,
      clk => clk_1_sg_x193,
      d => convert2_dout_net,
      en => '1',
      rst => '1',
      q => delay3_q_net
    );

  delay4: entity work.xldelay
    generic map (
      latency => 4,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x193,
      clk => clk_1_sg_x193,
      d => delay17_q_net,
      en => '1',
      rst => '1',
      q => delay4_q_net
    );

  delay5: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x193,
      clk => clk_1_sg_x193,
      d => delay27_q_net_x0,
      en => '1',
      rst => '1',
      q => delay5_q_net
    );

  delay6: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x193,
      clk => clk_1_sg_x193,
      d => delay3_q_net,
      en => '1',
      rst => '1',
      q => delay6_q_net
    );

  delay7: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x193,
      clk => clk_1_sg_x193,
      d => delay6_q_net,
      en => '1',
      rst => '1',
      q => delay7_q_net
    );

  delay8: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x193,
      clk => clk_1_sg_x193,
      d => delay7_q_net,
      en => '1',
      rst => '1',
      q => delay8_q_net
    );

  delay9: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x193,
      clk => clk_1_sg_x193,
      d => delay11_q_net,
      en => '1',
      rst => '1',
      q => delay9_q_net
    );

  delay_bram1_35767b457f: entity work.delay_bram1_entity_35767b457f
    port map (
      ce_1 => ce_1_sg_x193,
      clk_1 => clk_1_sg_x193,
      din => convert3_dout_net_x1,
      dout => ram_data_out_net_x0
    );

  delay_bram2_42e727bcea: entity work.delay_bram2_entity_42e727bcea
    port map (
      ce_1 => ce_1_sg_x193,
      clk_1 => clk_1_sg_x193,
      din => convert3_dout_net_x1,
      dout => ram_data_out_net_x1
    );

  delay_bram4_24ba55b66f: entity work.delay_bram1_entity_35767b457f
    port map (
      ce_1 => ce_1_sg_x193,
      clk_1 => clk_1_sg_x193,
      din => convert1_dout_net_x1,
      dout => ram_data_out_net_x2
    );

  delay_bram5_7bed078602: entity work.delay_bram5_entity_7bed078602
    port map (
      ce_1 => ce_1_sg_x193,
      clk_1 => clk_1_sg_x193,
      din => convert1_dout_net_x1,
      dout => ram_data_out_net_x3
    );

  mult1: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 18,
      a_width => 21,
      b_arith => xlSigned,
      b_bin_pt => 16,
      b_width => 18,
      c_a_type => 0,
      c_a_width => 21,
      c_b_type => 0,
      c_b_width => 18,
      c_baat => 21,
      c_output_width => 39,
      c_type => 0,
      core_name0 => "mult_11_2_d3611e41a47815a8",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 34,
      p_width => 39,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x1,
      b => register1_q_net_x1,
      ce => ce_1_sg_x193,
      clk => clk_1_sg_x193,
      clr => '0',
      core_ce => ce_1_sg_x193,
      core_clk => clk_1_sg_x193,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult1_p_net
    );

  mult2: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 34,
      a_width => 40,
      b_arith => xlSigned,
      b_bin_pt => 16,
      b_width => 18,
      c_a_type => 0,
      c_a_width => 40,
      c_b_type => 0,
      c_b_width => 18,
      c_baat => 40,
      c_output_width => 58,
      c_type => 0,
      core_name0 => "mult_11_2_0d4e928dcde39e83",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 50,
      p_width => 58,
      quantization => 1
    )
    port map (
      a => addsub3_s_net,
      b => register1_q_net_x2,
      ce => ce_1_sg_x193,
      clk => clk_1_sg_x193,
      clr => '0',
      core_ce => ce_1_sg_x193,
      core_clk => clk_1_sg_x193,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult2_p_net
    );

  mult3: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 18,
      a_width => 21,
      b_arith => xlSigned,
      b_bin_pt => 16,
      b_width => 18,
      c_a_type => 0,
      c_a_width => 21,
      c_b_type => 0,
      c_b_width => 18,
      c_baat => 21,
      c_output_width => 39,
      c_type => 0,
      core_name0 => "mult_11_2_d3611e41a47815a8",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 34,
      p_width => 39,
      quantization => 1
    )
    port map (
      a => convert3_dout_net_x1,
      b => register1_q_net_x2,
      ce => ce_1_sg_x193,
      clk => clk_1_sg_x193,
      clr => '0',
      core_ce => ce_1_sg_x193,
      core_clk => clk_1_sg_x193,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult3_p_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture0/lim_cps"

entity lim_cps_entity_99d2deee63 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    lim: in std_logic_vector(14 downto 0); 
    pps: in std_logic; 
    trig: in std_logic; 
    under_cap: out std_logic
  );
end lim_cps_entity_99d2deee63;

architecture structural of lim_cps_entity_99d2deee63 is
  signal addsub_s_net: std_logic_vector(12 downto 0);
  signal ce_1_sg_x196: std_logic;
  signal clk_1_sg_x196: std_logic;
  signal constant3_op_net: std_logic_vector(12 downto 0);
  signal constant_op_net: std_logic_vector(12 downto 0);
  signal delay12_q_net: std_logic;
  signal delay13_q_net_x0: std_logic_vector(12 downto 0);
  signal delay13_q_net_x1: std_logic;
  signal delay1_q_net: std_logic;
  signal delay2_q_net_x1: std_logic;
  signal delay34_q_net_x0: std_logic;
  signal delay73_q_net: std_logic_vector(12 downto 0);
  signal logical3_y_net: std_logic;
  signal mux2_y_net: std_logic_vector(12 downto 0);
  signal mux_y_net: std_logic_vector(12 downto 0);
  signal register1_q_net_x0: std_logic_vector(14 downto 0);
  signal relational5_op_net_x0: std_logic;
  signal relational5_op_net_x1: std_logic;

begin
  ce_1_sg_x196 <= ce_1;
  clk_1_sg_x196 <= clk_1;
  register1_q_net_x0 <= lim;
  delay34_q_net_x0 <= pps;
  delay13_q_net_x1 <= trig;
  under_cap <= relational5_op_net_x1;

  addsub: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlUnsigned,
      a_bin_pt => 0,
      a_width => 13,
      b_arith => xlUnsigned,
      b_bin_pt => 0,
      b_width => 13,
      c_has_c_out => 0,
      c_latency => 1,
      c_output_width => 14,
      core_name0 => "addsb_11_0_ccc02b0ec9bb7d2f",
      extra_registers => 2,
      full_s_arith => 1,
      full_s_width => 14,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlUnsigned,
      s_bin_pt => 0,
      s_width => 13
    )
    port map (
      a => delay13_q_net_x0,
      b => constant3_op_net,
      ce => ce_1_sg_x196,
      clk => clk_1_sg_x196,
      clr => '0',
      en => "1",
      s => addsub_s_net
    );

  constant3: entity work.constant_50be3b5040
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant3_op_net
    );

  constant_x0: entity work.constant_0c8736a503
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant_op_net
    );

  delay1: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x196,
      clk => clk_1_sg_x196,
      d(0) => delay34_q_net_x0,
      en => '1',
      rst => '1',
      q(0) => delay1_q_net
    );

  delay12: entity work.delay_be3fbaeea3
    port map (
      ce => ce_1_sg_x196,
      clk => clk_1_sg_x196,
      clr => '0',
      d(0) => relational5_op_net_x1,
      q(0) => delay12_q_net
    );

  delay13: entity work.xldelay
    generic map (
      latency => 251,
      reg_retiming => 0,
      reset => 0,
      width => 13
    )
    port map (
      ce => ce_1_sg_x196,
      clk => clk_1_sg_x196,
      d => mux_y_net,
      en => '1',
      rst => '1',
      q => delay13_q_net_x0
    );

  delay2: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x196,
      clk => clk_1_sg_x196,
      d(0) => delay1_q_net,
      en => '1',
      rst => '1',
      q(0) => delay2_q_net_x1
    );

  delay73: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 13
    )
    port map (
      ce => ce_1_sg_x196,
      clk => clk_1_sg_x196,
      d => delay13_q_net_x0,
      en => '1',
      rst => '1',
      q => delay73_q_net
    );

  logical3: entity work.logical_4239a88767
    port map (
      ce => ce_1_sg_x196,
      clk => clk_1_sg_x196,
      clr => '0',
      d0(0) => delay13_q_net_x1,
      d1(0) => delay12_q_net,
      y(0) => logical3_y_net
    );

  mux: entity work.mux_7fc381b8fa
    port map (
      ce => ce_1_sg_x196,
      clk => clk_1_sg_x196,
      clr => '0',
      d0 => mux2_y_net,
      d1 => constant_op_net,
      sel(0) => relational5_op_net_x0,
      y => mux_y_net
    );

  mux2: entity work.mux_7fc381b8fa
    port map (
      ce => ce_1_sg_x196,
      clk => clk_1_sg_x196,
      clr => '0',
      d0 => delay73_q_net,
      d1 => addsub_s_net,
      sel(0) => logical3_y_net,
      y => mux2_y_net
    );

  pulse_ext256_968cfe0b0d: entity work.pulse_ext_entity_a9f8db2fd2
    port map (
      ce_1 => ce_1_sg_x196,
      clk_1 => clk_1_sg_x196,
      in_x0 => delay2_q_net_x1,
      out_x0 => relational5_op_net_x0
    );

  relational5: entity work.relational_0ce8e2557d
    port map (
      a => mux_y_net,
      b => register1_q_net_x0,
      ce => ce_1_sg_x196,
      clk => clk_1_sg_x196,
      clr => '0',
      op(0) => relational5_op_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture0/load_thresh"

entity load_thresh_entity_d7e3bf0a22 is
  port (
    darkquad29_capture0_load_thresh_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end load_thresh_entity_d7e3bf0a22;

architecture structural of load_thresh_entity_d7e3bf0a22 is
  signal darkquad29_capture0_load_thresh_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_capture0_load_thresh_user_data_out_net_x0 <= darkquad29_capture0_load_thresh_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_capture0_load_thresh_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture0/pipeline1"

entity pipeline1_entity_ce5d488c45 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(17 downto 0); 
    q: out std_logic_vector(17 downto 0)
  );
end pipeline1_entity_ce5d488c45;

architecture structural of pipeline1_entity_ce5d488c45 is
  signal ce_1_sg_x197: std_logic;
  signal clk_1_sg_x197: std_logic;
  signal register0_q_net: std_logic_vector(17 downto 0);
  signal register1_q_net_x2: std_logic_vector(17 downto 0);
  signal reinterpret3_output_port_net_x0: std_logic_vector(17 downto 0);

begin
  ce_1_sg_x197 <= ce_1;
  clk_1_sg_x197 <= clk_1;
  reinterpret3_output_port_net_x0 <= d;
  q <= register1_q_net_x2;

  register0: entity work.xlregister
    generic map (
      d_width => 18,
      init_value => b"000000000000000000"
    )
    port map (
      ce => ce_1_sg_x197,
      clk => clk_1_sg_x197,
      d => reinterpret3_output_port_net_x0,
      en => "1",
      rst => "0",
      q => register0_q_net
    );

  register1: entity work.xlregister
    generic map (
      d_width => 18,
      init_value => b"000000000000000000"
    )
    port map (
      ce => ce_1_sg_x197,
      clk => clk_1_sg_x197,
      d => register0_q_net,
      en => "1",
      rst => "0",
      q => register1_q_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture0/pipeline2"

entity pipeline2_entity_5eadf3bb39 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(19 downto 0); 
    q: out std_logic_vector(19 downto 0)
  );
end pipeline2_entity_5eadf3bb39;

architecture structural of pipeline2_entity_5eadf3bb39 is
  signal ce_1_sg_x198: std_logic;
  signal clk_1_sg_x198: std_logic;
  signal delay66_q_net_x0: std_logic_vector(19 downto 0);
  signal register0_q_net: std_logic_vector(19 downto 0);
  signal register1_q_net_x0: std_logic_vector(19 downto 0);

begin
  ce_1_sg_x198 <= ce_1;
  clk_1_sg_x198 <= clk_1;
  delay66_q_net_x0 <= d;
  q <= register1_q_net_x0;

  register0: entity work.xlregister
    generic map (
      d_width => 20,
      init_value => b"00000000000000000000"
    )
    port map (
      ce => ce_1_sg_x198,
      clk => clk_1_sg_x198,
      d => delay66_q_net_x0,
      en => "1",
      rst => "0",
      q => register0_q_net
    );

  register1: entity work.xlregister
    generic map (
      d_width => 20,
      init_value => b"00000000000000000000"
    )
    port map (
      ce => ce_1_sg_x198,
      clk => clk_1_sg_x198,
      d => register0_q_net,
      en => "1",
      rst => "0",
      q => register1_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture0/pipeline7"

entity pipeline7_entity_51dd812305 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(14 downto 0); 
    q: out std_logic_vector(14 downto 0)
  );
end pipeline7_entity_51dd812305;

architecture structural of pipeline7_entity_51dd812305 is
  signal ce_1_sg_x200: std_logic;
  signal clk_1_sg_x200: std_logic;
  signal register0_q_net: std_logic_vector(14 downto 0);
  signal register1_q_net_x1: std_logic_vector(14 downto 0);
  signal slice4_y_net_x0: std_logic_vector(14 downto 0);

begin
  ce_1_sg_x200 <= ce_1;
  clk_1_sg_x200 <= clk_1;
  slice4_y_net_x0 <= d;
  q <= register1_q_net_x1;

  register0: entity work.xlregister
    generic map (
      d_width => 15,
      init_value => b"000000000000000"
    )
    port map (
      ce => ce_1_sg_x200,
      clk => clk_1_sg_x200,
      d => slice4_y_net_x0,
      en => "1",
      rst => "0",
      q => register0_q_net
    );

  register1: entity work.xlregister
    generic map (
      d_width => 15,
      init_value => b"000000000000000"
    )
    port map (
      ce => ce_1_sg_x200,
      clk => clk_1_sg_x200,
      d => register0_q_net,
      en => "1",
      rst => "0",
      q => register1_q_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture0/pix/calc_add"

entity calc_add_entity_27b5517daf is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(7 downto 0); 
    out_x0: out std_logic_vector(9 downto 0)
  );
end calc_add_entity_27b5517daf;

architecture structural of calc_add_entity_27b5517daf is
  signal add_sub_s_net: std_logic;
  signal ce_1_sg_x201: std_logic;
  signal clk_1_sg_x201: std_logic;
  signal concat_y_net: std_logic_vector(9 downto 0);
  signal const_op_net: std_logic;
  signal convert_addr_dout_net: std_logic_vector(9 downto 0);
  signal delay6_q_net_x0: std_logic_vector(7 downto 0);
  signal lsw_y_net: std_logic;
  signal manipulate_op_net: std_logic;
  signal msw_y_net: std_logic_vector(8 downto 0);
  signal mux_y_net_x0: std_logic_vector(9 downto 0);

begin
  ce_1_sg_x201 <= ce_1;
  clk_1_sg_x201 <= clk_1;
  delay6_q_net_x0 <= in_x0;
  out_x0 <= mux_y_net_x0;

  add_sub: entity work.addsub_c13097e33e
    port map (
      a(0) => const_op_net,
      b(0) => lsw_y_net,
      ce => ce_1_sg_x201,
      clk => clk_1_sg_x201,
      clr => '0',
      s(0) => add_sub_s_net
    );

  concat: entity work.concat_1d98d96b58
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => msw_y_net,
      in1(0) => add_sub_s_net,
      y => concat_y_net
    );

  const: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => const_op_net
    );

  convert_addr: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 8,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 10,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x201,
      clk => clk_1_sg_x201,
      clr => '0',
      din => delay6_q_net_x0,
      en => "1",
      dout => convert_addr_dout_net
    );

  lsw: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 10,
      y_width => 1
    )
    port map (
      x => convert_addr_dout_net,
      y(0) => lsw_y_net
    );

  manipulate: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => manipulate_op_net
    );

  msw: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 9,
      x_width => 10,
      y_width => 9
    )
    port map (
      x => convert_addr_dout_net,
      y => msw_y_net
    );

  mux: entity work.mux_4fe5face7f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0 => convert_addr_dout_net,
      d1 => concat_y_net,
      sel(0) => manipulate_op_net,
      y => mux_y_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture0/pix/munge_in"

entity munge_in_entity_9df1f10b0c is
  port (
    din: in std_logic_vector(9 downto 0); 
    dout: out std_logic_vector(9 downto 0)
  );
end munge_in_entity_9df1f10b0c;

architecture structural of munge_in_entity_9df1f10b0c is
  signal constant3_op_net_x0: std_logic_vector(9 downto 0);
  signal reinterpret_out_output_port_net_x0: std_logic_vector(9 downto 0);

begin
  constant3_op_net_x0 <= din;
  dout <= reinterpret_out_output_port_net_x0;

  reinterpret_out: entity work.reinterpret_7093fd32f4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => constant3_op_net_x0,
      output_port => reinterpret_out_output_port_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture0/pix"

entity pix_entity_883e660ce7 is
  port (
    addr: in std_logic_vector(7 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    darkquad29_capture0_pix_data_out: in std_logic_vector(31 downto 0); 
    data_in: in std_logic_vector(9 downto 0); 
    we: in std_logic; 
    convert_addr_x0: out std_logic_vector(9 downto 0); 
    convert_din1_x0: out std_logic_vector(31 downto 0); 
    convert_we_x0: out std_logic; 
    data_out: out std_logic_vector(31 downto 0)
  );
end pix_entity_883e660ce7;

architecture structural of pix_entity_883e660ce7 is
  signal ce_1_sg_x202: std_logic;
  signal clk_1_sg_x202: std_logic;
  signal constant2_op_net_x0: std_logic;
  signal constant3_op_net_x1: std_logic_vector(9 downto 0);
  signal convert_addr_dout_net_x0: std_logic_vector(9 downto 0);
  signal convert_din1_dout_net_x0: std_logic_vector(31 downto 0);
  signal convert_we_dout_net_x0: std_logic;
  signal darkquad29_capture0_pix_data_out_net_x1: std_logic_vector(31 downto 0);
  signal delay6_q_net_x1: std_logic_vector(7 downto 0);
  signal mux_y_net_x0: std_logic_vector(9 downto 0);
  signal reinterpret_out_output_port_net_x0: std_logic_vector(9 downto 0);
  signal reinterpret_out_output_port_net_x2: std_logic_vector(31 downto 0);

begin
  delay6_q_net_x1 <= addr;
  ce_1_sg_x202 <= ce_1;
  clk_1_sg_x202 <= clk_1;
  darkquad29_capture0_pix_data_out_net_x1 <= darkquad29_capture0_pix_data_out;
  constant3_op_net_x1 <= data_in;
  constant2_op_net_x0 <= we;
  convert_addr_x0 <= convert_addr_dout_net_x0;
  convert_din1_x0 <= convert_din1_dout_net_x0;
  convert_we_x0 <= convert_we_dout_net_x0;
  data_out <= reinterpret_out_output_port_net_x2;

  calc_add_27b5517daf: entity work.calc_add_entity_27b5517daf
    port map (
      ce_1 => ce_1_sg_x202,
      clk_1 => clk_1_sg_x202,
      in_x0 => delay6_q_net_x1,
      out_x0 => mux_y_net_x0
    );

  convert_addr: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 10,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 10,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x202,
      clk => clk_1_sg_x202,
      clr => '0',
      din => mux_y_net_x0,
      en => "1",
      dout => convert_addr_dout_net_x0
    );

  convert_din1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 10,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x202,
      clk => clk_1_sg_x202,
      clr => '0',
      din => reinterpret_out_output_port_net_x0,
      en => "1",
      dout => convert_din1_dout_net_x0
    );

  convert_we: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x202,
      clk => clk_1_sg_x202,
      clr => '0',
      din(0) => constant2_op_net_x0,
      en => "1",
      dout(0) => convert_we_dout_net_x0
    );

  munge_in_9df1f10b0c: entity work.munge_in_entity_9df1f10b0c
    port map (
      din => constant3_op_net_x1,
      dout => reinterpret_out_output_port_net_x0
    );

  munge_out_b72e8811ff: entity work.munge_in_entity_9341d54c73
    port map (
      din => darkquad29_capture0_pix_data_out_net_x1,
      dout => reinterpret_out_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture0/threshold"

entity threshold_entity_5cc5c4779d is
  port (
    darkquad29_capture0_threshold_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end threshold_entity_5cc5c4779d;

architecture structural of threshold_entity_5cc5c4779d is
  signal darkquad29_capture0_threshold_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_capture0_threshold_user_data_out_net_x0 <= darkquad29_capture0_threshold_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_capture0_threshold_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture0/trigger/delay_bram1"

entity delay_bram1_entity_2b7890f9d1 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(15 downto 0); 
    dout: out std_logic_vector(15 downto 0)
  );
end delay_bram1_entity_2b7890f9d1;

architecture structural of delay_bram1_entity_2b7890f9d1 is
  signal ce_1_sg_x203: std_logic;
  signal clk_1_sg_x203: std_logic;
  signal constant_op_net: std_logic;
  signal counter_op_net: std_logic_vector(8 downto 0);
  signal delay10_q_net_x0: std_logic_vector(15 downto 0);
  signal ram_data_out_net_x0: std_logic_vector(15 downto 0);

begin
  ce_1_sg_x203 <= ce_1;
  clk_1_sg_x203 <= clk_1;
  delay10_q_net_x0 <= din;
  dout <= ram_data_out_net_x0;

  constant_x0: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant_op_net
    );

  counter: entity work.xlcounter_limit_darkquad29
    generic map (
      cnt_15_0 => 509,
      cnt_31_16 => 0,
      cnt_47_32 => 0,
      cnt_63_48 => 0,
      core_name0 => "cntr_11_0_ca10e447a1c1c04f",
      count_limited => 1,
      op_arith => xlUnsigned,
      op_width => 9
    )
    port map (
      ce => ce_1_sg_x203,
      clk => clk_1_sg_x203,
      clr => '0',
      en => "1",
      rst => "0",
      op => counter_op_net
    );

  ram: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 9,
      c_width => 16,
      core_name0 => "bmg_72_ee57e7186689376a",
      latency => 1
    )
    port map (
      addr => counter_op_net,
      ce => ce_1_sg_x203,
      clk => clk_1_sg_x203,
      data_in => delay10_q_net_x0,
      en => "1",
      rst => "0",
      we(0) => constant_op_net,
      data_out => ram_data_out_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture0/trigger/delay_bram10"

entity delay_bram10_entity_1b9961e04f is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic; 
    dout: out std_logic
  );
end delay_bram10_entity_1b9961e04f;

architecture structural of delay_bram10_entity_1b9961e04f is
  signal ce_1_sg_x204: std_logic;
  signal clk_1_sg_x204: std_logic;
  signal constant_op_net: std_logic;
  signal counter_op_net: std_logic_vector(8 downto 0);
  signal ram_data_out_net_x0: std_logic;
  signal relational5_op_net_x0: std_logic;

begin
  ce_1_sg_x204 <= ce_1;
  clk_1_sg_x204 <= clk_1;
  relational5_op_net_x0 <= din;
  dout <= ram_data_out_net_x0;

  constant_x0: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant_op_net
    );

  counter: entity work.xlcounter_limit_darkquad29
    generic map (
      cnt_15_0 => 509,
      cnt_31_16 => 0,
      cnt_47_32 => 0,
      cnt_63_48 => 0,
      core_name0 => "cntr_11_0_ca10e447a1c1c04f",
      count_limited => 1,
      op_arith => xlUnsigned,
      op_width => 9
    )
    port map (
      ce => ce_1_sg_x204,
      clk => clk_1_sg_x204,
      clr => '0',
      en => "1",
      rst => "0",
      op => counter_op_net
    );

  ram: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 9,
      c_width => 1,
      core_name0 => "bmg_72_79627314d23ed512",
      latency => 1
    )
    port map (
      addr => counter_op_net,
      ce => ce_1_sg_x204,
      clk => clk_1_sg_x204,
      data_in(0) => relational5_op_net_x0,
      en => "1",
      rst => "0",
      we(0) => constant_op_net,
      data_out(0) => ram_data_out_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture0/trigger/delay_bram2"

entity delay_bram2_entity_823e30d1a9 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic; 
    dout: out std_logic
  );
end delay_bram2_entity_823e30d1a9;

architecture structural of delay_bram2_entity_823e30d1a9 is
  signal ce_1_sg_x205: std_logic;
  signal clk_1_sg_x205: std_logic;
  signal constant_op_net: std_logic;
  signal counter_op_net: std_logic_vector(7 downto 0);
  signal delay45_q_net_x0: std_logic;
  signal ram_data_out_net_x0: std_logic;

begin
  ce_1_sg_x205 <= ce_1;
  clk_1_sg_x205 <= clk_1;
  delay45_q_net_x0 <= din;
  dout <= ram_data_out_net_x0;

  constant_x0: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant_op_net
    );

  counter: entity work.xlcounter_limit_darkquad29
    generic map (
      cnt_15_0 => 253,
      cnt_31_16 => 0,
      cnt_47_32 => 0,
      cnt_63_48 => 0,
      core_name0 => "cntr_11_0_564d43d07a40ef72",
      count_limited => 1,
      op_arith => xlUnsigned,
      op_width => 8
    )
    port map (
      ce => ce_1_sg_x205,
      clk => clk_1_sg_x205,
      clr => '0',
      en => "1",
      rst => "0",
      op => counter_op_net
    );

  ram: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 1,
      core_name0 => "bmg_72_5886869123e35b2f",
      latency => 1
    )
    port map (
      addr => counter_op_net,
      ce => ce_1_sg_x205,
      clk => clk_1_sg_x205,
      data_in(0) => delay45_q_net_x0,
      en => "1",
      rst => "0",
      we(0) => constant_op_net,
      data_out(0) => ram_data_out_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture0/trigger/delay_bram5"

entity delay_bram5_entity_44fa2015ec is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(7 downto 0); 
    dout: out std_logic_vector(7 downto 0)
  );
end delay_bram5_entity_44fa2015ec;

architecture structural of delay_bram5_entity_44fa2015ec is
  signal ce_1_sg_x208: std_logic;
  signal clk_1_sg_x208: std_logic;
  signal constant_op_net: std_logic;
  signal counter_op_net: std_logic_vector(8 downto 0);
  signal delay73_q_net_x0: std_logic_vector(7 downto 0);
  signal ram_data_out_net_x0: std_logic_vector(7 downto 0);

begin
  ce_1_sg_x208 <= ce_1;
  clk_1_sg_x208 <= clk_1;
  delay73_q_net_x0 <= din;
  dout <= ram_data_out_net_x0;

  constant_x0: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant_op_net
    );

  counter: entity work.xlcounter_limit_darkquad29
    generic map (
      cnt_15_0 => 509,
      cnt_31_16 => 0,
      cnt_47_32 => 0,
      cnt_63_48 => 0,
      core_name0 => "cntr_11_0_ca10e447a1c1c04f",
      count_limited => 1,
      op_arith => xlUnsigned,
      op_width => 9
    )
    port map (
      ce => ce_1_sg_x208,
      clk => clk_1_sg_x208,
      clr => '0',
      en => "1",
      rst => "0",
      op => counter_op_net
    );

  ram: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 9,
      c_width => 8,
      core_name0 => "bmg_72_6496c8c9773931f5",
      latency => 1
    )
    port map (
      addr => counter_op_net,
      ce => ce_1_sg_x208,
      clk => clk_1_sg_x208,
      data_in => delay73_q_net_x0,
      en => "1",
      rst => "0",
      we(0) => constant_op_net,
      data_out => ram_data_out_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture0/trigger/delay_bram6"

entity delay_bram6_entity_4df9fabe2b is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic; 
    dout: out std_logic
  );
end delay_bram6_entity_4df9fabe2b;

architecture structural of delay_bram6_entity_4df9fabe2b is
  signal ce_1_sg_x209: std_logic;
  signal clk_1_sg_x209: std_logic;
  signal constant_op_net: std_logic;
  signal counter_op_net: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x0: std_logic;
  signal reinterpret_output_port_net_x0: std_logic;

begin
  ce_1_sg_x209 <= ce_1;
  clk_1_sg_x209 <= clk_1;
  reinterpret_output_port_net_x0 <= din;
  dout <= ram_data_out_net_x0;

  constant_x0: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant_op_net
    );

  counter: entity work.xlcounter_limit_darkquad29
    generic map (
      cnt_15_0 => 2557,
      cnt_31_16 => 0,
      cnt_47_32 => 0,
      cnt_63_48 => 0,
      core_name0 => "cntr_11_0_0e7aae3b0f9694f8",
      count_limited => 1,
      op_arith => xlUnsigned,
      op_width => 12
    )
    port map (
      ce => ce_1_sg_x209,
      clk => clk_1_sg_x209,
      clr => '0',
      en => "1",
      rst => "0",
      op => counter_op_net
    );

  ram: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 12,
      c_width => 1,
      core_name0 => "bmg_72_b851979848828b10",
      latency => 1
    )
    port map (
      addr => counter_op_net,
      ce => ce_1_sg_x209,
      clk => clk_1_sg_x209,
      data_in(0) => reinterpret_output_port_net_x0,
      en => "1",
      rst => "0",
      we(0) => constant_op_net,
      data_out(0) => ram_data_out_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture0/trigger/delay_bram7"

entity delay_bram7_entity_09701768c8 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(9 downto 0); 
    dout: out std_logic_vector(9 downto 0)
  );
end delay_bram7_entity_09701768c8;

architecture structural of delay_bram7_entity_09701768c8 is
  signal addsub4_s_net_x0: std_logic_vector(9 downto 0);
  signal ce_1_sg_x210: std_logic;
  signal clk_1_sg_x210: std_logic;
  signal constant_op_net: std_logic;
  signal counter_op_net: std_logic_vector(7 downto 0);
  signal ram_data_out_net_x0: std_logic_vector(9 downto 0);

begin
  ce_1_sg_x210 <= ce_1;
  clk_1_sg_x210 <= clk_1;
  addsub4_s_net_x0 <= din;
  dout <= ram_data_out_net_x0;

  constant_x0: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant_op_net
    );

  counter: entity work.xlcounter_limit_darkquad29
    generic map (
      cnt_15_0 => 247,
      cnt_31_16 => 0,
      cnt_47_32 => 0,
      cnt_63_48 => 0,
      core_name0 => "cntr_11_0_d1eeca027ba03819",
      count_limited => 1,
      op_arith => xlUnsigned,
      op_width => 8
    )
    port map (
      ce => ce_1_sg_x210,
      clk => clk_1_sg_x210,
      clr => '0',
      en => "1",
      rst => "0",
      op => counter_op_net
    );

  ram: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 10,
      core_name0 => "bmg_72_c89b8e32d1739de7",
      latency => 1
    )
    port map (
      addr => counter_op_net,
      ce => ce_1_sg_x210,
      clk => clk_1_sg_x210,
      data_in => addsub4_s_net_x0,
      en => "1",
      rst => "0",
      we(0) => constant_op_net,
      data_out => ram_data_out_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture0/trigger/delay_bram9"

entity delay_bram9_entity_ef7acd49f3 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(15 downto 0); 
    dout: out std_logic_vector(15 downto 0)
  );
end delay_bram9_entity_ef7acd49f3;

architecture structural of delay_bram9_entity_ef7acd49f3 is
  signal ce_1_sg_x211: std_logic;
  signal clk_1_sg_x211: std_logic;
  signal constant_op_net: std_logic;
  signal counter_op_net: std_logic_vector(7 downto 0);
  signal delay26_q_net_x0: std_logic_vector(15 downto 0);
  signal ram_data_out_net_x0: std_logic_vector(15 downto 0);

begin
  ce_1_sg_x211 <= ce_1;
  clk_1_sg_x211 <= clk_1;
  delay26_q_net_x0 <= din;
  dout <= ram_data_out_net_x0;

  constant_x0: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant_op_net
    );

  counter: entity work.xlcounter_limit_darkquad29
    generic map (
      cnt_15_0 => 253,
      cnt_31_16 => 0,
      cnt_47_32 => 0,
      cnt_63_48 => 0,
      core_name0 => "cntr_11_0_564d43d07a40ef72",
      count_limited => 1,
      op_arith => xlUnsigned,
      op_width => 8
    )
    port map (
      ce => ce_1_sg_x211,
      clk => clk_1_sg_x211,
      clr => '0',
      en => "1",
      rst => "0",
      op => counter_op_net
    );

  ram: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 16,
      core_name0 => "bmg_72_0164249481f978ca",
      latency => 1
    )
    port map (
      addr => counter_op_net,
      ce => ce_1_sg_x211,
      clk => clk_1_sg_x211,
      data_in => delay26_q_net_x0,
      en => "1",
      rst => "0",
      we(0) => constant_op_net,
      data_out => ram_data_out_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture0/trigger"

entity trigger_entity_9aeb6a1bfd is
  port (
    baseline: in std_logic_vector(15 downto 0); 
    ce_1: in std_logic; 
    ch_in: in std_logic_vector(7 downto 0); 
    clk_1: in std_logic; 
    filtered_in: in std_logic_vector(15 downto 0); 
    raw_in: in std_logic_vector(15 downto 0); 
    threshold: in std_logic_vector(15 downto 0); 
    base_out: out std_logic_vector(15 downto 0); 
    ch_out: out std_logic_vector(7 downto 0); 
    data_out: out std_logic_vector(15 downto 0); 
    trigger: out std_logic
  );
end trigger_entity_9aeb6a1bfd;

architecture structural of trigger_entity_9aeb6a1bfd is
  signal addsub2_s_net: std_logic_vector(9 downto 0);
  signal addsub3_s_net: std_logic_vector(15 downto 0);
  signal addsub4_s_net_x0: std_logic_vector(9 downto 0);
  signal ce_1_sg_x212: std_logic;
  signal clk_1_sg_x212: std_logic;
  signal constant1_op_net: std_logic_vector(11 downto 0);
  signal constant4_op_net: std_logic_vector(7 downto 0);
  signal delay10_q_net_x0: std_logic_vector(15 downto 0);
  signal delay11_q_net: std_logic_vector(15 downto 0);
  signal delay12_q_net_x0: std_logic_vector(15 downto 0);
  signal delay13_q_net_x0: std_logic_vector(15 downto 0);
  signal delay14_q_net: std_logic;
  signal delay15_q_net_x0: std_logic_vector(15 downto 0);
  signal delay16_q_net: std_logic_vector(7 downto 0);
  signal delay17_q_net_x0: std_logic;
  signal delay18_q_net: std_logic_vector(7 downto 0);
  signal delay19_q_net: std_logic;
  signal delay1_q_net: std_logic_vector(15 downto 0);
  signal delay20_q_net: std_logic;
  signal delay25_q_net: std_logic_vector(15 downto 0);
  signal delay26_q_net: std_logic_vector(15 downto 0);
  signal delay26_q_net_x1: std_logic_vector(15 downto 0);
  signal delay27_q_net: std_logic;
  signal delay28_q_net_x0: std_logic_vector(15 downto 0);
  signal delay28_q_net_x1: std_logic_vector(7 downto 0);
  signal delay29_q_net: std_logic_vector(15 downto 0);
  signal delay2_q_net: std_logic_vector(15 downto 0);
  signal delay30_q_net_x0: std_logic;
  signal delay30_q_net_x1: std_logic_vector(15 downto 0);
  signal delay31_q_net_x0: std_logic;
  signal delay31_q_net_x1: std_logic_vector(15 downto 0);
  signal delay3_q_net: std_logic_vector(15 downto 0);
  signal delay44_q_net_x0: std_logic_vector(15 downto 0);
  signal delay45_q_net_x0: std_logic;
  signal delay5_q_net: std_logic_vector(15 downto 0);
  signal delay60_q_net: std_logic_vector(15 downto 0);
  signal delay66_q_net: std_logic_vector(7 downto 0);
  signal delay67_q_net: std_logic_vector(7 downto 0);
  signal delay68_q_net: std_logic_vector(7 downto 0);
  signal delay73_q_net_x0: std_logic_vector(7 downto 0);
  signal delay74_q_net_x0: std_logic_vector(7 downto 0);
  signal delay8_q_net: std_logic_vector(15 downto 0);
  signal delay9_q_net: std_logic;
  signal inverter_op_net: std_logic;
  signal logical7_y_net_x0: std_logic;
  signal ram_data_out_net_x0: std_logic_vector(15 downto 0);
  signal ram_data_out_net_x1: std_logic;
  signal ram_data_out_net_x2: std_logic;
  signal ram_data_out_net_x3: std_logic_vector(15 downto 0);
  signal ram_data_out_net_x4: std_logic;
  signal ram_data_out_net_x5: std_logic_vector(7 downto 0);
  signal ram_data_out_net_x6: std_logic;
  signal ram_data_out_net_x7: std_logic_vector(9 downto 0);
  signal ram_data_out_net_x8: std_logic_vector(15 downto 0);
  signal reinterpret_output_port_net_x0: std_logic;
  signal relational1_op_net: std_logic;
  signal relational2_op_net: std_logic;
  signal relational5_op_net_x0: std_logic;

begin
  delay31_q_net_x1 <= baseline;
  ce_1_sg_x212 <= ce_1;
  delay28_q_net_x1 <= ch_in;
  clk_1_sg_x212 <= clk_1;
  delay44_q_net_x0 <= filtered_in;
  delay26_q_net_x1 <= raw_in;
  delay30_q_net_x1 <= threshold;
  base_out <= delay13_q_net_x0;
  ch_out <= delay74_q_net_x0;
  data_out <= delay15_q_net_x0;
  trigger <= logical7_y_net_x0;

  addsub2: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlUnsigned,
      a_bin_pt => 0,
      a_width => 10,
      b_arith => xlUnsigned,
      b_bin_pt => 0,
      b_width => 1,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 11,
      core_name0 => "addsb_11_0_aa7bb2ad873d54b6",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 11,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlUnsigned,
      s_bin_pt => 0,
      s_width => 10
    )
    port map (
      a => ram_data_out_net_x7,
      b(0) => ram_data_out_net_x6,
      ce => ce_1_sg_x212,
      clk => clk_1_sg_x212,
      clr => '0',
      en => "1",
      s => addsub2_s_net
    );

  addsub3: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 13,
      a_width => 16,
      b_arith => xlSigned,
      b_bin_pt => 13,
      b_width => 16,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 17,
      core_name0 => "addsb_11_0_ce88f01554f26992",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 17,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 13,
      s_width => 16
    )
    port map (
      a => delay26_q_net_x1,
      b => ram_data_out_net_x8,
      ce => ce_1_sg_x212,
      clk => clk_1_sg_x212,
      clr => '0',
      en => "1",
      s => addsub3_s_net
    );

  addsub4: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlUnsigned,
      a_bin_pt => 0,
      a_width => 10,
      b_arith => xlUnsigned,
      b_bin_pt => 0,
      b_width => 1,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 11,
      core_name0 => "addsb_11_0_f46b761f6397bd18",
      extra_registers => 1,
      full_s_arith => 1,
      full_s_width => 11,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlUnsigned,
      s_bin_pt => 0,
      s_width => 10
    )
    port map (
      a => addsub2_s_net,
      b(0) => delay20_q_net,
      ce => ce_1_sg_x212,
      clk => clk_1_sg_x212,
      clr => '0',
      en => "1",
      s => addsub4_s_net_x0
    );

  constant1: entity work.constant_fd28b32bf8
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant1_op_net
    );

  constant4: entity work.constant_ac4da3a0cc
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant4_op_net
    );

  delay1: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x212,
      clk => clk_1_sg_x212,
      d => delay28_q_net_x0,
      en => '1',
      rst => '1',
      q => delay1_q_net
    );

  delay10: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x212,
      clk => clk_1_sg_x212,
      d => delay2_q_net,
      en => '1',
      rst => '1',
      q => delay10_q_net_x0
    );

  delay11: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x212,
      clk => clk_1_sg_x212,
      d => delay3_q_net,
      en => '1',
      rst => '1',
      q => delay11_q_net
    );

  delay12: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x212,
      clk => clk_1_sg_x212,
      d => delay8_q_net,
      en => '1',
      rst => '1',
      q => delay12_q_net_x0
    );

  delay13: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x212,
      clk => clk_1_sg_x212,
      d => ram_data_out_net_x3,
      en => '1',
      rst => '1',
      q => delay13_q_net_x0
    );

  delay14: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x212,
      clk => clk_1_sg_x212,
      d(0) => delay9_q_net,
      en => '1',
      rst => '1',
      q(0) => delay14_q_net
    );

  delay15: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x212,
      clk => clk_1_sg_x212,
      d => ram_data_out_net_x0,
      en => '1',
      rst => '1',
      q => delay15_q_net_x0
    );

  delay16: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x212,
      clk => clk_1_sg_x212,
      d => delay18_q_net,
      en => '1',
      rst => '1',
      q => delay16_q_net
    );

  delay17: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x212,
      clk => clk_1_sg_x212,
      d(0) => delay14_q_net,
      en => '1',
      rst => '1',
      q(0) => delay17_q_net_x0
    );

  delay18: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x212,
      clk => clk_1_sg_x212,
      d => delay68_q_net,
      en => '1',
      rst => '1',
      q => delay18_q_net
    );

  delay19: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x212,
      clk => clk_1_sg_x212,
      d(0) => inverter_op_net,
      en => '1',
      rst => '1',
      q(0) => delay19_q_net
    );

  delay2: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x212,
      clk => clk_1_sg_x212,
      d => delay1_q_net,
      en => '1',
      rst => '1',
      q => delay2_q_net
    );

  delay20: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x212,
      clk => clk_1_sg_x212,
      d(0) => reinterpret_output_port_net_x0,
      en => '1',
      rst => '1',
      q(0) => delay20_q_net
    );

  delay25: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x212,
      clk => clk_1_sg_x212,
      d => delay31_q_net_x1,
      en => '1',
      rst => '1',
      q => delay25_q_net
    );

  delay26: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x212,
      clk => clk_1_sg_x212,
      d => delay30_q_net_x1,
      en => '1',
      rst => '1',
      q => delay26_q_net
    );

  delay27: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x212,
      clk => clk_1_sg_x212,
      d(0) => relational2_op_net,
      en => '1',
      rst => '1',
      q(0) => delay27_q_net
    );

  delay28: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x212,
      clk => clk_1_sg_x212,
      d => delay11_q_net,
      en => '1',
      rst => '1',
      q => delay28_q_net_x0
    );

  delay29: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x212,
      clk => clk_1_sg_x212,
      d => delay60_q_net,
      en => '1',
      rst => '1',
      q => delay29_q_net
    );

  delay3: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x212,
      clk => clk_1_sg_x212,
      d => delay44_q_net_x0,
      en => '1',
      rst => '1',
      q => delay3_q_net
    );

  delay30: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x212,
      clk => clk_1_sg_x212,
      d(0) => relational1_op_net,
      en => '1',
      rst => '1',
      q(0) => delay30_q_net_x0
    );

  delay31: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x212,
      clk => clk_1_sg_x212,
      d(0) => delay19_q_net,
      en => '1',
      rst => '1',
      q(0) => delay31_q_net_x0
    );

  delay45: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x212,
      clk => clk_1_sg_x212,
      d(0) => delay31_q_net_x0,
      en => '1',
      rst => '1',
      q(0) => delay45_q_net_x0
    );

  delay5: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x212,
      clk => clk_1_sg_x212,
      d => delay29_q_net,
      en => '1',
      rst => '1',
      q => delay5_q_net
    );

  delay60: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x212,
      clk => clk_1_sg_x212,
      d => delay25_q_net,
      en => '1',
      rst => '1',
      q => delay60_q_net
    );

  delay66: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x212,
      clk => clk_1_sg_x212,
      d => delay28_q_net_x1,
      en => '1',
      rst => '1',
      q => delay66_q_net
    );

  delay67: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x212,
      clk => clk_1_sg_x212,
      d => delay66_q_net,
      en => '1',
      rst => '1',
      q => delay67_q_net
    );

  delay68: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x212,
      clk => clk_1_sg_x212,
      d => delay67_q_net,
      en => '1',
      rst => '1',
      q => delay68_q_net
    );

  delay73: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x212,
      clk => clk_1_sg_x212,
      d => delay16_q_net,
      en => '1',
      rst => '1',
      q => delay73_q_net_x0
    );

  delay74: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x212,
      clk => clk_1_sg_x212,
      d => ram_data_out_net_x5,
      en => '1',
      rst => '1',
      q => delay74_q_net_x0
    );

  delay8: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x212,
      clk => clk_1_sg_x212,
      d => delay5_q_net,
      en => '1',
      rst => '1',
      q => delay8_q_net
    );

  delay9: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x212,
      clk => clk_1_sg_x212,
      d(0) => delay30_q_net_x0,
      en => '1',
      rst => '1',
      q(0) => delay9_q_net
    );

  delay_bram10_1b9961e04f: entity work.delay_bram10_entity_1b9961e04f
    port map (
      ce_1 => ce_1_sg_x212,
      clk_1 => clk_1_sg_x212,
      din => relational5_op_net_x0,
      dout => ram_data_out_net_x1
    );

  delay_bram1_2b7890f9d1: entity work.delay_bram1_entity_2b7890f9d1
    port map (
      ce_1 => ce_1_sg_x212,
      clk_1 => clk_1_sg_x212,
      din => delay10_q_net_x0,
      dout => ram_data_out_net_x0
    );

  delay_bram2_823e30d1a9: entity work.delay_bram2_entity_823e30d1a9
    port map (
      ce_1 => ce_1_sg_x212,
      clk_1 => clk_1_sg_x212,
      din => delay45_q_net_x0,
      dout => ram_data_out_net_x2
    );

  delay_bram3_0db2aaf53b: entity work.delay_bram1_entity_2b7890f9d1
    port map (
      ce_1 => ce_1_sg_x212,
      clk_1 => clk_1_sg_x212,
      din => delay12_q_net_x0,
      dout => ram_data_out_net_x3
    );

  delay_bram4_4755cf187a: entity work.delay_bram10_entity_1b9961e04f
    port map (
      ce_1 => ce_1_sg_x212,
      clk_1 => clk_1_sg_x212,
      din => delay17_q_net_x0,
      dout => ram_data_out_net_x4
    );

  delay_bram5_44fa2015ec: entity work.delay_bram5_entity_44fa2015ec
    port map (
      ce_1 => ce_1_sg_x212,
      clk_1 => clk_1_sg_x212,
      din => delay73_q_net_x0,
      dout => ram_data_out_net_x5
    );

  delay_bram6_4df9fabe2b: entity work.delay_bram6_entity_4df9fabe2b
    port map (
      ce_1 => ce_1_sg_x212,
      clk_1 => clk_1_sg_x212,
      din => reinterpret_output_port_net_x0,
      dout => ram_data_out_net_x6
    );

  delay_bram7_09701768c8: entity work.delay_bram7_entity_09701768c8
    port map (
      ce_1 => ce_1_sg_x212,
      clk_1 => clk_1_sg_x212,
      din => addsub4_s_net_x0,
      dout => ram_data_out_net_x7
    );

  delay_bram9_ef7acd49f3: entity work.delay_bram9_entity_ef7acd49f3
    port map (
      ce_1 => ce_1_sg_x212,
      clk_1 => clk_1_sg_x212,
      din => delay26_q_net_x1,
      dout => ram_data_out_net_x8
    );

  inverter: entity work.inverter_6844eee868
    port map (
      ce => ce_1_sg_x212,
      clk => clk_1_sg_x212,
      clr => '0',
      ip(0) => relational2_op_net,
      op(0) => inverter_op_net
    );

  logical7: entity work.logical_ef735095f8
    port map (
      ce => ce_1_sg_x212,
      clk => clk_1_sg_x212,
      clr => '0',
      d0(0) => ram_data_out_net_x2,
      d1(0) => delay45_q_net_x0,
      d2(0) => ram_data_out_net_x1,
      d3(0) => ram_data_out_net_x4,
      y(0) => logical7_y_net_x0
    );

  reinterpret: entity work.reinterpret_112d91c147
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port(0) => delay27_q_net,
      output_port(0) => reinterpret_output_port_net_x0
    );

  relational1: entity work.relational_2705f2d4ec
    port map (
      a => delay3_q_net,
      b => delay26_q_net,
      ce => ce_1_sg_x212,
      clk => clk_1_sg_x212,
      clr => '0',
      op(0) => relational1_op_net
    );

  relational2: entity work.relational_95e7a52777
    port map (
      a => addsub3_s_net,
      b => constant1_op_net,
      ce => ce_1_sg_x212,
      clk => clk_1_sg_x212,
      clr => '0',
      op(0) => relational2_op_net
    );

  relational5: entity work.relational_1af0fb0f38
    port map (
      a => addsub4_s_net_x0,
      b => constant4_op_net,
      ce => ce_1_sg_x212,
      clk => clk_1_sg_x212,
      clr => '0',
      op(0) => relational5_op_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture0"

entity capture0_entity_6e7ee31b1e is
  port (
    ce_1: in std_logic; 
    ch_in: in std_logic_vector(7 downto 0); 
    clk_1: in std_logic; 
    darkquad29_capture0_base_kf_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture0_base_kq_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture0_cps_lim_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture0_load_thresh_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture0_pix_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture0_threshold_user_data_out: in std_logic_vector(31 downto 0); 
    data_in: in std_logic_vector(11 downto 0); 
    pps: in std_logic; 
    ts_in: in std_logic_vector(8 downto 0); 
    ch_out: out std_logic_vector(7 downto 0); 
    phase_out: out std_logic_vector(15 downto 0); 
    photon_out: out std_logic_vector(63 downto 0); 
    pix: out std_logic_vector(9 downto 0); 
    pix_x0: out std_logic_vector(31 downto 0); 
    pix_x1: out std_logic; 
    we_out: out std_logic
  );
end capture0_entity_6e7ee31b1e;

architecture structural of capture0_entity_6e7ee31b1e is
  signal ce_1_sg_x213: std_logic;
  signal clk_1_sg_x213: std_logic;
  signal concat1_y_net: std_logic_vector(63 downto 0);
  signal constant2_op_net_x0: std_logic;
  signal constant3_op_net_x1: std_logic_vector(9 downto 0);
  signal convert2_dout_net: std_logic_vector(15 downto 0);
  signal convert_addr_dout_net_x1: std_logic_vector(9 downto 0);
  signal convert_din1_dout_net_x1: std_logic_vector(31 downto 0);
  signal convert_dout_net_x0: std_logic_vector(15 downto 0);
  signal convert_we_dout_net_x1: std_logic;
  signal darkquad29_capture0_base_kf_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal darkquad29_capture0_base_kq_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal darkquad29_capture0_cps_lim_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal darkquad29_capture0_load_thresh_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal darkquad29_capture0_pix_data_out_net_x2: std_logic_vector(31 downto 0);
  signal darkquad29_capture0_threshold_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal delay10_q_net_x0: std_logic_vector(8 downto 0);
  signal delay10_q_net_x1: std_logic_vector(11 downto 0);
  signal delay11_q_net: std_logic_vector(15 downto 0);
  signal delay12_q_net: std_logic_vector(8 downto 0);
  signal delay13_q_net_x0: std_logic_vector(15 downto 0);
  signal delay13_q_net_x1: std_logic;
  signal delay13_q_net_x2: std_logic_vector(7 downto 0);
  signal delay14_q_net_x0: std_logic;
  signal delay14_q_net_x1: std_logic;
  signal delay15_q_net: std_logic_vector(7 downto 0);
  signal delay15_q_net_x0: std_logic_vector(15 downto 0);
  signal delay16_q_net: std_logic_vector(15 downto 0);
  signal delay17_q_net: std_logic_vector(15 downto 0);
  signal delay18_q_net: std_logic_vector(15 downto 0);
  signal delay19_q_net: std_logic_vector(8 downto 0);
  signal delay19_q_net_x0: std_logic_vector(15 downto 0);
  signal delay1_q_net: std_logic;
  signal delay20_q_net: std_logic_vector(15 downto 0);
  signal delay20_q_net_x0: std_logic_vector(15 downto 0);
  signal delay21_q_net: std_logic_vector(7 downto 0);
  signal delay21_q_net_x0: std_logic_vector(7 downto 0);
  signal delay22_q_net: std_logic_vector(17 downto 0);
  signal delay23_q_net: std_logic_vector(15 downto 0);
  signal delay24_q_net: std_logic;
  signal delay25_q_net_x0: std_logic_vector(7 downto 0);
  signal delay26_q_net_x1: std_logic_vector(15 downto 0);
  signal delay27_q_net_x0: std_logic_vector(15 downto 0);
  signal delay28_q_net_x1: std_logic_vector(7 downto 0);
  signal delay29_q_net: std_logic_vector(8 downto 0);
  signal delay2_q_net: std_logic_vector(31 downto 0);
  signal delay30_q_net_x1: std_logic_vector(15 downto 0);
  signal delay31_q_net_x1: std_logic_vector(15 downto 0);
  signal delay32_q_net: std_logic_vector(16 downto 0);
  signal delay33_q_net: std_logic;
  signal delay34_q_net_x0: std_logic;
  signal delay35_q_net: std_logic;
  signal delay36_q_net: std_logic;
  signal delay37_q_net: std_logic;
  signal delay38_q_net: std_logic;
  signal delay39_q_net: std_logic;
  signal delay3_q_net: std_logic_vector(31 downto 0);
  signal delay40_q_net: std_logic;
  signal delay41_q_net: std_logic;
  signal delay42_q_net: std_logic;
  signal delay43_q_net: std_logic_vector(17 downto 0);
  signal delay44_q_net_x0: std_logic_vector(15 downto 0);
  signal delay45_q_net: std_logic_vector(15 downto 0);
  signal delay47_q_net: std_logic_vector(15 downto 0);
  signal delay49_q_net: std_logic_vector(15 downto 0);
  signal delay4_q_net: std_logic_vector(8 downto 0);
  signal delay50_q_net: std_logic_vector(16 downto 0);
  signal delay51_q_net: std_logic_vector(8 downto 0);
  signal delay53_q_net: std_logic_vector(15 downto 0);
  signal delay54_q_net: std_logic_vector(17 downto 0);
  signal delay56_q_net: std_logic_vector(16 downto 0);
  signal delay57_q_net: std_logic_vector(8 downto 0);
  signal delay58_q_net_x0: std_logic_vector(15 downto 0);
  signal delay5_q_net: std_logic_vector(8 downto 0);
  signal delay65_q_net: std_logic_vector(8 downto 0);
  signal delay66_q_net_x0: std_logic_vector(19 downto 0);
  signal delay6_q_net_x1: std_logic_vector(7 downto 0);
  signal delay74_q_net: std_logic;
  signal delay74_q_net_x0: std_logic_vector(7 downto 0);
  signal delay79_q_net: std_logic_vector(63 downto 0);
  signal delay7_q_net: std_logic_vector(15 downto 0);
  signal delay80_q_net: std_logic_vector(15 downto 0);
  signal delay81_q_net: std_logic_vector(15 downto 0);
  signal delay87_q_net_x0: std_logic_vector(63 downto 0);
  signal delay8_q_net: std_logic;
  signal delay90_q_net: std_logic_vector(7 downto 0);
  signal delay91_q_net: std_logic_vector(7 downto 0);
  signal delay92_q_net: std_logic_vector(7 downto 0);
  signal delay93_q_net: std_logic_vector(7 downto 0);
  signal delay94_q_net: std_logic_vector(7 downto 0);
  signal delay95_q_net_x0: std_logic_vector(7 downto 0);
  signal delay9_q_net: std_logic_vector(8 downto 0);
  signal delay9_q_net_x1: std_logic_vector(8 downto 0);
  signal logical1_y_net: std_logic;
  signal logical2_y_net_x0: std_logic;
  signal logical7_y_net_x0: std_logic;
  signal logical7_y_net_x1: std_logic;
  signal mux1_y_net: std_logic_vector(7 downto 0);
  signal register1_q_net_x0: std_logic_vector(19 downto 0);
  signal register1_q_net_x1: std_logic_vector(14 downto 0);
  signal register1_q_net_x2: std_logic_vector(17 downto 0);
  signal register1_q_net_x3: std_logic_vector(17 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x2: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x3: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x4: std_logic_vector(31 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(15 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret3_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret4_output_port_net: std_logic_vector(19 downto 0);
  signal reinterpret6_output_port_net: std_logic_vector(8 downto 0);
  signal reinterpret7_output_port_net: std_logic_vector(17 downto 0);
  signal reinterpret8_output_port_net: std_logic_vector(16 downto 0);
  signal reinterpret_out_output_port_net_x2: std_logic_vector(31 downto 0);
  signal relational5_op_net_x1: std_logic;
  signal s_12_9_1_dout_net: std_logic_vector(16 downto 0);
  signal s_12_9_3_dout_net: std_logic_vector(17 downto 0);
  signal single_port_ram_data_out_net: std_logic_vector(15 downto 0);
  signal slice13_y_net: std_logic;
  signal slice14_y_net: std_logic_vector(7 downto 0);
  signal slice1_y_net: std_logic_vector(19 downto 0);
  signal slice2_y_net: std_logic_vector(17 downto 0);
  signal slice3_y_net: std_logic_vector(17 downto 0);
  signal slice4_y_net_x0: std_logic_vector(14 downto 0);
  signal slice5_y_net: std_logic_vector(15 downto 0);

begin
  ce_1_sg_x213 <= ce_1;
  delay13_q_net_x2 <= ch_in;
  clk_1_sg_x213 <= clk_1;
  darkquad29_capture0_base_kf_user_data_out_net_x1 <= darkquad29_capture0_base_kf_user_data_out;
  darkquad29_capture0_base_kq_user_data_out_net_x1 <= darkquad29_capture0_base_kq_user_data_out;
  darkquad29_capture0_cps_lim_user_data_out_net_x1 <= darkquad29_capture0_cps_lim_user_data_out;
  darkquad29_capture0_load_thresh_user_data_out_net_x1 <= darkquad29_capture0_load_thresh_user_data_out;
  darkquad29_capture0_pix_data_out_net_x2 <= darkquad29_capture0_pix_data_out;
  darkquad29_capture0_threshold_user_data_out_net_x1 <= darkquad29_capture0_threshold_user_data_out;
  delay10_q_net_x1 <= data_in;
  delay14_q_net_x0 <= pps;
  delay9_q_net_x1 <= ts_in;
  ch_out <= delay95_q_net_x0;
  phase_out <= delay58_q_net_x0;
  photon_out <= delay87_q_net_x0;
  pix <= convert_addr_dout_net_x1;
  pix_x0 <= convert_din1_dout_net_x1;
  pix_x1 <= convert_we_dout_net_x1;
  we_out <= logical2_y_net_x0;

  base_kf_d3a106f79b: entity work.base_kf_entity_d3a106f79b
    port map (
      darkquad29_capture0_base_kf_user_data_out => darkquad29_capture0_base_kf_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x0
    );

  base_kq_bfd3a04c3b: entity work.base_kq_entity_bfd3a04c3b
    port map (
      darkquad29_capture0_base_kq_user_data_out => darkquad29_capture0_base_kq_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x1
    );

  concat1: entity work.concat_d7ce1ba691
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret4_output_port_net,
      in1 => reinterpret6_output_port_net,
      in2 => reinterpret7_output_port_net,
      in3 => reinterpret8_output_port_net,
      y => concat1_y_net
    );

  constant2: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant2_op_net_x0
    );

  constant3: entity work.constant_498bc68c14
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant3_op_net_x1
    );

  convert2: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 9,
      din_width => 12,
      dout_arith => 2,
      dout_bin_pt => 13,
      dout_width => 16,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      clr => '0',
      din => delay10_q_net_x1,
      en => "1",
      dout => convert2_dout_net
    );

  cps_lim_d70c5caf8d: entity work.cps_lim_entity_d70c5caf8d
    port map (
      darkquad29_capture0_cps_lim_user_data_out => darkquad29_capture0_cps_lim_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x2
    );

  deadtime_87d78ea2d1: entity work.deadtime_entity_87d78ea2d1
    port map (
      ce_1 => ce_1_sg_x213,
      clk_1 => clk_1_sg_x213,
      in_x0 => delay14_q_net_x1,
      out_x0 => logical7_y_net_x0
    );

  delay1: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d(0) => slice13_y_net,
      en => '1',
      rst => '1',
      q(0) => delay1_q_net
    );

  delay10: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 9
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => delay9_q_net,
      en => '1',
      rst => '1',
      q => delay10_q_net_x0
    );

  delay11: entity work.delay_4246ea65a9
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      clr => '0',
      d => delay15_q_net_x0,
      q => delay11_q_net
    );

  delay12: entity work.delay_09771002d6
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      clr => '0',
      d => delay5_q_net,
      q => delay12_q_net
    );

  delay13: entity work.delay_c53de546ea
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      clr => '0',
      d(0) => logical1_y_net,
      q(0) => delay13_q_net_x1
    );

  delay14: entity work.delay_9701834818
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      clr => '0',
      d(0) => logical1_y_net,
      q(0) => delay14_q_net_x1
    );

  delay15: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => delay13_q_net_x2,
      en => '1',
      rst => '1',
      q => delay15_q_net
    );

  delay16: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => slice5_y_net,
      en => '1',
      rst => '1',
      q => delay16_q_net
    );

  delay17: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => convert2_dout_net,
      en => '1',
      rst => '1',
      q => delay17_q_net
    );

  delay18: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => single_port_ram_data_out_net,
      en => '1',
      rst => '1',
      q => delay18_q_net
    );

  delay19: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 9
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => delay57_q_net,
      en => '1',
      rst => '1',
      q => delay19_q_net
    );

  delay2: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 32
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => reint1_output_port_net_x3,
      en => '1',
      rst => '1',
      q => delay2_q_net
    );

  delay20: entity work.xldelay
    generic map (
      latency => 14,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => delay18_q_net,
      en => '1',
      rst => '1',
      q => delay20_q_net
    );

  delay21: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => delay15_q_net,
      en => '1',
      rst => '1',
      q => delay21_q_net
    );

  delay22: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 18
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => delay54_q_net,
      en => '1',
      rst => '1',
      q => delay22_q_net
    );

  delay23: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => delay17_q_net,
      en => '1',
      rst => '1',
      q => delay23_q_net
    );

  delay24: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d(0) => delay8_q_net,
      en => '1',
      rst => '1',
      q(0) => delay24_q_net
    );

  delay25: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => delay21_q_net,
      en => '1',
      rst => '1',
      q => delay25_q_net_x0
    );

  delay26: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => delay20_q_net_x0,
      en => '1',
      rst => '1',
      q => delay26_q_net_x1
    );

  delay27: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => delay23_q_net,
      en => '1',
      rst => '1',
      q => delay27_q_net_x0
    );

  delay28: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => delay21_q_net_x0,
      en => '1',
      rst => '1',
      q => delay28_q_net_x1
    );

  delay29: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 9
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => delay65_q_net,
      en => '1',
      rst => '1',
      q => delay29_q_net
    );

  delay3: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 32
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => reint1_output_port_net_x4,
      en => '1',
      rst => '1',
      q => delay3_q_net
    );

  delay30: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => delay20_q_net,
      en => '1',
      rst => '1',
      q => delay30_q_net_x1
    );

  delay31: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => convert_dout_net_x0,
      en => '1',
      rst => '1',
      q => delay31_q_net_x1
    );

  delay32: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 17
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => delay56_q_net,
      en => '1',
      rst => '1',
      q => delay32_q_net
    );

  delay33: entity work.xldelay
    generic map (
      latency => 13,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d(0) => delay38_q_net,
      en => '1',
      rst => '1',
      q(0) => delay33_q_net
    );

  delay34: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d(0) => delay35_q_net,
      en => '1',
      rst => '1',
      q(0) => delay34_q_net_x0
    );

  delay35: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d(0) => delay36_q_net,
      en => '1',
      rst => '1',
      q(0) => delay35_q_net
    );

  delay36: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d(0) => delay37_q_net,
      en => '1',
      rst => '1',
      q(0) => delay36_q_net
    );

  delay37: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      clr => '0',
      d(0) => delay33_q_net,
      q(0) => delay37_q_net
    );

  delay38: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d(0) => delay39_q_net,
      en => '1',
      rst => '1',
      q(0) => delay38_q_net
    );

  delay39: entity work.xldelay
    generic map (
      latency => 14,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d(0) => delay40_q_net,
      en => '1',
      rst => '1',
      q(0) => delay39_q_net
    );

  delay4: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 9
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => delay9_q_net_x1,
      en => '1',
      rst => '1',
      q => delay4_q_net
    );

  delay40: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d(0) => delay41_q_net,
      en => '1',
      rst => '1',
      q(0) => delay40_q_net
    );

  delay41: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d(0) => delay42_q_net,
      en => '1',
      rst => '1',
      q(0) => delay41_q_net
    );

  delay42: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d(0) => delay14_q_net_x0,
      en => '1',
      rst => '1',
      q(0) => delay42_q_net
    );

  delay43: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 18
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => s_12_9_3_dout_net,
      en => '1',
      rst => '1',
      q => delay43_q_net
    );

  delay44: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => delay19_q_net_x0,
      en => '1',
      rst => '1',
      q => delay44_q_net_x0
    );

  delay45: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => delay81_q_net,
      en => '1',
      rst => '1',
      q => delay45_q_net
    );

  delay47: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => delay45_q_net,
      en => '1',
      rst => '1',
      q => delay47_q_net
    );

  delay49: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => delay47_q_net,
      en => '1',
      rst => '1',
      q => delay49_q_net
    );

  delay5: entity work.xldelay
    generic map (
      latency => 13,
      reg_retiming => 0,
      reset => 0,
      width => 9
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => delay29_q_net,
      en => '1',
      rst => '1',
      q => delay5_q_net
    );

  delay50: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 17
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => s_12_9_1_dout_net,
      en => '1',
      rst => '1',
      q => delay50_q_net
    );

  delay51: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 9
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => delay12_q_net,
      en => '1',
      rst => '1',
      q => delay51_q_net
    );

  delay53: entity work.xldelay
    generic map (
      latency => 6,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => delay49_q_net,
      en => '1',
      rst => '1',
      q => delay53_q_net
    );

  delay54: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 18
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => delay43_q_net,
      en => '1',
      rst => '1',
      q => delay54_q_net
    );

  delay56: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 17
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => delay50_q_net,
      en => '1',
      rst => '1',
      q => delay56_q_net
    );

  delay57: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 9
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => delay51_q_net,
      en => '1',
      rst => '1',
      q => delay57_q_net
    );

  delay58: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => delay53_q_net,
      en => '1',
      rst => '1',
      q => delay58_q_net_x0
    );

  delay6: entity work.delay_ebec135d8a
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      clr => '0',
      d => delay74_q_net_x0,
      q => delay6_q_net_x1
    );

  delay65: entity work.xldelay
    generic map (
      latency => 14,
      reg_retiming => 0,
      reset => 0,
      width => 9
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => delay10_q_net_x0,
      en => '1',
      rst => '1',
      q => delay65_q_net
    );

  delay66: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 20
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => slice1_y_net,
      en => '1',
      rst => '1',
      q => delay66_q_net_x0
    );

  delay7: entity work.delay_4246ea65a9
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      clr => '0',
      d => delay13_q_net_x0,
      q => delay7_q_net
    );

  delay74: entity work.xldelay
    generic map (
      latency => 6,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d(0) => delay13_q_net_x1,
      en => '1',
      rst => '1',
      q(0) => delay74_q_net
    );

  delay79: entity work.xldelay
    generic map (
      latency => 6,
      reg_retiming => 0,
      reset => 0,
      width => 64
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => concat1_y_net,
      en => '1',
      rst => '1',
      q => delay79_q_net
    );

  delay8: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      clr => '0',
      d(0) => logical7_y_net_x1,
      q(0) => delay8_q_net
    );

  delay80: entity work.xldelay
    generic map (
      latency => 13,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => delay26_q_net_x1,
      en => '1',
      rst => '1',
      q => delay80_q_net
    );

  delay81: entity work.delay_4246ea65a9
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      clr => '0',
      d => delay80_q_net,
      q => delay81_q_net
    );

  delay87: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 64
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => delay79_q_net,
      en => '1',
      rst => '1',
      q => delay87_q_net_x0
    );

  delay9: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 9
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => delay4_q_net,
      en => '1',
      rst => '1',
      q => delay9_q_net
    );

  delay90: entity work.delay_ebec135d8a
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      clr => '0',
      d => delay74_q_net_x0,
      q => delay90_q_net
    );

  delay91: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => delay90_q_net,
      en => '1',
      rst => '1',
      q => delay91_q_net
    );

  delay92: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => delay91_q_net,
      en => '1',
      rst => '1',
      q => delay92_q_net
    );

  delay93: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => delay92_q_net,
      en => '1',
      rst => '1',
      q => delay93_q_net
    );

  delay94: entity work.xldelay
    generic map (
      latency => 6,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => delay93_q_net,
      en => '1',
      rst => '1',
      q => delay94_q_net
    );

  delay95: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      d => delay94_q_net,
      en => '1',
      rst => '1',
      q => delay95_q_net_x0
    );

  filter_c79fa858fb: entity work.filter_entity_c79fa858fb
    port map (
      ce_1 => ce_1_sg_x213,
      ch_in => delay25_q_net_x0,
      clk_1 => clk_1_sg_x213,
      kf => register1_q_net_x3,
      kq => register1_q_net_x2,
      raw_in => delay27_q_net_x0,
      ch_out => delay21_q_net_x0,
      filtered_out => delay19_q_net_x0,
      raw_out => delay20_q_net_x0,
      res_out => convert_dout_net_x0
    );

  lim_cps_99d2deee63: entity work.lim_cps_entity_99d2deee63
    port map (
      ce_1 => ce_1_sg_x213,
      clk_1 => clk_1_sg_x213,
      lim => register1_q_net_x1,
      pps => delay34_q_net_x0,
      trig => delay13_q_net_x1,
      under_cap => relational5_op_net_x1
    );

  load_thresh_d7e3bf0a22: entity work.load_thresh_entity_d7e3bf0a22
    port map (
      darkquad29_capture0_load_thresh_user_data_out => darkquad29_capture0_load_thresh_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x3
    );

  logical1: entity work.logical_799f62af22
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      clr => '0',
      d0(0) => delay24_q_net,
      d1(0) => logical7_y_net_x0,
      y(0) => logical1_y_net
    );

  logical2: entity work.logical_799f62af22
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      clr => '0',
      d0(0) => delay74_q_net,
      d1(0) => relational5_op_net_x1,
      y(0) => logical2_y_net_x0
    );

  mux1: entity work.mux_cc14a035dc
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      clr => '0',
      d0 => delay13_q_net_x2,
      d1 => slice14_y_net,
      sel(0) => slice13_y_net,
      y => mux1_y_net
    );

  pipeline1_ce5d488c45: entity work.pipeline1_entity_ce5d488c45
    port map (
      ce_1 => ce_1_sg_x213,
      clk_1 => clk_1_sg_x213,
      d => reinterpret3_output_port_net_x0,
      q => register1_q_net_x2
    );

  pipeline20_8f44e5de98: entity work.pipeline1_entity_ce5d488c45
    port map (
      ce_1 => ce_1_sg_x213,
      clk_1 => clk_1_sg_x213,
      d => reinterpret2_output_port_net_x0,
      q => register1_q_net_x3
    );

  pipeline2_5eadf3bb39: entity work.pipeline2_entity_5eadf3bb39
    port map (
      ce_1 => ce_1_sg_x213,
      clk_1 => clk_1_sg_x213,
      d => delay66_q_net_x0,
      q => register1_q_net_x0
    );

  pipeline7_51dd812305: entity work.pipeline7_entity_51dd812305
    port map (
      ce_1 => ce_1_sg_x213,
      clk_1 => clk_1_sg_x213,
      d => slice4_y_net_x0,
      q => register1_q_net_x1
    );

  pix_883e660ce7: entity work.pix_entity_883e660ce7
    port map (
      addr => delay6_q_net_x1,
      ce_1 => ce_1_sg_x213,
      clk_1 => clk_1_sg_x213,
      darkquad29_capture0_pix_data_out => darkquad29_capture0_pix_data_out_net_x2,
      data_in => constant3_op_net_x1,
      we => constant2_op_net_x0,
      convert_addr_x0 => convert_addr_dout_net_x1,
      convert_din1_x0 => convert_din1_dout_net_x1,
      convert_we_x0 => convert_we_dout_net_x1,
      data_out => reinterpret_out_output_port_net_x2
    );

  reinterpret1: entity work.reinterpret_151459306d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => delay16_q_net,
      output_port => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_9a0fa0f632
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret2_output_port_net_x0
    );

  reinterpret3: entity work.reinterpret_9a0fa0f632
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice3_y_net,
      output_port => reinterpret3_output_port_net_x0
    );

  reinterpret4: entity work.reinterpret_713b6c5d29
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => register1_q_net_x0,
      output_port => reinterpret4_output_port_net
    );

  reinterpret6: entity work.reinterpret_b754317574
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => delay19_q_net,
      output_port => reinterpret6_output_port_net
    );

  reinterpret7: entity work.reinterpret_580feec131
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => delay22_q_net,
      output_port => reinterpret7_output_port_net
    );

  reinterpret8: entity work.reinterpret_573890e1c0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => delay32_q_net,
      output_port => reinterpret8_output_port_net
    );

  s_12_9_1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 13,
      din_width => 16,
      dout_arith => 2,
      dout_bin_pt => 14,
      dout_width => 17,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      clr => '0',
      din => delay7_q_net,
      en => "1",
      dout => s_12_9_1_dout_net
    );

  s_12_9_3: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 13,
      din_width => 16,
      dout_arith => 2,
      dout_bin_pt => 15,
      dout_width => 18,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      clr => '0',
      din => delay11_q_net,
      en => "1",
      dout => s_12_9_3_dout_net
    );

  single_port_ram: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 16,
      core_name0 => "bmg_72_b40f882ae90aebcf",
      latency => 2
    )
    port map (
      addr => mux1_y_net,
      ce => ce_1_sg_x213,
      clk => clk_1_sg_x213,
      data_in => reinterpret1_output_port_net,
      en => "1",
      rst => "0",
      we(0) => delay1_q_net,
      data_out => single_port_ram_data_out_net
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 19,
      x_width => 32,
      y_width => 20
    )
    port map (
      x => reinterpret_out_output_port_net_x2,
      y => slice1_y_net
    );

  slice13: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => delay2_q_net,
      y(0) => slice13_y_net
    );

  slice14: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 8,
      x_width => 32,
      y_width => 8
    )
    port map (
      x => delay2_q_net,
      y => slice14_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 17,
      x_width => 32,
      y_width => 18
    )
    port map (
      x => reint1_output_port_net_x0,
      y => slice2_y_net
    );

  slice3: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 17,
      x_width => 32,
      y_width => 18
    )
    port map (
      x => reint1_output_port_net_x1,
      y => slice3_y_net
    );

  slice4: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 14,
      x_width => 32,
      y_width => 15
    )
    port map (
      x => reint1_output_port_net_x2,
      y => slice4_y_net_x0
    );

  slice5: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 15,
      x_width => 32,
      y_width => 16
    )
    port map (
      x => delay3_q_net,
      y => slice5_y_net
    );

  threshold_5cc5c4779d: entity work.threshold_entity_5cc5c4779d
    port map (
      darkquad29_capture0_threshold_user_data_out => darkquad29_capture0_threshold_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x4
    );

  trigger_9aeb6a1bfd: entity work.trigger_entity_9aeb6a1bfd
    port map (
      baseline => delay31_q_net_x1,
      ce_1 => ce_1_sg_x213,
      ch_in => delay28_q_net_x1,
      clk_1 => clk_1_sg_x213,
      filtered_in => delay44_q_net_x0,
      raw_in => delay26_q_net_x1,
      threshold => delay30_q_net_x1,
      base_out => delay13_q_net_x0,
      ch_out => delay74_q_net_x0,
      data_out => delay15_q_net_x0,
      trigger => logical7_y_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture1/base_kf"

entity base_kf_entity_8201c52af1 is
  port (
    darkquad29_capture1_base_kf_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end base_kf_entity_8201c52af1;

architecture structural of base_kf_entity_8201c52af1 is
  signal darkquad29_capture1_base_kf_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_capture1_base_kf_user_data_out_net_x0 <= darkquad29_capture1_base_kf_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_capture1_base_kf_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture1/base_kq"

entity base_kq_entity_0cfd155fdb is
  port (
    darkquad29_capture1_base_kq_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end base_kq_entity_0cfd155fdb;

architecture structural of base_kq_entity_0cfd155fdb is
  signal darkquad29_capture1_base_kq_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_capture1_base_kq_user_data_out_net_x0 <= darkquad29_capture1_base_kq_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_capture1_base_kq_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture1/cps_lim"

entity cps_lim_entity_21fe64723d is
  port (
    darkquad29_capture1_cps_lim_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end cps_lim_entity_21fe64723d;

architecture structural of cps_lim_entity_21fe64723d is
  signal darkquad29_capture1_cps_lim_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_capture1_cps_lim_user_data_out_net_x0 <= darkquad29_capture1_cps_lim_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_capture1_cps_lim_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture1/load_thresh"

entity load_thresh_entity_40c0f2d42a is
  port (
    darkquad29_capture1_load_thresh_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end load_thresh_entity_40c0f2d42a;

architecture structural of load_thresh_entity_40c0f2d42a is
  signal darkquad29_capture1_load_thresh_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_capture1_load_thresh_user_data_out_net_x0 <= darkquad29_capture1_load_thresh_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_capture1_load_thresh_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture1/pix"

entity pix_entity_05d07f9cb0 is
  port (
    addr: in std_logic_vector(7 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    darkquad29_capture1_pix_data_out: in std_logic_vector(31 downto 0); 
    data_in: in std_logic_vector(9 downto 0); 
    we: in std_logic; 
    convert_addr_x0: out std_logic_vector(9 downto 0); 
    convert_din1_x0: out std_logic_vector(31 downto 0); 
    convert_we_x0: out std_logic; 
    data_out: out std_logic_vector(31 downto 0)
  );
end pix_entity_05d07f9cb0;

architecture structural of pix_entity_05d07f9cb0 is
  signal ce_1_sg_x237: std_logic;
  signal clk_1_sg_x237: std_logic;
  signal constant2_op_net_x0: std_logic;
  signal constant3_op_net_x1: std_logic_vector(9 downto 0);
  signal convert_addr_dout_net_x0: std_logic_vector(9 downto 0);
  signal convert_din1_dout_net_x0: std_logic_vector(31 downto 0);
  signal convert_we_dout_net_x0: std_logic;
  signal darkquad29_capture1_pix_data_out_net_x1: std_logic_vector(31 downto 0);
  signal delay6_q_net_x1: std_logic_vector(7 downto 0);
  signal mux_y_net_x0: std_logic_vector(9 downto 0);
  signal reinterpret_out_output_port_net_x0: std_logic_vector(9 downto 0);
  signal reinterpret_out_output_port_net_x2: std_logic_vector(31 downto 0);

begin
  delay6_q_net_x1 <= addr;
  ce_1_sg_x237 <= ce_1;
  clk_1_sg_x237 <= clk_1;
  darkquad29_capture1_pix_data_out_net_x1 <= darkquad29_capture1_pix_data_out;
  constant3_op_net_x1 <= data_in;
  constant2_op_net_x0 <= we;
  convert_addr_x0 <= convert_addr_dout_net_x0;
  convert_din1_x0 <= convert_din1_dout_net_x0;
  convert_we_x0 <= convert_we_dout_net_x0;
  data_out <= reinterpret_out_output_port_net_x2;

  calc_add_514e1b35e2: entity work.calc_add_entity_27b5517daf
    port map (
      ce_1 => ce_1_sg_x237,
      clk_1 => clk_1_sg_x237,
      in_x0 => delay6_q_net_x1,
      out_x0 => mux_y_net_x0
    );

  convert_addr: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 10,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 10,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x237,
      clk => clk_1_sg_x237,
      clr => '0',
      din => mux_y_net_x0,
      en => "1",
      dout => convert_addr_dout_net_x0
    );

  convert_din1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 10,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x237,
      clk => clk_1_sg_x237,
      clr => '0',
      din => reinterpret_out_output_port_net_x0,
      en => "1",
      dout => convert_din1_dout_net_x0
    );

  convert_we: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x237,
      clk => clk_1_sg_x237,
      clr => '0',
      din(0) => constant2_op_net_x0,
      en => "1",
      dout(0) => convert_we_dout_net_x0
    );

  munge_in_52bd6f7c82: entity work.munge_in_entity_9df1f10b0c
    port map (
      din => constant3_op_net_x1,
      dout => reinterpret_out_output_port_net_x0
    );

  munge_out_41d2d3d1a3: entity work.munge_in_entity_9341d54c73
    port map (
      din => darkquad29_capture1_pix_data_out_net_x1,
      dout => reinterpret_out_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture1/threshold"

entity threshold_entity_0e4d6015d7 is
  port (
    darkquad29_capture1_threshold_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end threshold_entity_0e4d6015d7;

architecture structural of threshold_entity_0e4d6015d7 is
  signal darkquad29_capture1_threshold_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_capture1_threshold_user_data_out_net_x0 <= darkquad29_capture1_threshold_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_capture1_threshold_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture1"

entity capture1_entity_3d7d95492d is
  port (
    ce_1: in std_logic; 
    ch_in: in std_logic_vector(7 downto 0); 
    clk_1: in std_logic; 
    darkquad29_capture1_base_kf_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture1_base_kq_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture1_cps_lim_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture1_load_thresh_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture1_pix_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture1_threshold_user_data_out: in std_logic_vector(31 downto 0); 
    data_in: in std_logic_vector(11 downto 0); 
    pps: in std_logic; 
    ts_in: in std_logic_vector(8 downto 0); 
    phase_out: out std_logic_vector(15 downto 0); 
    photon_out: out std_logic_vector(63 downto 0); 
    pix: out std_logic_vector(9 downto 0); 
    pix_x0: out std_logic_vector(31 downto 0); 
    pix_x1: out std_logic; 
    we_out: out std_logic
  );
end capture1_entity_3d7d95492d;

architecture structural of capture1_entity_3d7d95492d is
  signal ce_1_sg_x248: std_logic;
  signal clk_1_sg_x248: std_logic;
  signal concat1_y_net: std_logic_vector(63 downto 0);
  signal constant2_op_net_x0: std_logic;
  signal constant3_op_net_x1: std_logic_vector(9 downto 0);
  signal convert2_dout_net: std_logic_vector(15 downto 0);
  signal convert_addr_dout_net_x1: std_logic_vector(9 downto 0);
  signal convert_din1_dout_net_x1: std_logic_vector(31 downto 0);
  signal convert_dout_net_x0: std_logic_vector(15 downto 0);
  signal convert_we_dout_net_x1: std_logic;
  signal darkquad29_capture1_base_kf_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal darkquad29_capture1_base_kq_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal darkquad29_capture1_cps_lim_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal darkquad29_capture1_load_thresh_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal darkquad29_capture1_pix_data_out_net_x2: std_logic_vector(31 downto 0);
  signal darkquad29_capture1_threshold_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal delay10_q_net: std_logic_vector(8 downto 0);
  signal delay11_q_net: std_logic_vector(15 downto 0);
  signal delay12_q_net: std_logic_vector(8 downto 0);
  signal delay13_q_net_x0: std_logic_vector(15 downto 0);
  signal delay13_q_net_x1: std_logic;
  signal delay14_q_net_x1: std_logic;
  signal delay14_q_net_x2: std_logic;
  signal delay15_q_net: std_logic_vector(7 downto 0);
  signal delay15_q_net_x0: std_logic_vector(15 downto 0);
  signal delay16_q_net: std_logic_vector(15 downto 0);
  signal delay17_q_net: std_logic_vector(15 downto 0);
  signal delay18_q_net: std_logic_vector(15 downto 0);
  signal delay19_q_net: std_logic_vector(8 downto 0);
  signal delay19_q_net_x0: std_logic_vector(15 downto 0);
  signal delay1_q_net: std_logic;
  signal delay20_q_net: std_logic_vector(15 downto 0);
  signal delay20_q_net_x0: std_logic_vector(15 downto 0);
  signal delay21_q_net: std_logic_vector(7 downto 0);
  signal delay21_q_net_x0: std_logic_vector(7 downto 0);
  signal delay22_q_net: std_logic_vector(17 downto 0);
  signal delay23_q_net: std_logic_vector(15 downto 0);
  signal delay24_q_net: std_logic;
  signal delay25_q_net_x0: std_logic_vector(7 downto 0);
  signal delay26_q_net_x1: std_logic_vector(15 downto 0);
  signal delay27_q_net_x0: std_logic_vector(15 downto 0);
  signal delay28_q_net_x1: std_logic_vector(7 downto 0);
  signal delay29_q_net: std_logic_vector(8 downto 0);
  signal delay2_q_net: std_logic_vector(31 downto 0);
  signal delay30_q_net_x1: std_logic_vector(15 downto 0);
  signal delay31_q_net_x1: std_logic_vector(15 downto 0);
  signal delay32_q_net: std_logic_vector(16 downto 0);
  signal delay33_q_net: std_logic;
  signal delay34_q_net_x0: std_logic;
  signal delay35_q_net: std_logic;
  signal delay36_q_net: std_logic;
  signal delay37_q_net: std_logic;
  signal delay38_q_net: std_logic;
  signal delay39_q_net: std_logic;
  signal delay3_q_net: std_logic_vector(31 downto 0);
  signal delay40_q_net: std_logic;
  signal delay41_q_net: std_logic;
  signal delay42_q_net: std_logic;
  signal delay43_q_net: std_logic_vector(17 downto 0);
  signal delay44_q_net_x0: std_logic_vector(15 downto 0);
  signal delay45_q_net: std_logic_vector(15 downto 0);
  signal delay47_q_net: std_logic_vector(15 downto 0);
  signal delay49_q_net: std_logic_vector(15 downto 0);
  signal delay4_q_net: std_logic_vector(8 downto 0);
  signal delay50_q_net: std_logic_vector(16 downto 0);
  signal delay51_q_net: std_logic_vector(8 downto 0);
  signal delay53_q_net: std_logic_vector(15 downto 0);
  signal delay54_q_net: std_logic_vector(17 downto 0);
  signal delay56_q_net: std_logic_vector(16 downto 0);
  signal delay57_q_net: std_logic_vector(8 downto 0);
  signal delay58_q_net_x0: std_logic_vector(15 downto 0);
  signal delay5_q_net: std_logic_vector(8 downto 0);
  signal delay65_q_net: std_logic_vector(8 downto 0);
  signal delay66_q_net_x0: std_logic_vector(19 downto 0);
  signal delay6_q_net_x1: std_logic_vector(7 downto 0);
  signal delay74_q_net: std_logic;
  signal delay74_q_net_x0: std_logic_vector(7 downto 0);
  signal delay79_q_net: std_logic_vector(63 downto 0);
  signal delay7_q_net: std_logic_vector(15 downto 0);
  signal delay80_q_net: std_logic_vector(15 downto 0);
  signal delay81_q_net: std_logic_vector(15 downto 0);
  signal delay87_q_net_x0: std_logic_vector(63 downto 0);
  signal delay8_q_net_x0: std_logic;
  signal delay8_q_net_x1: std_logic_vector(11 downto 0);
  signal delay9_q_net_x0: std_logic_vector(8 downto 0);
  signal delay9_q_net_x2: std_logic_vector(7 downto 0);
  signal delay9_q_net_x3: std_logic_vector(8 downto 0);
  signal logical1_y_net: std_logic;
  signal logical2_y_net_x0: std_logic;
  signal logical7_y_net_x0: std_logic;
  signal logical7_y_net_x1: std_logic;
  signal mux1_y_net: std_logic_vector(7 downto 0);
  signal register1_q_net_x0: std_logic_vector(19 downto 0);
  signal register1_q_net_x1: std_logic_vector(14 downto 0);
  signal register1_q_net_x2: std_logic_vector(17 downto 0);
  signal register1_q_net_x3: std_logic_vector(17 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x2: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x3: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x4: std_logic_vector(31 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(15 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret3_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret4_output_port_net: std_logic_vector(19 downto 0);
  signal reinterpret6_output_port_net: std_logic_vector(8 downto 0);
  signal reinterpret7_output_port_net: std_logic_vector(17 downto 0);
  signal reinterpret8_output_port_net: std_logic_vector(16 downto 0);
  signal reinterpret_out_output_port_net_x2: std_logic_vector(31 downto 0);
  signal relational5_op_net_x1: std_logic;
  signal s_12_9_1_dout_net: std_logic_vector(16 downto 0);
  signal s_12_9_3_dout_net: std_logic_vector(17 downto 0);
  signal single_port_ram_data_out_net: std_logic_vector(15 downto 0);
  signal slice13_y_net: std_logic;
  signal slice14_y_net: std_logic_vector(7 downto 0);
  signal slice1_y_net: std_logic_vector(19 downto 0);
  signal slice2_y_net: std_logic_vector(17 downto 0);
  signal slice3_y_net: std_logic_vector(17 downto 0);
  signal slice4_y_net_x0: std_logic_vector(14 downto 0);
  signal slice5_y_net: std_logic_vector(15 downto 0);

begin
  ce_1_sg_x248 <= ce_1;
  delay9_q_net_x2 <= ch_in;
  clk_1_sg_x248 <= clk_1;
  darkquad29_capture1_base_kf_user_data_out_net_x1 <= darkquad29_capture1_base_kf_user_data_out;
  darkquad29_capture1_base_kq_user_data_out_net_x1 <= darkquad29_capture1_base_kq_user_data_out;
  darkquad29_capture1_cps_lim_user_data_out_net_x1 <= darkquad29_capture1_cps_lim_user_data_out;
  darkquad29_capture1_load_thresh_user_data_out_net_x1 <= darkquad29_capture1_load_thresh_user_data_out;
  darkquad29_capture1_pix_data_out_net_x2 <= darkquad29_capture1_pix_data_out;
  darkquad29_capture1_threshold_user_data_out_net_x1 <= darkquad29_capture1_threshold_user_data_out;
  delay8_q_net_x1 <= data_in;
  delay14_q_net_x2 <= pps;
  delay9_q_net_x3 <= ts_in;
  phase_out <= delay58_q_net_x0;
  photon_out <= delay87_q_net_x0;
  pix <= convert_addr_dout_net_x1;
  pix_x0 <= convert_din1_dout_net_x1;
  pix_x1 <= convert_we_dout_net_x1;
  we_out <= logical2_y_net_x0;

  base_kf_8201c52af1: entity work.base_kf_entity_8201c52af1
    port map (
      darkquad29_capture1_base_kf_user_data_out => darkquad29_capture1_base_kf_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x0
    );

  base_kq_0cfd155fdb: entity work.base_kq_entity_0cfd155fdb
    port map (
      darkquad29_capture1_base_kq_user_data_out => darkquad29_capture1_base_kq_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x1
    );

  concat1: entity work.concat_d7ce1ba691
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret4_output_port_net,
      in1 => reinterpret6_output_port_net,
      in2 => reinterpret7_output_port_net,
      in3 => reinterpret8_output_port_net,
      y => concat1_y_net
    );

  constant2: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant2_op_net_x0
    );

  constant3: entity work.constant_498bc68c14
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant3_op_net_x1
    );

  convert2: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 9,
      din_width => 12,
      dout_arith => 2,
      dout_bin_pt => 13,
      dout_width => 16,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      clr => '0',
      din => delay8_q_net_x1,
      en => "1",
      dout => convert2_dout_net
    );

  cps_lim_21fe64723d: entity work.cps_lim_entity_21fe64723d
    port map (
      darkquad29_capture1_cps_lim_user_data_out => darkquad29_capture1_cps_lim_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x2
    );

  deadtime_736a548d04: entity work.deadtime_entity_87d78ea2d1
    port map (
      ce_1 => ce_1_sg_x248,
      clk_1 => clk_1_sg_x248,
      in_x0 => delay14_q_net_x1,
      out_x0 => logical7_y_net_x0
    );

  delay1: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d(0) => slice13_y_net,
      en => '1',
      rst => '1',
      q(0) => delay1_q_net
    );

  delay10: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 9
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d => delay9_q_net_x0,
      en => '1',
      rst => '1',
      q => delay10_q_net
    );

  delay11: entity work.delay_4246ea65a9
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      clr => '0',
      d => delay15_q_net_x0,
      q => delay11_q_net
    );

  delay12: entity work.delay_09771002d6
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      clr => '0',
      d => delay5_q_net,
      q => delay12_q_net
    );

  delay13: entity work.delay_c53de546ea
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      clr => '0',
      d(0) => logical1_y_net,
      q(0) => delay13_q_net_x1
    );

  delay14: entity work.delay_9701834818
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      clr => '0',
      d(0) => logical1_y_net,
      q(0) => delay14_q_net_x1
    );

  delay15: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d => delay9_q_net_x2,
      en => '1',
      rst => '1',
      q => delay15_q_net
    );

  delay16: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d => slice5_y_net,
      en => '1',
      rst => '1',
      q => delay16_q_net
    );

  delay17: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d => convert2_dout_net,
      en => '1',
      rst => '1',
      q => delay17_q_net
    );

  delay18: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d => single_port_ram_data_out_net,
      en => '1',
      rst => '1',
      q => delay18_q_net
    );

  delay19: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 9
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d => delay57_q_net,
      en => '1',
      rst => '1',
      q => delay19_q_net
    );

  delay2: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 32
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d => reint1_output_port_net_x3,
      en => '1',
      rst => '1',
      q => delay2_q_net
    );

  delay20: entity work.xldelay
    generic map (
      latency => 14,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d => delay18_q_net,
      en => '1',
      rst => '1',
      q => delay20_q_net
    );

  delay21: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d => delay15_q_net,
      en => '1',
      rst => '1',
      q => delay21_q_net
    );

  delay22: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 18
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d => delay54_q_net,
      en => '1',
      rst => '1',
      q => delay22_q_net
    );

  delay23: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d => delay17_q_net,
      en => '1',
      rst => '1',
      q => delay23_q_net
    );

  delay24: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d(0) => delay8_q_net_x0,
      en => '1',
      rst => '1',
      q(0) => delay24_q_net
    );

  delay25: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d => delay21_q_net,
      en => '1',
      rst => '1',
      q => delay25_q_net_x0
    );

  delay26: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d => delay20_q_net_x0,
      en => '1',
      rst => '1',
      q => delay26_q_net_x1
    );

  delay27: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d => delay23_q_net,
      en => '1',
      rst => '1',
      q => delay27_q_net_x0
    );

  delay28: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d => delay21_q_net_x0,
      en => '1',
      rst => '1',
      q => delay28_q_net_x1
    );

  delay29: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 9
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d => delay65_q_net,
      en => '1',
      rst => '1',
      q => delay29_q_net
    );

  delay3: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 32
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d => reint1_output_port_net_x4,
      en => '1',
      rst => '1',
      q => delay3_q_net
    );

  delay30: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d => delay20_q_net,
      en => '1',
      rst => '1',
      q => delay30_q_net_x1
    );

  delay31: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d => convert_dout_net_x0,
      en => '1',
      rst => '1',
      q => delay31_q_net_x1
    );

  delay32: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 17
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d => delay56_q_net,
      en => '1',
      rst => '1',
      q => delay32_q_net
    );

  delay33: entity work.xldelay
    generic map (
      latency => 13,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d(0) => delay38_q_net,
      en => '1',
      rst => '1',
      q(0) => delay33_q_net
    );

  delay34: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d(0) => delay35_q_net,
      en => '1',
      rst => '1',
      q(0) => delay34_q_net_x0
    );

  delay35: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d(0) => delay36_q_net,
      en => '1',
      rst => '1',
      q(0) => delay35_q_net
    );

  delay36: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d(0) => delay37_q_net,
      en => '1',
      rst => '1',
      q(0) => delay36_q_net
    );

  delay37: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      clr => '0',
      d(0) => delay33_q_net,
      q(0) => delay37_q_net
    );

  delay38: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d(0) => delay39_q_net,
      en => '1',
      rst => '1',
      q(0) => delay38_q_net
    );

  delay39: entity work.xldelay
    generic map (
      latency => 14,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d(0) => delay40_q_net,
      en => '1',
      rst => '1',
      q(0) => delay39_q_net
    );

  delay4: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 9
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d => delay9_q_net_x3,
      en => '1',
      rst => '1',
      q => delay4_q_net
    );

  delay40: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d(0) => delay41_q_net,
      en => '1',
      rst => '1',
      q(0) => delay40_q_net
    );

  delay41: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d(0) => delay42_q_net,
      en => '1',
      rst => '1',
      q(0) => delay41_q_net
    );

  delay42: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d(0) => delay14_q_net_x2,
      en => '1',
      rst => '1',
      q(0) => delay42_q_net
    );

  delay43: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 18
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d => s_12_9_3_dout_net,
      en => '1',
      rst => '1',
      q => delay43_q_net
    );

  delay44: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d => delay19_q_net_x0,
      en => '1',
      rst => '1',
      q => delay44_q_net_x0
    );

  delay45: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d => delay81_q_net,
      en => '1',
      rst => '1',
      q => delay45_q_net
    );

  delay47: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d => delay45_q_net,
      en => '1',
      rst => '1',
      q => delay47_q_net
    );

  delay49: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d => delay47_q_net,
      en => '1',
      rst => '1',
      q => delay49_q_net
    );

  delay5: entity work.xldelay
    generic map (
      latency => 13,
      reg_retiming => 0,
      reset => 0,
      width => 9
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d => delay29_q_net,
      en => '1',
      rst => '1',
      q => delay5_q_net
    );

  delay50: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 17
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d => s_12_9_1_dout_net,
      en => '1',
      rst => '1',
      q => delay50_q_net
    );

  delay51: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 9
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d => delay12_q_net,
      en => '1',
      rst => '1',
      q => delay51_q_net
    );

  delay53: entity work.xldelay
    generic map (
      latency => 6,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d => delay49_q_net,
      en => '1',
      rst => '1',
      q => delay53_q_net
    );

  delay54: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 18
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d => delay43_q_net,
      en => '1',
      rst => '1',
      q => delay54_q_net
    );

  delay56: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 17
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d => delay50_q_net,
      en => '1',
      rst => '1',
      q => delay56_q_net
    );

  delay57: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 9
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d => delay51_q_net,
      en => '1',
      rst => '1',
      q => delay57_q_net
    );

  delay58: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d => delay53_q_net,
      en => '1',
      rst => '1',
      q => delay58_q_net_x0
    );

  delay6: entity work.delay_ebec135d8a
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      clr => '0',
      d => delay74_q_net_x0,
      q => delay6_q_net_x1
    );

  delay65: entity work.xldelay
    generic map (
      latency => 14,
      reg_retiming => 0,
      reset => 0,
      width => 9
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d => delay10_q_net,
      en => '1',
      rst => '1',
      q => delay65_q_net
    );

  delay66: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 20
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d => slice1_y_net,
      en => '1',
      rst => '1',
      q => delay66_q_net_x0
    );

  delay7: entity work.delay_4246ea65a9
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      clr => '0',
      d => delay13_q_net_x0,
      q => delay7_q_net
    );

  delay74: entity work.xldelay
    generic map (
      latency => 6,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d(0) => delay13_q_net_x1,
      en => '1',
      rst => '1',
      q(0) => delay74_q_net
    );

  delay79: entity work.xldelay
    generic map (
      latency => 6,
      reg_retiming => 0,
      reset => 0,
      width => 64
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d => concat1_y_net,
      en => '1',
      rst => '1',
      q => delay79_q_net
    );

  delay8: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      clr => '0',
      d(0) => logical7_y_net_x1,
      q(0) => delay8_q_net_x0
    );

  delay80: entity work.xldelay
    generic map (
      latency => 13,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d => delay26_q_net_x1,
      en => '1',
      rst => '1',
      q => delay80_q_net
    );

  delay81: entity work.delay_4246ea65a9
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      clr => '0',
      d => delay80_q_net,
      q => delay81_q_net
    );

  delay87: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 64
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d => delay79_q_net,
      en => '1',
      rst => '1',
      q => delay87_q_net_x0
    );

  delay9: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 9
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      d => delay4_q_net,
      en => '1',
      rst => '1',
      q => delay9_q_net_x0
    );

  filter_0d0d040738: entity work.filter_entity_c79fa858fb
    port map (
      ce_1 => ce_1_sg_x248,
      ch_in => delay25_q_net_x0,
      clk_1 => clk_1_sg_x248,
      kf => register1_q_net_x3,
      kq => register1_q_net_x2,
      raw_in => delay27_q_net_x0,
      ch_out => delay21_q_net_x0,
      filtered_out => delay19_q_net_x0,
      raw_out => delay20_q_net_x0,
      res_out => convert_dout_net_x0
    );

  lim_cps_7e7f20b177: entity work.lim_cps_entity_99d2deee63
    port map (
      ce_1 => ce_1_sg_x248,
      clk_1 => clk_1_sg_x248,
      lim => register1_q_net_x1,
      pps => delay34_q_net_x0,
      trig => delay13_q_net_x1,
      under_cap => relational5_op_net_x1
    );

  load_thresh_40c0f2d42a: entity work.load_thresh_entity_40c0f2d42a
    port map (
      darkquad29_capture1_load_thresh_user_data_out => darkquad29_capture1_load_thresh_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x3
    );

  logical1: entity work.logical_799f62af22
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      clr => '0',
      d0(0) => delay24_q_net,
      d1(0) => logical7_y_net_x0,
      y(0) => logical1_y_net
    );

  logical2: entity work.logical_799f62af22
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      clr => '0',
      d0(0) => delay74_q_net,
      d1(0) => relational5_op_net_x1,
      y(0) => logical2_y_net_x0
    );

  mux1: entity work.mux_cc14a035dc
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      clr => '0',
      d0 => delay9_q_net_x2,
      d1 => slice14_y_net,
      sel(0) => slice13_y_net,
      y => mux1_y_net
    );

  pipeline1_74b2f10441: entity work.pipeline1_entity_ce5d488c45
    port map (
      ce_1 => ce_1_sg_x248,
      clk_1 => clk_1_sg_x248,
      d => reinterpret3_output_port_net_x0,
      q => register1_q_net_x2
    );

  pipeline20_0a2b041e30: entity work.pipeline1_entity_ce5d488c45
    port map (
      ce_1 => ce_1_sg_x248,
      clk_1 => clk_1_sg_x248,
      d => reinterpret2_output_port_net_x0,
      q => register1_q_net_x3
    );

  pipeline2_1b432896fe: entity work.pipeline2_entity_5eadf3bb39
    port map (
      ce_1 => ce_1_sg_x248,
      clk_1 => clk_1_sg_x248,
      d => delay66_q_net_x0,
      q => register1_q_net_x0
    );

  pipeline7_e525f997b4: entity work.pipeline7_entity_51dd812305
    port map (
      ce_1 => ce_1_sg_x248,
      clk_1 => clk_1_sg_x248,
      d => slice4_y_net_x0,
      q => register1_q_net_x1
    );

  pix_05d07f9cb0: entity work.pix_entity_05d07f9cb0
    port map (
      addr => delay6_q_net_x1,
      ce_1 => ce_1_sg_x248,
      clk_1 => clk_1_sg_x248,
      darkquad29_capture1_pix_data_out => darkquad29_capture1_pix_data_out_net_x2,
      data_in => constant3_op_net_x1,
      we => constant2_op_net_x0,
      convert_addr_x0 => convert_addr_dout_net_x1,
      convert_din1_x0 => convert_din1_dout_net_x1,
      convert_we_x0 => convert_we_dout_net_x1,
      data_out => reinterpret_out_output_port_net_x2
    );

  reinterpret1: entity work.reinterpret_151459306d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => delay16_q_net,
      output_port => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_9a0fa0f632
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret2_output_port_net_x0
    );

  reinterpret3: entity work.reinterpret_9a0fa0f632
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice3_y_net,
      output_port => reinterpret3_output_port_net_x0
    );

  reinterpret4: entity work.reinterpret_713b6c5d29
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => register1_q_net_x0,
      output_port => reinterpret4_output_port_net
    );

  reinterpret6: entity work.reinterpret_b754317574
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => delay19_q_net,
      output_port => reinterpret6_output_port_net
    );

  reinterpret7: entity work.reinterpret_580feec131
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => delay22_q_net,
      output_port => reinterpret7_output_port_net
    );

  reinterpret8: entity work.reinterpret_573890e1c0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => delay32_q_net,
      output_port => reinterpret8_output_port_net
    );

  s_12_9_1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 13,
      din_width => 16,
      dout_arith => 2,
      dout_bin_pt => 14,
      dout_width => 17,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      clr => '0',
      din => delay7_q_net,
      en => "1",
      dout => s_12_9_1_dout_net
    );

  s_12_9_3: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 13,
      din_width => 16,
      dout_arith => 2,
      dout_bin_pt => 15,
      dout_width => 18,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      clr => '0',
      din => delay11_q_net,
      en => "1",
      dout => s_12_9_3_dout_net
    );

  single_port_ram: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 16,
      core_name0 => "bmg_72_b40f882ae90aebcf",
      latency => 2
    )
    port map (
      addr => mux1_y_net,
      ce => ce_1_sg_x248,
      clk => clk_1_sg_x248,
      data_in => reinterpret1_output_port_net,
      en => "1",
      rst => "0",
      we(0) => delay1_q_net,
      data_out => single_port_ram_data_out_net
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 19,
      x_width => 32,
      y_width => 20
    )
    port map (
      x => reinterpret_out_output_port_net_x2,
      y => slice1_y_net
    );

  slice13: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => delay2_q_net,
      y(0) => slice13_y_net
    );

  slice14: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 8,
      x_width => 32,
      y_width => 8
    )
    port map (
      x => delay2_q_net,
      y => slice14_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 17,
      x_width => 32,
      y_width => 18
    )
    port map (
      x => reint1_output_port_net_x0,
      y => slice2_y_net
    );

  slice3: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 17,
      x_width => 32,
      y_width => 18
    )
    port map (
      x => reint1_output_port_net_x1,
      y => slice3_y_net
    );

  slice4: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 14,
      x_width => 32,
      y_width => 15
    )
    port map (
      x => reint1_output_port_net_x2,
      y => slice4_y_net_x0
    );

  slice5: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 15,
      x_width => 32,
      y_width => 16
    )
    port map (
      x => delay3_q_net,
      y => slice5_y_net
    );

  threshold_0e4d6015d7: entity work.threshold_entity_0e4d6015d7
    port map (
      darkquad29_capture1_threshold_user_data_out => darkquad29_capture1_threshold_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x4
    );

  trigger_5f21b7688f: entity work.trigger_entity_9aeb6a1bfd
    port map (
      baseline => delay31_q_net_x1,
      ce_1 => ce_1_sg_x248,
      ch_in => delay28_q_net_x1,
      clk_1 => clk_1_sg_x248,
      filtered_in => delay44_q_net_x0,
      raw_in => delay26_q_net_x1,
      threshold => delay30_q_net_x1,
      base_out => delay13_q_net_x0,
      ch_out => delay74_q_net_x0,
      data_out => delay15_q_net_x0,
      trigger => logical7_y_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture2/base_kf"

entity base_kf_entity_0650701dfd is
  port (
    darkquad29_capture2_base_kf_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end base_kf_entity_0650701dfd;

architecture structural of base_kf_entity_0650701dfd is
  signal darkquad29_capture2_base_kf_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_capture2_base_kf_user_data_out_net_x0 <= darkquad29_capture2_base_kf_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_capture2_base_kf_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture2/base_kq"

entity base_kq_entity_b6f4936c1a is
  port (
    darkquad29_capture2_base_kq_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end base_kq_entity_b6f4936c1a;

architecture structural of base_kq_entity_b6f4936c1a is
  signal darkquad29_capture2_base_kq_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_capture2_base_kq_user_data_out_net_x0 <= darkquad29_capture2_base_kq_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_capture2_base_kq_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture2/cps_lim"

entity cps_lim_entity_9587fb2ede is
  port (
    darkquad29_capture2_cps_lim_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end cps_lim_entity_9587fb2ede;

architecture structural of cps_lim_entity_9587fb2ede is
  signal darkquad29_capture2_cps_lim_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_capture2_cps_lim_user_data_out_net_x0 <= darkquad29_capture2_cps_lim_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_capture2_cps_lim_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture2/load_thresh"

entity load_thresh_entity_744ad3ed8f is
  port (
    darkquad29_capture2_load_thresh_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end load_thresh_entity_744ad3ed8f;

architecture structural of load_thresh_entity_744ad3ed8f is
  signal darkquad29_capture2_load_thresh_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_capture2_load_thresh_user_data_out_net_x0 <= darkquad29_capture2_load_thresh_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_capture2_load_thresh_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture2/pix"

entity pix_entity_8fd46338bd is
  port (
    addr: in std_logic_vector(7 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    darkquad29_capture2_pix_data_out: in std_logic_vector(31 downto 0); 
    data_in: in std_logic_vector(9 downto 0); 
    we: in std_logic; 
    convert_addr_x0: out std_logic_vector(9 downto 0); 
    convert_din1_x0: out std_logic_vector(31 downto 0); 
    convert_we_x0: out std_logic; 
    data_out: out std_logic_vector(31 downto 0)
  );
end pix_entity_8fd46338bd;

architecture structural of pix_entity_8fd46338bd is
  signal ce_1_sg_x272: std_logic;
  signal clk_1_sg_x272: std_logic;
  signal constant2_op_net_x0: std_logic;
  signal constant3_op_net_x1: std_logic_vector(9 downto 0);
  signal convert_addr_dout_net_x0: std_logic_vector(9 downto 0);
  signal convert_din1_dout_net_x0: std_logic_vector(31 downto 0);
  signal convert_we_dout_net_x0: std_logic;
  signal darkquad29_capture2_pix_data_out_net_x1: std_logic_vector(31 downto 0);
  signal delay6_q_net_x1: std_logic_vector(7 downto 0);
  signal mux_y_net_x0: std_logic_vector(9 downto 0);
  signal reinterpret_out_output_port_net_x0: std_logic_vector(9 downto 0);
  signal reinterpret_out_output_port_net_x2: std_logic_vector(31 downto 0);

begin
  delay6_q_net_x1 <= addr;
  ce_1_sg_x272 <= ce_1;
  clk_1_sg_x272 <= clk_1;
  darkquad29_capture2_pix_data_out_net_x1 <= darkquad29_capture2_pix_data_out;
  constant3_op_net_x1 <= data_in;
  constant2_op_net_x0 <= we;
  convert_addr_x0 <= convert_addr_dout_net_x0;
  convert_din1_x0 <= convert_din1_dout_net_x0;
  convert_we_x0 <= convert_we_dout_net_x0;
  data_out <= reinterpret_out_output_port_net_x2;

  calc_add_fc4973d657: entity work.calc_add_entity_27b5517daf
    port map (
      ce_1 => ce_1_sg_x272,
      clk_1 => clk_1_sg_x272,
      in_x0 => delay6_q_net_x1,
      out_x0 => mux_y_net_x0
    );

  convert_addr: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 10,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 10,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x272,
      clk => clk_1_sg_x272,
      clr => '0',
      din => mux_y_net_x0,
      en => "1",
      dout => convert_addr_dout_net_x0
    );

  convert_din1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 10,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x272,
      clk => clk_1_sg_x272,
      clr => '0',
      din => reinterpret_out_output_port_net_x0,
      en => "1",
      dout => convert_din1_dout_net_x0
    );

  convert_we: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x272,
      clk => clk_1_sg_x272,
      clr => '0',
      din(0) => constant2_op_net_x0,
      en => "1",
      dout(0) => convert_we_dout_net_x0
    );

  munge_in_373f06dac7: entity work.munge_in_entity_9df1f10b0c
    port map (
      din => constant3_op_net_x1,
      dout => reinterpret_out_output_port_net_x0
    );

  munge_out_9638434417: entity work.munge_in_entity_9341d54c73
    port map (
      din => darkquad29_capture2_pix_data_out_net_x1,
      dout => reinterpret_out_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture2/threshold"

entity threshold_entity_d1f5212005 is
  port (
    darkquad29_capture2_threshold_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end threshold_entity_d1f5212005;

architecture structural of threshold_entity_d1f5212005 is
  signal darkquad29_capture2_threshold_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_capture2_threshold_user_data_out_net_x0 <= darkquad29_capture2_threshold_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_capture2_threshold_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture2"

entity capture2_entity_a102a35138 is
  port (
    ce_1: in std_logic; 
    ch_in: in std_logic_vector(7 downto 0); 
    clk_1: in std_logic; 
    darkquad29_capture2_base_kf_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture2_base_kq_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture2_cps_lim_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture2_load_thresh_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture2_pix_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture2_threshold_user_data_out: in std_logic_vector(31 downto 0); 
    data_in: in std_logic_vector(11 downto 0); 
    pps: in std_logic; 
    ts_in: in std_logic_vector(8 downto 0); 
    phase_out: out std_logic_vector(15 downto 0); 
    photon_out: out std_logic_vector(63 downto 0); 
    pix: out std_logic_vector(9 downto 0); 
    pix_x0: out std_logic_vector(31 downto 0); 
    pix_x1: out std_logic; 
    we_out: out std_logic
  );
end capture2_entity_a102a35138;

architecture structural of capture2_entity_a102a35138 is
  signal ce_1_sg_x283: std_logic;
  signal clk_1_sg_x283: std_logic;
  signal concat1_y_net: std_logic_vector(63 downto 0);
  signal constant2_op_net_x0: std_logic;
  signal constant3_op_net_x1: std_logic_vector(9 downto 0);
  signal convert2_dout_net: std_logic_vector(15 downto 0);
  signal convert_addr_dout_net_x1: std_logic_vector(9 downto 0);
  signal convert_din1_dout_net_x1: std_logic_vector(31 downto 0);
  signal convert_dout_net_x0: std_logic_vector(15 downto 0);
  signal convert_we_dout_net_x1: std_logic;
  signal darkquad29_capture2_base_kf_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal darkquad29_capture2_base_kq_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal darkquad29_capture2_cps_lim_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal darkquad29_capture2_load_thresh_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal darkquad29_capture2_pix_data_out_net_x2: std_logic_vector(31 downto 0);
  signal darkquad29_capture2_threshold_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal delay10_q_net: std_logic_vector(8 downto 0);
  signal delay11_q_net: std_logic_vector(15 downto 0);
  signal delay12_q_net: std_logic_vector(8 downto 0);
  signal delay13_q_net_x0: std_logic_vector(15 downto 0);
  signal delay13_q_net_x1: std_logic;
  signal delay14_q_net_x1: std_logic;
  signal delay14_q_net_x3: std_logic;
  signal delay15_q_net: std_logic_vector(7 downto 0);
  signal delay15_q_net_x0: std_logic_vector(15 downto 0);
  signal delay16_q_net: std_logic_vector(15 downto 0);
  signal delay17_q_net: std_logic_vector(15 downto 0);
  signal delay18_q_net: std_logic_vector(15 downto 0);
  signal delay19_q_net: std_logic_vector(8 downto 0);
  signal delay19_q_net_x0: std_logic_vector(15 downto 0);
  signal delay1_q_net: std_logic;
  signal delay20_q_net: std_logic_vector(15 downto 0);
  signal delay20_q_net_x0: std_logic_vector(15 downto 0);
  signal delay21_q_net: std_logic_vector(7 downto 0);
  signal delay21_q_net_x0: std_logic_vector(7 downto 0);
  signal delay22_q_net: std_logic_vector(17 downto 0);
  signal delay23_q_net: std_logic_vector(15 downto 0);
  signal delay24_q_net: std_logic;
  signal delay25_q_net_x0: std_logic_vector(7 downto 0);
  signal delay26_q_net_x1: std_logic_vector(15 downto 0);
  signal delay27_q_net_x0: std_logic_vector(15 downto 0);
  signal delay28_q_net_x1: std_logic_vector(7 downto 0);
  signal delay29_q_net: std_logic_vector(8 downto 0);
  signal delay2_q_net: std_logic_vector(31 downto 0);
  signal delay30_q_net_x1: std_logic_vector(15 downto 0);
  signal delay31_q_net_x1: std_logic_vector(15 downto 0);
  signal delay32_q_net: std_logic_vector(16 downto 0);
  signal delay33_q_net_x0: std_logic;
  signal delay33_q_net_x1: std_logic_vector(11 downto 0);
  signal delay34_q_net_x0: std_logic;
  signal delay34_q_net_x1: std_logic_vector(7 downto 0);
  signal delay35_q_net: std_logic;
  signal delay36_q_net: std_logic;
  signal delay37_q_net: std_logic;
  signal delay38_q_net: std_logic;
  signal delay39_q_net: std_logic;
  signal delay3_q_net: std_logic_vector(31 downto 0);
  signal delay40_q_net: std_logic;
  signal delay41_q_net: std_logic;
  signal delay42_q_net: std_logic;
  signal delay43_q_net: std_logic_vector(17 downto 0);
  signal delay44_q_net_x0: std_logic_vector(15 downto 0);
  signal delay45_q_net: std_logic_vector(15 downto 0);
  signal delay47_q_net: std_logic_vector(15 downto 0);
  signal delay49_q_net: std_logic_vector(15 downto 0);
  signal delay4_q_net: std_logic_vector(8 downto 0);
  signal delay50_q_net: std_logic_vector(16 downto 0);
  signal delay51_q_net: std_logic_vector(8 downto 0);
  signal delay53_q_net: std_logic_vector(15 downto 0);
  signal delay54_q_net: std_logic_vector(17 downto 0);
  signal delay56_q_net: std_logic_vector(16 downto 0);
  signal delay57_q_net: std_logic_vector(8 downto 0);
  signal delay58_q_net_x0: std_logic_vector(15 downto 0);
  signal delay5_q_net: std_logic_vector(8 downto 0);
  signal delay65_q_net: std_logic_vector(8 downto 0);
  signal delay66_q_net_x0: std_logic_vector(19 downto 0);
  signal delay6_q_net_x1: std_logic_vector(7 downto 0);
  signal delay74_q_net: std_logic;
  signal delay74_q_net_x0: std_logic_vector(7 downto 0);
  signal delay79_q_net: std_logic_vector(63 downto 0);
  signal delay7_q_net: std_logic_vector(15 downto 0);
  signal delay80_q_net: std_logic_vector(15 downto 0);
  signal delay81_q_net: std_logic_vector(15 downto 0);
  signal delay87_q_net_x0: std_logic_vector(63 downto 0);
  signal delay8_q_net: std_logic;
  signal delay9_q_net: std_logic_vector(8 downto 0);
  signal delay9_q_net_x4: std_logic_vector(8 downto 0);
  signal logical1_y_net: std_logic;
  signal logical2_y_net_x0: std_logic;
  signal logical7_y_net_x0: std_logic;
  signal logical7_y_net_x1: std_logic;
  signal mux1_y_net: std_logic_vector(7 downto 0);
  signal register1_q_net_x0: std_logic_vector(19 downto 0);
  signal register1_q_net_x1: std_logic_vector(14 downto 0);
  signal register1_q_net_x2: std_logic_vector(17 downto 0);
  signal register1_q_net_x3: std_logic_vector(17 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x2: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x3: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x4: std_logic_vector(31 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(15 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret3_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret4_output_port_net: std_logic_vector(19 downto 0);
  signal reinterpret6_output_port_net: std_logic_vector(8 downto 0);
  signal reinterpret7_output_port_net: std_logic_vector(17 downto 0);
  signal reinterpret8_output_port_net: std_logic_vector(16 downto 0);
  signal reinterpret_out_output_port_net_x2: std_logic_vector(31 downto 0);
  signal relational5_op_net_x1: std_logic;
  signal s_12_9_1_dout_net: std_logic_vector(16 downto 0);
  signal s_12_9_3_dout_net: std_logic_vector(17 downto 0);
  signal single_port_ram_data_out_net: std_logic_vector(15 downto 0);
  signal slice13_y_net: std_logic;
  signal slice14_y_net: std_logic_vector(7 downto 0);
  signal slice1_y_net: std_logic_vector(19 downto 0);
  signal slice2_y_net: std_logic_vector(17 downto 0);
  signal slice3_y_net: std_logic_vector(17 downto 0);
  signal slice4_y_net_x0: std_logic_vector(14 downto 0);
  signal slice5_y_net: std_logic_vector(15 downto 0);

begin
  ce_1_sg_x283 <= ce_1;
  delay34_q_net_x1 <= ch_in;
  clk_1_sg_x283 <= clk_1;
  darkquad29_capture2_base_kf_user_data_out_net_x1 <= darkquad29_capture2_base_kf_user_data_out;
  darkquad29_capture2_base_kq_user_data_out_net_x1 <= darkquad29_capture2_base_kq_user_data_out;
  darkquad29_capture2_cps_lim_user_data_out_net_x1 <= darkquad29_capture2_cps_lim_user_data_out;
  darkquad29_capture2_load_thresh_user_data_out_net_x1 <= darkquad29_capture2_load_thresh_user_data_out;
  darkquad29_capture2_pix_data_out_net_x2 <= darkquad29_capture2_pix_data_out;
  darkquad29_capture2_threshold_user_data_out_net_x1 <= darkquad29_capture2_threshold_user_data_out;
  delay33_q_net_x1 <= data_in;
  delay14_q_net_x3 <= pps;
  delay9_q_net_x4 <= ts_in;
  phase_out <= delay58_q_net_x0;
  photon_out <= delay87_q_net_x0;
  pix <= convert_addr_dout_net_x1;
  pix_x0 <= convert_din1_dout_net_x1;
  pix_x1 <= convert_we_dout_net_x1;
  we_out <= logical2_y_net_x0;

  base_kf_0650701dfd: entity work.base_kf_entity_0650701dfd
    port map (
      darkquad29_capture2_base_kf_user_data_out => darkquad29_capture2_base_kf_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x0
    );

  base_kq_b6f4936c1a: entity work.base_kq_entity_b6f4936c1a
    port map (
      darkquad29_capture2_base_kq_user_data_out => darkquad29_capture2_base_kq_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x1
    );

  concat1: entity work.concat_d7ce1ba691
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret4_output_port_net,
      in1 => reinterpret6_output_port_net,
      in2 => reinterpret7_output_port_net,
      in3 => reinterpret8_output_port_net,
      y => concat1_y_net
    );

  constant2: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant2_op_net_x0
    );

  constant3: entity work.constant_498bc68c14
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant3_op_net_x1
    );

  convert2: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 9,
      din_width => 12,
      dout_arith => 2,
      dout_bin_pt => 13,
      dout_width => 16,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      clr => '0',
      din => delay33_q_net_x1,
      en => "1",
      dout => convert2_dout_net
    );

  cps_lim_9587fb2ede: entity work.cps_lim_entity_9587fb2ede
    port map (
      darkquad29_capture2_cps_lim_user_data_out => darkquad29_capture2_cps_lim_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x2
    );

  deadtime_4da948b7b2: entity work.deadtime_entity_87d78ea2d1
    port map (
      ce_1 => ce_1_sg_x283,
      clk_1 => clk_1_sg_x283,
      in_x0 => delay14_q_net_x1,
      out_x0 => logical7_y_net_x0
    );

  delay1: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d(0) => slice13_y_net,
      en => '1',
      rst => '1',
      q(0) => delay1_q_net
    );

  delay10: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 9
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d => delay9_q_net,
      en => '1',
      rst => '1',
      q => delay10_q_net
    );

  delay11: entity work.delay_4246ea65a9
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      clr => '0',
      d => delay15_q_net_x0,
      q => delay11_q_net
    );

  delay12: entity work.delay_09771002d6
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      clr => '0',
      d => delay5_q_net,
      q => delay12_q_net
    );

  delay13: entity work.delay_c53de546ea
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      clr => '0',
      d(0) => logical1_y_net,
      q(0) => delay13_q_net_x1
    );

  delay14: entity work.delay_9701834818
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      clr => '0',
      d(0) => logical1_y_net,
      q(0) => delay14_q_net_x1
    );

  delay15: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d => delay34_q_net_x1,
      en => '1',
      rst => '1',
      q => delay15_q_net
    );

  delay16: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d => slice5_y_net,
      en => '1',
      rst => '1',
      q => delay16_q_net
    );

  delay17: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d => convert2_dout_net,
      en => '1',
      rst => '1',
      q => delay17_q_net
    );

  delay18: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d => single_port_ram_data_out_net,
      en => '1',
      rst => '1',
      q => delay18_q_net
    );

  delay19: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 9
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d => delay57_q_net,
      en => '1',
      rst => '1',
      q => delay19_q_net
    );

  delay2: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 32
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d => reint1_output_port_net_x3,
      en => '1',
      rst => '1',
      q => delay2_q_net
    );

  delay20: entity work.xldelay
    generic map (
      latency => 14,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d => delay18_q_net,
      en => '1',
      rst => '1',
      q => delay20_q_net
    );

  delay21: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d => delay15_q_net,
      en => '1',
      rst => '1',
      q => delay21_q_net
    );

  delay22: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 18
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d => delay54_q_net,
      en => '1',
      rst => '1',
      q => delay22_q_net
    );

  delay23: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d => delay17_q_net,
      en => '1',
      rst => '1',
      q => delay23_q_net
    );

  delay24: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d(0) => delay8_q_net,
      en => '1',
      rst => '1',
      q(0) => delay24_q_net
    );

  delay25: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d => delay21_q_net,
      en => '1',
      rst => '1',
      q => delay25_q_net_x0
    );

  delay26: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d => delay20_q_net_x0,
      en => '1',
      rst => '1',
      q => delay26_q_net_x1
    );

  delay27: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d => delay23_q_net,
      en => '1',
      rst => '1',
      q => delay27_q_net_x0
    );

  delay28: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d => delay21_q_net_x0,
      en => '1',
      rst => '1',
      q => delay28_q_net_x1
    );

  delay29: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 9
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d => delay65_q_net,
      en => '1',
      rst => '1',
      q => delay29_q_net
    );

  delay3: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 32
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d => reint1_output_port_net_x4,
      en => '1',
      rst => '1',
      q => delay3_q_net
    );

  delay30: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d => delay20_q_net,
      en => '1',
      rst => '1',
      q => delay30_q_net_x1
    );

  delay31: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d => convert_dout_net_x0,
      en => '1',
      rst => '1',
      q => delay31_q_net_x1
    );

  delay32: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 17
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d => delay56_q_net,
      en => '1',
      rst => '1',
      q => delay32_q_net
    );

  delay33: entity work.xldelay
    generic map (
      latency => 13,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d(0) => delay38_q_net,
      en => '1',
      rst => '1',
      q(0) => delay33_q_net_x0
    );

  delay34: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d(0) => delay35_q_net,
      en => '1',
      rst => '1',
      q(0) => delay34_q_net_x0
    );

  delay35: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d(0) => delay36_q_net,
      en => '1',
      rst => '1',
      q(0) => delay35_q_net
    );

  delay36: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d(0) => delay37_q_net,
      en => '1',
      rst => '1',
      q(0) => delay36_q_net
    );

  delay37: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      clr => '0',
      d(0) => delay33_q_net_x0,
      q(0) => delay37_q_net
    );

  delay38: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d(0) => delay39_q_net,
      en => '1',
      rst => '1',
      q(0) => delay38_q_net
    );

  delay39: entity work.xldelay
    generic map (
      latency => 14,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d(0) => delay40_q_net,
      en => '1',
      rst => '1',
      q(0) => delay39_q_net
    );

  delay4: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 9
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d => delay9_q_net_x4,
      en => '1',
      rst => '1',
      q => delay4_q_net
    );

  delay40: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d(0) => delay41_q_net,
      en => '1',
      rst => '1',
      q(0) => delay40_q_net
    );

  delay41: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d(0) => delay42_q_net,
      en => '1',
      rst => '1',
      q(0) => delay41_q_net
    );

  delay42: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d(0) => delay14_q_net_x3,
      en => '1',
      rst => '1',
      q(0) => delay42_q_net
    );

  delay43: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 18
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d => s_12_9_3_dout_net,
      en => '1',
      rst => '1',
      q => delay43_q_net
    );

  delay44: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d => delay19_q_net_x0,
      en => '1',
      rst => '1',
      q => delay44_q_net_x0
    );

  delay45: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d => delay81_q_net,
      en => '1',
      rst => '1',
      q => delay45_q_net
    );

  delay47: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d => delay45_q_net,
      en => '1',
      rst => '1',
      q => delay47_q_net
    );

  delay49: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d => delay47_q_net,
      en => '1',
      rst => '1',
      q => delay49_q_net
    );

  delay5: entity work.xldelay
    generic map (
      latency => 13,
      reg_retiming => 0,
      reset => 0,
      width => 9
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d => delay29_q_net,
      en => '1',
      rst => '1',
      q => delay5_q_net
    );

  delay50: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 17
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d => s_12_9_1_dout_net,
      en => '1',
      rst => '1',
      q => delay50_q_net
    );

  delay51: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 9
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d => delay12_q_net,
      en => '1',
      rst => '1',
      q => delay51_q_net
    );

  delay53: entity work.xldelay
    generic map (
      latency => 6,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d => delay49_q_net,
      en => '1',
      rst => '1',
      q => delay53_q_net
    );

  delay54: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 18
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d => delay43_q_net,
      en => '1',
      rst => '1',
      q => delay54_q_net
    );

  delay56: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 17
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d => delay50_q_net,
      en => '1',
      rst => '1',
      q => delay56_q_net
    );

  delay57: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 9
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d => delay51_q_net,
      en => '1',
      rst => '1',
      q => delay57_q_net
    );

  delay58: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d => delay53_q_net,
      en => '1',
      rst => '1',
      q => delay58_q_net_x0
    );

  delay6: entity work.delay_ebec135d8a
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      clr => '0',
      d => delay74_q_net_x0,
      q => delay6_q_net_x1
    );

  delay65: entity work.xldelay
    generic map (
      latency => 14,
      reg_retiming => 0,
      reset => 0,
      width => 9
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d => delay10_q_net,
      en => '1',
      rst => '1',
      q => delay65_q_net
    );

  delay66: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 20
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d => slice1_y_net,
      en => '1',
      rst => '1',
      q => delay66_q_net_x0
    );

  delay7: entity work.delay_4246ea65a9
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      clr => '0',
      d => delay13_q_net_x0,
      q => delay7_q_net
    );

  delay74: entity work.xldelay
    generic map (
      latency => 6,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d(0) => delay13_q_net_x1,
      en => '1',
      rst => '1',
      q(0) => delay74_q_net
    );

  delay79: entity work.xldelay
    generic map (
      latency => 6,
      reg_retiming => 0,
      reset => 0,
      width => 64
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d => concat1_y_net,
      en => '1',
      rst => '1',
      q => delay79_q_net
    );

  delay8: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      clr => '0',
      d(0) => logical7_y_net_x1,
      q(0) => delay8_q_net
    );

  delay80: entity work.xldelay
    generic map (
      latency => 13,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d => delay26_q_net_x1,
      en => '1',
      rst => '1',
      q => delay80_q_net
    );

  delay81: entity work.delay_4246ea65a9
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      clr => '0',
      d => delay80_q_net,
      q => delay81_q_net
    );

  delay87: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 64
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d => delay79_q_net,
      en => '1',
      rst => '1',
      q => delay87_q_net_x0
    );

  delay9: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 9
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      d => delay4_q_net,
      en => '1',
      rst => '1',
      q => delay9_q_net
    );

  filter_3bf25ce06e: entity work.filter_entity_c79fa858fb
    port map (
      ce_1 => ce_1_sg_x283,
      ch_in => delay25_q_net_x0,
      clk_1 => clk_1_sg_x283,
      kf => register1_q_net_x3,
      kq => register1_q_net_x2,
      raw_in => delay27_q_net_x0,
      ch_out => delay21_q_net_x0,
      filtered_out => delay19_q_net_x0,
      raw_out => delay20_q_net_x0,
      res_out => convert_dout_net_x0
    );

  lim_cps_44c886215e: entity work.lim_cps_entity_99d2deee63
    port map (
      ce_1 => ce_1_sg_x283,
      clk_1 => clk_1_sg_x283,
      lim => register1_q_net_x1,
      pps => delay34_q_net_x0,
      trig => delay13_q_net_x1,
      under_cap => relational5_op_net_x1
    );

  load_thresh_744ad3ed8f: entity work.load_thresh_entity_744ad3ed8f
    port map (
      darkquad29_capture2_load_thresh_user_data_out => darkquad29_capture2_load_thresh_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x3
    );

  logical1: entity work.logical_799f62af22
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      clr => '0',
      d0(0) => delay24_q_net,
      d1(0) => logical7_y_net_x0,
      y(0) => logical1_y_net
    );

  logical2: entity work.logical_799f62af22
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      clr => '0',
      d0(0) => delay74_q_net,
      d1(0) => relational5_op_net_x1,
      y(0) => logical2_y_net_x0
    );

  mux1: entity work.mux_cc14a035dc
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      clr => '0',
      d0 => delay34_q_net_x1,
      d1 => slice14_y_net,
      sel(0) => slice13_y_net,
      y => mux1_y_net
    );

  pipeline1_5d4567552e: entity work.pipeline1_entity_ce5d488c45
    port map (
      ce_1 => ce_1_sg_x283,
      clk_1 => clk_1_sg_x283,
      d => reinterpret3_output_port_net_x0,
      q => register1_q_net_x2
    );

  pipeline20_a92cc6262b: entity work.pipeline1_entity_ce5d488c45
    port map (
      ce_1 => ce_1_sg_x283,
      clk_1 => clk_1_sg_x283,
      d => reinterpret2_output_port_net_x0,
      q => register1_q_net_x3
    );

  pipeline2_34fad9de69: entity work.pipeline2_entity_5eadf3bb39
    port map (
      ce_1 => ce_1_sg_x283,
      clk_1 => clk_1_sg_x283,
      d => delay66_q_net_x0,
      q => register1_q_net_x0
    );

  pipeline7_130aabfdf9: entity work.pipeline7_entity_51dd812305
    port map (
      ce_1 => ce_1_sg_x283,
      clk_1 => clk_1_sg_x283,
      d => slice4_y_net_x0,
      q => register1_q_net_x1
    );

  pix_8fd46338bd: entity work.pix_entity_8fd46338bd
    port map (
      addr => delay6_q_net_x1,
      ce_1 => ce_1_sg_x283,
      clk_1 => clk_1_sg_x283,
      darkquad29_capture2_pix_data_out => darkquad29_capture2_pix_data_out_net_x2,
      data_in => constant3_op_net_x1,
      we => constant2_op_net_x0,
      convert_addr_x0 => convert_addr_dout_net_x1,
      convert_din1_x0 => convert_din1_dout_net_x1,
      convert_we_x0 => convert_we_dout_net_x1,
      data_out => reinterpret_out_output_port_net_x2
    );

  reinterpret1: entity work.reinterpret_151459306d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => delay16_q_net,
      output_port => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_9a0fa0f632
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret2_output_port_net_x0
    );

  reinterpret3: entity work.reinterpret_9a0fa0f632
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice3_y_net,
      output_port => reinterpret3_output_port_net_x0
    );

  reinterpret4: entity work.reinterpret_713b6c5d29
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => register1_q_net_x0,
      output_port => reinterpret4_output_port_net
    );

  reinterpret6: entity work.reinterpret_b754317574
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => delay19_q_net,
      output_port => reinterpret6_output_port_net
    );

  reinterpret7: entity work.reinterpret_580feec131
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => delay22_q_net,
      output_port => reinterpret7_output_port_net
    );

  reinterpret8: entity work.reinterpret_573890e1c0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => delay32_q_net,
      output_port => reinterpret8_output_port_net
    );

  s_12_9_1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 13,
      din_width => 16,
      dout_arith => 2,
      dout_bin_pt => 14,
      dout_width => 17,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      clr => '0',
      din => delay7_q_net,
      en => "1",
      dout => s_12_9_1_dout_net
    );

  s_12_9_3: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 13,
      din_width => 16,
      dout_arith => 2,
      dout_bin_pt => 15,
      dout_width => 18,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      clr => '0',
      din => delay11_q_net,
      en => "1",
      dout => s_12_9_3_dout_net
    );

  single_port_ram: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 16,
      core_name0 => "bmg_72_b40f882ae90aebcf",
      latency => 2
    )
    port map (
      addr => mux1_y_net,
      ce => ce_1_sg_x283,
      clk => clk_1_sg_x283,
      data_in => reinterpret1_output_port_net,
      en => "1",
      rst => "0",
      we(0) => delay1_q_net,
      data_out => single_port_ram_data_out_net
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 19,
      x_width => 32,
      y_width => 20
    )
    port map (
      x => reinterpret_out_output_port_net_x2,
      y => slice1_y_net
    );

  slice13: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => delay2_q_net,
      y(0) => slice13_y_net
    );

  slice14: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 8,
      x_width => 32,
      y_width => 8
    )
    port map (
      x => delay2_q_net,
      y => slice14_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 17,
      x_width => 32,
      y_width => 18
    )
    port map (
      x => reint1_output_port_net_x0,
      y => slice2_y_net
    );

  slice3: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 17,
      x_width => 32,
      y_width => 18
    )
    port map (
      x => reint1_output_port_net_x1,
      y => slice3_y_net
    );

  slice4: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 14,
      x_width => 32,
      y_width => 15
    )
    port map (
      x => reint1_output_port_net_x2,
      y => slice4_y_net_x0
    );

  slice5: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 15,
      x_width => 32,
      y_width => 16
    )
    port map (
      x => delay3_q_net,
      y => slice5_y_net
    );

  threshold_d1f5212005: entity work.threshold_entity_d1f5212005
    port map (
      darkquad29_capture2_threshold_user_data_out => darkquad29_capture2_threshold_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x4
    );

  trigger_6b3a04399d: entity work.trigger_entity_9aeb6a1bfd
    port map (
      baseline => delay31_q_net_x1,
      ce_1 => ce_1_sg_x283,
      ch_in => delay28_q_net_x1,
      clk_1 => clk_1_sg_x283,
      filtered_in => delay44_q_net_x0,
      raw_in => delay26_q_net_x1,
      threshold => delay30_q_net_x1,
      base_out => delay13_q_net_x0,
      ch_out => delay74_q_net_x0,
      data_out => delay15_q_net_x0,
      trigger => logical7_y_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture3/base_kf"

entity base_kf_entity_13512ae12b is
  port (
    darkquad29_capture3_base_kf_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end base_kf_entity_13512ae12b;

architecture structural of base_kf_entity_13512ae12b is
  signal darkquad29_capture3_base_kf_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_capture3_base_kf_user_data_out_net_x0 <= darkquad29_capture3_base_kf_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_capture3_base_kf_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture3/base_kq"

entity base_kq_entity_e77f98bbc3 is
  port (
    darkquad29_capture3_base_kq_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end base_kq_entity_e77f98bbc3;

architecture structural of base_kq_entity_e77f98bbc3 is
  signal darkquad29_capture3_base_kq_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_capture3_base_kq_user_data_out_net_x0 <= darkquad29_capture3_base_kq_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_capture3_base_kq_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture3/cps_lim"

entity cps_lim_entity_bc0accfa7c is
  port (
    darkquad29_capture3_cps_lim_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end cps_lim_entity_bc0accfa7c;

architecture structural of cps_lim_entity_bc0accfa7c is
  signal darkquad29_capture3_cps_lim_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_capture3_cps_lim_user_data_out_net_x0 <= darkquad29_capture3_cps_lim_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_capture3_cps_lim_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture3/load_thresh"

entity load_thresh_entity_f877541318 is
  port (
    darkquad29_capture3_load_thresh_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end load_thresh_entity_f877541318;

architecture structural of load_thresh_entity_f877541318 is
  signal darkquad29_capture3_load_thresh_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_capture3_load_thresh_user_data_out_net_x0 <= darkquad29_capture3_load_thresh_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_capture3_load_thresh_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture3/pix"

entity pix_entity_886b006b7a is
  port (
    addr: in std_logic_vector(7 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    darkquad29_capture3_pix_data_out: in std_logic_vector(31 downto 0); 
    data_in: in std_logic_vector(9 downto 0); 
    we: in std_logic; 
    convert_addr_x0: out std_logic_vector(9 downto 0); 
    convert_din1_x0: out std_logic_vector(31 downto 0); 
    convert_we_x0: out std_logic; 
    data_out: out std_logic_vector(31 downto 0)
  );
end pix_entity_886b006b7a;

architecture structural of pix_entity_886b006b7a is
  signal ce_1_sg_x307: std_logic;
  signal clk_1_sg_x307: std_logic;
  signal constant2_op_net_x0: std_logic;
  signal constant3_op_net_x1: std_logic_vector(9 downto 0);
  signal convert_addr_dout_net_x0: std_logic_vector(9 downto 0);
  signal convert_din1_dout_net_x0: std_logic_vector(31 downto 0);
  signal convert_we_dout_net_x0: std_logic;
  signal darkquad29_capture3_pix_data_out_net_x1: std_logic_vector(31 downto 0);
  signal delay6_q_net_x1: std_logic_vector(7 downto 0);
  signal mux_y_net_x0: std_logic_vector(9 downto 0);
  signal reinterpret_out_output_port_net_x0: std_logic_vector(9 downto 0);
  signal reinterpret_out_output_port_net_x2: std_logic_vector(31 downto 0);

begin
  delay6_q_net_x1 <= addr;
  ce_1_sg_x307 <= ce_1;
  clk_1_sg_x307 <= clk_1;
  darkquad29_capture3_pix_data_out_net_x1 <= darkquad29_capture3_pix_data_out;
  constant3_op_net_x1 <= data_in;
  constant2_op_net_x0 <= we;
  convert_addr_x0 <= convert_addr_dout_net_x0;
  convert_din1_x0 <= convert_din1_dout_net_x0;
  convert_we_x0 <= convert_we_dout_net_x0;
  data_out <= reinterpret_out_output_port_net_x2;

  calc_add_87fe8eef5c: entity work.calc_add_entity_27b5517daf
    port map (
      ce_1 => ce_1_sg_x307,
      clk_1 => clk_1_sg_x307,
      in_x0 => delay6_q_net_x1,
      out_x0 => mux_y_net_x0
    );

  convert_addr: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 10,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 10,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x307,
      clk => clk_1_sg_x307,
      clr => '0',
      din => mux_y_net_x0,
      en => "1",
      dout => convert_addr_dout_net_x0
    );

  convert_din1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 10,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x307,
      clk => clk_1_sg_x307,
      clr => '0',
      din => reinterpret_out_output_port_net_x0,
      en => "1",
      dout => convert_din1_dout_net_x0
    );

  convert_we: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x307,
      clk => clk_1_sg_x307,
      clr => '0',
      din(0) => constant2_op_net_x0,
      en => "1",
      dout(0) => convert_we_dout_net_x0
    );

  munge_in_89bd0b8dd0: entity work.munge_in_entity_9df1f10b0c
    port map (
      din => constant3_op_net_x1,
      dout => reinterpret_out_output_port_net_x0
    );

  munge_out_9de5945340: entity work.munge_in_entity_9341d54c73
    port map (
      din => darkquad29_capture3_pix_data_out_net_x1,
      dout => reinterpret_out_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture3/threshold"

entity threshold_entity_ff54b219de is
  port (
    darkquad29_capture3_threshold_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end threshold_entity_ff54b219de;

architecture structural of threshold_entity_ff54b219de is
  signal darkquad29_capture3_threshold_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_capture3_threshold_user_data_out_net_x0 <= darkquad29_capture3_threshold_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_capture3_threshold_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/capture3"

entity capture3_entity_cfd3dd3fa9 is
  port (
    ce_1: in std_logic; 
    ch_in: in std_logic_vector(7 downto 0); 
    clk_1: in std_logic; 
    darkquad29_capture3_base_kf_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture3_base_kq_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture3_cps_lim_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture3_load_thresh_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture3_pix_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture3_threshold_user_data_out: in std_logic_vector(31 downto 0); 
    data_in: in std_logic_vector(11 downto 0); 
    pps: in std_logic; 
    ts_in: in std_logic_vector(8 downto 0); 
    phase_out: out std_logic_vector(15 downto 0); 
    photon_out: out std_logic_vector(63 downto 0); 
    pix: out std_logic_vector(9 downto 0); 
    pix_x0: out std_logic_vector(31 downto 0); 
    pix_x1: out std_logic; 
    we_out: out std_logic
  );
end capture3_entity_cfd3dd3fa9;

architecture structural of capture3_entity_cfd3dd3fa9 is
  signal ce_1_sg_x318: std_logic;
  signal clk_1_sg_x318: std_logic;
  signal concat1_y_net: std_logic_vector(63 downto 0);
  signal constant2_op_net_x0: std_logic;
  signal constant3_op_net_x1: std_logic_vector(9 downto 0);
  signal convert2_dout_net: std_logic_vector(15 downto 0);
  signal convert_addr_dout_net_x1: std_logic_vector(9 downto 0);
  signal convert_din1_dout_net_x1: std_logic_vector(31 downto 0);
  signal convert_dout_net_x0: std_logic_vector(15 downto 0);
  signal convert_we_dout_net_x1: std_logic;
  signal darkquad29_capture3_base_kf_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal darkquad29_capture3_base_kq_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal darkquad29_capture3_cps_lim_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal darkquad29_capture3_load_thresh_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal darkquad29_capture3_pix_data_out_net_x2: std_logic_vector(31 downto 0);
  signal darkquad29_capture3_threshold_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal delay10_q_net: std_logic_vector(8 downto 0);
  signal delay11_q_net: std_logic_vector(15 downto 0);
  signal delay12_q_net: std_logic_vector(8 downto 0);
  signal delay13_q_net_x0: std_logic_vector(15 downto 0);
  signal delay13_q_net_x1: std_logic;
  signal delay14_q_net_x1: std_logic;
  signal delay14_q_net_x4: std_logic;
  signal delay15_q_net: std_logic_vector(7 downto 0);
  signal delay15_q_net_x0: std_logic_vector(15 downto 0);
  signal delay16_q_net: std_logic_vector(15 downto 0);
  signal delay17_q_net: std_logic_vector(15 downto 0);
  signal delay18_q_net: std_logic_vector(15 downto 0);
  signal delay19_q_net: std_logic_vector(8 downto 0);
  signal delay19_q_net_x0: std_logic_vector(15 downto 0);
  signal delay1_q_net: std_logic;
  signal delay20_q_net: std_logic_vector(15 downto 0);
  signal delay20_q_net_x0: std_logic_vector(15 downto 0);
  signal delay21_q_net: std_logic_vector(7 downto 0);
  signal delay21_q_net_x0: std_logic_vector(7 downto 0);
  signal delay22_q_net: std_logic_vector(17 downto 0);
  signal delay23_q_net: std_logic_vector(15 downto 0);
  signal delay24_q_net: std_logic;
  signal delay25_q_net_x0: std_logic_vector(7 downto 0);
  signal delay26_q_net_x1: std_logic_vector(15 downto 0);
  signal delay27_q_net_x0: std_logic_vector(15 downto 0);
  signal delay28_q_net_x1: std_logic_vector(7 downto 0);
  signal delay29_q_net: std_logic_vector(8 downto 0);
  signal delay2_q_net: std_logic_vector(31 downto 0);
  signal delay30_q_net_x1: std_logic_vector(15 downto 0);
  signal delay31_q_net_x1: std_logic_vector(15 downto 0);
  signal delay32_q_net: std_logic_vector(16 downto 0);
  signal delay33_q_net: std_logic;
  signal delay34_q_net_x0: std_logic;
  signal delay35_q_net: std_logic;
  signal delay36_q_net: std_logic;
  signal delay37_q_net: std_logic;
  signal delay38_q_net: std_logic;
  signal delay39_q_net: std_logic;
  signal delay3_q_net: std_logic_vector(31 downto 0);
  signal delay40_q_net: std_logic;
  signal delay41_q_net: std_logic;
  signal delay42_q_net: std_logic;
  signal delay43_q_net: std_logic_vector(17 downto 0);
  signal delay44_q_net_x0: std_logic_vector(15 downto 0);
  signal delay45_q_net_x0: std_logic_vector(15 downto 0);
  signal delay45_q_net_x1: std_logic_vector(11 downto 0);
  signal delay46_q_net_x0: std_logic_vector(7 downto 0);
  signal delay47_q_net: std_logic_vector(15 downto 0);
  signal delay49_q_net: std_logic_vector(15 downto 0);
  signal delay4_q_net: std_logic_vector(8 downto 0);
  signal delay50_q_net: std_logic_vector(16 downto 0);
  signal delay51_q_net: std_logic_vector(8 downto 0);
  signal delay53_q_net: std_logic_vector(15 downto 0);
  signal delay54_q_net: std_logic_vector(17 downto 0);
  signal delay56_q_net: std_logic_vector(16 downto 0);
  signal delay57_q_net: std_logic_vector(8 downto 0);
  signal delay58_q_net_x0: std_logic_vector(15 downto 0);
  signal delay5_q_net: std_logic_vector(8 downto 0);
  signal delay65_q_net: std_logic_vector(8 downto 0);
  signal delay66_q_net_x0: std_logic_vector(19 downto 0);
  signal delay6_q_net_x1: std_logic_vector(7 downto 0);
  signal delay74_q_net: std_logic;
  signal delay74_q_net_x0: std_logic_vector(7 downto 0);
  signal delay79_q_net: std_logic_vector(63 downto 0);
  signal delay7_q_net: std_logic_vector(15 downto 0);
  signal delay80_q_net: std_logic_vector(15 downto 0);
  signal delay81_q_net: std_logic_vector(15 downto 0);
  signal delay87_q_net_x0: std_logic_vector(63 downto 0);
  signal delay8_q_net: std_logic;
  signal delay9_q_net: std_logic_vector(8 downto 0);
  signal delay9_q_net_x5: std_logic_vector(8 downto 0);
  signal logical1_y_net: std_logic;
  signal logical2_y_net_x0: std_logic;
  signal logical7_y_net_x0: std_logic;
  signal logical7_y_net_x1: std_logic;
  signal mux1_y_net: std_logic_vector(7 downto 0);
  signal register1_q_net_x0: std_logic_vector(19 downto 0);
  signal register1_q_net_x1: std_logic_vector(14 downto 0);
  signal register1_q_net_x2: std_logic_vector(17 downto 0);
  signal register1_q_net_x3: std_logic_vector(17 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x2: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x3: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x4: std_logic_vector(31 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(15 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret3_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret4_output_port_net: std_logic_vector(19 downto 0);
  signal reinterpret6_output_port_net: std_logic_vector(8 downto 0);
  signal reinterpret7_output_port_net: std_logic_vector(17 downto 0);
  signal reinterpret8_output_port_net: std_logic_vector(16 downto 0);
  signal reinterpret_out_output_port_net_x2: std_logic_vector(31 downto 0);
  signal relational5_op_net_x1: std_logic;
  signal s_12_9_1_dout_net: std_logic_vector(16 downto 0);
  signal s_12_9_3_dout_net: std_logic_vector(17 downto 0);
  signal single_port_ram_data_out_net: std_logic_vector(15 downto 0);
  signal slice13_y_net: std_logic;
  signal slice14_y_net: std_logic_vector(7 downto 0);
  signal slice1_y_net: std_logic_vector(19 downto 0);
  signal slice2_y_net: std_logic_vector(17 downto 0);
  signal slice3_y_net: std_logic_vector(17 downto 0);
  signal slice4_y_net_x0: std_logic_vector(14 downto 0);
  signal slice5_y_net: std_logic_vector(15 downto 0);

begin
  ce_1_sg_x318 <= ce_1;
  delay46_q_net_x0 <= ch_in;
  clk_1_sg_x318 <= clk_1;
  darkquad29_capture3_base_kf_user_data_out_net_x1 <= darkquad29_capture3_base_kf_user_data_out;
  darkquad29_capture3_base_kq_user_data_out_net_x1 <= darkquad29_capture3_base_kq_user_data_out;
  darkquad29_capture3_cps_lim_user_data_out_net_x1 <= darkquad29_capture3_cps_lim_user_data_out;
  darkquad29_capture3_load_thresh_user_data_out_net_x1 <= darkquad29_capture3_load_thresh_user_data_out;
  darkquad29_capture3_pix_data_out_net_x2 <= darkquad29_capture3_pix_data_out;
  darkquad29_capture3_threshold_user_data_out_net_x1 <= darkquad29_capture3_threshold_user_data_out;
  delay45_q_net_x1 <= data_in;
  delay14_q_net_x4 <= pps;
  delay9_q_net_x5 <= ts_in;
  phase_out <= delay58_q_net_x0;
  photon_out <= delay87_q_net_x0;
  pix <= convert_addr_dout_net_x1;
  pix_x0 <= convert_din1_dout_net_x1;
  pix_x1 <= convert_we_dout_net_x1;
  we_out <= logical2_y_net_x0;

  base_kf_13512ae12b: entity work.base_kf_entity_13512ae12b
    port map (
      darkquad29_capture3_base_kf_user_data_out => darkquad29_capture3_base_kf_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x0
    );

  base_kq_e77f98bbc3: entity work.base_kq_entity_e77f98bbc3
    port map (
      darkquad29_capture3_base_kq_user_data_out => darkquad29_capture3_base_kq_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x1
    );

  concat1: entity work.concat_d7ce1ba691
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret4_output_port_net,
      in1 => reinterpret6_output_port_net,
      in2 => reinterpret7_output_port_net,
      in3 => reinterpret8_output_port_net,
      y => concat1_y_net
    );

  constant2: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant2_op_net_x0
    );

  constant3: entity work.constant_498bc68c14
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant3_op_net_x1
    );

  convert2: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 9,
      din_width => 12,
      dout_arith => 2,
      dout_bin_pt => 13,
      dout_width => 16,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      clr => '0',
      din => delay45_q_net_x1,
      en => "1",
      dout => convert2_dout_net
    );

  cps_lim_bc0accfa7c: entity work.cps_lim_entity_bc0accfa7c
    port map (
      darkquad29_capture3_cps_lim_user_data_out => darkquad29_capture3_cps_lim_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x2
    );

  deadtime_c8b2397601: entity work.deadtime_entity_87d78ea2d1
    port map (
      ce_1 => ce_1_sg_x318,
      clk_1 => clk_1_sg_x318,
      in_x0 => delay14_q_net_x1,
      out_x0 => logical7_y_net_x0
    );

  delay1: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d(0) => slice13_y_net,
      en => '1',
      rst => '1',
      q(0) => delay1_q_net
    );

  delay10: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 9
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d => delay9_q_net,
      en => '1',
      rst => '1',
      q => delay10_q_net
    );

  delay11: entity work.delay_4246ea65a9
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      clr => '0',
      d => delay15_q_net_x0,
      q => delay11_q_net
    );

  delay12: entity work.delay_09771002d6
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      clr => '0',
      d => delay5_q_net,
      q => delay12_q_net
    );

  delay13: entity work.delay_c53de546ea
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      clr => '0',
      d(0) => logical1_y_net,
      q(0) => delay13_q_net_x1
    );

  delay14: entity work.delay_9701834818
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      clr => '0',
      d(0) => logical1_y_net,
      q(0) => delay14_q_net_x1
    );

  delay15: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d => delay46_q_net_x0,
      en => '1',
      rst => '1',
      q => delay15_q_net
    );

  delay16: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d => slice5_y_net,
      en => '1',
      rst => '1',
      q => delay16_q_net
    );

  delay17: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d => convert2_dout_net,
      en => '1',
      rst => '1',
      q => delay17_q_net
    );

  delay18: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d => single_port_ram_data_out_net,
      en => '1',
      rst => '1',
      q => delay18_q_net
    );

  delay19: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 9
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d => delay57_q_net,
      en => '1',
      rst => '1',
      q => delay19_q_net
    );

  delay2: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 32
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d => reint1_output_port_net_x3,
      en => '1',
      rst => '1',
      q => delay2_q_net
    );

  delay20: entity work.xldelay
    generic map (
      latency => 14,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d => delay18_q_net,
      en => '1',
      rst => '1',
      q => delay20_q_net
    );

  delay21: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d => delay15_q_net,
      en => '1',
      rst => '1',
      q => delay21_q_net
    );

  delay22: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 18
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d => delay54_q_net,
      en => '1',
      rst => '1',
      q => delay22_q_net
    );

  delay23: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d => delay17_q_net,
      en => '1',
      rst => '1',
      q => delay23_q_net
    );

  delay24: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d(0) => delay8_q_net,
      en => '1',
      rst => '1',
      q(0) => delay24_q_net
    );

  delay25: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d => delay21_q_net,
      en => '1',
      rst => '1',
      q => delay25_q_net_x0
    );

  delay26: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d => delay20_q_net_x0,
      en => '1',
      rst => '1',
      q => delay26_q_net_x1
    );

  delay27: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d => delay23_q_net,
      en => '1',
      rst => '1',
      q => delay27_q_net_x0
    );

  delay28: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d => delay21_q_net_x0,
      en => '1',
      rst => '1',
      q => delay28_q_net_x1
    );

  delay29: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 9
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d => delay65_q_net,
      en => '1',
      rst => '1',
      q => delay29_q_net
    );

  delay3: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 32
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d => reint1_output_port_net_x4,
      en => '1',
      rst => '1',
      q => delay3_q_net
    );

  delay30: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d => delay20_q_net,
      en => '1',
      rst => '1',
      q => delay30_q_net_x1
    );

  delay31: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d => convert_dout_net_x0,
      en => '1',
      rst => '1',
      q => delay31_q_net_x1
    );

  delay32: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 17
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d => delay56_q_net,
      en => '1',
      rst => '1',
      q => delay32_q_net
    );

  delay33: entity work.xldelay
    generic map (
      latency => 13,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d(0) => delay38_q_net,
      en => '1',
      rst => '1',
      q(0) => delay33_q_net
    );

  delay34: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d(0) => delay35_q_net,
      en => '1',
      rst => '1',
      q(0) => delay34_q_net_x0
    );

  delay35: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d(0) => delay36_q_net,
      en => '1',
      rst => '1',
      q(0) => delay35_q_net
    );

  delay36: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d(0) => delay37_q_net,
      en => '1',
      rst => '1',
      q(0) => delay36_q_net
    );

  delay37: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      clr => '0',
      d(0) => delay33_q_net,
      q(0) => delay37_q_net
    );

  delay38: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d(0) => delay39_q_net,
      en => '1',
      rst => '1',
      q(0) => delay38_q_net
    );

  delay39: entity work.xldelay
    generic map (
      latency => 14,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d(0) => delay40_q_net,
      en => '1',
      rst => '1',
      q(0) => delay39_q_net
    );

  delay4: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 9
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d => delay9_q_net_x5,
      en => '1',
      rst => '1',
      q => delay4_q_net
    );

  delay40: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d(0) => delay41_q_net,
      en => '1',
      rst => '1',
      q(0) => delay40_q_net
    );

  delay41: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d(0) => delay42_q_net,
      en => '1',
      rst => '1',
      q(0) => delay41_q_net
    );

  delay42: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d(0) => delay14_q_net_x4,
      en => '1',
      rst => '1',
      q(0) => delay42_q_net
    );

  delay43: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 18
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d => s_12_9_3_dout_net,
      en => '1',
      rst => '1',
      q => delay43_q_net
    );

  delay44: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d => delay19_q_net_x0,
      en => '1',
      rst => '1',
      q => delay44_q_net_x0
    );

  delay45: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d => delay81_q_net,
      en => '1',
      rst => '1',
      q => delay45_q_net_x0
    );

  delay47: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d => delay45_q_net_x0,
      en => '1',
      rst => '1',
      q => delay47_q_net
    );

  delay49: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d => delay47_q_net,
      en => '1',
      rst => '1',
      q => delay49_q_net
    );

  delay5: entity work.xldelay
    generic map (
      latency => 13,
      reg_retiming => 0,
      reset => 0,
      width => 9
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d => delay29_q_net,
      en => '1',
      rst => '1',
      q => delay5_q_net
    );

  delay50: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 17
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d => s_12_9_1_dout_net,
      en => '1',
      rst => '1',
      q => delay50_q_net
    );

  delay51: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 9
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d => delay12_q_net,
      en => '1',
      rst => '1',
      q => delay51_q_net
    );

  delay53: entity work.xldelay
    generic map (
      latency => 6,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d => delay49_q_net,
      en => '1',
      rst => '1',
      q => delay53_q_net
    );

  delay54: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 18
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d => delay43_q_net,
      en => '1',
      rst => '1',
      q => delay54_q_net
    );

  delay56: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 17
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d => delay50_q_net,
      en => '1',
      rst => '1',
      q => delay56_q_net
    );

  delay57: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 9
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d => delay51_q_net,
      en => '1',
      rst => '1',
      q => delay57_q_net
    );

  delay58: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d => delay53_q_net,
      en => '1',
      rst => '1',
      q => delay58_q_net_x0
    );

  delay6: entity work.delay_ebec135d8a
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      clr => '0',
      d => delay74_q_net_x0,
      q => delay6_q_net_x1
    );

  delay65: entity work.xldelay
    generic map (
      latency => 14,
      reg_retiming => 0,
      reset => 0,
      width => 9
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d => delay10_q_net,
      en => '1',
      rst => '1',
      q => delay65_q_net
    );

  delay66: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 20
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d => slice1_y_net,
      en => '1',
      rst => '1',
      q => delay66_q_net_x0
    );

  delay7: entity work.delay_4246ea65a9
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      clr => '0',
      d => delay13_q_net_x0,
      q => delay7_q_net
    );

  delay74: entity work.xldelay
    generic map (
      latency => 6,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d(0) => delay13_q_net_x1,
      en => '1',
      rst => '1',
      q(0) => delay74_q_net
    );

  delay79: entity work.xldelay
    generic map (
      latency => 6,
      reg_retiming => 0,
      reset => 0,
      width => 64
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d => concat1_y_net,
      en => '1',
      rst => '1',
      q => delay79_q_net
    );

  delay8: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      clr => '0',
      d(0) => logical7_y_net_x1,
      q(0) => delay8_q_net
    );

  delay80: entity work.xldelay
    generic map (
      latency => 13,
      reg_retiming => 0,
      reset => 0,
      width => 16
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d => delay26_q_net_x1,
      en => '1',
      rst => '1',
      q => delay80_q_net
    );

  delay81: entity work.delay_4246ea65a9
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      clr => '0',
      d => delay80_q_net,
      q => delay81_q_net
    );

  delay87: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 64
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d => delay79_q_net,
      en => '1',
      rst => '1',
      q => delay87_q_net_x0
    );

  delay9: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 9
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      d => delay4_q_net,
      en => '1',
      rst => '1',
      q => delay9_q_net
    );

  filter_49f4773f61: entity work.filter_entity_c79fa858fb
    port map (
      ce_1 => ce_1_sg_x318,
      ch_in => delay25_q_net_x0,
      clk_1 => clk_1_sg_x318,
      kf => register1_q_net_x3,
      kq => register1_q_net_x2,
      raw_in => delay27_q_net_x0,
      ch_out => delay21_q_net_x0,
      filtered_out => delay19_q_net_x0,
      raw_out => delay20_q_net_x0,
      res_out => convert_dout_net_x0
    );

  lim_cps_06877ed00d: entity work.lim_cps_entity_99d2deee63
    port map (
      ce_1 => ce_1_sg_x318,
      clk_1 => clk_1_sg_x318,
      lim => register1_q_net_x1,
      pps => delay34_q_net_x0,
      trig => delay13_q_net_x1,
      under_cap => relational5_op_net_x1
    );

  load_thresh_f877541318: entity work.load_thresh_entity_f877541318
    port map (
      darkquad29_capture3_load_thresh_user_data_out => darkquad29_capture3_load_thresh_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x3
    );

  logical1: entity work.logical_799f62af22
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      clr => '0',
      d0(0) => delay24_q_net,
      d1(0) => logical7_y_net_x0,
      y(0) => logical1_y_net
    );

  logical2: entity work.logical_799f62af22
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      clr => '0',
      d0(0) => delay74_q_net,
      d1(0) => relational5_op_net_x1,
      y(0) => logical2_y_net_x0
    );

  mux1: entity work.mux_cc14a035dc
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      clr => '0',
      d0 => delay46_q_net_x0,
      d1 => slice14_y_net,
      sel(0) => slice13_y_net,
      y => mux1_y_net
    );

  pipeline1_f86d6e3c3d: entity work.pipeline1_entity_ce5d488c45
    port map (
      ce_1 => ce_1_sg_x318,
      clk_1 => clk_1_sg_x318,
      d => reinterpret3_output_port_net_x0,
      q => register1_q_net_x2
    );

  pipeline20_99bac639cb: entity work.pipeline1_entity_ce5d488c45
    port map (
      ce_1 => ce_1_sg_x318,
      clk_1 => clk_1_sg_x318,
      d => reinterpret2_output_port_net_x0,
      q => register1_q_net_x3
    );

  pipeline2_3e7db5ead8: entity work.pipeline2_entity_5eadf3bb39
    port map (
      ce_1 => ce_1_sg_x318,
      clk_1 => clk_1_sg_x318,
      d => delay66_q_net_x0,
      q => register1_q_net_x0
    );

  pipeline7_a2cb9d8535: entity work.pipeline7_entity_51dd812305
    port map (
      ce_1 => ce_1_sg_x318,
      clk_1 => clk_1_sg_x318,
      d => slice4_y_net_x0,
      q => register1_q_net_x1
    );

  pix_886b006b7a: entity work.pix_entity_886b006b7a
    port map (
      addr => delay6_q_net_x1,
      ce_1 => ce_1_sg_x318,
      clk_1 => clk_1_sg_x318,
      darkquad29_capture3_pix_data_out => darkquad29_capture3_pix_data_out_net_x2,
      data_in => constant3_op_net_x1,
      we => constant2_op_net_x0,
      convert_addr_x0 => convert_addr_dout_net_x1,
      convert_din1_x0 => convert_din1_dout_net_x1,
      convert_we_x0 => convert_we_dout_net_x1,
      data_out => reinterpret_out_output_port_net_x2
    );

  reinterpret1: entity work.reinterpret_151459306d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => delay16_q_net,
      output_port => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_9a0fa0f632
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret2_output_port_net_x0
    );

  reinterpret3: entity work.reinterpret_9a0fa0f632
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice3_y_net,
      output_port => reinterpret3_output_port_net_x0
    );

  reinterpret4: entity work.reinterpret_713b6c5d29
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => register1_q_net_x0,
      output_port => reinterpret4_output_port_net
    );

  reinterpret6: entity work.reinterpret_b754317574
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => delay19_q_net,
      output_port => reinterpret6_output_port_net
    );

  reinterpret7: entity work.reinterpret_580feec131
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => delay22_q_net,
      output_port => reinterpret7_output_port_net
    );

  reinterpret8: entity work.reinterpret_573890e1c0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => delay32_q_net,
      output_port => reinterpret8_output_port_net
    );

  s_12_9_1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 13,
      din_width => 16,
      dout_arith => 2,
      dout_bin_pt => 14,
      dout_width => 17,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      clr => '0',
      din => delay7_q_net,
      en => "1",
      dout => s_12_9_1_dout_net
    );

  s_12_9_3: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 13,
      din_width => 16,
      dout_arith => 2,
      dout_bin_pt => 15,
      dout_width => 18,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      clr => '0',
      din => delay11_q_net,
      en => "1",
      dout => s_12_9_3_dout_net
    );

  single_port_ram: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 16,
      core_name0 => "bmg_72_b40f882ae90aebcf",
      latency => 2
    )
    port map (
      addr => mux1_y_net,
      ce => ce_1_sg_x318,
      clk => clk_1_sg_x318,
      data_in => reinterpret1_output_port_net,
      en => "1",
      rst => "0",
      we(0) => delay1_q_net,
      data_out => single_port_ram_data_out_net
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 19,
      x_width => 32,
      y_width => 20
    )
    port map (
      x => reinterpret_out_output_port_net_x2,
      y => slice1_y_net
    );

  slice13: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => delay2_q_net,
      y(0) => slice13_y_net
    );

  slice14: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 8,
      x_width => 32,
      y_width => 8
    )
    port map (
      x => delay2_q_net,
      y => slice14_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 17,
      x_width => 32,
      y_width => 18
    )
    port map (
      x => reint1_output_port_net_x0,
      y => slice2_y_net
    );

  slice3: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 17,
      x_width => 32,
      y_width => 18
    )
    port map (
      x => reint1_output_port_net_x1,
      y => slice3_y_net
    );

  slice4: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 14,
      x_width => 32,
      y_width => 15
    )
    port map (
      x => reint1_output_port_net_x2,
      y => slice4_y_net_x0
    );

  slice5: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 15,
      x_width => 32,
      y_width => 16
    )
    port map (
      x => delay3_q_net,
      y => slice5_y_net
    );

  threshold_ff54b219de: entity work.threshold_entity_ff54b219de
    port map (
      darkquad29_capture3_threshold_user_data_out => darkquad29_capture3_threshold_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x4
    );

  trigger_f8b3b7dc2d: entity work.trigger_entity_9aeb6a1bfd
    port map (
      baseline => delay31_q_net_x1,
      ce_1 => ce_1_sg_x318,
      ch_in => delay28_q_net_x1,
      clk_1 => clk_1_sg_x318,
      filtered_in => delay44_q_net_x0,
      raw_in => delay26_q_net_x1,
      threshold => delay30_q_net_x1,
      base_out => delay13_q_net_x0,
      ch_out => delay74_q_net_x0,
      data_out => delay15_q_net_x0,
      trigger => logical7_y_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/chan_sel/bus_create"

entity bus_create_entity_80b0f81968 is
  port (
    in1: in std_logic_vector(10 downto 0); 
    in2: in std_logic_vector(10 downto 0); 
    in3: in std_logic_vector(10 downto 0); 
    in4: in std_logic_vector(10 downto 0); 
    bus_out: out std_logic_vector(43 downto 0)
  );
end bus_create_entity_80b0f81968;

architecture structural of bus_create_entity_80b0f81968 is
  signal concatenate_y_net_x0: std_logic_vector(43 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(10 downto 0);
  signal reinterpret2_output_port_net: std_logic_vector(10 downto 0);
  signal reinterpret3_output_port_net: std_logic_vector(10 downto 0);
  signal reinterpret4_output_port_net: std_logic_vector(10 downto 0);
  signal slice12_y_net_x0: std_logic_vector(10 downto 0);
  signal slice3_y_net_x0: std_logic_vector(10 downto 0);
  signal slice4_y_net_x0: std_logic_vector(10 downto 0);
  signal slice5_y_net_x0: std_logic_vector(10 downto 0);

begin
  slice12_y_net_x0 <= in1;
  slice3_y_net_x0 <= in2;
  slice4_y_net_x0 <= in3;
  slice5_y_net_x0 <= in4;
  bus_out <= concatenate_y_net_x0;

  concatenate: entity work.concat_8aa53a854d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret1_output_port_net,
      in1 => reinterpret2_output_port_net,
      in2 => reinterpret3_output_port_net,
      in3 => reinterpret4_output_port_net,
      y => concatenate_y_net_x0
    );

  reinterpret1: entity work.reinterpret_6b1adb5d55
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice12_y_net_x0,
      output_port => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_6b1adb5d55
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice3_y_net_x0,
      output_port => reinterpret2_output_port_net
    );

  reinterpret3: entity work.reinterpret_6b1adb5d55
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice4_y_net_x0,
      output_port => reinterpret3_output_port_net
    );

  reinterpret4: entity work.reinterpret_6b1adb5d55
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice5_y_net_x0,
      output_port => reinterpret4_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/chan_sel/bus_expand2"

entity bus_expand2_entity_5940a35d68 is
  port (
    bus_in: in std_logic_vector(287 downto 0); 
    lsb_out1: out std_logic_vector(71 downto 0); 
    msb_out4: out std_logic_vector(71 downto 0); 
    out2: out std_logic_vector(71 downto 0); 
    out3: out std_logic_vector(71 downto 0)
  );
end bus_expand2_entity_5940a35d68;

architecture structural of bus_expand2_entity_5940a35d68 is
  signal mux6_y_net_x0: std_logic_vector(287 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(71 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(71 downto 0);
  signal reinterpret3_output_port_net_x0: std_logic_vector(71 downto 0);
  signal reinterpret4_output_port_net_x0: std_logic_vector(71 downto 0);
  signal slice1_y_net: std_logic_vector(71 downto 0);
  signal slice2_y_net: std_logic_vector(71 downto 0);
  signal slice3_y_net: std_logic_vector(71 downto 0);
  signal slice4_y_net: std_logic_vector(71 downto 0);

begin
  mux6_y_net_x0 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x0;
  msb_out4 <= reinterpret4_output_port_net_x0;
  out2 <= reinterpret2_output_port_net_x0;
  out3 <= reinterpret3_output_port_net_x0;

  reinterpret1: entity work.reinterpret_8b4279cdc5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x0
    );

  reinterpret2: entity work.reinterpret_8b4279cdc5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret2_output_port_net_x0
    );

  reinterpret3: entity work.reinterpret_8b4279cdc5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice3_y_net,
      output_port => reinterpret3_output_port_net_x0
    );

  reinterpret4: entity work.reinterpret_8b4279cdc5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice4_y_net,
      output_port => reinterpret4_output_port_net_x0
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 71,
      x_width => 288,
      y_width => 72
    )
    port map (
      x => mux6_y_net_x0,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 72,
      new_msb => 143,
      x_width => 288,
      y_width => 72
    )
    port map (
      x => mux6_y_net_x0,
      y => slice2_y_net
    );

  slice3: entity work.xlslice
    generic map (
      new_lsb => 144,
      new_msb => 215,
      x_width => 288,
      y_width => 72
    )
    port map (
      x => mux6_y_net_x0,
      y => slice3_y_net
    );

  slice4: entity work.xlslice
    generic map (
      new_lsb => 216,
      new_msb => 287,
      x_width => 288,
      y_width => 72
    )
    port map (
      x => mux6_y_net_x0,
      y => slice4_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/chan_sel/ch_bin0"

entity ch_bin0_entity_636913790d is
  port (
    darkquad29_chan_sel_ch_bin0_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end ch_bin0_entity_636913790d;

architecture structural of ch_bin0_entity_636913790d is
  signal darkquad29_chan_sel_ch_bin0_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_chan_sel_ch_bin0_user_data_out_net_x0 <= darkquad29_chan_sel_ch_bin0_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_chan_sel_ch_bin0_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/chan_sel/ch_bin1"

entity ch_bin1_entity_4088329920 is
  port (
    darkquad29_chan_sel_ch_bin1_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end ch_bin1_entity_4088329920;

architecture structural of ch_bin1_entity_4088329920 is
  signal darkquad29_chan_sel_ch_bin1_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_chan_sel_ch_bin1_user_data_out_net_x0 <= darkquad29_chan_sel_ch_bin1_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_chan_sel_ch_bin1_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/chan_sel/ch_bin2"

entity ch_bin2_entity_1e3aa8db66 is
  port (
    darkquad29_chan_sel_ch_bin2_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end ch_bin2_entity_1e3aa8db66;

architecture structural of ch_bin2_entity_1e3aa8db66 is
  signal darkquad29_chan_sel_ch_bin2_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_chan_sel_ch_bin2_user_data_out_net_x0 <= darkquad29_chan_sel_ch_bin2_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_chan_sel_ch_bin2_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/chan_sel/ch_bin3"

entity ch_bin3_entity_d90a703761 is
  port (
    darkquad29_chan_sel_ch_bin3_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end ch_bin3_entity_d90a703761;

architecture structural of ch_bin3_entity_d90a703761 is
  signal darkquad29_chan_sel_ch_bin3_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_chan_sel_ch_bin3_user_data_out_net_x0 <= darkquad29_chan_sel_ch_bin3_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_chan_sel_ch_bin3_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/chan_sel/dbl_quad_buffer/quad_buff/buff/bus_expand"

entity bus_expand_entity_a89a0e138e is
  port (
    bus_in: in std_logic_vector(575 downto 0); 
    lsb_out1: out std_logic_vector(71 downto 0); 
    msb_out8: out std_logic_vector(71 downto 0); 
    out2: out std_logic_vector(71 downto 0); 
    out3: out std_logic_vector(71 downto 0); 
    out4: out std_logic_vector(71 downto 0); 
    out5: out std_logic_vector(71 downto 0); 
    out6: out std_logic_vector(71 downto 0); 
    out7: out std_logic_vector(71 downto 0)
  );
end bus_expand_entity_a89a0e138e;

architecture structural of bus_expand_entity_a89a0e138e is
  signal delay2_q_net_x0: std_logic_vector(575 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(71 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(71 downto 0);
  signal reinterpret3_output_port_net_x0: std_logic_vector(71 downto 0);
  signal reinterpret4_output_port_net_x0: std_logic_vector(71 downto 0);
  signal reinterpret5_output_port_net_x0: std_logic_vector(71 downto 0);
  signal reinterpret6_output_port_net_x0: std_logic_vector(71 downto 0);
  signal reinterpret7_output_port_net_x0: std_logic_vector(71 downto 0);
  signal reinterpret8_output_port_net_x0: std_logic_vector(71 downto 0);
  signal slice1_y_net: std_logic_vector(71 downto 0);
  signal slice2_y_net: std_logic_vector(71 downto 0);
  signal slice3_y_net: std_logic_vector(71 downto 0);
  signal slice4_y_net: std_logic_vector(71 downto 0);
  signal slice5_y_net: std_logic_vector(71 downto 0);
  signal slice6_y_net: std_logic_vector(71 downto 0);
  signal slice7_y_net: std_logic_vector(71 downto 0);
  signal slice8_y_net: std_logic_vector(71 downto 0);

begin
  delay2_q_net_x0 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x0;
  msb_out8 <= reinterpret8_output_port_net_x0;
  out2 <= reinterpret2_output_port_net_x0;
  out3 <= reinterpret3_output_port_net_x0;
  out4 <= reinterpret4_output_port_net_x0;
  out5 <= reinterpret5_output_port_net_x0;
  out6 <= reinterpret6_output_port_net_x0;
  out7 <= reinterpret7_output_port_net_x0;

  reinterpret1: entity work.reinterpret_8b4279cdc5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x0
    );

  reinterpret2: entity work.reinterpret_8b4279cdc5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret2_output_port_net_x0
    );

  reinterpret3: entity work.reinterpret_8b4279cdc5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice3_y_net,
      output_port => reinterpret3_output_port_net_x0
    );

  reinterpret4: entity work.reinterpret_8b4279cdc5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice4_y_net,
      output_port => reinterpret4_output_port_net_x0
    );

  reinterpret5: entity work.reinterpret_8b4279cdc5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice5_y_net,
      output_port => reinterpret5_output_port_net_x0
    );

  reinterpret6: entity work.reinterpret_8b4279cdc5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice6_y_net,
      output_port => reinterpret6_output_port_net_x0
    );

  reinterpret7: entity work.reinterpret_8b4279cdc5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice7_y_net,
      output_port => reinterpret7_output_port_net_x0
    );

  reinterpret8: entity work.reinterpret_8b4279cdc5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice8_y_net,
      output_port => reinterpret8_output_port_net_x0
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 71,
      x_width => 576,
      y_width => 72
    )
    port map (
      x => delay2_q_net_x0,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 72,
      new_msb => 143,
      x_width => 576,
      y_width => 72
    )
    port map (
      x => delay2_q_net_x0,
      y => slice2_y_net
    );

  slice3: entity work.xlslice
    generic map (
      new_lsb => 144,
      new_msb => 215,
      x_width => 576,
      y_width => 72
    )
    port map (
      x => delay2_q_net_x0,
      y => slice3_y_net
    );

  slice4: entity work.xlslice
    generic map (
      new_lsb => 216,
      new_msb => 287,
      x_width => 576,
      y_width => 72
    )
    port map (
      x => delay2_q_net_x0,
      y => slice4_y_net
    );

  slice5: entity work.xlslice
    generic map (
      new_lsb => 288,
      new_msb => 359,
      x_width => 576,
      y_width => 72
    )
    port map (
      x => delay2_q_net_x0,
      y => slice5_y_net
    );

  slice6: entity work.xlslice
    generic map (
      new_lsb => 360,
      new_msb => 431,
      x_width => 576,
      y_width => 72
    )
    port map (
      x => delay2_q_net_x0,
      y => slice6_y_net
    );

  slice7: entity work.xlslice
    generic map (
      new_lsb => 432,
      new_msb => 503,
      x_width => 576,
      y_width => 72
    )
    port map (
      x => delay2_q_net_x0,
      y => slice7_y_net
    );

  slice8: entity work.xlslice
    generic map (
      new_lsb => 504,
      new_msb => 575,
      x_width => 576,
      y_width => 72
    )
    port map (
      x => delay2_q_net_x0,
      y => slice8_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/chan_sel/dbl_quad_buffer/quad_buff/buff/bus_expand1"

entity bus_expand1_entity_48cd010ec3 is
  port (
    bus_in: in std_logic_vector(10 downto 0); 
    lsb_out1: out std_logic_vector(2 downto 0); 
    msb_out2: out std_logic_vector(7 downto 0)
  );
end bus_expand1_entity_48cd010ec3;

architecture structural of bus_expand1_entity_48cd010ec3 is
  signal reinterpret1_output_port_net_x0: std_logic_vector(2 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(7 downto 0);
  signal reinterpret4_output_port_net_x0: std_logic_vector(10 downto 0);
  signal slice1_y_net: std_logic_vector(2 downto 0);
  signal slice2_y_net: std_logic_vector(7 downto 0);

begin
  reinterpret4_output_port_net_x0 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x0;
  msb_out2 <= reinterpret2_output_port_net_x0;

  reinterpret1: entity work.reinterpret_c4fa12acb5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x0
    );

  reinterpret2: entity work.reinterpret_f21e7f2ddf
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret2_output_port_net_x0
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 2,
      x_width => 11,
      y_width => 3
    )
    port map (
      x => reinterpret4_output_port_net_x0,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 3,
      new_msb => 10,
      x_width => 11,
      y_width => 8
    )
    port map (
      x => reinterpret4_output_port_net_x0,
      y => slice2_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/chan_sel/dbl_quad_buffer/quad_buff/buff"

entity buff_entity_fc9ac0f157 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    data_in: in std_logic_vector(575 downto 0); 
    rd_addr: in std_logic_vector(10 downto 0); 
    we: in std_logic; 
    wr_addr: in std_logic_vector(7 downto 0); 
    data_out: out std_logic_vector(71 downto 0)
  );
end buff_entity_fc9ac0f157;

architecture structural of buff_entity_fc9ac0f157 is
  signal ce_1_sg_x319: std_logic;
  signal clk_1_sg_x319: std_logic;
  signal delay1_q_net: std_logic_vector(2 downto 0);
  signal delay2_q_net_x0: std_logic_vector(575 downto 0);
  signal delay2_q_net_x1: std_logic_vector(575 downto 0);
  signal delay3_q_net: std_logic_vector(2 downto 0);
  signal delay6_q_net: std_logic;
  signal delay7_q_net_x0: std_logic_vector(7 downto 0);
  signal inverter_op_net_x0: std_logic;
  signal mux3_y_net_x0: std_logic_vector(71 downto 0);
  signal mux_y_net: std_logic_vector(7 downto 0);
  signal ram1_data_out_net: std_logic_vector(71 downto 0);
  signal ram2_data_out_net: std_logic_vector(71 downto 0);
  signal ram3_data_out_net: std_logic_vector(71 downto 0);
  signal ram4_data_out_net: std_logic_vector(71 downto 0);
  signal ram5_data_out_net: std_logic_vector(71 downto 0);
  signal ram6_data_out_net: std_logic_vector(71 downto 0);
  signal ram7_data_out_net: std_logic_vector(71 downto 0);
  signal ram8_data_out_net: std_logic_vector(71 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(71 downto 0);
  signal reinterpret1_output_port_net_x1: std_logic_vector(2 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(71 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(7 downto 0);
  signal reinterpret3_output_port_net_x0: std_logic_vector(71 downto 0);
  signal reinterpret4_output_port_net_x0: std_logic_vector(71 downto 0);
  signal reinterpret4_output_port_net_x2: std_logic_vector(10 downto 0);
  signal reinterpret5_output_port_net_x0: std_logic_vector(71 downto 0);
  signal reinterpret6_output_port_net_x0: std_logic_vector(71 downto 0);
  signal reinterpret7_output_port_net_x0: std_logic_vector(71 downto 0);
  signal reinterpret8_output_port_net_x0: std_logic_vector(71 downto 0);

begin
  ce_1_sg_x319 <= ce_1;
  clk_1_sg_x319 <= clk_1;
  delay2_q_net_x1 <= data_in;
  reinterpret4_output_port_net_x2 <= rd_addr;
  inverter_op_net_x0 <= we;
  delay7_q_net_x0 <= wr_addr;
  data_out <= mux3_y_net_x0;

  bus_expand1_48cd010ec3: entity work.bus_expand1_entity_48cd010ec3
    port map (
      bus_in => reinterpret4_output_port_net_x2,
      lsb_out1 => reinterpret1_output_port_net_x1,
      msb_out2 => reinterpret2_output_port_net_x1
    );

  bus_expand_a89a0e138e: entity work.bus_expand_entity_a89a0e138e
    port map (
      bus_in => delay2_q_net_x0,
      lsb_out1 => reinterpret1_output_port_net_x0,
      msb_out8 => reinterpret8_output_port_net_x0,
      out2 => reinterpret2_output_port_net_x0,
      out3 => reinterpret3_output_port_net_x0,
      out4 => reinterpret4_output_port_net_x0,
      out5 => reinterpret5_output_port_net_x0,
      out6 => reinterpret6_output_port_net_x0,
      out7 => reinterpret7_output_port_net_x0
    );

  delay1: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 3
    )
    port map (
      ce => ce_1_sg_x319,
      clk => clk_1_sg_x319,
      d => reinterpret1_output_port_net_x1,
      en => '1',
      rst => '1',
      q => delay1_q_net
    );

  delay2: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 576
    )
    port map (
      ce => ce_1_sg_x319,
      clk => clk_1_sg_x319,
      d => delay2_q_net_x1,
      en => '1',
      rst => '1',
      q => delay2_q_net_x0
    );

  delay3: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 3
    )
    port map (
      ce => ce_1_sg_x319,
      clk => clk_1_sg_x319,
      d => delay1_q_net,
      en => '1',
      rst => '1',
      q => delay3_q_net
    );

  delay6: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x319,
      clk => clk_1_sg_x319,
      d(0) => inverter_op_net_x0,
      en => '1',
      rst => '1',
      q(0) => delay6_q_net
    );

  mux: entity work.mux_cc14a035dc
    port map (
      ce => ce_1_sg_x319,
      clk => clk_1_sg_x319,
      clr => '0',
      d0 => reinterpret2_output_port_net_x1,
      d1 => delay7_q_net_x0,
      sel(0) => inverter_op_net_x0,
      y => mux_y_net
    );

  mux3: entity work.mux_c9e724c9c7
    port map (
      ce => ce_1_sg_x319,
      clk => clk_1_sg_x319,
      clr => '0',
      d0 => ram3_data_out_net,
      d1 => ram1_data_out_net,
      d2 => ram2_data_out_net,
      d3 => ram4_data_out_net,
      d4 => ram5_data_out_net,
      d5 => ram6_data_out_net,
      d6 => ram7_data_out_net,
      d7 => ram8_data_out_net,
      sel => delay3_q_net,
      y => mux3_y_net_x0
    );

  ram1: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 72,
      core_name0 => "bmg_72_4ed81b7c7b802023",
      latency => 2
    )
    port map (
      addr => mux_y_net,
      ce => ce_1_sg_x319,
      clk => clk_1_sg_x319,
      data_in => reinterpret7_output_port_net_x0,
      en => "1",
      rst => "0",
      we(0) => delay6_q_net,
      data_out => ram1_data_out_net
    );

  ram2: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 72,
      core_name0 => "bmg_72_4ed81b7c7b802023",
      latency => 2
    )
    port map (
      addr => mux_y_net,
      ce => ce_1_sg_x319,
      clk => clk_1_sg_x319,
      data_in => reinterpret6_output_port_net_x0,
      en => "1",
      rst => "0",
      we(0) => delay6_q_net,
      data_out => ram2_data_out_net
    );

  ram3: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 72,
      core_name0 => "bmg_72_4ed81b7c7b802023",
      latency => 2
    )
    port map (
      addr => mux_y_net,
      ce => ce_1_sg_x319,
      clk => clk_1_sg_x319,
      data_in => reinterpret8_output_port_net_x0,
      en => "1",
      rst => "0",
      we(0) => delay6_q_net,
      data_out => ram3_data_out_net
    );

  ram4: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 72,
      core_name0 => "bmg_72_4ed81b7c7b802023",
      latency => 2
    )
    port map (
      addr => mux_y_net,
      ce => ce_1_sg_x319,
      clk => clk_1_sg_x319,
      data_in => reinterpret5_output_port_net_x0,
      en => "1",
      rst => "0",
      we(0) => delay6_q_net,
      data_out => ram4_data_out_net
    );

  ram5: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 72,
      core_name0 => "bmg_72_4ed81b7c7b802023",
      latency => 2
    )
    port map (
      addr => mux_y_net,
      ce => ce_1_sg_x319,
      clk => clk_1_sg_x319,
      data_in => reinterpret4_output_port_net_x0,
      en => "1",
      rst => "0",
      we(0) => delay6_q_net,
      data_out => ram5_data_out_net
    );

  ram6: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 72,
      core_name0 => "bmg_72_4ed81b7c7b802023",
      latency => 2
    )
    port map (
      addr => mux_y_net,
      ce => ce_1_sg_x319,
      clk => clk_1_sg_x319,
      data_in => reinterpret3_output_port_net_x0,
      en => "1",
      rst => "0",
      we(0) => delay6_q_net,
      data_out => ram6_data_out_net
    );

  ram7: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 72,
      core_name0 => "bmg_72_4ed81b7c7b802023",
      latency => 2
    )
    port map (
      addr => mux_y_net,
      ce => ce_1_sg_x319,
      clk => clk_1_sg_x319,
      data_in => reinterpret2_output_port_net_x0,
      en => "1",
      rst => "0",
      we(0) => delay6_q_net,
      data_out => ram7_data_out_net
    );

  ram8: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 72,
      core_name0 => "bmg_72_4ed81b7c7b802023",
      latency => 2
    )
    port map (
      addr => mux_y_net,
      ce => ce_1_sg_x319,
      clk => clk_1_sg_x319,
      data_in => reinterpret1_output_port_net_x0,
      en => "1",
      rst => "0",
      we(0) => delay6_q_net,
      data_out => ram8_data_out_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/chan_sel/dbl_quad_buffer/quad_buff/bus_create"

entity bus_create_entity_9f1f95f417 is
  port (
    in1: in std_logic_vector(71 downto 0); 
    in2: in std_logic_vector(71 downto 0); 
    in3: in std_logic_vector(71 downto 0); 
    in4: in std_logic_vector(71 downto 0); 
    bus_out: out std_logic_vector(287 downto 0)
  );
end bus_create_entity_9f1f95f417;

architecture structural of bus_create_entity_9f1f95f417 is
  signal concatenate_y_net_x0: std_logic_vector(287 downto 0);
  signal mux3_y_net_x4: std_logic_vector(71 downto 0);
  signal mux3_y_net_x5: std_logic_vector(71 downto 0);
  signal mux3_y_net_x6: std_logic_vector(71 downto 0);
  signal mux3_y_net_x7: std_logic_vector(71 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(71 downto 0);
  signal reinterpret2_output_port_net: std_logic_vector(71 downto 0);
  signal reinterpret3_output_port_net: std_logic_vector(71 downto 0);
  signal reinterpret4_output_port_net: std_logic_vector(71 downto 0);

begin
  mux3_y_net_x4 <= in1;
  mux3_y_net_x5 <= in2;
  mux3_y_net_x6 <= in3;
  mux3_y_net_x7 <= in4;
  bus_out <= concatenate_y_net_x0;

  concatenate: entity work.concat_e4625e6202
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret1_output_port_net,
      in1 => reinterpret2_output_port_net,
      in2 => reinterpret3_output_port_net,
      in3 => reinterpret4_output_port_net,
      y => concatenate_y_net_x0
    );

  reinterpret1: entity work.reinterpret_8b4279cdc5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => mux3_y_net_x4,
      output_port => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_8b4279cdc5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => mux3_y_net_x5,
      output_port => reinterpret2_output_port_net
    );

  reinterpret3: entity work.reinterpret_8b4279cdc5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => mux3_y_net_x6,
      output_port => reinterpret3_output_port_net
    );

  reinterpret4: entity work.reinterpret_8b4279cdc5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => mux3_y_net_x7,
      output_port => reinterpret4_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/chan_sel/dbl_quad_buffer/quad_buff/bus_expand2"

entity bus_expand2_entity_1ed377c07a is
  port (
    bus_in: in std_logic_vector(43 downto 0); 
    lsb_out1: out std_logic_vector(10 downto 0); 
    msb_out4: out std_logic_vector(10 downto 0); 
    out2: out std_logic_vector(10 downto 0); 
    out3: out std_logic_vector(10 downto 0)
  );
end bus_expand2_entity_1ed377c07a;

architecture structural of bus_expand2_entity_1ed377c07a is
  signal delay1_q_net_x0: std_logic_vector(43 downto 0);
  signal reinterpret1_output_port_net_x4: std_logic_vector(10 downto 0);
  signal reinterpret2_output_port_net_x4: std_logic_vector(10 downto 0);
  signal reinterpret3_output_port_net_x3: std_logic_vector(10 downto 0);
  signal reinterpret4_output_port_net_x3: std_logic_vector(10 downto 0);
  signal slice1_y_net: std_logic_vector(10 downto 0);
  signal slice2_y_net: std_logic_vector(10 downto 0);
  signal slice3_y_net: std_logic_vector(10 downto 0);
  signal slice4_y_net: std_logic_vector(10 downto 0);

begin
  delay1_q_net_x0 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x4;
  msb_out4 <= reinterpret4_output_port_net_x3;
  out2 <= reinterpret2_output_port_net_x4;
  out3 <= reinterpret3_output_port_net_x3;

  reinterpret1: entity work.reinterpret_6b1adb5d55
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x4
    );

  reinterpret2: entity work.reinterpret_6b1adb5d55
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret2_output_port_net_x4
    );

  reinterpret3: entity work.reinterpret_6b1adb5d55
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice3_y_net,
      output_port => reinterpret3_output_port_net_x3
    );

  reinterpret4: entity work.reinterpret_6b1adb5d55
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice4_y_net,
      output_port => reinterpret4_output_port_net_x3
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 10,
      x_width => 44,
      y_width => 11
    )
    port map (
      x => delay1_q_net_x0,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 11,
      new_msb => 21,
      x_width => 44,
      y_width => 11
    )
    port map (
      x => delay1_q_net_x0,
      y => slice2_y_net
    );

  slice3: entity work.xlslice
    generic map (
      new_lsb => 22,
      new_msb => 32,
      x_width => 44,
      y_width => 11
    )
    port map (
      x => delay1_q_net_x0,
      y => slice3_y_net
    );

  slice4: entity work.xlslice
    generic map (
      new_lsb => 33,
      new_msb => 43,
      x_width => 44,
      y_width => 11
    )
    port map (
      x => delay1_q_net_x0,
      y => slice4_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/chan_sel/dbl_quad_buffer/quad_buff"

entity quad_buff_entity_af6b6b8a83 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    data: in std_logic_vector(575 downto 0); 
    rd_addrs: in std_logic_vector(43 downto 0); 
    we: in std_logic; 
    wr_addr: in std_logic_vector(7 downto 0); 
    dout: out std_logic_vector(287 downto 0)
  );
end quad_buff_entity_af6b6b8a83;

architecture structural of quad_buff_entity_af6b6b8a83 is
  signal ce_1_sg_x323: std_logic;
  signal clk_1_sg_x323: std_logic;
  signal concatenate_y_net_x1: std_logic_vector(287 downto 0);
  signal delay1_q_net_x1: std_logic_vector(43 downto 0);
  signal delay2_q_net_x5: std_logic_vector(575 downto 0);
  signal delay7_q_net_x4: std_logic_vector(7 downto 0);
  signal inverter_op_net_x4: std_logic;
  signal mux3_y_net_x4: std_logic_vector(71 downto 0);
  signal mux3_y_net_x5: std_logic_vector(71 downto 0);
  signal mux3_y_net_x6: std_logic_vector(71 downto 0);
  signal mux3_y_net_x7: std_logic_vector(71 downto 0);
  signal reinterpret1_output_port_net_x4: std_logic_vector(10 downto 0);
  signal reinterpret2_output_port_net_x4: std_logic_vector(10 downto 0);
  signal reinterpret3_output_port_net_x3: std_logic_vector(10 downto 0);
  signal reinterpret4_output_port_net_x3: std_logic_vector(10 downto 0);

begin
  ce_1_sg_x323 <= ce_1;
  clk_1_sg_x323 <= clk_1;
  delay2_q_net_x5 <= data;
  delay1_q_net_x1 <= rd_addrs;
  inverter_op_net_x4 <= we;
  delay7_q_net_x4 <= wr_addr;
  dout <= concatenate_y_net_x1;

  buff1_e154de64a7: entity work.buff_entity_fc9ac0f157
    port map (
      ce_1 => ce_1_sg_x323,
      clk_1 => clk_1_sg_x323,
      data_in => delay2_q_net_x5,
      rd_addr => reinterpret3_output_port_net_x3,
      we => inverter_op_net_x4,
      wr_addr => delay7_q_net_x4,
      data_out => mux3_y_net_x5
    );

  buff2_64ff6cac3c: entity work.buff_entity_fc9ac0f157
    port map (
      ce_1 => ce_1_sg_x323,
      clk_1 => clk_1_sg_x323,
      data_in => delay2_q_net_x5,
      rd_addr => reinterpret2_output_port_net_x4,
      we => inverter_op_net_x4,
      wr_addr => delay7_q_net_x4,
      data_out => mux3_y_net_x6
    );

  buff3_af4e6a30f4: entity work.buff_entity_fc9ac0f157
    port map (
      ce_1 => ce_1_sg_x323,
      clk_1 => clk_1_sg_x323,
      data_in => delay2_q_net_x5,
      rd_addr => reinterpret1_output_port_net_x4,
      we => inverter_op_net_x4,
      wr_addr => delay7_q_net_x4,
      data_out => mux3_y_net_x7
    );

  buff_fc9ac0f157: entity work.buff_entity_fc9ac0f157
    port map (
      ce_1 => ce_1_sg_x323,
      clk_1 => clk_1_sg_x323,
      data_in => delay2_q_net_x5,
      rd_addr => reinterpret4_output_port_net_x3,
      we => inverter_op_net_x4,
      wr_addr => delay7_q_net_x4,
      data_out => mux3_y_net_x4
    );

  bus_create_9f1f95f417: entity work.bus_create_entity_9f1f95f417
    port map (
      in1 => mux3_y_net_x4,
      in2 => mux3_y_net_x5,
      in3 => mux3_y_net_x6,
      in4 => mux3_y_net_x7,
      bus_out => concatenate_y_net_x1
    );

  bus_expand2_1ed377c07a: entity work.bus_expand2_entity_1ed377c07a
    port map (
      bus_in => delay1_q_net_x1,
      lsb_out1 => reinterpret1_output_port_net_x4,
      msb_out4 => reinterpret4_output_port_net_x3,
      out2 => reinterpret2_output_port_net_x4,
      out3 => reinterpret3_output_port_net_x3
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/chan_sel/dbl_quad_buffer"

entity dbl_quad_buffer_entity_02006ad3b7 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(575 downto 0); 
    rd_addrs: in std_logic_vector(43 downto 0); 
    rw_mode: in std_logic; 
    wr_addr: in std_logic_vector(7 downto 0); 
    dout: out std_logic_vector(287 downto 0); 
    misc_out: out std_logic_vector(7 downto 0)
  );
end dbl_quad_buffer_entity_02006ad3b7;

architecture structural of dbl_quad_buffer_entity_02006ad3b7 is
  signal ce_1_sg_x329: std_logic;
  signal clk_1_sg_x329: std_logic;
  signal concatenate_y_net_x1: std_logic_vector(287 downto 0);
  signal concatenate_y_net_x2: std_logic_vector(287 downto 0);
  signal delay10_q_net_x0: std_logic_vector(7 downto 0);
  signal delay16_q_net_x0: std_logic_vector(43 downto 0);
  signal delay1_q_net_x3: std_logic_vector(43 downto 0);
  signal delay2_q_net_x10: std_logic_vector(575 downto 0);
  signal delay3_q_net_x5: std_logic;
  signal delay4_q_net_x0: std_logic_vector(7 downto 0);
  signal delay4_q_net_x1: std_logic_vector(575 downto 0);
  signal delay5_q_net: std_logic_vector(7 downto 0);
  signal delay6_q_net_x0: std_logic_vector(7 downto 0);
  signal delay7_q_net_x9: std_logic_vector(7 downto 0);
  signal delay8_q_net_x0: std_logic;
  signal delay8_q_net_x1: std_logic;
  signal delay_q_net: std_logic;
  signal inverter_op_net_x4: std_logic;
  signal mux6_y_net_x1: std_logic_vector(287 downto 0);

begin
  ce_1_sg_x329 <= ce_1;
  clk_1_sg_x329 <= clk_1;
  delay4_q_net_x1 <= din;
  delay16_q_net_x0 <= rd_addrs;
  delay8_q_net_x1 <= rw_mode;
  delay10_q_net_x0 <= wr_addr;
  dout <= mux6_y_net_x1;
  misc_out <= delay6_q_net_x0;

  delay: entity work.xldelay
    generic map (
      latency => 5,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x329,
      clk => clk_1_sg_x329,
      d(0) => delay8_q_net_x0,
      en => '1',
      rst => '1',
      q(0) => delay_q_net
    );

  delay1: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 44
    )
    port map (
      ce => ce_1_sg_x329,
      clk => clk_1_sg_x329,
      d => delay16_q_net_x0,
      en => '1',
      rst => '1',
      q => delay1_q_net_x3
    );

  delay2: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 576
    )
    port map (
      ce => ce_1_sg_x329,
      clk => clk_1_sg_x329,
      d => delay4_q_net_x1,
      en => '1',
      rst => '1',
      q => delay2_q_net_x10
    );

  delay3: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x329,
      clk => clk_1_sg_x329,
      d(0) => delay8_q_net_x1,
      en => '1',
      rst => '1',
      q(0) => delay3_q_net_x5
    );

  delay4: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x329,
      clk => clk_1_sg_x329,
      d => delay10_q_net_x0,
      en => '1',
      rst => '1',
      q => delay4_q_net_x0
    );

  delay5: entity work.xldelay
    generic map (
      latency => 5,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x329,
      clk => clk_1_sg_x329,
      d => delay4_q_net_x0,
      en => '1',
      rst => '1',
      q => delay5_q_net
    );

  delay6: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x329,
      clk => clk_1_sg_x329,
      d => delay5_q_net,
      en => '1',
      rst => '1',
      q => delay6_q_net_x0
    );

  delay7: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x329,
      clk => clk_1_sg_x329,
      d => delay10_q_net_x0,
      en => '1',
      rst => '1',
      q => delay7_q_net_x9
    );

  delay8: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x329,
      clk => clk_1_sg_x329,
      d(0) => delay8_q_net_x1,
      en => '1',
      rst => '1',
      q(0) => delay8_q_net_x0
    );

  inverter: entity work.inverter_6844eee868
    port map (
      ce => ce_1_sg_x329,
      clk => clk_1_sg_x329,
      clr => '0',
      ip(0) => delay8_q_net_x1,
      op(0) => inverter_op_net_x4
    );

  mux6: entity work.mux_2b46a879f8
    port map (
      ce => ce_1_sg_x329,
      clk => clk_1_sg_x329,
      clr => '0',
      d0 => concatenate_y_net_x2,
      d1 => concatenate_y_net_x1,
      sel(0) => delay_q_net,
      y => mux6_y_net_x1
    );

  quad_buff1_0ef8d9f858: entity work.quad_buff_entity_af6b6b8a83
    port map (
      ce_1 => ce_1_sg_x329,
      clk_1 => clk_1_sg_x329,
      data => delay2_q_net_x10,
      rd_addrs => delay1_q_net_x3,
      we => delay3_q_net_x5,
      wr_addr => delay7_q_net_x9,
      dout => concatenate_y_net_x2
    );

  quad_buff_af6b6b8a83: entity work.quad_buff_entity_af6b6b8a83
    port map (
      ce_1 => ce_1_sg_x329,
      clk_1 => clk_1_sg_x329,
      data => delay2_q_net_x10,
      rd_addrs => delay1_q_net_x3,
      we => inverter_op_net_x4,
      wr_addr => delay7_q_net_x9,
      dout => concatenate_y_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/chan_sel/load"

entity load_entity_ec926c8cbe is
  port (
    darkquad29_chan_sel_load_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end load_entity_ec926c8cbe;

architecture structural of load_entity_ec926c8cbe is
  signal darkquad29_chan_sel_load_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_chan_sel_load_user_data_out_net_x0 <= darkquad29_chan_sel_load_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_chan_sel_load_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/chan_sel"

entity chan_sel_entity_2cc6acb10c is
  port (
    bin_ctr: in std_logic_vector(7 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    darkquad29_chan_sel_ch_bin0_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_chan_sel_ch_bin1_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_chan_sel_ch_bin2_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_chan_sel_ch_bin3_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_chan_sel_load_user_data_out: in std_logic_vector(31 downto 0); 
    fft_data: in std_logic_vector(575 downto 0); 
    fft_rdy: in std_logic; 
    ch0_data: out std_logic_vector(71 downto 0); 
    ch1_data: out std_logic_vector(71 downto 0); 
    ch2_data: out std_logic_vector(71 downto 0); 
    ch3_data: out std_logic_vector(71 downto 0); 
    ch_ctr: out std_logic_vector(7 downto 0)
  );
end chan_sel_entity_2cc6acb10c;

architecture structural of chan_sel_entity_2cc6acb10c is
  signal ce_1_sg_x330: std_logic;
  signal clk_1_sg_x330: std_logic;
  signal concatenate_y_net_x0: std_logic_vector(43 downto 0);
  signal darkquad29_chan_sel_ch_bin0_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal darkquad29_chan_sel_ch_bin1_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal darkquad29_chan_sel_ch_bin2_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal darkquad29_chan_sel_ch_bin3_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal darkquad29_chan_sel_load_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal delay10_q_net_x0: std_logic_vector(7 downto 0);
  signal delay11_q_net: std_logic_vector(7 downto 0);
  signal delay12_q_net_x0: std_logic_vector(31 downto 0);
  signal delay12_q_net_x1: std_logic;
  signal delay13_q_net: std_logic_vector(31 downto 0);
  signal delay14_q_net_x0: std_logic_vector(31 downto 0);
  signal delay14_q_net_x1: std_logic_vector(7 downto 0);
  signal delay16_q_net_x0: std_logic_vector(43 downto 0);
  signal delay18_q_net: std_logic;
  signal delay1_q_net: std_logic_vector(31 downto 0);
  signal delay2_q_net: std_logic_vector(31 downto 0);
  signal delay3_q_net: std_logic_vector(575 downto 0);
  signal delay4_q_net_x1: std_logic_vector(575 downto 0);
  signal delay5_q_net: std_logic_vector(575 downto 0);
  signal delay6_q_net: std_logic;
  signal delay6_q_net_x1: std_logic_vector(7 downto 0);
  signal delay7_q_net: std_logic;
  signal delay8_q_net_x1: std_logic;
  signal delay9_q_net: std_logic_vector(7 downto 0);
  signal mux2_y_net: std_logic_vector(7 downto 0);
  signal mux6_y_net_x1: std_logic_vector(287 downto 0);
  signal register1_q_net_x0: std_logic_vector(575 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x2: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x3: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x4: std_logic_vector(31 downto 0);
  signal reinterpret1_output_port_net_x1: std_logic_vector(71 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(71 downto 0);
  signal reinterpret3_output_port_net_x1: std_logic_vector(71 downto 0);
  signal reinterpret4_output_port_net_x1: std_logic_vector(71 downto 0);
  signal selector_op_net: std_logic;
  signal single_port_ram2_data_out_net: std_logic_vector(43 downto 0);
  signal slice12_y_net_x0: std_logic_vector(10 downto 0);
  signal slice1_y_net: std_logic;
  signal slice23_y_net: std_logic;
  signal slice24_y_net: std_logic_vector(7 downto 0);
  signal slice2_y_net: std_logic;
  signal slice3_y_net_x0: std_logic_vector(10 downto 0);
  signal slice4_y_net_x0: std_logic_vector(10 downto 0);
  signal slice5_y_net_x0: std_logic_vector(10 downto 0);

begin
  delay14_q_net_x1 <= bin_ctr;
  ce_1_sg_x330 <= ce_1;
  clk_1_sg_x330 <= clk_1;
  darkquad29_chan_sel_ch_bin0_user_data_out_net_x1 <= darkquad29_chan_sel_ch_bin0_user_data_out;
  darkquad29_chan_sel_ch_bin1_user_data_out_net_x1 <= darkquad29_chan_sel_ch_bin1_user_data_out;
  darkquad29_chan_sel_ch_bin2_user_data_out_net_x1 <= darkquad29_chan_sel_ch_bin2_user_data_out;
  darkquad29_chan_sel_ch_bin3_user_data_out_net_x1 <= darkquad29_chan_sel_ch_bin3_user_data_out;
  darkquad29_chan_sel_load_user_data_out_net_x1 <= darkquad29_chan_sel_load_user_data_out;
  register1_q_net_x0 <= fft_data;
  delay12_q_net_x1 <= fft_rdy;
  ch0_data <= reinterpret4_output_port_net_x1;
  ch1_data <= reinterpret3_output_port_net_x1;
  ch2_data <= reinterpret2_output_port_net_x1;
  ch3_data <= reinterpret1_output_port_net_x1;
  ch_ctr <= delay6_q_net_x1;

  bus_create_80b0f81968: entity work.bus_create_entity_80b0f81968
    port map (
      in1 => slice12_y_net_x0,
      in2 => slice3_y_net_x0,
      in3 => slice4_y_net_x0,
      in4 => slice5_y_net_x0,
      bus_out => concatenate_y_net_x0
    );

  bus_expand2_5940a35d68: entity work.bus_expand2_entity_5940a35d68
    port map (
      bus_in => mux6_y_net_x1,
      lsb_out1 => reinterpret1_output_port_net_x1,
      msb_out4 => reinterpret4_output_port_net_x1,
      out2 => reinterpret2_output_port_net_x1,
      out3 => reinterpret3_output_port_net_x1
    );

  ch_bin0_636913790d: entity work.ch_bin0_entity_636913790d
    port map (
      darkquad29_chan_sel_ch_bin0_user_data_out => darkquad29_chan_sel_ch_bin0_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x0
    );

  ch_bin1_4088329920: entity work.ch_bin1_entity_4088329920
    port map (
      darkquad29_chan_sel_ch_bin1_user_data_out => darkquad29_chan_sel_ch_bin1_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x1
    );

  ch_bin2_1e3aa8db66: entity work.ch_bin2_entity_1e3aa8db66
    port map (
      darkquad29_chan_sel_ch_bin2_user_data_out => darkquad29_chan_sel_ch_bin2_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x2
    );

  ch_bin3_d90a703761: entity work.ch_bin3_entity_d90a703761
    port map (
      darkquad29_chan_sel_ch_bin3_user_data_out => darkquad29_chan_sel_ch_bin3_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x3
    );

  dbl_quad_buffer_02006ad3b7: entity work.dbl_quad_buffer_entity_02006ad3b7
    port map (
      ce_1 => ce_1_sg_x330,
      clk_1 => clk_1_sg_x330,
      din => delay4_q_net_x1,
      rd_addrs => delay16_q_net_x0,
      rw_mode => delay8_q_net_x1,
      wr_addr => delay10_q_net_x0,
      dout => mux6_y_net_x1,
      misc_out => delay6_q_net_x1
    );

  delay1: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 32
    )
    port map (
      ce => ce_1_sg_x330,
      clk => clk_1_sg_x330,
      d => reint1_output_port_net_x4,
      en => '1',
      rst => '1',
      q => delay1_q_net
    );

  delay10: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x330,
      clk => clk_1_sg_x330,
      d => delay11_q_net,
      en => '1',
      rst => '1',
      q => delay10_q_net_x0
    );

  delay11: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x330,
      clk => clk_1_sg_x330,
      d => delay9_q_net,
      en => '1',
      rst => '1',
      q => delay11_q_net
    );

  delay12: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 32
    )
    port map (
      ce => ce_1_sg_x330,
      clk => clk_1_sg_x330,
      d => reint1_output_port_net_x1,
      en => '1',
      rst => '1',
      q => delay12_q_net_x0
    );

  delay13: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 32
    )
    port map (
      ce => ce_1_sg_x330,
      clk => clk_1_sg_x330,
      d => reint1_output_port_net_x2,
      en => '1',
      rst => '1',
      q => delay13_q_net
    );

  delay14: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 32
    )
    port map (
      ce => ce_1_sg_x330,
      clk => clk_1_sg_x330,
      d => reint1_output_port_net_x3,
      en => '1',
      rst => '1',
      q => delay14_q_net_x0
    );

  delay16: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 44
    )
    port map (
      ce => ce_1_sg_x330,
      clk => clk_1_sg_x330,
      d => single_port_ram2_data_out_net,
      en => '1',
      rst => '1',
      q => delay16_q_net_x0
    );

  delay18: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x330,
      clk => clk_1_sg_x330,
      d(0) => slice23_y_net,
      en => '1',
      rst => '1',
      q(0) => delay18_q_net
    );

  delay2: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 32
    )
    port map (
      ce => ce_1_sg_x330,
      clk => clk_1_sg_x330,
      d => reint1_output_port_net_x0,
      en => '1',
      rst => '1',
      q => delay2_q_net
    );

  delay3: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 576
    )
    port map (
      ce => ce_1_sg_x330,
      clk => clk_1_sg_x330,
      d => register1_q_net_x0,
      en => '1',
      rst => '1',
      q => delay3_q_net
    );

  delay4: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 576
    )
    port map (
      ce => ce_1_sg_x330,
      clk => clk_1_sg_x330,
      d => delay5_q_net,
      en => '1',
      rst => '1',
      q => delay4_q_net_x1
    );

  delay5: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 576
    )
    port map (
      ce => ce_1_sg_x330,
      clk => clk_1_sg_x330,
      d => delay3_q_net,
      en => '1',
      rst => '1',
      q => delay5_q_net
    );

  delay6: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x330,
      clk => clk_1_sg_x330,
      d(0) => slice2_y_net,
      en => '1',
      rst => '1',
      q(0) => delay6_q_net
    );

  delay7: entity work.xldelay
    generic map (
      latency => 3,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x330,
      clk => clk_1_sg_x330,
      d(0) => delay6_q_net,
      en => '1',
      rst => '1',
      q(0) => delay7_q_net
    );

  delay8: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x330,
      clk => clk_1_sg_x330,
      d(0) => delay7_q_net,
      en => '1',
      rst => '1',
      q(0) => delay8_q_net_x1
    );

  delay9: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x330,
      clk => clk_1_sg_x330,
      d => delay14_q_net_x1,
      en => '1',
      rst => '1',
      q => delay9_q_net
    );

  load_ec926c8cbe: entity work.load_entity_ec926c8cbe
    port map (
      darkquad29_chan_sel_load_user_data_out => darkquad29_chan_sel_load_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x4
    );

  mux2: entity work.mux_cc14a035dc
    port map (
      ce => ce_1_sg_x330,
      clk => clk_1_sg_x330,
      clr => '0',
      d0 => delay14_q_net_x1,
      d1 => slice24_y_net,
      sel(0) => slice23_y_net,
      y => mux2_y_net
    );

  selector: entity work.counter_2943023fcf
    port map (
      ce => ce_1_sg_x330,
      clk => clk_1_sg_x330,
      clr => '0',
      en(0) => slice1_y_net,
      op(0) => selector_op_net
    );

  single_port_ram2: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 44,
      core_name0 => "bmg_72_83f6efe890a72ff6",
      latency => 2
    )
    port map (
      addr => mux2_y_net,
      ce => ce_1_sg_x330,
      clk => clk_1_sg_x330,
      data_in => concatenate_y_net_x0,
      en => "1",
      rst => "0",
      we(0) => delay18_q_net,
      data_out => single_port_ram2_data_out_net
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 1,
      y_width => 1
    )
    port map (
      x(0) => delay12_q_net_x1,
      y(0) => slice1_y_net
    );

  slice12: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 10,
      x_width => 32,
      y_width => 11
    )
    port map (
      x => delay2_q_net,
      y => slice12_y_net_x0
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 1,
      y_width => 1
    )
    port map (
      x(0) => selector_op_net,
      y(0) => slice2_y_net
    );

  slice23: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => delay1_q_net,
      y(0) => slice23_y_net
    );

  slice24: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 8,
      x_width => 32,
      y_width => 8
    )
    port map (
      x => delay1_q_net,
      y => slice24_y_net
    );

  slice3: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 10,
      x_width => 32,
      y_width => 11
    )
    port map (
      x => delay12_q_net_x0,
      y => slice3_y_net_x0
    );

  slice4: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 10,
      x_width => 32,
      y_width => 11
    )
    port map (
      x => delay13_q_net,
      y => slice4_y_net_x0
    );

  slice5: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 10,
      x_width => 32,
      y_width => 11
    )
    port map (
      x => delay14_q_net_x0,
      y => slice5_y_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/check_lag/latch"

entity latch_entity_89b4a9d902 is
  port (
    darkquad29_check_lag_latch_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end latch_entity_89b4a9d902;

architecture structural of latch_entity_89b4a9d902 is
  signal darkquad29_check_lag_latch_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_check_lag_latch_user_data_out_net_x0 <= darkquad29_check_lag_latch_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_check_lag_latch_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/check_lag"

entity check_lag_entity_eee441ab05 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    darkquad29_check_lag_latch_user_data_out: in std_logic_vector(31 downto 0); 
    data_ch_in: in std_logic_vector(7 downto 0); 
    dds_ch_in: in std_logic_vector(19 downto 0); 
    data_ch: out std_logic_vector(31 downto 0); 
    dds_ch: out std_logic_vector(31 downto 0)
  );
end check_lag_entity_eee441ab05;

architecture structural of check_lag_entity_eee441ab05 is
  signal cast_gw_dout_net_x2: std_logic_vector(31 downto 0);
  signal cast_gw_dout_net_x3: std_logic_vector(31 downto 0);
  signal ce_1_sg_x336: std_logic;
  signal clk_1_sg_x336: std_logic;
  signal darkquad29_check_lag_latch_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal delay6_q_net_x2: std_logic_vector(7 downto 0);
  signal en2_y_net_x0: std_logic;
  signal register1_q_net_x0: std_logic;
  signal register1_q_net_x1: std_logic_vector(7 downto 0);
  signal register1_q_net_x2: std_logic_vector(7 downto 0);
  signal register1_q_net_x3: std_logic_vector(7 downto 0);
  signal register2_q_net_x0: std_logic_vector(7 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal reinterpret1_output_port_net_x1: std_logic_vector(19 downto 0);
  signal slice9_y_net: std_logic_vector(7 downto 0);

begin
  ce_1_sg_x336 <= ce_1;
  clk_1_sg_x336 <= clk_1;
  darkquad29_check_lag_latch_user_data_out_net_x1 <= darkquad29_check_lag_latch_user_data_out;
  delay6_q_net_x2 <= data_ch_in;
  reinterpret1_output_port_net_x1 <= dds_ch_in;
  data_ch <= cast_gw_dout_net_x2;
  dds_ch <= cast_gw_dout_net_x3;

  data_ch_83e30e20bf: entity work.v7_ready_entity_d5f3d8453a
    port map (
      ce_1 => ce_1_sg_x336,
      clk_1 => clk_1_sg_x336,
      out_reg => register1_q_net_x2,
      cast_gw_x0 => cast_gw_dout_net_x2
    );

  dds_ch_e77403acbc: entity work.v7_ready_entity_d5f3d8453a
    port map (
      ce_1 => ce_1_sg_x336,
      clk_1 => clk_1_sg_x336,
      out_reg => register1_q_net_x3,
      cast_gw_x0 => cast_gw_dout_net_x3
    );

  en2: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => reint1_output_port_net_x0,
      y(0) => en2_y_net_x0
    );

  latch_89b4a9d902: entity work.latch_entity_89b4a9d902
    port map (
      darkquad29_check_lag_latch_user_data_out => darkquad29_check_lag_latch_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x0
    );

  pipeline19_109f17779c: entity work.pipeline4_entity_7ef90e571d
    port map (
      ce_1 => ce_1_sg_x336,
      clk_1 => clk_1_sg_x336,
      d => register1_q_net_x1,
      q => register1_q_net_x2
    );

  pipeline1_d305ce0010: entity work.pipeline3_entity_fb0a315a6d
    port map (
      ce_1 => ce_1_sg_x336,
      clk_1 => clk_1_sg_x336,
      d => en2_y_net_x0,
      q => register1_q_net_x0
    );

  pipeline21_3659b9319e: entity work.pipeline4_entity_7ef90e571d
    port map (
      ce_1 => ce_1_sg_x336,
      clk_1 => clk_1_sg_x336,
      d => register2_q_net_x0,
      q => register1_q_net_x3
    );

  register1: entity work.xlregister
    generic map (
      d_width => 8,
      init_value => b"00000000"
    )
    port map (
      ce => ce_1_sg_x336,
      clk => clk_1_sg_x336,
      d => delay6_q_net_x2,
      en(0) => register1_q_net_x0,
      rst => "0",
      q => register1_q_net_x1
    );

  register2: entity work.xlregister
    generic map (
      d_width => 8,
      init_value => b"00000000"
    )
    port map (
      ce => ce_1_sg_x336,
      clk => clk_1_sg_x336,
      d => slice9_y_net,
      en(0) => register1_q_net_x0,
      rst => "0",
      q => register2_q_net_x0
    );

  slice9: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 7,
      x_width => 20,
      y_width => 8
    )
    port map (
      x => reinterpret1_output_port_net_x1,
      y => slice9_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/conv_phase0/c_to_ri5"

entity c_to_ri5_entity_ba9f1565d9 is
  port (
    c: in std_logic_vector(31 downto 0); 
    im: out std_logic_vector(15 downto 0); 
    re: out std_logic_vector(15 downto 0)
  );
end c_to_ri5_entity_ba9f1565d9;

architecture structural of c_to_ri5_entity_ba9f1565d9 is
  signal force_im_output_port_net_x0: std_logic_vector(15 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(15 downto 0);
  signal single_port_ram1_data_out_net_x0: std_logic_vector(31 downto 0);
  signal slice_im_y_net: std_logic_vector(15 downto 0);
  signal slice_re_y_net: std_logic_vector(15 downto 0);

begin
  single_port_ram1_data_out_net_x0 <= c;
  im <= force_im_output_port_net_x0;
  re <= force_re_output_port_net_x0;

  force_im: entity work.reinterpret_151459306d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_im_y_net,
      output_port => force_im_output_port_net_x0
    );

  force_re: entity work.reinterpret_151459306d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_re_y_net,
      output_port => force_re_output_port_net_x0
    );

  slice_im: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 15,
      x_width => 32,
      y_width => 16
    )
    port map (
      x => single_port_ram1_data_out_net_x0,
      y => slice_im_y_net
    );

  slice_re: entity work.xlslice
    generic map (
      new_lsb => 16,
      new_msb => 31,
      x_width => 32,
      y_width => 16
    )
    port map (
      x => single_port_ram1_data_out_net_x0,
      y => slice_re_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/conv_phase0/centers"

entity centers_entity_447e6ec370 is
  port (
    darkquad29_conv_phase0_centers_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end centers_entity_447e6ec370;

architecture structural of centers_entity_447e6ec370 is
  signal darkquad29_conv_phase0_centers_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_conv_phase0_centers_user_data_out_net_x0 <= darkquad29_conv_phase0_centers_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_conv_phase0_centers_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/conv_phase0/load_centers"

entity load_centers_entity_7a0df6b283 is
  port (
    darkquad29_conv_phase0_load_centers_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end load_centers_entity_7a0df6b283;

architecture structural of load_centers_entity_7a0df6b283 is
  signal darkquad29_conv_phase0_load_centers_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_conv_phase0_load_centers_user_data_out_net_x0 <= darkquad29_conv_phase0_load_centers_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_conv_phase0_load_centers_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/conv_phase0"

entity conv_phase0_entity_6bd627872e is
  port (
    ce_1: in std_logic; 
    ch_in: in std_logic_vector(7 downto 0); 
    clk_1: in std_logic; 
    darkquad29_conv_phase0_centers_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_conv_phase0_load_centers_user_data_out: in std_logic_vector(31 downto 0); 
    data_in: in std_logic_vector(37 downto 0); 
    ch_out: out std_logic_vector(7 downto 0); 
    phase_out: out std_logic_vector(11 downto 0)
  );
end conv_phase0_entity_6bd627872e;

architecture structural of conv_phase0_entity_6bd627872e is
  signal addsub1_s_net: std_logic_vector(19 downto 0);
  signal addsub4_s_net: std_logic_vector(19 downto 0);
  signal arctan_phase_out_net_x0: std_logic_vector(11 downto 0);
  signal ce_1_sg_x337: std_logic;
  signal clk_1_sg_x337: std_logic;
  signal darkquad29_conv_phase0_centers_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal darkquad29_conv_phase0_load_centers_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal delay10_q_net_x0: std_logic_vector(37 downto 0);
  signal delay1_q_net_x0: std_logic_vector(7 downto 0);
  signal delay2_q_net: std_logic_vector(7 downto 0);
  signal delay35_q_net_x0: std_logic_vector(37 downto 0);
  signal delay36_q_net_x0: std_logic_vector(7 downto 0);
  signal delay3_q_net: std_logic;
  signal delay4_q_net: std_logic_vector(31 downto 0);
  signal delay7_q_net: std_logic_vector(7 downto 0);
  signal delay8_q_net: std_logic_vector(37 downto 0);
  signal delay9_q_net: std_logic_vector(7 downto 0);
  signal force_im_output_port_net_x0: std_logic_vector(18 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(15 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(18 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(15 downto 0);
  signal mux2_y_net: std_logic_vector(7 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal reinterpret2_output_port_net: std_logic_vector(19 downto 0);
  signal reinterpret3_output_port_net: std_logic_vector(19 downto 0);
  signal single_port_ram1_data_out_net_x0: std_logic_vector(31 downto 0);
  signal slice7_y_net: std_logic;
  signal slice8_y_net: std_logic_vector(7 downto 0);

begin
  ce_1_sg_x337 <= ce_1;
  delay36_q_net_x0 <= ch_in;
  clk_1_sg_x337 <= clk_1;
  darkquad29_conv_phase0_centers_user_data_out_net_x1 <= darkquad29_conv_phase0_centers_user_data_out;
  darkquad29_conv_phase0_load_centers_user_data_out_net_x1 <= darkquad29_conv_phase0_load_centers_user_data_out;
  delay35_q_net_x0 <= data_in;
  ch_out <= delay1_q_net_x0;
  phase_out <= arctan_phase_out_net_x0;

  addsub1: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 14,
      b_width => 16,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 20,
      core_name0 => "addsb_11_0_7a7e9e33c32e594c",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 20,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 17,
      s_width => 20
    )
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x337,
      clk => clk_1_sg_x337,
      clr => '0',
      en => "1",
      s => addsub1_s_net
    );

  addsub4: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 14,
      b_width => 16,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 20,
      core_name0 => "addsb_11_0_7a7e9e33c32e594c",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 20,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 17,
      s_width => 20
    )
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x337,
      clk => clk_1_sg_x337,
      clr => '0',
      en => "1",
      s => addsub4_s_net
    );

  arctan: entity work.xlcordic_53adb7b8edc473345e768703dfed392e
    port map (
      ce => ce_1_sg_x337,
      clk => clk_1_sg_x337,
      x_in => reinterpret2_output_port_net,
      y_in => reinterpret3_output_port_net,
      phase_out => arctan_phase_out_net_x0
    );

  c_to_ri2_4377cecac9: entity work.c_to_ri1_entity_f17f9bae25
    port map (
      c => delay10_q_net_x0,
      im => force_im_output_port_net_x0,
      re => force_re_output_port_net_x0
    );

  c_to_ri5_ba9f1565d9: entity work.c_to_ri5_entity_ba9f1565d9
    port map (
      c => single_port_ram1_data_out_net_x0,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  centers_447e6ec370: entity work.centers_entity_447e6ec370
    port map (
      darkquad29_conv_phase0_centers_user_data_out => darkquad29_conv_phase0_centers_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x0
    );

  delay1: entity work.delay_d1b224f0a6
    port map (
      ce => ce_1_sg_x337,
      clk => clk_1_sg_x337,
      clr => '0',
      d => delay2_q_net,
      q => delay1_q_net_x0
    );

  delay10: entity work.delay_29899636e8
    port map (
      ce => ce_1_sg_x337,
      clk => clk_1_sg_x337,
      clr => '0',
      d => delay8_q_net,
      q => delay10_q_net_x0
    );

  delay2: entity work.delay_9565135955
    port map (
      ce => ce_1_sg_x337,
      clk => clk_1_sg_x337,
      clr => '0',
      d => delay9_q_net,
      q => delay2_q_net
    );

  delay3: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x337,
      clk => clk_1_sg_x337,
      clr => '0',
      d(0) => slice7_y_net,
      q(0) => delay3_q_net
    );

  delay4: entity work.delay_672d2b8d1e
    port map (
      ce => ce_1_sg_x337,
      clk => clk_1_sg_x337,
      clr => '0',
      d => reint1_output_port_net_x0,
      q => delay4_q_net
    );

  delay7: entity work.delay_ebec135d8a
    port map (
      ce => ce_1_sg_x337,
      clk => clk_1_sg_x337,
      clr => '0',
      d => delay36_q_net_x0,
      q => delay7_q_net
    );

  delay8: entity work.delay_d64b27fc5c
    port map (
      ce => ce_1_sg_x337,
      clk => clk_1_sg_x337,
      clr => '0',
      d => delay35_q_net_x0,
      q => delay8_q_net
    );

  delay9: entity work.delay_9565135955
    port map (
      ce => ce_1_sg_x337,
      clk => clk_1_sg_x337,
      clr => '0',
      d => delay7_q_net,
      q => delay9_q_net
    );

  load_centers_7a0df6b283: entity work.load_centers_entity_7a0df6b283
    port map (
      darkquad29_conv_phase0_load_centers_user_data_out => darkquad29_conv_phase0_load_centers_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x1
    );

  mux2: entity work.mux_cc14a035dc
    port map (
      ce => ce_1_sg_x337,
      clk => clk_1_sg_x337,
      clr => '0',
      d0 => delay36_q_net_x0,
      d1 => slice8_y_net,
      sel(0) => slice7_y_net,
      y => mux2_y_net
    );

  reinterpret2: entity work.reinterpret_3f9089a15b
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => addsub4_s_net,
      output_port => reinterpret2_output_port_net
    );

  reinterpret3: entity work.reinterpret_3f9089a15b
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => addsub1_s_net,
      output_port => reinterpret3_output_port_net
    );

  single_port_ram1: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 32,
      core_name0 => "bmg_72_88f9a9ffe68f6b35",
      latency => 2
    )
    port map (
      addr => mux2_y_net,
      ce => ce_1_sg_x337,
      clk => clk_1_sg_x337,
      data_in => delay4_q_net,
      en => "1",
      rst => "0",
      we(0) => delay3_q_net,
      data_out => single_port_ram1_data_out_net_x0
    );

  slice7: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => reint1_output_port_net_x1,
      y(0) => slice7_y_net
    );

  slice8: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 8,
      x_width => 32,
      y_width => 8
    )
    port map (
      x => reint1_output_port_net_x1,
      y => slice8_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/conv_phase1/centers"

entity centers_entity_38cd3bcdf8 is
  port (
    darkquad29_conv_phase1_centers_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end centers_entity_38cd3bcdf8;

architecture structural of centers_entity_38cd3bcdf8 is
  signal darkquad29_conv_phase1_centers_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_conv_phase1_centers_user_data_out_net_x0 <= darkquad29_conv_phase1_centers_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_conv_phase1_centers_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/conv_phase1/load_centers"

entity load_centers_entity_57baf8f75e is
  port (
    darkquad29_conv_phase1_load_centers_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end load_centers_entity_57baf8f75e;

architecture structural of load_centers_entity_57baf8f75e is
  signal darkquad29_conv_phase1_load_centers_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_conv_phase1_load_centers_user_data_out_net_x0 <= darkquad29_conv_phase1_load_centers_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_conv_phase1_load_centers_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/conv_phase1"

entity conv_phase1_entity_1a26ce14a5 is
  port (
    ce_1: in std_logic; 
    ch_in: in std_logic_vector(7 downto 0); 
    clk_1: in std_logic; 
    darkquad29_conv_phase1_centers_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_conv_phase1_load_centers_user_data_out: in std_logic_vector(31 downto 0); 
    data_in: in std_logic_vector(37 downto 0); 
    ch_out: out std_logic_vector(7 downto 0); 
    phase_out: out std_logic_vector(11 downto 0)
  );
end conv_phase1_entity_1a26ce14a5;

architecture structural of conv_phase1_entity_1a26ce14a5 is
  signal addsub1_s_net: std_logic_vector(19 downto 0);
  signal addsub4_s_net: std_logic_vector(19 downto 0);
  signal arctan_phase_out_net_x0: std_logic_vector(11 downto 0);
  signal ce_1_sg_x338: std_logic;
  signal clk_1_sg_x338: std_logic;
  signal darkquad29_conv_phase1_centers_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal darkquad29_conv_phase1_load_centers_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal delay10_q_net_x0: std_logic_vector(37 downto 0);
  signal delay17_q_net_x0: std_logic_vector(37 downto 0);
  signal delay18_q_net_x0: std_logic_vector(7 downto 0);
  signal delay1_q_net_x0: std_logic_vector(7 downto 0);
  signal delay2_q_net: std_logic_vector(7 downto 0);
  signal delay3_q_net: std_logic;
  signal delay4_q_net: std_logic_vector(31 downto 0);
  signal delay7_q_net: std_logic_vector(7 downto 0);
  signal delay8_q_net: std_logic_vector(37 downto 0);
  signal delay9_q_net: std_logic_vector(7 downto 0);
  signal force_im_output_port_net_x0: std_logic_vector(18 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(15 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(18 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(15 downto 0);
  signal mux2_y_net: std_logic_vector(7 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal reinterpret2_output_port_net: std_logic_vector(19 downto 0);
  signal reinterpret3_output_port_net: std_logic_vector(19 downto 0);
  signal single_port_ram1_data_out_net_x0: std_logic_vector(31 downto 0);
  signal slice7_y_net: std_logic;
  signal slice8_y_net: std_logic_vector(7 downto 0);

begin
  ce_1_sg_x338 <= ce_1;
  delay18_q_net_x0 <= ch_in;
  clk_1_sg_x338 <= clk_1;
  darkquad29_conv_phase1_centers_user_data_out_net_x1 <= darkquad29_conv_phase1_centers_user_data_out;
  darkquad29_conv_phase1_load_centers_user_data_out_net_x1 <= darkquad29_conv_phase1_load_centers_user_data_out;
  delay17_q_net_x0 <= data_in;
  ch_out <= delay1_q_net_x0;
  phase_out <= arctan_phase_out_net_x0;

  addsub1: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 14,
      b_width => 16,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 20,
      core_name0 => "addsb_11_0_7a7e9e33c32e594c",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 20,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 17,
      s_width => 20
    )
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x338,
      clk => clk_1_sg_x338,
      clr => '0',
      en => "1",
      s => addsub1_s_net
    );

  addsub4: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 14,
      b_width => 16,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 20,
      core_name0 => "addsb_11_0_7a7e9e33c32e594c",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 20,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 17,
      s_width => 20
    )
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x338,
      clk => clk_1_sg_x338,
      clr => '0',
      en => "1",
      s => addsub4_s_net
    );

  arctan: entity work.xlcordic_53adb7b8edc473345e768703dfed392e
    port map (
      ce => ce_1_sg_x338,
      clk => clk_1_sg_x338,
      x_in => reinterpret2_output_port_net,
      y_in => reinterpret3_output_port_net,
      phase_out => arctan_phase_out_net_x0
    );

  c_to_ri2_8624c97e69: entity work.c_to_ri1_entity_f17f9bae25
    port map (
      c => delay10_q_net_x0,
      im => force_im_output_port_net_x0,
      re => force_re_output_port_net_x0
    );

  c_to_ri5_a453dea6ad: entity work.c_to_ri5_entity_ba9f1565d9
    port map (
      c => single_port_ram1_data_out_net_x0,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  centers_38cd3bcdf8: entity work.centers_entity_38cd3bcdf8
    port map (
      darkquad29_conv_phase1_centers_user_data_out => darkquad29_conv_phase1_centers_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x0
    );

  delay1: entity work.delay_d1b224f0a6
    port map (
      ce => ce_1_sg_x338,
      clk => clk_1_sg_x338,
      clr => '0',
      d => delay2_q_net,
      q => delay1_q_net_x0
    );

  delay10: entity work.delay_29899636e8
    port map (
      ce => ce_1_sg_x338,
      clk => clk_1_sg_x338,
      clr => '0',
      d => delay8_q_net,
      q => delay10_q_net_x0
    );

  delay2: entity work.delay_9565135955
    port map (
      ce => ce_1_sg_x338,
      clk => clk_1_sg_x338,
      clr => '0',
      d => delay9_q_net,
      q => delay2_q_net
    );

  delay3: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x338,
      clk => clk_1_sg_x338,
      clr => '0',
      d(0) => slice7_y_net,
      q(0) => delay3_q_net
    );

  delay4: entity work.delay_672d2b8d1e
    port map (
      ce => ce_1_sg_x338,
      clk => clk_1_sg_x338,
      clr => '0',
      d => reint1_output_port_net_x0,
      q => delay4_q_net
    );

  delay7: entity work.delay_ebec135d8a
    port map (
      ce => ce_1_sg_x338,
      clk => clk_1_sg_x338,
      clr => '0',
      d => delay18_q_net_x0,
      q => delay7_q_net
    );

  delay8: entity work.delay_d64b27fc5c
    port map (
      ce => ce_1_sg_x338,
      clk => clk_1_sg_x338,
      clr => '0',
      d => delay17_q_net_x0,
      q => delay8_q_net
    );

  delay9: entity work.delay_9565135955
    port map (
      ce => ce_1_sg_x338,
      clk => clk_1_sg_x338,
      clr => '0',
      d => delay7_q_net,
      q => delay9_q_net
    );

  load_centers_57baf8f75e: entity work.load_centers_entity_57baf8f75e
    port map (
      darkquad29_conv_phase1_load_centers_user_data_out => darkquad29_conv_phase1_load_centers_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x1
    );

  mux2: entity work.mux_cc14a035dc
    port map (
      ce => ce_1_sg_x338,
      clk => clk_1_sg_x338,
      clr => '0',
      d0 => delay18_q_net_x0,
      d1 => slice8_y_net,
      sel(0) => slice7_y_net,
      y => mux2_y_net
    );

  reinterpret2: entity work.reinterpret_3f9089a15b
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => addsub4_s_net,
      output_port => reinterpret2_output_port_net
    );

  reinterpret3: entity work.reinterpret_3f9089a15b
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => addsub1_s_net,
      output_port => reinterpret3_output_port_net
    );

  single_port_ram1: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 32,
      core_name0 => "bmg_72_88f9a9ffe68f6b35",
      latency => 2
    )
    port map (
      addr => mux2_y_net,
      ce => ce_1_sg_x338,
      clk => clk_1_sg_x338,
      data_in => delay4_q_net,
      en => "1",
      rst => "0",
      we(0) => delay3_q_net,
      data_out => single_port_ram1_data_out_net_x0
    );

  slice7: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => reint1_output_port_net_x1,
      y(0) => slice7_y_net
    );

  slice8: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 8,
      x_width => 32,
      y_width => 8
    )
    port map (
      x => reint1_output_port_net_x1,
      y => slice8_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/conv_phase2/centers"

entity centers_entity_bedb969114 is
  port (
    darkquad29_conv_phase2_centers_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end centers_entity_bedb969114;

architecture structural of centers_entity_bedb969114 is
  signal darkquad29_conv_phase2_centers_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_conv_phase2_centers_user_data_out_net_x0 <= darkquad29_conv_phase2_centers_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_conv_phase2_centers_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/conv_phase2/load_centers"

entity load_centers_entity_9542d46859 is
  port (
    darkquad29_conv_phase2_load_centers_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end load_centers_entity_9542d46859;

architecture structural of load_centers_entity_9542d46859 is
  signal darkquad29_conv_phase2_load_centers_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_conv_phase2_load_centers_user_data_out_net_x0 <= darkquad29_conv_phase2_load_centers_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_conv_phase2_load_centers_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/conv_phase2"

entity conv_phase2_entity_f3d301a38c is
  port (
    ce_1: in std_logic; 
    ch_in: in std_logic_vector(7 downto 0); 
    clk_1: in std_logic; 
    darkquad29_conv_phase2_centers_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_conv_phase2_load_centers_user_data_out: in std_logic_vector(31 downto 0); 
    data_in: in std_logic_vector(37 downto 0); 
    ch_out: out std_logic_vector(7 downto 0); 
    phase_out: out std_logic_vector(11 downto 0)
  );
end conv_phase2_entity_f3d301a38c;

architecture structural of conv_phase2_entity_f3d301a38c is
  signal addsub1_s_net: std_logic_vector(19 downto 0);
  signal addsub4_s_net: std_logic_vector(19 downto 0);
  signal arctan_phase_out_net_x0: std_logic_vector(11 downto 0);
  signal ce_1_sg_x339: std_logic;
  signal clk_1_sg_x339: std_logic;
  signal darkquad29_conv_phase2_centers_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal darkquad29_conv_phase2_load_centers_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal delay10_q_net_x0: std_logic_vector(37 downto 0);
  signal delay1_q_net_x0: std_logic_vector(7 downto 0);
  signal delay26_q_net_x0: std_logic_vector(37 downto 0);
  signal delay28_q_net_x0: std_logic_vector(7 downto 0);
  signal delay2_q_net: std_logic_vector(7 downto 0);
  signal delay3_q_net: std_logic;
  signal delay4_q_net: std_logic_vector(31 downto 0);
  signal delay7_q_net: std_logic_vector(7 downto 0);
  signal delay8_q_net: std_logic_vector(37 downto 0);
  signal delay9_q_net: std_logic_vector(7 downto 0);
  signal force_im_output_port_net_x0: std_logic_vector(18 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(15 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(18 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(15 downto 0);
  signal mux2_y_net: std_logic_vector(7 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal reinterpret2_output_port_net: std_logic_vector(19 downto 0);
  signal reinterpret3_output_port_net: std_logic_vector(19 downto 0);
  signal single_port_ram1_data_out_net_x0: std_logic_vector(31 downto 0);
  signal slice7_y_net: std_logic;
  signal slice8_y_net: std_logic_vector(7 downto 0);

begin
  ce_1_sg_x339 <= ce_1;
  delay28_q_net_x0 <= ch_in;
  clk_1_sg_x339 <= clk_1;
  darkquad29_conv_phase2_centers_user_data_out_net_x1 <= darkquad29_conv_phase2_centers_user_data_out;
  darkquad29_conv_phase2_load_centers_user_data_out_net_x1 <= darkquad29_conv_phase2_load_centers_user_data_out;
  delay26_q_net_x0 <= data_in;
  ch_out <= delay1_q_net_x0;
  phase_out <= arctan_phase_out_net_x0;

  addsub1: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 14,
      b_width => 16,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 20,
      core_name0 => "addsb_11_0_7a7e9e33c32e594c",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 20,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 17,
      s_width => 20
    )
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x339,
      clk => clk_1_sg_x339,
      clr => '0',
      en => "1",
      s => addsub1_s_net
    );

  addsub4: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 14,
      b_width => 16,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 20,
      core_name0 => "addsb_11_0_7a7e9e33c32e594c",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 20,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 17,
      s_width => 20
    )
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x339,
      clk => clk_1_sg_x339,
      clr => '0',
      en => "1",
      s => addsub4_s_net
    );

  arctan: entity work.xlcordic_53adb7b8edc473345e768703dfed392e
    port map (
      ce => ce_1_sg_x339,
      clk => clk_1_sg_x339,
      x_in => reinterpret2_output_port_net,
      y_in => reinterpret3_output_port_net,
      phase_out => arctan_phase_out_net_x0
    );

  c_to_ri2_ea89d82582: entity work.c_to_ri1_entity_f17f9bae25
    port map (
      c => delay10_q_net_x0,
      im => force_im_output_port_net_x0,
      re => force_re_output_port_net_x0
    );

  c_to_ri5_7a2130d8a2: entity work.c_to_ri5_entity_ba9f1565d9
    port map (
      c => single_port_ram1_data_out_net_x0,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  centers_bedb969114: entity work.centers_entity_bedb969114
    port map (
      darkquad29_conv_phase2_centers_user_data_out => darkquad29_conv_phase2_centers_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x0
    );

  delay1: entity work.delay_d1b224f0a6
    port map (
      ce => ce_1_sg_x339,
      clk => clk_1_sg_x339,
      clr => '0',
      d => delay2_q_net,
      q => delay1_q_net_x0
    );

  delay10: entity work.delay_29899636e8
    port map (
      ce => ce_1_sg_x339,
      clk => clk_1_sg_x339,
      clr => '0',
      d => delay8_q_net,
      q => delay10_q_net_x0
    );

  delay2: entity work.delay_9565135955
    port map (
      ce => ce_1_sg_x339,
      clk => clk_1_sg_x339,
      clr => '0',
      d => delay9_q_net,
      q => delay2_q_net
    );

  delay3: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x339,
      clk => clk_1_sg_x339,
      clr => '0',
      d(0) => slice7_y_net,
      q(0) => delay3_q_net
    );

  delay4: entity work.delay_672d2b8d1e
    port map (
      ce => ce_1_sg_x339,
      clk => clk_1_sg_x339,
      clr => '0',
      d => reint1_output_port_net_x0,
      q => delay4_q_net
    );

  delay7: entity work.delay_ebec135d8a
    port map (
      ce => ce_1_sg_x339,
      clk => clk_1_sg_x339,
      clr => '0',
      d => delay28_q_net_x0,
      q => delay7_q_net
    );

  delay8: entity work.delay_d64b27fc5c
    port map (
      ce => ce_1_sg_x339,
      clk => clk_1_sg_x339,
      clr => '0',
      d => delay26_q_net_x0,
      q => delay8_q_net
    );

  delay9: entity work.delay_9565135955
    port map (
      ce => ce_1_sg_x339,
      clk => clk_1_sg_x339,
      clr => '0',
      d => delay7_q_net,
      q => delay9_q_net
    );

  load_centers_9542d46859: entity work.load_centers_entity_9542d46859
    port map (
      darkquad29_conv_phase2_load_centers_user_data_out => darkquad29_conv_phase2_load_centers_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x1
    );

  mux2: entity work.mux_cc14a035dc
    port map (
      ce => ce_1_sg_x339,
      clk => clk_1_sg_x339,
      clr => '0',
      d0 => delay28_q_net_x0,
      d1 => slice8_y_net,
      sel(0) => slice7_y_net,
      y => mux2_y_net
    );

  reinterpret2: entity work.reinterpret_3f9089a15b
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => addsub4_s_net,
      output_port => reinterpret2_output_port_net
    );

  reinterpret3: entity work.reinterpret_3f9089a15b
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => addsub1_s_net,
      output_port => reinterpret3_output_port_net
    );

  single_port_ram1: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 32,
      core_name0 => "bmg_72_88f9a9ffe68f6b35",
      latency => 2
    )
    port map (
      addr => mux2_y_net,
      ce => ce_1_sg_x339,
      clk => clk_1_sg_x339,
      data_in => delay4_q_net,
      en => "1",
      rst => "0",
      we(0) => delay3_q_net,
      data_out => single_port_ram1_data_out_net_x0
    );

  slice7: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => reint1_output_port_net_x1,
      y(0) => slice7_y_net
    );

  slice8: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 8,
      x_width => 32,
      y_width => 8
    )
    port map (
      x => reint1_output_port_net_x1,
      y => slice8_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/conv_phase3/centers"

entity centers_entity_ca2787dfc0 is
  port (
    darkquad29_conv_phase3_centers_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end centers_entity_ca2787dfc0;

architecture structural of centers_entity_ca2787dfc0 is
  signal darkquad29_conv_phase3_centers_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_conv_phase3_centers_user_data_out_net_x0 <= darkquad29_conv_phase3_centers_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_conv_phase3_centers_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/conv_phase3/load_centers"

entity load_centers_entity_740ad34b96 is
  port (
    darkquad29_conv_phase3_load_centers_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end load_centers_entity_740ad34b96;

architecture structural of load_centers_entity_740ad34b96 is
  signal darkquad29_conv_phase3_load_centers_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_conv_phase3_load_centers_user_data_out_net_x0 <= darkquad29_conv_phase3_load_centers_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_conv_phase3_load_centers_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/conv_phase3"

entity conv_phase3_entity_5b7a61fe21 is
  port (
    ce_1: in std_logic; 
    ch_in: in std_logic_vector(7 downto 0); 
    clk_1: in std_logic; 
    darkquad29_conv_phase3_centers_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_conv_phase3_load_centers_user_data_out: in std_logic_vector(31 downto 0); 
    data_in: in std_logic_vector(37 downto 0); 
    ch_out: out std_logic_vector(7 downto 0); 
    phase_out: out std_logic_vector(11 downto 0)
  );
end conv_phase3_entity_5b7a61fe21;

architecture structural of conv_phase3_entity_5b7a61fe21 is
  signal addsub1_s_net: std_logic_vector(19 downto 0);
  signal addsub4_s_net: std_logic_vector(19 downto 0);
  signal arctan_phase_out_net_x0: std_logic_vector(11 downto 0);
  signal ce_1_sg_x340: std_logic;
  signal clk_1_sg_x340: std_logic;
  signal darkquad29_conv_phase3_centers_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal darkquad29_conv_phase3_load_centers_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal delay10_q_net_x0: std_logic_vector(37 downto 0);
  signal delay1_q_net_x0: std_logic_vector(7 downto 0);
  signal delay2_q_net: std_logic_vector(7 downto 0);
  signal delay39_q_net_x0: std_logic_vector(37 downto 0);
  signal delay3_q_net: std_logic;
  signal delay40_q_net_x0: std_logic_vector(7 downto 0);
  signal delay4_q_net: std_logic_vector(31 downto 0);
  signal delay7_q_net: std_logic_vector(7 downto 0);
  signal delay8_q_net: std_logic_vector(37 downto 0);
  signal delay9_q_net: std_logic_vector(7 downto 0);
  signal force_im_output_port_net_x0: std_logic_vector(18 downto 0);
  signal force_im_output_port_net_x1: std_logic_vector(15 downto 0);
  signal force_re_output_port_net_x0: std_logic_vector(18 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(15 downto 0);
  signal mux2_y_net: std_logic_vector(7 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal reinterpret2_output_port_net: std_logic_vector(19 downto 0);
  signal reinterpret3_output_port_net: std_logic_vector(19 downto 0);
  signal single_port_ram1_data_out_net_x0: std_logic_vector(31 downto 0);
  signal slice7_y_net: std_logic;
  signal slice8_y_net: std_logic_vector(7 downto 0);

begin
  ce_1_sg_x340 <= ce_1;
  delay40_q_net_x0 <= ch_in;
  clk_1_sg_x340 <= clk_1;
  darkquad29_conv_phase3_centers_user_data_out_net_x1 <= darkquad29_conv_phase3_centers_user_data_out;
  darkquad29_conv_phase3_load_centers_user_data_out_net_x1 <= darkquad29_conv_phase3_load_centers_user_data_out;
  delay39_q_net_x0 <= data_in;
  ch_out <= delay1_q_net_x0;
  phase_out <= arctan_phase_out_net_x0;

  addsub1: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 14,
      b_width => 16,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 20,
      core_name0 => "addsb_11_0_7a7e9e33c32e594c",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 20,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 17,
      s_width => 20
    )
    port map (
      a => force_im_output_port_net_x0,
      b => force_im_output_port_net_x1,
      ce => ce_1_sg_x340,
      clk => clk_1_sg_x340,
      clr => '0',
      en => "1",
      s => addsub1_s_net
    );

  addsub4: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 14,
      b_width => 16,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 20,
      core_name0 => "addsb_11_0_7a7e9e33c32e594c",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 20,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 17,
      s_width => 20
    )
    port map (
      a => force_re_output_port_net_x0,
      b => force_re_output_port_net_x1,
      ce => ce_1_sg_x340,
      clk => clk_1_sg_x340,
      clr => '0',
      en => "1",
      s => addsub4_s_net
    );

  arctan: entity work.xlcordic_53adb7b8edc473345e768703dfed392e
    port map (
      ce => ce_1_sg_x340,
      clk => clk_1_sg_x340,
      x_in => reinterpret2_output_port_net,
      y_in => reinterpret3_output_port_net,
      phase_out => arctan_phase_out_net_x0
    );

  c_to_ri2_bb15d3c6b2: entity work.c_to_ri1_entity_f17f9bae25
    port map (
      c => delay10_q_net_x0,
      im => force_im_output_port_net_x0,
      re => force_re_output_port_net_x0
    );

  c_to_ri5_65cb38d831: entity work.c_to_ri5_entity_ba9f1565d9
    port map (
      c => single_port_ram1_data_out_net_x0,
      im => force_im_output_port_net_x1,
      re => force_re_output_port_net_x1
    );

  centers_ca2787dfc0: entity work.centers_entity_ca2787dfc0
    port map (
      darkquad29_conv_phase3_centers_user_data_out => darkquad29_conv_phase3_centers_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x0
    );

  delay1: entity work.delay_d1b224f0a6
    port map (
      ce => ce_1_sg_x340,
      clk => clk_1_sg_x340,
      clr => '0',
      d => delay2_q_net,
      q => delay1_q_net_x0
    );

  delay10: entity work.delay_29899636e8
    port map (
      ce => ce_1_sg_x340,
      clk => clk_1_sg_x340,
      clr => '0',
      d => delay8_q_net,
      q => delay10_q_net_x0
    );

  delay2: entity work.delay_9565135955
    port map (
      ce => ce_1_sg_x340,
      clk => clk_1_sg_x340,
      clr => '0',
      d => delay9_q_net,
      q => delay2_q_net
    );

  delay3: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x340,
      clk => clk_1_sg_x340,
      clr => '0',
      d(0) => slice7_y_net,
      q(0) => delay3_q_net
    );

  delay4: entity work.delay_672d2b8d1e
    port map (
      ce => ce_1_sg_x340,
      clk => clk_1_sg_x340,
      clr => '0',
      d => reint1_output_port_net_x0,
      q => delay4_q_net
    );

  delay7: entity work.delay_ebec135d8a
    port map (
      ce => ce_1_sg_x340,
      clk => clk_1_sg_x340,
      clr => '0',
      d => delay40_q_net_x0,
      q => delay7_q_net
    );

  delay8: entity work.delay_d64b27fc5c
    port map (
      ce => ce_1_sg_x340,
      clk => clk_1_sg_x340,
      clr => '0',
      d => delay39_q_net_x0,
      q => delay8_q_net
    );

  delay9: entity work.delay_9565135955
    port map (
      ce => ce_1_sg_x340,
      clk => clk_1_sg_x340,
      clr => '0',
      d => delay7_q_net,
      q => delay9_q_net
    );

  load_centers_740ad34b96: entity work.load_centers_entity_740ad34b96
    port map (
      darkquad29_conv_phase3_load_centers_user_data_out => darkquad29_conv_phase3_load_centers_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x1
    );

  mux2: entity work.mux_cc14a035dc
    port map (
      ce => ce_1_sg_x340,
      clk => clk_1_sg_x340,
      clr => '0',
      d0 => delay40_q_net_x0,
      d1 => slice8_y_net,
      sel(0) => slice7_y_net,
      y => mux2_y_net
    );

  reinterpret2: entity work.reinterpret_3f9089a15b
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => addsub4_s_net,
      output_port => reinterpret2_output_port_net
    );

  reinterpret3: entity work.reinterpret_3f9089a15b
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => addsub1_s_net,
      output_port => reinterpret3_output_port_net
    );

  single_port_ram1: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 32,
      core_name0 => "bmg_72_88f9a9ffe68f6b35",
      latency => 2
    )
    port map (
      addr => mux2_y_net,
      ce => ce_1_sg_x340,
      clk => clk_1_sg_x340,
      data_in => delay4_q_net,
      en => "1",
      rst => "0",
      we(0) => delay3_q_net,
      data_out => single_port_ram1_data_out_net_x0
    );

  slice7: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => reint1_output_port_net_x1,
      y(0) => slice7_y_net
    );

  slice8: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 8,
      x_width => 32,
      y_width => 8
    )
    port map (
      x => reint1_output_port_net_x1,
      y => slice8_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/dds_delay"

entity dds_delay_entity_255e95bed2 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    delay: in std_logic_vector(8 downto 0); 
    din: in std_logic_vector(275 downto 0); 
    dout: out std_logic_vector(275 downto 0)
  );
end dds_delay_entity_255e95bed2;

architecture structural of dds_delay_entity_255e95bed2 is
  signal addsub_s_net: std_logic_vector(8 downto 0);
  signal ce_1_sg_x341: std_logic;
  signal clk_1_sg_x341: std_logic;
  signal constant2_op_net: std_logic;
  signal constant4_op_net: std_logic;
  signal dual_port_ram_doutb_net_x0: std_logic_vector(275 downto 0);
  signal register1_q_net_x1: std_logic_vector(8 downto 0);
  signal register1_q_net_x2: std_logic_vector(275 downto 0);
  signal wr_addr_op_net: std_logic_vector(8 downto 0);

begin
  ce_1_sg_x341 <= ce_1;
  clk_1_sg_x341 <= clk_1;
  register1_q_net_x1 <= delay;
  register1_q_net_x2 <= din;
  dout <= dual_port_ram_doutb_net_x0;

  addsub: entity work.addsub_5da0e88a67
    port map (
      a => wr_addr_op_net,
      b => register1_q_net_x1,
      ce => ce_1_sg_x341,
      clk => clk_1_sg_x341,
      clr => '0',
      s => addsub_s_net
    );

  constant2: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant2_op_net
    );

  constant4: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant4_op_net
    );

  dual_port_ram: entity work.xldpram_darkquad29
    generic map (
      c_address_width_a => 9,
      c_address_width_b => 9,
      c_width_a => 276,
      c_width_b => 276,
      core_name0 => "bmg_72_5200d17ea41d7d8d",
      latency => 2
    )
    port map (
      a_ce => ce_1_sg_x341,
      a_clk => clk_1_sg_x341,
      addra => wr_addr_op_net,
      addrb => addsub_s_net,
      b_ce => ce_1_sg_x341,
      b_clk => clk_1_sg_x341,
      dina => register1_q_net_x2,
      dinb => register1_q_net_x2,
      ena => "1",
      enb => "1",
      rsta => "0",
      rstb => "0",
      wea(0) => constant2_op_net,
      web(0) => constant4_op_net,
      doutb => dual_port_ram_doutb_net_x0
    );

  wr_addr: entity work.xlcounter_free_darkquad29
    generic map (
      core_name0 => "cntr_11_0_198c863c3eaf9bde",
      op_arith => xlUnsigned,
      op_width => 9
    )
    port map (
      ce => ce_1_sg_x341,
      clk => clk_1_sg_x341,
      clr => '0',
      en => "1",
      rst => "0",
      op => wr_addr_op_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/dds_lut/pipeline1"

entity pipeline1_entity_f892c55246 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(71 downto 0); 
    q: out std_logic_vector(71 downto 0)
  );
end pipeline1_entity_f892c55246;

architecture structural of pipeline1_entity_f892c55246 is
  signal ce_1_sg_x343: std_logic;
  signal clk_1_sg_x343: std_logic;
  signal extract_parity_b_net_x0: std_logic_vector(71 downto 0);
  signal register0_q_net: std_logic_vector(71 downto 0);
  signal register1_q_net_x0: std_logic_vector(71 downto 0);

begin
  ce_1_sg_x343 <= ce_1;
  clk_1_sg_x343 <= clk_1;
  extract_parity_b_net_x0 <= d;
  q <= register1_q_net_x0;

  register0: entity work.xlregister
    generic map (
      d_width => 72,
      init_value => b"000000000000000000000000000000000000000000000000000000000000000000000000"
    )
    port map (
      ce => ce_1_sg_x343,
      clk => clk_1_sg_x343,
      d => extract_parity_b_net_x0,
      en => "1",
      rst => "0",
      q => register0_q_net
    );

  register1: entity work.xlregister
    generic map (
      d_width => 72,
      init_value => b"000000000000000000000000000000000000000000000000000000000000000000000000"
    )
    port map (
      ce => ce_1_sg_x343,
      clk => clk_1_sg_x343,
      d => register0_q_net,
      en => "1",
      rst => "0",
      q => register1_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/dds_lut/qdr0"

entity qdr0_entity_d9a3f7c3d9 is
  port (
    address: in std_logic_vector(31 downto 0); 
    be: in std_logic_vector(7 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    darkquad29_dds_lut_qdr0_data_out: in std_logic_vector(71 downto 0); 
    data_in: in std_logic_vector(71 downto 0); 
    rd_en: in std_logic; 
    wr_en: in std_logic; 
    convert_address_x0: out std_logic_vector(31 downto 0); 
    convert_be_x0: out std_logic_vector(7 downto 0); 
    convert_data_in_x0: out std_logic_vector(71 downto 0); 
    convert_rd_en_x0: out std_logic; 
    convert_wr_en_x0: out std_logic; 
    data_out: out std_logic_vector(71 downto 0)
  );
end qdr0_entity_d9a3f7c3d9;

architecture structural of qdr0_entity_d9a3f7c3d9 is
  signal ce_1_sg_x348: std_logic;
  signal clk_1_sg_x348: std_logic;
  signal convert_address_dout_net_x0: std_logic_vector(31 downto 0);
  signal convert_be_dout_net_x0: std_logic_vector(7 downto 0);
  signal convert_data_in1_dout_net: std_logic_vector(71 downto 0);
  signal convert_data_in_dout_net_x0: std_logic_vector(71 downto 0);
  signal convert_rd_en_dout_net_x0: std_logic;
  signal convert_wr_en_dout_net_x0: std_logic;
  signal darkquad29_dds_lut_qdr0_data_out_net_x0: std_logic_vector(71 downto 0);
  signal delay53_q_net_x0: std_logic;
  signal delay54_q_net_x0: std_logic;
  signal delay55_q_net_x0: std_logic_vector(7 downto 0);
  signal delay56_q_net_x0: std_logic_vector(31 downto 0);
  signal delay57_q_net_x0: std_logic_vector(71 downto 0);
  signal extract_parity_b_net_x1: std_logic_vector(71 downto 0);
  signal force_data_out_output_port_net: std_logic_vector(71 downto 0);
  signal insert_parity_b_net: std_logic_vector(71 downto 0);

begin
  delay56_q_net_x0 <= address;
  delay55_q_net_x0 <= be;
  ce_1_sg_x348 <= ce_1;
  clk_1_sg_x348 <= clk_1;
  darkquad29_dds_lut_qdr0_data_out_net_x0 <= darkquad29_dds_lut_qdr0_data_out;
  delay57_q_net_x0 <= data_in;
  delay53_q_net_x0 <= rd_en;
  delay54_q_net_x0 <= wr_en;
  convert_address_x0 <= convert_address_dout_net_x0;
  convert_be_x0 <= convert_be_dout_net_x0;
  convert_data_in_x0 <= convert_data_in_dout_net_x0;
  convert_rd_en_x0 <= convert_rd_en_dout_net_x0;
  convert_wr_en_x0 <= convert_wr_en_dout_net_x0;
  data_out <= extract_parity_b_net_x1;

  convert_address: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 32,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x348,
      clk => clk_1_sg_x348,
      clr => '0',
      din => delay56_q_net_x0,
      en => "1",
      dout => convert_address_dout_net_x0
    );

  convert_be: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 8,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 8,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x348,
      clk => clk_1_sg_x348,
      clr => '0',
      din => delay55_q_net_x0,
      en => "1",
      dout => convert_be_dout_net_x0
    );

  convert_data_in: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 72,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 72,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x348,
      clk => clk_1_sg_x348,
      clr => '0',
      din => insert_parity_b_net,
      en => "1",
      dout => convert_data_in_dout_net_x0
    );

  convert_data_in1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 72,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 72,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x348,
      clk => clk_1_sg_x348,
      clr => '0',
      din => delay57_q_net_x0,
      en => "1",
      dout => convert_data_in1_dout_net
    );

  convert_rd_en: entity work.xlconvert
    generic map (
      bool_conversion => 1,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x348,
      clk => clk_1_sg_x348,
      clr => '0',
      din(0) => delay53_q_net_x0,
      en => "1",
      dout(0) => convert_rd_en_dout_net_x0
    );

  convert_wr_en: entity work.xlconvert
    generic map (
      bool_conversion => 1,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x348,
      clk => clk_1_sg_x348,
      clr => '0',
      din(0) => delay54_q_net_x0,
      en => "1",
      dout(0) => convert_wr_en_dout_net_x0
    );

  extract_parity: entity work.bitbasher_7f79f7d703
    port map (
      a => force_data_out_output_port_net,
      ce => '0',
      clk => '0',
      clr => '0',
      b => extract_parity_b_net_x1
    );

  force_data_out: entity work.reinterpret_8b4279cdc5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => darkquad29_dds_lut_qdr0_data_out_net_x0,
      output_port => force_data_out_output_port_net
    );

  insert_parity: entity work.bitbasher_34778e1824
    port map (
      a => convert_data_in1_dout_net,
      ce => '0',
      clk => '0',
      clr => '0',
      b => insert_parity_b_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/dds_lut/qdr1"

entity qdr1_entity_6eb00c7834 is
  port (
    address: in std_logic_vector(31 downto 0); 
    be: in std_logic_vector(7 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    darkquad29_dds_lut_qdr1_data_out: in std_logic_vector(71 downto 0); 
    data_in: in std_logic_vector(71 downto 0); 
    rd_en: in std_logic; 
    wr_en: in std_logic; 
    convert_address_x0: out std_logic_vector(31 downto 0); 
    convert_be_x0: out std_logic_vector(7 downto 0); 
    convert_data_in_x0: out std_logic_vector(71 downto 0); 
    convert_rd_en_x0: out std_logic; 
    convert_wr_en_x0: out std_logic; 
    data_out: out std_logic_vector(71 downto 0)
  );
end qdr1_entity_6eb00c7834;

architecture structural of qdr1_entity_6eb00c7834 is
  signal ce_1_sg_x349: std_logic;
  signal clk_1_sg_x349: std_logic;
  signal convert_address_dout_net_x0: std_logic_vector(31 downto 0);
  signal convert_be_dout_net_x0: std_logic_vector(7 downto 0);
  signal convert_data_in1_dout_net: std_logic_vector(71 downto 0);
  signal convert_data_in_dout_net_x0: std_logic_vector(71 downto 0);
  signal convert_rd_en_dout_net_x0: std_logic;
  signal convert_wr_en_dout_net_x0: std_logic;
  signal darkquad29_dds_lut_qdr1_data_out_net_x0: std_logic_vector(71 downto 0);
  signal delay58_q_net_x0: std_logic;
  signal delay59_q_net_x0: std_logic;
  signal delay60_q_net_x0: std_logic_vector(7 downto 0);
  signal delay61_q_net_x0: std_logic_vector(31 downto 0);
  signal delay62_q_net_x0: std_logic_vector(71 downto 0);
  signal extract_parity_b_net_x1: std_logic_vector(71 downto 0);
  signal force_data_out_output_port_net: std_logic_vector(71 downto 0);
  signal insert_parity_b_net: std_logic_vector(71 downto 0);

begin
  delay61_q_net_x0 <= address;
  delay60_q_net_x0 <= be;
  ce_1_sg_x349 <= ce_1;
  clk_1_sg_x349 <= clk_1;
  darkquad29_dds_lut_qdr1_data_out_net_x0 <= darkquad29_dds_lut_qdr1_data_out;
  delay62_q_net_x0 <= data_in;
  delay58_q_net_x0 <= rd_en;
  delay59_q_net_x0 <= wr_en;
  convert_address_x0 <= convert_address_dout_net_x0;
  convert_be_x0 <= convert_be_dout_net_x0;
  convert_data_in_x0 <= convert_data_in_dout_net_x0;
  convert_rd_en_x0 <= convert_rd_en_dout_net_x0;
  convert_wr_en_x0 <= convert_wr_en_dout_net_x0;
  data_out <= extract_parity_b_net_x1;

  convert_address: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 32,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x349,
      clk => clk_1_sg_x349,
      clr => '0',
      din => delay61_q_net_x0,
      en => "1",
      dout => convert_address_dout_net_x0
    );

  convert_be: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 8,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 8,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x349,
      clk => clk_1_sg_x349,
      clr => '0',
      din => delay60_q_net_x0,
      en => "1",
      dout => convert_be_dout_net_x0
    );

  convert_data_in: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 72,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 72,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x349,
      clk => clk_1_sg_x349,
      clr => '0',
      din => insert_parity_b_net,
      en => "1",
      dout => convert_data_in_dout_net_x0
    );

  convert_data_in1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 72,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 72,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x349,
      clk => clk_1_sg_x349,
      clr => '0',
      din => delay62_q_net_x0,
      en => "1",
      dout => convert_data_in1_dout_net
    );

  convert_rd_en: entity work.xlconvert
    generic map (
      bool_conversion => 1,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x349,
      clk => clk_1_sg_x349,
      clr => '0',
      din(0) => delay58_q_net_x0,
      en => "1",
      dout(0) => convert_rd_en_dout_net_x0
    );

  convert_wr_en: entity work.xlconvert
    generic map (
      bool_conversion => 1,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x349,
      clk => clk_1_sg_x349,
      clr => '0',
      din(0) => delay59_q_net_x0,
      en => "1",
      dout(0) => convert_wr_en_dout_net_x0
    );

  extract_parity: entity work.bitbasher_7f79f7d703
    port map (
      a => force_data_out_output_port_net,
      ce => '0',
      clk => '0',
      clr => '0',
      b => extract_parity_b_net_x1
    );

  force_data_out: entity work.reinterpret_8b4279cdc5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => darkquad29_dds_lut_qdr1_data_out_net_x0,
      output_port => force_data_out_output_port_net
    );

  insert_parity: entity work.bitbasher_34778e1824
    port map (
      a => convert_data_in1_dout_net,
      ce => '0',
      clk => '0',
      clr => '0',
      b => insert_parity_b_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/dds_lut/qdr2"

entity qdr2_entity_0b1e7f1358 is
  port (
    address: in std_logic_vector(31 downto 0); 
    be: in std_logic_vector(7 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    darkquad29_dds_lut_qdr2_data_out: in std_logic_vector(71 downto 0); 
    data_in: in std_logic_vector(71 downto 0); 
    rd_en: in std_logic; 
    wr_en: in std_logic; 
    convert_address_x0: out std_logic_vector(31 downto 0); 
    convert_be_x0: out std_logic_vector(7 downto 0); 
    convert_data_in_x0: out std_logic_vector(71 downto 0); 
    convert_rd_en_x0: out std_logic; 
    convert_wr_en_x0: out std_logic; 
    data_out: out std_logic_vector(71 downto 0)
  );
end qdr2_entity_0b1e7f1358;

architecture structural of qdr2_entity_0b1e7f1358 is
  signal ce_1_sg_x350: std_logic;
  signal clk_1_sg_x350: std_logic;
  signal convert_address_dout_net_x0: std_logic_vector(31 downto 0);
  signal convert_be_dout_net_x0: std_logic_vector(7 downto 0);
  signal convert_data_in1_dout_net: std_logic_vector(71 downto 0);
  signal convert_data_in_dout_net_x0: std_logic_vector(71 downto 0);
  signal convert_rd_en_dout_net_x0: std_logic;
  signal convert_wr_en_dout_net_x0: std_logic;
  signal darkquad29_dds_lut_qdr2_data_out_net_x0: std_logic_vector(71 downto 0);
  signal delay63_q_net_x0: std_logic;
  signal delay64_q_net_x0: std_logic;
  signal delay65_q_net_x0: std_logic_vector(7 downto 0);
  signal delay66_q_net_x0: std_logic_vector(31 downto 0);
  signal delay67_q_net_x0: std_logic_vector(71 downto 0);
  signal extract_parity_b_net_x1: std_logic_vector(71 downto 0);
  signal force_data_out_output_port_net: std_logic_vector(71 downto 0);
  signal insert_parity_b_net: std_logic_vector(71 downto 0);

begin
  delay66_q_net_x0 <= address;
  delay65_q_net_x0 <= be;
  ce_1_sg_x350 <= ce_1;
  clk_1_sg_x350 <= clk_1;
  darkquad29_dds_lut_qdr2_data_out_net_x0 <= darkquad29_dds_lut_qdr2_data_out;
  delay67_q_net_x0 <= data_in;
  delay63_q_net_x0 <= rd_en;
  delay64_q_net_x0 <= wr_en;
  convert_address_x0 <= convert_address_dout_net_x0;
  convert_be_x0 <= convert_be_dout_net_x0;
  convert_data_in_x0 <= convert_data_in_dout_net_x0;
  convert_rd_en_x0 <= convert_rd_en_dout_net_x0;
  convert_wr_en_x0 <= convert_wr_en_dout_net_x0;
  data_out <= extract_parity_b_net_x1;

  convert_address: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 32,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x350,
      clk => clk_1_sg_x350,
      clr => '0',
      din => delay66_q_net_x0,
      en => "1",
      dout => convert_address_dout_net_x0
    );

  convert_be: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 8,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 8,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x350,
      clk => clk_1_sg_x350,
      clr => '0',
      din => delay65_q_net_x0,
      en => "1",
      dout => convert_be_dout_net_x0
    );

  convert_data_in: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 72,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 72,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x350,
      clk => clk_1_sg_x350,
      clr => '0',
      din => insert_parity_b_net,
      en => "1",
      dout => convert_data_in_dout_net_x0
    );

  convert_data_in1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 72,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 72,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x350,
      clk => clk_1_sg_x350,
      clr => '0',
      din => delay67_q_net_x0,
      en => "1",
      dout => convert_data_in1_dout_net
    );

  convert_rd_en: entity work.xlconvert
    generic map (
      bool_conversion => 1,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x350,
      clk => clk_1_sg_x350,
      clr => '0',
      din(0) => delay63_q_net_x0,
      en => "1",
      dout(0) => convert_rd_en_dout_net_x0
    );

  convert_wr_en: entity work.xlconvert
    generic map (
      bool_conversion => 1,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x350,
      clk => clk_1_sg_x350,
      clr => '0',
      din(0) => delay64_q_net_x0,
      en => "1",
      dout(0) => convert_wr_en_dout_net_x0
    );

  extract_parity: entity work.bitbasher_7f79f7d703
    port map (
      a => force_data_out_output_port_net,
      ce => '0',
      clk => '0',
      clr => '0',
      b => extract_parity_b_net_x1
    );

  force_data_out: entity work.reinterpret_8b4279cdc5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => darkquad29_dds_lut_qdr2_data_out_net_x0,
      output_port => force_data_out_output_port_net
    );

  insert_parity: entity work.bitbasher_34778e1824
    port map (
      a => convert_data_in1_dout_net,
      ce => '0',
      clk => '0',
      clr => '0',
      b => insert_parity_b_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/dds_lut/qdr3"

entity qdr3_entity_9e06afc007 is
  port (
    address: in std_logic_vector(31 downto 0); 
    be: in std_logic_vector(7 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    darkquad29_dds_lut_qdr3_data_out: in std_logic_vector(71 downto 0); 
    data_in: in std_logic_vector(71 downto 0); 
    rd_en: in std_logic; 
    wr_en: in std_logic; 
    convert_address_x0: out std_logic_vector(31 downto 0); 
    convert_be_x0: out std_logic_vector(7 downto 0); 
    convert_data_in_x0: out std_logic_vector(71 downto 0); 
    convert_rd_en_x0: out std_logic; 
    convert_wr_en_x0: out std_logic; 
    data_out: out std_logic_vector(71 downto 0)
  );
end qdr3_entity_9e06afc007;

architecture structural of qdr3_entity_9e06afc007 is
  signal ce_1_sg_x351: std_logic;
  signal clk_1_sg_x351: std_logic;
  signal convert_address_dout_net_x0: std_logic_vector(31 downto 0);
  signal convert_be_dout_net_x0: std_logic_vector(7 downto 0);
  signal convert_data_in1_dout_net: std_logic_vector(71 downto 0);
  signal convert_data_in_dout_net_x0: std_logic_vector(71 downto 0);
  signal convert_rd_en_dout_net_x0: std_logic;
  signal convert_wr_en_dout_net_x0: std_logic;
  signal darkquad29_dds_lut_qdr3_data_out_net_x0: std_logic_vector(71 downto 0);
  signal delay68_q_net_x0: std_logic;
  signal delay69_q_net_x0: std_logic;
  signal delay70_q_net_x0: std_logic_vector(7 downto 0);
  signal delay71_q_net_x0: std_logic_vector(31 downto 0);
  signal delay93_q_net_x0: std_logic_vector(71 downto 0);
  signal extract_parity_b_net_x1: std_logic_vector(71 downto 0);
  signal force_data_out_output_port_net: std_logic_vector(71 downto 0);
  signal insert_parity_b_net: std_logic_vector(71 downto 0);

begin
  delay71_q_net_x0 <= address;
  delay70_q_net_x0 <= be;
  ce_1_sg_x351 <= ce_1;
  clk_1_sg_x351 <= clk_1;
  darkquad29_dds_lut_qdr3_data_out_net_x0 <= darkquad29_dds_lut_qdr3_data_out;
  delay93_q_net_x0 <= data_in;
  delay68_q_net_x0 <= rd_en;
  delay69_q_net_x0 <= wr_en;
  convert_address_x0 <= convert_address_dout_net_x0;
  convert_be_x0 <= convert_be_dout_net_x0;
  convert_data_in_x0 <= convert_data_in_dout_net_x0;
  convert_rd_en_x0 <= convert_rd_en_dout_net_x0;
  convert_wr_en_x0 <= convert_wr_en_dout_net_x0;
  data_out <= extract_parity_b_net_x1;

  convert_address: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 32,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x351,
      clk => clk_1_sg_x351,
      clr => '0',
      din => delay71_q_net_x0,
      en => "1",
      dout => convert_address_dout_net_x0
    );

  convert_be: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 8,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 8,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x351,
      clk => clk_1_sg_x351,
      clr => '0',
      din => delay70_q_net_x0,
      en => "1",
      dout => convert_be_dout_net_x0
    );

  convert_data_in: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 72,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 72,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x351,
      clk => clk_1_sg_x351,
      clr => '0',
      din => insert_parity_b_net,
      en => "1",
      dout => convert_data_in_dout_net_x0
    );

  convert_data_in1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 72,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 72,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x351,
      clk => clk_1_sg_x351,
      clr => '0',
      din => delay93_q_net_x0,
      en => "1",
      dout => convert_data_in1_dout_net
    );

  convert_rd_en: entity work.xlconvert
    generic map (
      bool_conversion => 1,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x351,
      clk => clk_1_sg_x351,
      clr => '0',
      din(0) => delay68_q_net_x0,
      en => "1",
      dout(0) => convert_rd_en_dout_net_x0
    );

  convert_wr_en: entity work.xlconvert
    generic map (
      bool_conversion => 1,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x351,
      clk => clk_1_sg_x351,
      clr => '0',
      din(0) => delay69_q_net_x0,
      en => "1",
      dout(0) => convert_wr_en_dout_net_x0
    );

  extract_parity: entity work.bitbasher_7f79f7d703
    port map (
      a => force_data_out_output_port_net,
      ce => '0',
      clk => '0',
      clr => '0',
      b => extract_parity_b_net_x1
    );

  force_data_out: entity work.reinterpret_8b4279cdc5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => darkquad29_dds_lut_qdr3_data_out_net_x0,
      output_port => force_data_out_output_port_net
    );

  insert_parity: entity work.bitbasher_34778e1824
    port map (
      a => convert_data_in1_dout_net,
      ce => '0',
      clk => '0',
      clr => '0',
      b => insert_parity_b_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/dds_lut/run"

entity run_entity_99b17bb860 is
  port (
    darkquad29_dds_lut_run_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end run_entity_99b17bb860;

architecture structural of run_entity_99b17bb860 is
  signal darkquad29_dds_lut_run_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_dds_lut_run_user_data_out_net_x0 <= darkquad29_dds_lut_run_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_dds_lut_run_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/dds_lut"

entity dds_lut_entity_798e2870b3 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    darkquad29_dds_lut_qdr0_data_out: in std_logic_vector(71 downto 0); 
    darkquad29_dds_lut_qdr1_data_out: in std_logic_vector(71 downto 0); 
    darkquad29_dds_lut_qdr2_data_out: in std_logic_vector(71 downto 0); 
    darkquad29_dds_lut_qdr3_data_out: in std_logic_vector(71 downto 0); 
    darkquad29_dds_lut_run_user_data_out: in std_logic_vector(31 downto 0); 
    start: in std_logic; 
    ctr_out: out std_logic_vector(19 downto 0); 
    dds0: out std_logic_vector(63 downto 0); 
    dds1: out std_logic_vector(63 downto 0); 
    dds2: out std_logic_vector(63 downto 0); 
    dds3: out std_logic_vector(63 downto 0); 
    qdr0: out std_logic_vector(31 downto 0); 
    qdr0_x0: out std_logic_vector(7 downto 0); 
    qdr0_x1: out std_logic_vector(71 downto 0); 
    qdr0_x2: out std_logic; 
    qdr0_x3: out std_logic; 
    qdr1: out std_logic_vector(31 downto 0); 
    qdr1_x0: out std_logic_vector(7 downto 0); 
    qdr1_x1: out std_logic_vector(71 downto 0); 
    qdr1_x2: out std_logic; 
    qdr1_x3: out std_logic; 
    qdr2: out std_logic_vector(31 downto 0); 
    qdr2_x0: out std_logic_vector(7 downto 0); 
    qdr2_x1: out std_logic_vector(71 downto 0); 
    qdr2_x2: out std_logic; 
    qdr2_x3: out std_logic; 
    qdr3: out std_logic_vector(31 downto 0); 
    qdr3_x0: out std_logic_vector(7 downto 0); 
    qdr3_x1: out std_logic_vector(71 downto 0); 
    qdr3_x2: out std_logic; 
    qdr3_x3: out std_logic
  );
end dds_lut_entity_798e2870b3;

architecture structural of dds_lut_entity_798e2870b3 is
  signal addr_ctr_op_net: std_logic_vector(19 downto 0);
  signal ce_1_sg_x352: std_logic;
  signal clk_1_sg_x352: std_logic;
  signal constant1_op_net: std_logic;
  signal constant3_op_net: std_logic_vector(7 downto 0);
  signal constant8_op_net: std_logic;
  signal convert1_dout_net: std_logic_vector(71 downto 0);
  signal convert2_dout_net: std_logic_vector(31 downto 0);
  signal convert3_dout_net_x1: std_logic_vector(63 downto 0);
  signal convert4_dout_net_x1: std_logic_vector(63 downto 0);
  signal convert6_dout_net_x1: std_logic_vector(63 downto 0);
  signal convert9_dout_net_x1: std_logic_vector(63 downto 0);
  signal convert_address_dout_net_x4: std_logic_vector(31 downto 0);
  signal convert_address_dout_net_x5: std_logic_vector(31 downto 0);
  signal convert_address_dout_net_x6: std_logic_vector(31 downto 0);
  signal convert_address_dout_net_x7: std_logic_vector(31 downto 0);
  signal convert_be_dout_net_x4: std_logic_vector(7 downto 0);
  signal convert_be_dout_net_x5: std_logic_vector(7 downto 0);
  signal convert_be_dout_net_x6: std_logic_vector(7 downto 0);
  signal convert_be_dout_net_x7: std_logic_vector(7 downto 0);
  signal convert_data_in_dout_net_x4: std_logic_vector(71 downto 0);
  signal convert_data_in_dout_net_x5: std_logic_vector(71 downto 0);
  signal convert_data_in_dout_net_x6: std_logic_vector(71 downto 0);
  signal convert_data_in_dout_net_x7: std_logic_vector(71 downto 0);
  signal convert_rd_en_dout_net_x4: std_logic;
  signal convert_rd_en_dout_net_x5: std_logic;
  signal convert_rd_en_dout_net_x6: std_logic;
  signal convert_rd_en_dout_net_x7: std_logic;
  signal convert_wr_en_dout_net_x4: std_logic;
  signal convert_wr_en_dout_net_x5: std_logic;
  signal convert_wr_en_dout_net_x6: std_logic;
  signal convert_wr_en_dout_net_x7: std_logic;
  signal darkquad29_dds_lut_qdr0_data_out_net_x1: std_logic_vector(71 downto 0);
  signal darkquad29_dds_lut_qdr1_data_out_net_x1: std_logic_vector(71 downto 0);
  signal darkquad29_dds_lut_qdr2_data_out_net_x1: std_logic_vector(71 downto 0);
  signal darkquad29_dds_lut_qdr3_data_out_net_x1: std_logic_vector(71 downto 0);
  signal darkquad29_dds_lut_run_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal delay14_q_net: std_logic_vector(19 downto 0);
  signal delay27_q_net: std_logic_vector(31 downto 0);
  signal delay48_q_net: std_logic_vector(19 downto 0);
  signal delay4_q_net: std_logic_vector(19 downto 0);
  signal delay53_q_net_x0: std_logic;
  signal delay54_q_net_x0: std_logic;
  signal delay55_q_net_x0: std_logic_vector(7 downto 0);
  signal delay56_q_net_x0: std_logic_vector(31 downto 0);
  signal delay57_q_net_x0: std_logic_vector(71 downto 0);
  signal delay58_q_net_x0: std_logic;
  signal delay59_q_net_x0: std_logic;
  signal delay60_q_net_x0: std_logic_vector(7 downto 0);
  signal delay61_q_net_x0: std_logic_vector(31 downto 0);
  signal delay62_q_net_x0: std_logic_vector(71 downto 0);
  signal delay63_q_net_x0: std_logic;
  signal delay64_q_net_x0: std_logic;
  signal delay65_q_net_x0: std_logic_vector(7 downto 0);
  signal delay66_q_net_x0: std_logic_vector(31 downto 0);
  signal delay67_q_net_x0: std_logic_vector(71 downto 0);
  signal delay68_q_net_x0: std_logic;
  signal delay69_q_net_x0: std_logic;
  signal delay70_q_net_x0: std_logic_vector(7 downto 0);
  signal delay71_q_net_x0: std_logic_vector(31 downto 0);
  signal delay76_q_net_x1: std_logic_vector(19 downto 0);
  signal delay92_q_net: std_logic_vector(71 downto 0);
  signal delay93_q_net_x0: std_logic_vector(71 downto 0);
  signal edge_op_y_net_x0: std_logic;
  signal en1_y_net: std_logic;
  signal en2_y_net: std_logic;
  signal en3_y_net: std_logic_vector(18 downto 0);
  signal en4_y_net_x0: std_logic;
  signal extract_parity_b_net_x1: std_logic_vector(71 downto 0);
  signal extract_parity_b_net_x2: std_logic_vector(71 downto 0);
  signal extract_parity_b_net_x3: std_logic_vector(71 downto 0);
  signal extract_parity_b_net_x4: std_logic_vector(71 downto 0);
  signal inverter1_op_net: std_logic;
  signal logical_y_net: std_logic;
  signal register0_q_net_x0: std_logic;
  signal register1_q_net: std_logic;
  signal register1_q_net_x0: std_logic_vector(71 downto 0);
  signal register1_q_net_x1: std_logic_vector(71 downto 0);
  signal register1_q_net_x2: std_logic_vector(71 downto 0);
  signal register1_q_net_x3: std_logic_vector(71 downto 0);
  signal register1_q_net_x38: std_logic;
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);

begin
  ce_1_sg_x352 <= ce_1;
  clk_1_sg_x352 <= clk_1;
  darkquad29_dds_lut_qdr0_data_out_net_x1 <= darkquad29_dds_lut_qdr0_data_out;
  darkquad29_dds_lut_qdr1_data_out_net_x1 <= darkquad29_dds_lut_qdr1_data_out;
  darkquad29_dds_lut_qdr2_data_out_net_x1 <= darkquad29_dds_lut_qdr2_data_out;
  darkquad29_dds_lut_qdr3_data_out_net_x1 <= darkquad29_dds_lut_qdr3_data_out;
  darkquad29_dds_lut_run_user_data_out_net_x1 <= darkquad29_dds_lut_run_user_data_out;
  register1_q_net_x38 <= start;
  ctr_out <= delay76_q_net_x1;
  dds0 <= convert9_dout_net_x1;
  dds1 <= convert3_dout_net_x1;
  dds2 <= convert4_dout_net_x1;
  dds3 <= convert6_dout_net_x1;
  qdr0 <= convert_address_dout_net_x4;
  qdr0_x0 <= convert_be_dout_net_x4;
  qdr0_x1 <= convert_data_in_dout_net_x4;
  qdr0_x2 <= convert_rd_en_dout_net_x4;
  qdr0_x3 <= convert_wr_en_dout_net_x4;
  qdr1 <= convert_address_dout_net_x5;
  qdr1_x0 <= convert_be_dout_net_x5;
  qdr1_x1 <= convert_data_in_dout_net_x5;
  qdr1_x2 <= convert_rd_en_dout_net_x5;
  qdr1_x3 <= convert_wr_en_dout_net_x5;
  qdr2 <= convert_address_dout_net_x6;
  qdr2_x0 <= convert_be_dout_net_x6;
  qdr2_x1 <= convert_data_in_dout_net_x6;
  qdr2_x2 <= convert_rd_en_dout_net_x6;
  qdr2_x3 <= convert_wr_en_dout_net_x6;
  qdr3 <= convert_address_dout_net_x7;
  qdr3_x0 <= convert_be_dout_net_x7;
  qdr3_x1 <= convert_data_in_dout_net_x7;
  qdr3_x2 <= convert_rd_en_dout_net_x7;
  qdr3_x3 <= convert_wr_en_dout_net_x7;

  addr_ctr: entity work.xlcounter_free_darkquad29
    generic map (
      core_name0 => "cntr_11_0_ed5c08cc07bca813",
      op_arith => xlUnsigned,
      op_width => 20
    )
    port map (
      ce => ce_1_sg_x352,
      clk => clk_1_sg_x352,
      clr => '0',
      en => "1",
      rst(0) => edge_op_y_net_x0,
      op => addr_ctr_op_net
    );

  constant1: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant1_op_net
    );

  constant3: entity work.constant_19562ab42f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant3_op_net
    );

  constant8: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant8_op_net
    );

  convert1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 72,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x352,
      clk => clk_1_sg_x352,
      clr => '0',
      din(0) => constant8_op_net,
      en => "1",
      dout => convert1_dout_net
    );

  convert2: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 19,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x352,
      clk => clk_1_sg_x352,
      clr => '0',
      din => en3_y_net,
      en => "1",
      dout => convert2_dout_net
    );

  convert3: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 72,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 64,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x352,
      clk => clk_1_sg_x352,
      clr => '0',
      din => register1_q_net_x0,
      en => "1",
      dout => convert3_dout_net_x1
    );

  convert4: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 72,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 64,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x352,
      clk => clk_1_sg_x352,
      clr => '0',
      din => register1_q_net_x2,
      en => "1",
      dout => convert4_dout_net_x1
    );

  convert6: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 72,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 64,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x352,
      clk => clk_1_sg_x352,
      clr => '0',
      din => register1_q_net_x3,
      en => "1",
      dout => convert6_dout_net_x1
    );

  convert9: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 72,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 64,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x352,
      clk => clk_1_sg_x352,
      clr => '0',
      din => register1_q_net_x1,
      en => "1",
      dout => convert9_dout_net_x1
    );

  delay14: entity work.xldelay
    generic map (
      latency => 10,
      reg_retiming => 0,
      reset => 0,
      width => 20
    )
    port map (
      ce => ce_1_sg_x352,
      clk => clk_1_sg_x352,
      d => delay48_q_net,
      en => '1',
      rst => '1',
      q => delay14_q_net
    );

  delay27: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 32
    )
    port map (
      ce => ce_1_sg_x352,
      clk => clk_1_sg_x352,
      d => convert2_dout_net,
      en => '1',
      rst => '1',
      q => delay27_q_net
    );

  delay4: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 20
    )
    port map (
      ce => ce_1_sg_x352,
      clk => clk_1_sg_x352,
      d => addr_ctr_op_net,
      en => '1',
      rst => '1',
      q => delay4_q_net
    );

  delay48: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 20
    )
    port map (
      ce => ce_1_sg_x352,
      clk => clk_1_sg_x352,
      d => delay4_q_net,
      en => '1',
      rst => '1',
      q => delay48_q_net
    );

  delay53: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x352,
      clk => clk_1_sg_x352,
      d(0) => register1_q_net,
      en => '1',
      rst => '1',
      q(0) => delay53_q_net_x0
    );

  delay54: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x352,
      clk => clk_1_sg_x352,
      d(0) => constant1_op_net,
      en => '1',
      rst => '1',
      q(0) => delay54_q_net_x0
    );

  delay55: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x352,
      clk => clk_1_sg_x352,
      d => constant3_op_net,
      en => '1',
      rst => '1',
      q => delay55_q_net_x0
    );

  delay56: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 32
    )
    port map (
      ce => ce_1_sg_x352,
      clk => clk_1_sg_x352,
      d => delay27_q_net,
      en => '1',
      rst => '1',
      q => delay56_q_net_x0
    );

  delay57: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 72
    )
    port map (
      ce => ce_1_sg_x352,
      clk => clk_1_sg_x352,
      d => delay92_q_net,
      en => '1',
      rst => '1',
      q => delay57_q_net_x0
    );

  delay58: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x352,
      clk => clk_1_sg_x352,
      d(0) => register1_q_net,
      en => '1',
      rst => '1',
      q(0) => delay58_q_net_x0
    );

  delay59: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x352,
      clk => clk_1_sg_x352,
      d(0) => constant1_op_net,
      en => '1',
      rst => '1',
      q(0) => delay59_q_net_x0
    );

  delay60: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x352,
      clk => clk_1_sg_x352,
      d => constant3_op_net,
      en => '1',
      rst => '1',
      q => delay60_q_net_x0
    );

  delay61: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 32
    )
    port map (
      ce => ce_1_sg_x352,
      clk => clk_1_sg_x352,
      d => delay27_q_net,
      en => '1',
      rst => '1',
      q => delay61_q_net_x0
    );

  delay62: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 72
    )
    port map (
      ce => ce_1_sg_x352,
      clk => clk_1_sg_x352,
      d => delay92_q_net,
      en => '1',
      rst => '1',
      q => delay62_q_net_x0
    );

  delay63: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x352,
      clk => clk_1_sg_x352,
      d(0) => register1_q_net,
      en => '1',
      rst => '1',
      q(0) => delay63_q_net_x0
    );

  delay64: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x352,
      clk => clk_1_sg_x352,
      d(0) => constant1_op_net,
      en => '1',
      rst => '1',
      q(0) => delay64_q_net_x0
    );

  delay65: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x352,
      clk => clk_1_sg_x352,
      d => constant3_op_net,
      en => '1',
      rst => '1',
      q => delay65_q_net_x0
    );

  delay66: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 32
    )
    port map (
      ce => ce_1_sg_x352,
      clk => clk_1_sg_x352,
      d => delay27_q_net,
      en => '1',
      rst => '1',
      q => delay66_q_net_x0
    );

  delay67: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 72
    )
    port map (
      ce => ce_1_sg_x352,
      clk => clk_1_sg_x352,
      d => delay92_q_net,
      en => '1',
      rst => '1',
      q => delay67_q_net_x0
    );

  delay68: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x352,
      clk => clk_1_sg_x352,
      d(0) => register1_q_net,
      en => '1',
      rst => '1',
      q(0) => delay68_q_net_x0
    );

  delay69: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x352,
      clk => clk_1_sg_x352,
      d(0) => constant1_op_net,
      en => '1',
      rst => '1',
      q(0) => delay69_q_net_x0
    );

  delay70: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x352,
      clk => clk_1_sg_x352,
      d => constant3_op_net,
      en => '1',
      rst => '1',
      q => delay70_q_net_x0
    );

  delay71: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 32
    )
    port map (
      ce => ce_1_sg_x352,
      clk => clk_1_sg_x352,
      d => delay27_q_net,
      en => '1',
      rst => '1',
      q => delay71_q_net_x0
    );

  delay76: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 20
    )
    port map (
      ce => ce_1_sg_x352,
      clk => clk_1_sg_x352,
      d => delay14_q_net,
      en => '1',
      rst => '1',
      q => delay76_q_net_x1
    );

  delay92: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 72
    )
    port map (
      ce => ce_1_sg_x352,
      clk => clk_1_sg_x352,
      d => convert1_dout_net,
      en => '1',
      rst => '1',
      q => delay92_q_net
    );

  delay93: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 72
    )
    port map (
      ce => ce_1_sg_x352,
      clk => clk_1_sg_x352,
      d => delay92_q_net,
      en => '1',
      rst => '1',
      q => delay93_q_net_x0
    );

  edge_detect_7ff7f1bda4: entity work.edge_detect3_entity_2efb246ca9
    port map (
      ce_1 => ce_1_sg_x352,
      clk_1 => clk_1_sg_x352,
      in_x0 => register1_q_net_x38,
      out_x0 => edge_op_y_net_x0
    );

  en1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 1,
      y_width => 1
    )
    port map (
      x(0) => logical_y_net,
      y(0) => en1_y_net
    );

  en2: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 20,
      y_width => 1
    )
    port map (
      x => addr_ctr_op_net,
      y(0) => en2_y_net
    );

  en3: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 19,
      x_width => 20,
      y_width => 19
    )
    port map (
      x => addr_ctr_op_net,
      y => en3_y_net
    );

  en4: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => reint1_output_port_net_x0,
      y(0) => en4_y_net_x0
    );

  inverter1: entity work.inverter_e5b38cca3b
    port map (
      ce => ce_1_sg_x352,
      clk => clk_1_sg_x352,
      clr => '0',
      ip(0) => en2_y_net,
      op(0) => inverter1_op_net
    );

  logical: entity work.logical_799f62af22
    port map (
      ce => ce_1_sg_x352,
      clk => clk_1_sg_x352,
      clr => '0',
      d0(0) => register1_q_net_x38,
      d1(0) => register0_q_net_x0,
      y(0) => logical_y_net
    );

  pipeline18_06393be982: entity work.pipeline1_entity_f892c55246
    port map (
      ce_1 => ce_1_sg_x352,
      clk_1 => clk_1_sg_x352,
      d => extract_parity_b_net_x1,
      q => register1_q_net_x1
    );

  pipeline1_f892c55246: entity work.pipeline1_entity_f892c55246
    port map (
      ce_1 => ce_1_sg_x352,
      clk_1 => clk_1_sg_x352,
      d => extract_parity_b_net_x2,
      q => register1_q_net_x0
    );

  pipeline2_caa070de40: entity work.pipeline1_entity_f892c55246
    port map (
      ce_1 => ce_1_sg_x352,
      clk_1 => clk_1_sg_x352,
      d => extract_parity_b_net_x3,
      q => register1_q_net_x2
    );

  pipeline3_eae21c9da4: entity work.pipeline1_entity_f892c55246
    port map (
      ce_1 => ce_1_sg_x352,
      clk_1 => clk_1_sg_x352,
      d => extract_parity_b_net_x4,
      q => register1_q_net_x3
    );

  pipeline4_848179cf5c: entity work.pipeline35_entity_0c537af9bd
    port map (
      ce_1 => ce_1_sg_x352,
      clk_1 => clk_1_sg_x352,
      d => en4_y_net_x0,
      q => register0_q_net_x0
    );

  qdr0_d9a3f7c3d9: entity work.qdr0_entity_d9a3f7c3d9
    port map (
      address => delay56_q_net_x0,
      be => delay55_q_net_x0,
      ce_1 => ce_1_sg_x352,
      clk_1 => clk_1_sg_x352,
      darkquad29_dds_lut_qdr0_data_out => darkquad29_dds_lut_qdr0_data_out_net_x1,
      data_in => delay57_q_net_x0,
      rd_en => delay53_q_net_x0,
      wr_en => delay54_q_net_x0,
      convert_address_x0 => convert_address_dout_net_x4,
      convert_be_x0 => convert_be_dout_net_x4,
      convert_data_in_x0 => convert_data_in_dout_net_x4,
      convert_rd_en_x0 => convert_rd_en_dout_net_x4,
      convert_wr_en_x0 => convert_wr_en_dout_net_x4,
      data_out => extract_parity_b_net_x1
    );

  qdr1_6eb00c7834: entity work.qdr1_entity_6eb00c7834
    port map (
      address => delay61_q_net_x0,
      be => delay60_q_net_x0,
      ce_1 => ce_1_sg_x352,
      clk_1 => clk_1_sg_x352,
      darkquad29_dds_lut_qdr1_data_out => darkquad29_dds_lut_qdr1_data_out_net_x1,
      data_in => delay62_q_net_x0,
      rd_en => delay58_q_net_x0,
      wr_en => delay59_q_net_x0,
      convert_address_x0 => convert_address_dout_net_x5,
      convert_be_x0 => convert_be_dout_net_x5,
      convert_data_in_x0 => convert_data_in_dout_net_x5,
      convert_rd_en_x0 => convert_rd_en_dout_net_x5,
      convert_wr_en_x0 => convert_wr_en_dout_net_x5,
      data_out => extract_parity_b_net_x2
    );

  qdr2_0b1e7f1358: entity work.qdr2_entity_0b1e7f1358
    port map (
      address => delay66_q_net_x0,
      be => delay65_q_net_x0,
      ce_1 => ce_1_sg_x352,
      clk_1 => clk_1_sg_x352,
      darkquad29_dds_lut_qdr2_data_out => darkquad29_dds_lut_qdr2_data_out_net_x1,
      data_in => delay67_q_net_x0,
      rd_en => delay63_q_net_x0,
      wr_en => delay64_q_net_x0,
      convert_address_x0 => convert_address_dout_net_x6,
      convert_be_x0 => convert_be_dout_net_x6,
      convert_data_in_x0 => convert_data_in_dout_net_x6,
      convert_rd_en_x0 => convert_rd_en_dout_net_x6,
      convert_wr_en_x0 => convert_wr_en_dout_net_x6,
      data_out => extract_parity_b_net_x3
    );

  qdr3_9e06afc007: entity work.qdr3_entity_9e06afc007
    port map (
      address => delay71_q_net_x0,
      be => delay70_q_net_x0,
      ce_1 => ce_1_sg_x352,
      clk_1 => clk_1_sg_x352,
      darkquad29_dds_lut_qdr3_data_out => darkquad29_dds_lut_qdr3_data_out_net_x1,
      data_in => delay93_q_net_x0,
      rd_en => delay68_q_net_x0,
      wr_en => delay69_q_net_x0,
      convert_address_x0 => convert_address_dout_net_x7,
      convert_be_x0 => convert_be_dout_net_x7,
      convert_data_in_x0 => convert_data_in_dout_net_x7,
      convert_rd_en_x0 => convert_rd_en_dout_net_x7,
      convert_wr_en_x0 => convert_wr_en_dout_net_x7,
      data_out => extract_parity_b_net_x4
    );

  register1: entity work.xlregister
    generic map (
      d_width => 1,
      init_value => b"0"
    )
    port map (
      ce => ce_1_sg_x352,
      clk => clk_1_sg_x352,
      d(0) => en1_y_net,
      en(0) => inverter1_op_net,
      rst => "0",
      q(0) => register1_q_net
    );

  run_99b17bb860: entity work.run_entity_99b17bb860
    port map (
      darkquad29_dds_lut_run_user_data_out => darkquad29_dds_lut_run_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/dds_shift"

entity dds_shift_entity_45e6bf424b is
  port (
    darkquad29_dds_shift_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end dds_shift_entity_45e6bf424b;

architecture structural of dds_shift_entity_45e6bf424b is
  signal darkquad29_dds_shift_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_dds_shift_user_data_out_net_x0 <= darkquad29_dds_shift_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_dds_shift_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/downsample0/bus_expand3"

entity bus_expand3_entity_6f3d297a6d is
  port (
    bus_in: in std_logic_vector(75 downto 0); 
    lsb_out1: out std_logic_vector(37 downto 0); 
    msb_out2: out std_logic_vector(37 downto 0)
  );
end bus_expand3_entity_6f3d297a6d;

architecture structural of bus_expand3_entity_6f3d297a6d is
  signal delay50_q_net_x0: std_logic_vector(75 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(37 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(37 downto 0);
  signal slice1_y_net: std_logic_vector(37 downto 0);
  signal slice2_y_net: std_logic_vector(37 downto 0);

begin
  delay50_q_net_x0 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x0;
  msb_out2 <= reinterpret2_output_port_net_x0;

  reinterpret1: entity work.reinterpret_1da3c4f87c
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x0
    );

  reinterpret2: entity work.reinterpret_1da3c4f87c
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret2_output_port_net_x0
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 37,
      x_width => 76,
      y_width => 38
    )
    port map (
      x => delay50_q_net_x0,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 38,
      new_msb => 75,
      x_width => 76,
      y_width => 38
    )
    port map (
      x => delay50_q_net_x0,
      y => slice2_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/downsample0/lpf_fir_i/adder_tree"

entity adder_tree_entity_08c0caf64b is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din1: in std_logic_vector(34 downto 0); 
    din10: in std_logic_vector(34 downto 0); 
    din11: in std_logic_vector(34 downto 0); 
    din12: in std_logic_vector(34 downto 0); 
    din13: in std_logic_vector(34 downto 0); 
    din14: in std_logic_vector(34 downto 0); 
    din15: in std_logic_vector(34 downto 0); 
    din16: in std_logic_vector(34 downto 0); 
    din17: in std_logic_vector(34 downto 0); 
    din18: in std_logic_vector(34 downto 0); 
    din2: in std_logic_vector(34 downto 0); 
    din3: in std_logic_vector(34 downto 0); 
    din4: in std_logic_vector(34 downto 0); 
    din5: in std_logic_vector(34 downto 0); 
    din6: in std_logic_vector(34 downto 0); 
    din7: in std_logic_vector(34 downto 0); 
    din8: in std_logic_vector(34 downto 0); 
    din9: in std_logic_vector(34 downto 0); 
    dout: out std_logic_vector(39 downto 0)
  );
end adder_tree_entity_08c0caf64b;

architecture structural of adder_tree_entity_08c0caf64b is
  signal addr10_s_net: std_logic_vector(36 downto 0);
  signal addr11_s_net: std_logic_vector(36 downto 0);
  signal addr12_s_net: std_logic_vector(36 downto 0);
  signal addr13_s_net: std_logic_vector(36 downto 0);
  signal addr15_s_net: std_logic_vector(37 downto 0);
  signal addr16_s_net: std_logic_vector(37 downto 0);
  signal addr18_s_net: std_logic_vector(38 downto 0);
  signal addr1_s_net: std_logic_vector(35 downto 0);
  signal addr20_s_net_x0: std_logic_vector(39 downto 0);
  signal addr2_s_net: std_logic_vector(35 downto 0);
  signal addr3_s_net: std_logic_vector(35 downto 0);
  signal addr4_s_net: std_logic_vector(35 downto 0);
  signal addr5_s_net: std_logic_vector(35 downto 0);
  signal addr6_s_net: std_logic_vector(35 downto 0);
  signal addr7_s_net: std_logic_vector(35 downto 0);
  signal addr8_s_net: std_logic_vector(35 downto 0);
  signal addr9_s_net: std_logic_vector(35 downto 0);
  signal ce_1_sg_x353: std_logic;
  signal clk_1_sg_x353: std_logic;
  signal dly14_q_net: std_logic_vector(35 downto 0);
  signal dly17_q_net: std_logic_vector(35 downto 0);
  signal dly19_q_net: std_logic_vector(35 downto 0);
  signal mult10_p_net_x0: std_logic_vector(34 downto 0);
  signal mult11_p_net_x0: std_logic_vector(34 downto 0);
  signal mult12_p_net_x0: std_logic_vector(34 downto 0);
  signal mult13_p_net_x0: std_logic_vector(34 downto 0);
  signal mult14_p_net_x0: std_logic_vector(34 downto 0);
  signal mult15_p_net_x0: std_logic_vector(34 downto 0);
  signal mult16_p_net_x0: std_logic_vector(34 downto 0);
  signal mult17_p_net_x0: std_logic_vector(34 downto 0);
  signal mult1_p_net_x0: std_logic_vector(34 downto 0);
  signal mult2_p_net_x0: std_logic_vector(34 downto 0);
  signal mult3_p_net_x0: std_logic_vector(34 downto 0);
  signal mult4_p_net_x0: std_logic_vector(34 downto 0);
  signal mult5_p_net_x0: std_logic_vector(34 downto 0);
  signal mult6_p_net_x0: std_logic_vector(34 downto 0);
  signal mult7_p_net_x0: std_logic_vector(34 downto 0);
  signal mult8_p_net_x0: std_logic_vector(34 downto 0);
  signal mult9_p_net_x0: std_logic_vector(34 downto 0);
  signal mult_p_net_x0: std_logic_vector(34 downto 0);

begin
  ce_1_sg_x353 <= ce_1;
  clk_1_sg_x353 <= clk_1;
  mult_p_net_x0 <= din1;
  mult9_p_net_x0 <= din10;
  mult10_p_net_x0 <= din11;
  mult11_p_net_x0 <= din12;
  mult12_p_net_x0 <= din13;
  mult13_p_net_x0 <= din14;
  mult14_p_net_x0 <= din15;
  mult15_p_net_x0 <= din16;
  mult16_p_net_x0 <= din17;
  mult17_p_net_x0 <= din18;
  mult1_p_net_x0 <= din2;
  mult2_p_net_x0 <= din3;
  mult3_p_net_x0 <= din4;
  mult4_p_net_x0 <= din5;
  mult5_p_net_x0 <= din6;
  mult6_p_net_x0 <= din7;
  mult7_p_net_x0 <= din8;
  mult8_p_net_x0 <= din9;
  dout <= addr20_s_net_x0;

  addr1: entity work.addsub_f7543d22d5
    port map (
      a => mult_p_net_x0,
      b => mult1_p_net_x0,
      ce => ce_1_sg_x353,
      clk => clk_1_sg_x353,
      clr => '0',
      s => addr1_s_net
    );

  addr10: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 32,
      a_width => 36,
      b_arith => xlSigned,
      b_bin_pt => 32,
      b_width => 36,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 37,
      core_name0 => "addsb_11_0_f71caeff01210ab2",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 37,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 32,
      s_width => 37
    )
    port map (
      a => addr1_s_net,
      b => addr2_s_net,
      ce => ce_1_sg_x353,
      clk => clk_1_sg_x353,
      clr => '0',
      en => "1",
      s => addr10_s_net
    );

  addr11: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 32,
      a_width => 36,
      b_arith => xlSigned,
      b_bin_pt => 32,
      b_width => 36,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 37,
      core_name0 => "addsb_11_0_f71caeff01210ab2",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 37,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 32,
      s_width => 37
    )
    port map (
      a => addr3_s_net,
      b => addr4_s_net,
      ce => ce_1_sg_x353,
      clk => clk_1_sg_x353,
      clr => '0',
      en => "1",
      s => addr11_s_net
    );

  addr12: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 32,
      a_width => 36,
      b_arith => xlSigned,
      b_bin_pt => 32,
      b_width => 36,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 37,
      core_name0 => "addsb_11_0_f71caeff01210ab2",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 37,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 32,
      s_width => 37
    )
    port map (
      a => addr5_s_net,
      b => addr6_s_net,
      ce => ce_1_sg_x353,
      clk => clk_1_sg_x353,
      clr => '0',
      en => "1",
      s => addr12_s_net
    );

  addr13: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 32,
      a_width => 36,
      b_arith => xlSigned,
      b_bin_pt => 32,
      b_width => 36,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 37,
      core_name0 => "addsb_11_0_f71caeff01210ab2",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 37,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 32,
      s_width => 37
    )
    port map (
      a => addr7_s_net,
      b => addr8_s_net,
      ce => ce_1_sg_x353,
      clk => clk_1_sg_x353,
      clr => '0',
      en => "1",
      s => addr13_s_net
    );

  addr15: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 32,
      a_width => 37,
      b_arith => xlSigned,
      b_bin_pt => 32,
      b_width => 37,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 38,
      core_name0 => "addsb_11_0_07eb1c1df5a181f1",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 38,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 32,
      s_width => 38
    )
    port map (
      a => addr10_s_net,
      b => addr11_s_net,
      ce => ce_1_sg_x353,
      clk => clk_1_sg_x353,
      clr => '0',
      en => "1",
      s => addr15_s_net
    );

  addr16: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 32,
      a_width => 37,
      b_arith => xlSigned,
      b_bin_pt => 32,
      b_width => 37,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 38,
      core_name0 => "addsb_11_0_07eb1c1df5a181f1",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 38,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 32,
      s_width => 38
    )
    port map (
      a => addr12_s_net,
      b => addr13_s_net,
      ce => ce_1_sg_x353,
      clk => clk_1_sg_x353,
      clr => '0',
      en => "1",
      s => addr16_s_net
    );

  addr18: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 32,
      a_width => 38,
      b_arith => xlSigned,
      b_bin_pt => 32,
      b_width => 38,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 39,
      core_name0 => "addsb_11_0_26c38df2140ab027",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 39,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 32,
      s_width => 39
    )
    port map (
      a => addr15_s_net,
      b => addr16_s_net,
      ce => ce_1_sg_x353,
      clk => clk_1_sg_x353,
      clr => '0',
      en => "1",
      s => addr18_s_net
    );

  addr2: entity work.addsub_f7543d22d5
    port map (
      a => mult2_p_net_x0,
      b => mult3_p_net_x0,
      ce => ce_1_sg_x353,
      clk => clk_1_sg_x353,
      clr => '0',
      s => addr2_s_net
    );

  addr20: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 32,
      a_width => 39,
      b_arith => xlSigned,
      b_bin_pt => 32,
      b_width => 36,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 40,
      core_name0 => "addsb_11_0_075266d61a42e95d",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 40,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 32,
      s_width => 40
    )
    port map (
      a => addr18_s_net,
      b => dly19_q_net,
      ce => ce_1_sg_x353,
      clk => clk_1_sg_x353,
      clr => '0',
      en => "1",
      s => addr20_s_net_x0
    );

  addr3: entity work.addsub_f7543d22d5
    port map (
      a => mult4_p_net_x0,
      b => mult5_p_net_x0,
      ce => ce_1_sg_x353,
      clk => clk_1_sg_x353,
      clr => '0',
      s => addr3_s_net
    );

  addr4: entity work.addsub_f7543d22d5
    port map (
      a => mult6_p_net_x0,
      b => mult7_p_net_x0,
      ce => ce_1_sg_x353,
      clk => clk_1_sg_x353,
      clr => '0',
      s => addr4_s_net
    );

  addr5: entity work.addsub_f7543d22d5
    port map (
      a => mult8_p_net_x0,
      b => mult9_p_net_x0,
      ce => ce_1_sg_x353,
      clk => clk_1_sg_x353,
      clr => '0',
      s => addr5_s_net
    );

  addr6: entity work.addsub_f7543d22d5
    port map (
      a => mult10_p_net_x0,
      b => mult11_p_net_x0,
      ce => ce_1_sg_x353,
      clk => clk_1_sg_x353,
      clr => '0',
      s => addr6_s_net
    );

  addr7: entity work.addsub_f7543d22d5
    port map (
      a => mult12_p_net_x0,
      b => mult13_p_net_x0,
      ce => ce_1_sg_x353,
      clk => clk_1_sg_x353,
      clr => '0',
      s => addr7_s_net
    );

  addr8: entity work.addsub_f7543d22d5
    port map (
      a => mult14_p_net_x0,
      b => mult15_p_net_x0,
      ce => ce_1_sg_x353,
      clk => clk_1_sg_x353,
      clr => '0',
      s => addr8_s_net
    );

  addr9: entity work.addsub_f7543d22d5
    port map (
      a => mult16_p_net_x0,
      b => mult17_p_net_x0,
      ce => ce_1_sg_x353,
      clk => clk_1_sg_x353,
      clr => '0',
      s => addr9_s_net
    );

  dly14: entity work.delay_4b00a70dea
    port map (
      ce => ce_1_sg_x353,
      clk => clk_1_sg_x353,
      clr => '0',
      d => addr9_s_net,
      q => dly14_q_net
    );

  dly17: entity work.delay_4b00a70dea
    port map (
      ce => ce_1_sg_x353,
      clk => clk_1_sg_x353,
      clr => '0',
      d => dly14_q_net,
      q => dly17_q_net
    );

  dly19: entity work.delay_4b00a70dea
    port map (
      ce => ce_1_sg_x353,
      clk => clk_1_sg_x353,
      clr => '0',
      d => dly17_q_net,
      q => dly19_q_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/downsample0/lpf_fir_i/delay_bram1"

entity delay_bram1_entity_c8aa799401 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(18 downto 0); 
    dout: out std_logic_vector(18 downto 0)
  );
end delay_bram1_entity_c8aa799401;

architecture structural of delay_bram1_entity_c8aa799401 is
  signal ce_1_sg_x354: std_logic;
  signal clk_1_sg_x354: std_logic;
  signal constant_op_net: std_logic;
  signal counter_op_net: std_logic_vector(7 downto 0);
  signal force_re_output_port_net_x1: std_logic_vector(18 downto 0);
  signal ram_data_out_net_x0: std_logic_vector(18 downto 0);

begin
  ce_1_sg_x354 <= ce_1;
  clk_1_sg_x354 <= clk_1;
  force_re_output_port_net_x1 <= din;
  dout <= ram_data_out_net_x0;

  constant_x0: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant_op_net
    );

  counter: entity work.xlcounter_limit_darkquad29
    generic map (
      cnt_15_0 => 253,
      cnt_31_16 => 0,
      cnt_47_32 => 0,
      cnt_63_48 => 0,
      core_name0 => "cntr_11_0_564d43d07a40ef72",
      count_limited => 1,
      op_arith => xlUnsigned,
      op_width => 8
    )
    port map (
      ce => ce_1_sg_x354,
      clk => clk_1_sg_x354,
      clr => '0',
      en => "1",
      rst => "0",
      op => counter_op_net
    );

  ram: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 19,
      core_name0 => "bmg_72_386cbab83765f0cd",
      latency => 1
    )
    port map (
      addr => counter_op_net,
      ce => ce_1_sg_x354,
      clk => clk_1_sg_x354,
      data_in => force_re_output_port_net_x1,
      en => "1",
      rst => "0",
      we(0) => constant_op_net,
      data_out => ram_data_out_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/downsample0/lpf_fir_i"

entity lpf_fir_i_entity_cfa52409f6 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    data0: in std_logic_vector(18 downto 0); 
    data1: in std_logic_vector(18 downto 0); 
    data_out: out std_logic_vector(18 downto 0)
  );
end lpf_fir_i_entity_cfa52409f6;

architecture structural of lpf_fir_i_entity_cfa52409f6 is
  signal addr20_s_net_x0: std_logic_vector(39 downto 0);
  signal ce_1_sg_x371: std_logic;
  signal clk_1_sg_x371: std_logic;
  signal constant10_op_net: std_logic_vector(15 downto 0);
  signal constant11_op_net: std_logic_vector(15 downto 0);
  signal constant12_op_net: std_logic_vector(15 downto 0);
  signal constant13_op_net: std_logic_vector(15 downto 0);
  signal constant14_op_net: std_logic_vector(15 downto 0);
  signal constant15_op_net: std_logic_vector(15 downto 0);
  signal constant16_op_net: std_logic_vector(15 downto 0);
  signal constant18_op_net: std_logic_vector(15 downto 0);
  signal constant1_op_net: std_logic_vector(15 downto 0);
  signal constant21_op_net: std_logic_vector(15 downto 0);
  signal constant2_op_net: std_logic_vector(15 downto 0);
  signal constant3_op_net: std_logic_vector(15 downto 0);
  signal constant4_op_net: std_logic_vector(15 downto 0);
  signal constant5_op_net: std_logic_vector(15 downto 0);
  signal constant6_op_net: std_logic_vector(15 downto 0);
  signal constant7_op_net: std_logic_vector(15 downto 0);
  signal constant8_op_net: std_logic_vector(15 downto 0);
  signal constant9_op_net: std_logic_vector(15 downto 0);
  signal convert_dout_net_x0: std_logic_vector(18 downto 0);
  signal force_re_output_port_net_x3: std_logic_vector(18 downto 0);
  signal force_re_output_port_net_x4: std_logic_vector(18 downto 0);
  signal mult10_p_net_x0: std_logic_vector(34 downto 0);
  signal mult11_p_net_x0: std_logic_vector(34 downto 0);
  signal mult12_p_net_x0: std_logic_vector(34 downto 0);
  signal mult13_p_net_x0: std_logic_vector(34 downto 0);
  signal mult14_p_net_x0: std_logic_vector(34 downto 0);
  signal mult15_p_net_x0: std_logic_vector(34 downto 0);
  signal mult16_p_net_x0: std_logic_vector(34 downto 0);
  signal mult17_p_net_x0: std_logic_vector(34 downto 0);
  signal mult1_p_net_x0: std_logic_vector(34 downto 0);
  signal mult2_p_net_x0: std_logic_vector(34 downto 0);
  signal mult3_p_net_x0: std_logic_vector(34 downto 0);
  signal mult4_p_net_x0: std_logic_vector(34 downto 0);
  signal mult5_p_net_x0: std_logic_vector(34 downto 0);
  signal mult6_p_net_x0: std_logic_vector(34 downto 0);
  signal mult7_p_net_x0: std_logic_vector(34 downto 0);
  signal mult8_p_net_x0: std_logic_vector(34 downto 0);
  signal mult9_p_net_x0: std_logic_vector(34 downto 0);
  signal mult_p_net_x0: std_logic_vector(34 downto 0);
  signal ram_data_out_net_x0: std_logic_vector(18 downto 0);
  signal ram_data_out_net_x1: std_logic_vector(18 downto 0);
  signal ram_data_out_net_x10: std_logic_vector(18 downto 0);
  signal ram_data_out_net_x11: std_logic_vector(18 downto 0);
  signal ram_data_out_net_x12: std_logic_vector(18 downto 0);
  signal ram_data_out_net_x13: std_logic_vector(18 downto 0);
  signal ram_data_out_net_x14: std_logic_vector(18 downto 0);
  signal ram_data_out_net_x15: std_logic_vector(18 downto 0);
  signal ram_data_out_net_x16: std_logic_vector(18 downto 0);
  signal ram_data_out_net_x2: std_logic_vector(18 downto 0);
  signal ram_data_out_net_x3: std_logic_vector(18 downto 0);
  signal ram_data_out_net_x4: std_logic_vector(18 downto 0);
  signal ram_data_out_net_x5: std_logic_vector(18 downto 0);
  signal ram_data_out_net_x6: std_logic_vector(18 downto 0);
  signal ram_data_out_net_x7: std_logic_vector(18 downto 0);
  signal ram_data_out_net_x8: std_logic_vector(18 downto 0);
  signal ram_data_out_net_x9: std_logic_vector(18 downto 0);

begin
  ce_1_sg_x371 <= ce_1;
  clk_1_sg_x371 <= clk_1;
  force_re_output_port_net_x3 <= data0;
  force_re_output_port_net_x4 <= data1;
  data_out <= convert_dout_net_x0;

  adder_tree_08c0caf64b: entity work.adder_tree_entity_08c0caf64b
    port map (
      ce_1 => ce_1_sg_x371,
      clk_1 => clk_1_sg_x371,
      din1 => mult_p_net_x0,
      din10 => mult9_p_net_x0,
      din11 => mult10_p_net_x0,
      din12 => mult11_p_net_x0,
      din13 => mult12_p_net_x0,
      din14 => mult13_p_net_x0,
      din15 => mult14_p_net_x0,
      din16 => mult15_p_net_x0,
      din17 => mult16_p_net_x0,
      din18 => mult17_p_net_x0,
      din2 => mult1_p_net_x0,
      din3 => mult2_p_net_x0,
      din4 => mult3_p_net_x0,
      din5 => mult4_p_net_x0,
      din6 => mult5_p_net_x0,
      din7 => mult6_p_net_x0,
      din8 => mult7_p_net_x0,
      din9 => mult8_p_net_x0,
      dout => addr20_s_net_x0
    );

  constant1: entity work.constant_5ffb58eb22
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant1_op_net
    );

  constant10: entity work.constant_9bd90577fa
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant10_op_net
    );

  constant11: entity work.constant_a6e8ddd940
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant11_op_net
    );

  constant12: entity work.constant_70566a39ae
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant12_op_net
    );

  constant13: entity work.constant_5ffb58eb22
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant13_op_net
    );

  constant14: entity work.constant_65987f1774
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant14_op_net
    );

  constant15: entity work.constant_6f91815d31
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant15_op_net
    );

  constant16: entity work.constant_b38f42a3c0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant16_op_net
    );

  constant18: entity work.constant_b38f42a3c0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant18_op_net
    );

  constant2: entity work.constant_70566a39ae
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant2_op_net
    );

  constant21: entity work.constant_d7af782a82
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant21_op_net
    );

  constant3: entity work.constant_65987f1774
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant3_op_net
    );

  constant4: entity work.constant_d7af782a82
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant4_op_net
    );

  constant5: entity work.constant_9bd90577fa
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant5_op_net
    );

  constant6: entity work.constant_6f91815d31
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant6_op_net
    );

  constant7: entity work.constant_cc00e1f180
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant7_op_net
    );

  constant8: entity work.constant_cc00e1f180
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant8_op_net
    );

  constant9: entity work.constant_a6e8ddd940
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant9_op_net
    );

  convert: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 32,
      din_width => 40,
      dout_arith => 2,
      dout_bin_pt => 17,
      dout_width => 19,
      latency => 2,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x371,
      clk => clk_1_sg_x371,
      clr => '0',
      din => addr20_s_net_x0,
      en => "1",
      dout => convert_dout_net_x0
    );

  delay_bram10_a11aeab682: entity work.delay_bram1_entity_c8aa799401
    port map (
      ce_1 => ce_1_sg_x371,
      clk_1 => clk_1_sg_x371,
      din => ram_data_out_net_x15,
      dout => ram_data_out_net_x3
    );

  delay_bram11_dc4689d46d: entity work.delay_bram1_entity_c8aa799401
    port map (
      ce_1 => ce_1_sg_x371,
      clk_1 => clk_1_sg_x371,
      din => ram_data_out_net_x16,
      dout => ram_data_out_net_x4
    );

  delay_bram12_8bb1932f76: entity work.delay_bram1_entity_c8aa799401
    port map (
      ce_1 => ce_1_sg_x371,
      clk_1 => clk_1_sg_x371,
      din => ram_data_out_net_x3,
      dout => ram_data_out_net_x5
    );

  delay_bram13_d96a26931d: entity work.delay_bram1_entity_c8aa799401
    port map (
      ce_1 => ce_1_sg_x371,
      clk_1 => clk_1_sg_x371,
      din => ram_data_out_net_x4,
      dout => ram_data_out_net_x6
    );

  delay_bram14_19ba35e7dd: entity work.delay_bram1_entity_c8aa799401
    port map (
      ce_1 => ce_1_sg_x371,
      clk_1 => clk_1_sg_x371,
      din => ram_data_out_net_x5,
      dout => ram_data_out_net_x7
    );

  delay_bram15_9e673cd3de: entity work.delay_bram1_entity_c8aa799401
    port map (
      ce_1 => ce_1_sg_x371,
      clk_1 => clk_1_sg_x371,
      din => ram_data_out_net_x6,
      dout => ram_data_out_net_x8
    );

  delay_bram16_1725fddfd9: entity work.delay_bram1_entity_c8aa799401
    port map (
      ce_1 => ce_1_sg_x371,
      clk_1 => clk_1_sg_x371,
      din => ram_data_out_net_x7,
      dout => ram_data_out_net_x0
    );

  delay_bram17_2a8865e29e: entity work.delay_bram1_entity_c8aa799401
    port map (
      ce_1 => ce_1_sg_x371,
      clk_1 => clk_1_sg_x371,
      din => ram_data_out_net_x8,
      dout => ram_data_out_net_x9
    );

  delay_bram1_c8aa799401: entity work.delay_bram1_entity_c8aa799401
    port map (
      ce_1 => ce_1_sg_x371,
      clk_1 => clk_1_sg_x371,
      din => force_re_output_port_net_x4,
      dout => ram_data_out_net_x1
    );

  delay_bram2_9c544ba75f: entity work.delay_bram1_entity_c8aa799401
    port map (
      ce_1 => ce_1_sg_x371,
      clk_1 => clk_1_sg_x371,
      din => force_re_output_port_net_x3,
      dout => ram_data_out_net_x10
    );

  delay_bram3_9f4fbcf682: entity work.delay_bram1_entity_c8aa799401
    port map (
      ce_1 => ce_1_sg_x371,
      clk_1 => clk_1_sg_x371,
      din => ram_data_out_net_x1,
      dout => ram_data_out_net_x11
    );

  delay_bram4_2db160a231: entity work.delay_bram1_entity_c8aa799401
    port map (
      ce_1 => ce_1_sg_x371,
      clk_1 => clk_1_sg_x371,
      din => ram_data_out_net_x10,
      dout => ram_data_out_net_x12
    );

  delay_bram5_b0fbb793a4: entity work.delay_bram1_entity_c8aa799401
    port map (
      ce_1 => ce_1_sg_x371,
      clk_1 => clk_1_sg_x371,
      din => ram_data_out_net_x11,
      dout => ram_data_out_net_x13
    );

  delay_bram6_37a8535837: entity work.delay_bram1_entity_c8aa799401
    port map (
      ce_1 => ce_1_sg_x371,
      clk_1 => clk_1_sg_x371,
      din => ram_data_out_net_x12,
      dout => ram_data_out_net_x2
    );

  delay_bram7_9e6484a62d: entity work.delay_bram1_entity_c8aa799401
    port map (
      ce_1 => ce_1_sg_x371,
      clk_1 => clk_1_sg_x371,
      din => ram_data_out_net_x13,
      dout => ram_data_out_net_x14
    );

  delay_bram8_9c6fd2eafa: entity work.delay_bram1_entity_c8aa799401
    port map (
      ce_1 => ce_1_sg_x371,
      clk_1 => clk_1_sg_x371,
      din => ram_data_out_net_x2,
      dout => ram_data_out_net_x15
    );

  delay_bram9_4447718ee8: entity work.delay_bram1_entity_c8aa799401
    port map (
      ce_1 => ce_1_sg_x371,
      clk_1 => clk_1_sg_x371,
      din => ram_data_out_net_x14,
      dout => ram_data_out_net_x16
    );

  mult: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 15,
      b_width => 16,
      c_a_type => 0,
      c_a_width => 19,
      c_b_type => 0,
      c_b_width => 16,
      c_baat => 19,
      c_output_width => 35,
      c_type => 0,
      core_name0 => "mult_11_2_645200e4043096c0",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 35,
      quantization => 1
    )
    port map (
      a => force_re_output_port_net_x3,
      b => constant21_op_net,
      ce => ce_1_sg_x371,
      clk => clk_1_sg_x371,
      clr => '0',
      core_ce => ce_1_sg_x371,
      core_clk => clk_1_sg_x371,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult_p_net_x0
    );

  mult1: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 15,
      b_width => 16,
      c_a_type => 0,
      c_a_width => 19,
      c_b_type => 0,
      c_b_width => 16,
      c_baat => 19,
      c_output_width => 35,
      c_type => 0,
      core_name0 => "mult_11_2_645200e4043096c0",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 35,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x1,
      b => constant18_op_net,
      ce => ce_1_sg_x371,
      clk => clk_1_sg_x371,
      clr => '0',
      core_ce => ce_1_sg_x371,
      core_clk => clk_1_sg_x371,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult1_p_net_x0
    );

  mult10: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 15,
      b_width => 16,
      c_a_type => 0,
      c_a_width => 19,
      c_b_type => 0,
      c_b_width => 16,
      c_baat => 19,
      c_output_width => 35,
      c_type => 0,
      core_name0 => "mult_11_2_645200e4043096c0",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 35,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x3,
      b => constant8_op_net,
      ce => ce_1_sg_x371,
      clk => clk_1_sg_x371,
      clr => '0',
      core_ce => ce_1_sg_x371,
      core_clk => clk_1_sg_x371,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult10_p_net_x0
    );

  mult11: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 15,
      b_width => 16,
      c_a_type => 0,
      c_a_width => 19,
      c_b_type => 0,
      c_b_width => 16,
      c_baat => 19,
      c_output_width => 35,
      c_type => 0,
      core_name0 => "mult_11_2_645200e4043096c0",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 35,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x4,
      b => constant10_op_net,
      ce => ce_1_sg_x371,
      clk => clk_1_sg_x371,
      clr => '0',
      core_ce => ce_1_sg_x371,
      core_clk => clk_1_sg_x371,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult11_p_net_x0
    );

  mult12: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 15,
      b_width => 16,
      c_a_type => 0,
      c_a_width => 19,
      c_b_type => 0,
      c_b_width => 16,
      c_baat => 19,
      c_output_width => 35,
      c_type => 0,
      core_name0 => "mult_11_2_645200e4043096c0",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 35,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x5,
      b => constant12_op_net,
      ce => ce_1_sg_x371,
      clk => clk_1_sg_x371,
      clr => '0',
      core_ce => ce_1_sg_x371,
      core_clk => clk_1_sg_x371,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult12_p_net_x0
    );

  mult13: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 15,
      b_width => 16,
      c_a_type => 0,
      c_a_width => 19,
      c_b_type => 0,
      c_b_width => 16,
      c_baat => 19,
      c_output_width => 35,
      c_type => 0,
      core_name0 => "mult_11_2_645200e4043096c0",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 35,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x6,
      b => constant13_op_net,
      ce => ce_1_sg_x371,
      clk => clk_1_sg_x371,
      clr => '0',
      core_ce => ce_1_sg_x371,
      core_clk => clk_1_sg_x371,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult13_p_net_x0
    );

  mult14: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 15,
      b_width => 16,
      c_a_type => 0,
      c_a_width => 19,
      c_b_type => 0,
      c_b_width => 16,
      c_baat => 19,
      c_output_width => 35,
      c_type => 0,
      core_name0 => "mult_11_2_645200e4043096c0",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 35,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x7,
      b => constant14_op_net,
      ce => ce_1_sg_x371,
      clk => clk_1_sg_x371,
      clr => '0',
      core_ce => ce_1_sg_x371,
      core_clk => clk_1_sg_x371,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult14_p_net_x0
    );

  mult15: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 15,
      b_width => 16,
      c_a_type => 0,
      c_a_width => 19,
      c_b_type => 0,
      c_b_width => 16,
      c_baat => 19,
      c_output_width => 35,
      c_type => 0,
      core_name0 => "mult_11_2_645200e4043096c0",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 35,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x8,
      b => constant15_op_net,
      ce => ce_1_sg_x371,
      clk => clk_1_sg_x371,
      clr => '0',
      core_ce => ce_1_sg_x371,
      core_clk => clk_1_sg_x371,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult15_p_net_x0
    );

  mult16: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 15,
      b_width => 16,
      c_a_type => 0,
      c_a_width => 19,
      c_b_type => 0,
      c_b_width => 16,
      c_baat => 19,
      c_output_width => 35,
      c_type => 0,
      core_name0 => "mult_11_2_645200e4043096c0",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 35,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x0,
      b => constant16_op_net,
      ce => ce_1_sg_x371,
      clk => clk_1_sg_x371,
      clr => '0',
      core_ce => ce_1_sg_x371,
      core_clk => clk_1_sg_x371,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult16_p_net_x0
    );

  mult17: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 15,
      b_width => 16,
      c_a_type => 0,
      c_a_width => 19,
      c_b_type => 0,
      c_b_width => 16,
      c_baat => 19,
      c_output_width => 35,
      c_type => 0,
      core_name0 => "mult_11_2_645200e4043096c0",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 35,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x9,
      b => constant4_op_net,
      ce => ce_1_sg_x371,
      clk => clk_1_sg_x371,
      clr => '0',
      core_ce => ce_1_sg_x371,
      core_clk => clk_1_sg_x371,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult17_p_net_x0
    );

  mult2: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 15,
      b_width => 16,
      c_a_type => 0,
      c_a_width => 19,
      c_b_type => 0,
      c_b_width => 16,
      c_baat => 19,
      c_output_width => 35,
      c_type => 0,
      core_name0 => "mult_11_2_645200e4043096c0",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 35,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x10,
      b => constant6_op_net,
      ce => ce_1_sg_x371,
      clk => clk_1_sg_x371,
      clr => '0',
      core_ce => ce_1_sg_x371,
      core_clk => clk_1_sg_x371,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult2_p_net_x0
    );

  mult3: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 15,
      b_width => 16,
      c_a_type => 0,
      c_a_width => 19,
      c_b_type => 0,
      c_b_width => 16,
      c_baat => 19,
      c_output_width => 35,
      c_type => 0,
      core_name0 => "mult_11_2_645200e4043096c0",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 35,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x11,
      b => constant3_op_net,
      ce => ce_1_sg_x371,
      clk => clk_1_sg_x371,
      clr => '0',
      core_ce => ce_1_sg_x371,
      core_clk => clk_1_sg_x371,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult3_p_net_x0
    );

  mult4: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 15,
      b_width => 16,
      c_a_type => 0,
      c_a_width => 19,
      c_b_type => 0,
      c_b_width => 16,
      c_baat => 19,
      c_output_width => 35,
      c_type => 0,
      core_name0 => "mult_11_2_645200e4043096c0",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 35,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x12,
      b => constant1_op_net,
      ce => ce_1_sg_x371,
      clk => clk_1_sg_x371,
      clr => '0',
      core_ce => ce_1_sg_x371,
      core_clk => clk_1_sg_x371,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult4_p_net_x0
    );

  mult5: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 15,
      b_width => 16,
      c_a_type => 0,
      c_a_width => 19,
      c_b_type => 0,
      c_b_width => 16,
      c_baat => 19,
      c_output_width => 35,
      c_type => 0,
      core_name0 => "mult_11_2_645200e4043096c0",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 35,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x13,
      b => constant2_op_net,
      ce => ce_1_sg_x371,
      clk => clk_1_sg_x371,
      clr => '0',
      core_ce => ce_1_sg_x371,
      core_clk => clk_1_sg_x371,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult5_p_net_x0
    );

  mult6: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 15,
      b_width => 16,
      c_a_type => 0,
      c_a_width => 19,
      c_b_type => 0,
      c_b_width => 16,
      c_baat => 19,
      c_output_width => 35,
      c_type => 0,
      core_name0 => "mult_11_2_645200e4043096c0",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 35,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x2,
      b => constant5_op_net,
      ce => ce_1_sg_x371,
      clk => clk_1_sg_x371,
      clr => '0',
      core_ce => ce_1_sg_x371,
      core_clk => clk_1_sg_x371,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult6_p_net_x0
    );

  mult7: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 15,
      b_width => 16,
      c_a_type => 0,
      c_a_width => 19,
      c_b_type => 0,
      c_b_width => 16,
      c_baat => 19,
      c_output_width => 35,
      c_type => 0,
      core_name0 => "mult_11_2_645200e4043096c0",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 35,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x14,
      b => constant7_op_net,
      ce => ce_1_sg_x371,
      clk => clk_1_sg_x371,
      clr => '0',
      core_ce => ce_1_sg_x371,
      core_clk => clk_1_sg_x371,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult7_p_net_x0
    );

  mult8: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 15,
      b_width => 16,
      c_a_type => 0,
      c_a_width => 19,
      c_b_type => 0,
      c_b_width => 16,
      c_baat => 19,
      c_output_width => 35,
      c_type => 0,
      core_name0 => "mult_11_2_645200e4043096c0",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 35,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x15,
      b => constant9_op_net,
      ce => ce_1_sg_x371,
      clk => clk_1_sg_x371,
      clr => '0',
      core_ce => ce_1_sg_x371,
      core_clk => clk_1_sg_x371,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult8_p_net_x0
    );

  mult9: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 15,
      b_width => 16,
      c_a_type => 0,
      c_a_width => 19,
      c_b_type => 0,
      c_b_width => 16,
      c_baat => 19,
      c_output_width => 35,
      c_type => 0,
      core_name0 => "mult_11_2_645200e4043096c0",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 35,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x16,
      b => constant11_op_net,
      ce => ce_1_sg_x371,
      clk => clk_1_sg_x371,
      clr => '0',
      core_ce => ce_1_sg_x371,
      core_clk => clk_1_sg_x371,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult9_p_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/downsample0/lpf_fir_i1/adder_tree"

entity adder_tree_entity_ea2e46c242 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din1: in std_logic_vector(34 downto 0); 
    din10: in std_logic_vector(34 downto 0); 
    din11: in std_logic_vector(34 downto 0); 
    din12: in std_logic_vector(34 downto 0); 
    din13: in std_logic_vector(34 downto 0); 
    din14: in std_logic_vector(34 downto 0); 
    din15: in std_logic_vector(34 downto 0); 
    din16: in std_logic_vector(34 downto 0); 
    din17: in std_logic_vector(34 downto 0); 
    din18: in std_logic_vector(34 downto 0); 
    din2: in std_logic_vector(34 downto 0); 
    din3: in std_logic_vector(34 downto 0); 
    din4: in std_logic_vector(34 downto 0); 
    din5: in std_logic_vector(34 downto 0); 
    din6: in std_logic_vector(34 downto 0); 
    din7: in std_logic_vector(34 downto 0); 
    din8: in std_logic_vector(34 downto 0); 
    din9: in std_logic_vector(34 downto 0); 
    sync: in std_logic_vector(7 downto 0); 
    dout: out std_logic_vector(39 downto 0); 
    sync_out: out std_logic_vector(7 downto 0)
  );
end adder_tree_entity_ea2e46c242;

architecture structural of adder_tree_entity_ea2e46c242 is
  signal addr10_s_net: std_logic_vector(36 downto 0);
  signal addr11_s_net: std_logic_vector(36 downto 0);
  signal addr12_s_net: std_logic_vector(36 downto 0);
  signal addr13_s_net: std_logic_vector(36 downto 0);
  signal addr15_s_net: std_logic_vector(37 downto 0);
  signal addr16_s_net: std_logic_vector(37 downto 0);
  signal addr18_s_net: std_logic_vector(38 downto 0);
  signal addr1_s_net: std_logic_vector(35 downto 0);
  signal addr20_s_net_x0: std_logic_vector(39 downto 0);
  signal addr2_s_net: std_logic_vector(35 downto 0);
  signal addr3_s_net: std_logic_vector(35 downto 0);
  signal addr4_s_net: std_logic_vector(35 downto 0);
  signal addr5_s_net: std_logic_vector(35 downto 0);
  signal addr6_s_net: std_logic_vector(35 downto 0);
  signal addr7_s_net: std_logic_vector(35 downto 0);
  signal addr8_s_net: std_logic_vector(35 downto 0);
  signal addr9_s_net: std_logic_vector(35 downto 0);
  signal ce_1_sg_x372: std_logic;
  signal clk_1_sg_x372: std_logic;
  signal delay16_q_net_x0: std_logic_vector(7 downto 0);
  signal dly14_q_net: std_logic_vector(35 downto 0);
  signal dly17_q_net: std_logic_vector(35 downto 0);
  signal dly19_q_net: std_logic_vector(35 downto 0);
  signal mult10_p_net_x0: std_logic_vector(34 downto 0);
  signal mult11_p_net_x0: std_logic_vector(34 downto 0);
  signal mult12_p_net_x0: std_logic_vector(34 downto 0);
  signal mult13_p_net_x0: std_logic_vector(34 downto 0);
  signal mult14_p_net_x0: std_logic_vector(34 downto 0);
  signal mult15_p_net_x0: std_logic_vector(34 downto 0);
  signal mult16_p_net_x0: std_logic_vector(34 downto 0);
  signal mult17_p_net_x0: std_logic_vector(34 downto 0);
  signal mult1_p_net_x0: std_logic_vector(34 downto 0);
  signal mult2_p_net_x0: std_logic_vector(34 downto 0);
  signal mult3_p_net_x0: std_logic_vector(34 downto 0);
  signal mult4_p_net_x0: std_logic_vector(34 downto 0);
  signal mult5_p_net_x0: std_logic_vector(34 downto 0);
  signal mult6_p_net_x0: std_logic_vector(34 downto 0);
  signal mult7_p_net_x0: std_logic_vector(34 downto 0);
  signal mult8_p_net_x0: std_logic_vector(34 downto 0);
  signal mult9_p_net_x0: std_logic_vector(34 downto 0);
  signal mult_p_net_x0: std_logic_vector(34 downto 0);
  signal sync_delay_q_net_x0: std_logic_vector(7 downto 0);

begin
  ce_1_sg_x372 <= ce_1;
  clk_1_sg_x372 <= clk_1;
  mult_p_net_x0 <= din1;
  mult9_p_net_x0 <= din10;
  mult10_p_net_x0 <= din11;
  mult11_p_net_x0 <= din12;
  mult12_p_net_x0 <= din13;
  mult13_p_net_x0 <= din14;
  mult14_p_net_x0 <= din15;
  mult15_p_net_x0 <= din16;
  mult16_p_net_x0 <= din17;
  mult17_p_net_x0 <= din18;
  mult1_p_net_x0 <= din2;
  mult2_p_net_x0 <= din3;
  mult3_p_net_x0 <= din4;
  mult4_p_net_x0 <= din5;
  mult5_p_net_x0 <= din6;
  mult6_p_net_x0 <= din7;
  mult7_p_net_x0 <= din8;
  mult8_p_net_x0 <= din9;
  delay16_q_net_x0 <= sync;
  dout <= addr20_s_net_x0;
  sync_out <= sync_delay_q_net_x0;

  addr1: entity work.addsub_f7543d22d5
    port map (
      a => mult_p_net_x0,
      b => mult1_p_net_x0,
      ce => ce_1_sg_x372,
      clk => clk_1_sg_x372,
      clr => '0',
      s => addr1_s_net
    );

  addr10: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 32,
      a_width => 36,
      b_arith => xlSigned,
      b_bin_pt => 32,
      b_width => 36,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 37,
      core_name0 => "addsb_11_0_f71caeff01210ab2",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 37,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 32,
      s_width => 37
    )
    port map (
      a => addr1_s_net,
      b => addr2_s_net,
      ce => ce_1_sg_x372,
      clk => clk_1_sg_x372,
      clr => '0',
      en => "1",
      s => addr10_s_net
    );

  addr11: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 32,
      a_width => 36,
      b_arith => xlSigned,
      b_bin_pt => 32,
      b_width => 36,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 37,
      core_name0 => "addsb_11_0_f71caeff01210ab2",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 37,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 32,
      s_width => 37
    )
    port map (
      a => addr3_s_net,
      b => addr4_s_net,
      ce => ce_1_sg_x372,
      clk => clk_1_sg_x372,
      clr => '0',
      en => "1",
      s => addr11_s_net
    );

  addr12: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 32,
      a_width => 36,
      b_arith => xlSigned,
      b_bin_pt => 32,
      b_width => 36,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 37,
      core_name0 => "addsb_11_0_f71caeff01210ab2",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 37,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 32,
      s_width => 37
    )
    port map (
      a => addr5_s_net,
      b => addr6_s_net,
      ce => ce_1_sg_x372,
      clk => clk_1_sg_x372,
      clr => '0',
      en => "1",
      s => addr12_s_net
    );

  addr13: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 32,
      a_width => 36,
      b_arith => xlSigned,
      b_bin_pt => 32,
      b_width => 36,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 37,
      core_name0 => "addsb_11_0_f71caeff01210ab2",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 37,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 32,
      s_width => 37
    )
    port map (
      a => addr7_s_net,
      b => addr8_s_net,
      ce => ce_1_sg_x372,
      clk => clk_1_sg_x372,
      clr => '0',
      en => "1",
      s => addr13_s_net
    );

  addr15: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 32,
      a_width => 37,
      b_arith => xlSigned,
      b_bin_pt => 32,
      b_width => 37,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 38,
      core_name0 => "addsb_11_0_07eb1c1df5a181f1",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 38,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 32,
      s_width => 38
    )
    port map (
      a => addr10_s_net,
      b => addr11_s_net,
      ce => ce_1_sg_x372,
      clk => clk_1_sg_x372,
      clr => '0',
      en => "1",
      s => addr15_s_net
    );

  addr16: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 32,
      a_width => 37,
      b_arith => xlSigned,
      b_bin_pt => 32,
      b_width => 37,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 38,
      core_name0 => "addsb_11_0_07eb1c1df5a181f1",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 38,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 32,
      s_width => 38
    )
    port map (
      a => addr12_s_net,
      b => addr13_s_net,
      ce => ce_1_sg_x372,
      clk => clk_1_sg_x372,
      clr => '0',
      en => "1",
      s => addr16_s_net
    );

  addr18: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 32,
      a_width => 38,
      b_arith => xlSigned,
      b_bin_pt => 32,
      b_width => 38,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 39,
      core_name0 => "addsb_11_0_26c38df2140ab027",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 39,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 32,
      s_width => 39
    )
    port map (
      a => addr15_s_net,
      b => addr16_s_net,
      ce => ce_1_sg_x372,
      clk => clk_1_sg_x372,
      clr => '0',
      en => "1",
      s => addr18_s_net
    );

  addr2: entity work.addsub_f7543d22d5
    port map (
      a => mult2_p_net_x0,
      b => mult3_p_net_x0,
      ce => ce_1_sg_x372,
      clk => clk_1_sg_x372,
      clr => '0',
      s => addr2_s_net
    );

  addr20: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 32,
      a_width => 39,
      b_arith => xlSigned,
      b_bin_pt => 32,
      b_width => 36,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 40,
      core_name0 => "addsb_11_0_075266d61a42e95d",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 40,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 32,
      s_width => 40
    )
    port map (
      a => addr18_s_net,
      b => dly19_q_net,
      ce => ce_1_sg_x372,
      clk => clk_1_sg_x372,
      clr => '0',
      en => "1",
      s => addr20_s_net_x0
    );

  addr3: entity work.addsub_f7543d22d5
    port map (
      a => mult4_p_net_x0,
      b => mult5_p_net_x0,
      ce => ce_1_sg_x372,
      clk => clk_1_sg_x372,
      clr => '0',
      s => addr3_s_net
    );

  addr4: entity work.addsub_f7543d22d5
    port map (
      a => mult6_p_net_x0,
      b => mult7_p_net_x0,
      ce => ce_1_sg_x372,
      clk => clk_1_sg_x372,
      clr => '0',
      s => addr4_s_net
    );

  addr5: entity work.addsub_f7543d22d5
    port map (
      a => mult8_p_net_x0,
      b => mult9_p_net_x0,
      ce => ce_1_sg_x372,
      clk => clk_1_sg_x372,
      clr => '0',
      s => addr5_s_net
    );

  addr6: entity work.addsub_f7543d22d5
    port map (
      a => mult10_p_net_x0,
      b => mult11_p_net_x0,
      ce => ce_1_sg_x372,
      clk => clk_1_sg_x372,
      clr => '0',
      s => addr6_s_net
    );

  addr7: entity work.addsub_f7543d22d5
    port map (
      a => mult12_p_net_x0,
      b => mult13_p_net_x0,
      ce => ce_1_sg_x372,
      clk => clk_1_sg_x372,
      clr => '0',
      s => addr7_s_net
    );

  addr8: entity work.addsub_f7543d22d5
    port map (
      a => mult14_p_net_x0,
      b => mult15_p_net_x0,
      ce => ce_1_sg_x372,
      clk => clk_1_sg_x372,
      clr => '0',
      s => addr8_s_net
    );

  addr9: entity work.addsub_f7543d22d5
    port map (
      a => mult16_p_net_x0,
      b => mult17_p_net_x0,
      ce => ce_1_sg_x372,
      clk => clk_1_sg_x372,
      clr => '0',
      s => addr9_s_net
    );

  dly14: entity work.delay_4b00a70dea
    port map (
      ce => ce_1_sg_x372,
      clk => clk_1_sg_x372,
      clr => '0',
      d => addr9_s_net,
      q => dly14_q_net
    );

  dly17: entity work.delay_4b00a70dea
    port map (
      ce => ce_1_sg_x372,
      clk => clk_1_sg_x372,
      clr => '0',
      d => dly14_q_net,
      q => dly17_q_net
    );

  dly19: entity work.delay_4b00a70dea
    port map (
      ce => ce_1_sg_x372,
      clk => clk_1_sg_x372,
      clr => '0',
      d => dly17_q_net,
      q => dly19_q_net
    );

  sync_delay: entity work.delay_396d62fe11
    port map (
      ce => ce_1_sg_x372,
      clk => clk_1_sg_x372,
      clr => '0',
      d => delay16_q_net_x0,
      q => sync_delay_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/downsample0/lpf_fir_i1"

entity lpf_fir_i1_entity_871bd92da5 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    data0: in std_logic_vector(18 downto 0); 
    data1: in std_logic_vector(18 downto 0); 
    misc_in: in std_logic_vector(7 downto 0); 
    data_out: out std_logic_vector(18 downto 0); 
    misc_out: out std_logic_vector(7 downto 0)
  );
end lpf_fir_i1_entity_871bd92da5;

architecture structural of lpf_fir_i1_entity_871bd92da5 is
  signal addr20_s_net_x0: std_logic_vector(39 downto 0);
  signal ce_1_sg_x390: std_logic;
  signal clk_1_sg_x390: std_logic;
  signal constant10_op_net: std_logic_vector(15 downto 0);
  signal constant11_op_net: std_logic_vector(15 downto 0);
  signal constant12_op_net: std_logic_vector(15 downto 0);
  signal constant13_op_net: std_logic_vector(15 downto 0);
  signal constant14_op_net: std_logic_vector(15 downto 0);
  signal constant15_op_net: std_logic_vector(15 downto 0);
  signal constant16_op_net: std_logic_vector(15 downto 0);
  signal constant18_op_net: std_logic_vector(15 downto 0);
  signal constant1_op_net: std_logic_vector(15 downto 0);
  signal constant21_op_net: std_logic_vector(15 downto 0);
  signal constant2_op_net: std_logic_vector(15 downto 0);
  signal constant3_op_net: std_logic_vector(15 downto 0);
  signal constant4_op_net: std_logic_vector(15 downto 0);
  signal constant5_op_net: std_logic_vector(15 downto 0);
  signal constant6_op_net: std_logic_vector(15 downto 0);
  signal constant7_op_net: std_logic_vector(15 downto 0);
  signal constant8_op_net: std_logic_vector(15 downto 0);
  signal constant9_op_net: std_logic_vector(15 downto 0);
  signal convert_dout_net_x0: std_logic_vector(18 downto 0);
  signal delay16_q_net_x0: std_logic_vector(7 downto 0);
  signal delay52_q_net_x0: std_logic_vector(7 downto 0);
  signal delay9_q_net_x0: std_logic_vector(7 downto 0);
  signal force_im_output_port_net_x3: std_logic_vector(18 downto 0);
  signal force_im_output_port_net_x4: std_logic_vector(18 downto 0);
  signal mult10_p_net_x0: std_logic_vector(34 downto 0);
  signal mult11_p_net_x0: std_logic_vector(34 downto 0);
  signal mult12_p_net_x0: std_logic_vector(34 downto 0);
  signal mult13_p_net_x0: std_logic_vector(34 downto 0);
  signal mult14_p_net_x0: std_logic_vector(34 downto 0);
  signal mult15_p_net_x0: std_logic_vector(34 downto 0);
  signal mult16_p_net_x0: std_logic_vector(34 downto 0);
  signal mult17_p_net_x0: std_logic_vector(34 downto 0);
  signal mult1_p_net_x0: std_logic_vector(34 downto 0);
  signal mult2_p_net_x0: std_logic_vector(34 downto 0);
  signal mult3_p_net_x0: std_logic_vector(34 downto 0);
  signal mult4_p_net_x0: std_logic_vector(34 downto 0);
  signal mult5_p_net_x0: std_logic_vector(34 downto 0);
  signal mult6_p_net_x0: std_logic_vector(34 downto 0);
  signal mult7_p_net_x0: std_logic_vector(34 downto 0);
  signal mult8_p_net_x0: std_logic_vector(34 downto 0);
  signal mult9_p_net_x0: std_logic_vector(34 downto 0);
  signal mult_p_net_x0: std_logic_vector(34 downto 0);
  signal ram_data_out_net_x0: std_logic_vector(18 downto 0);
  signal ram_data_out_net_x1: std_logic_vector(18 downto 0);
  signal ram_data_out_net_x10: std_logic_vector(18 downto 0);
  signal ram_data_out_net_x11: std_logic_vector(18 downto 0);
  signal ram_data_out_net_x12: std_logic_vector(18 downto 0);
  signal ram_data_out_net_x13: std_logic_vector(18 downto 0);
  signal ram_data_out_net_x14: std_logic_vector(18 downto 0);
  signal ram_data_out_net_x15: std_logic_vector(18 downto 0);
  signal ram_data_out_net_x16: std_logic_vector(18 downto 0);
  signal ram_data_out_net_x2: std_logic_vector(18 downto 0);
  signal ram_data_out_net_x3: std_logic_vector(18 downto 0);
  signal ram_data_out_net_x4: std_logic_vector(18 downto 0);
  signal ram_data_out_net_x5: std_logic_vector(18 downto 0);
  signal ram_data_out_net_x6: std_logic_vector(18 downto 0);
  signal ram_data_out_net_x7: std_logic_vector(18 downto 0);
  signal ram_data_out_net_x8: std_logic_vector(18 downto 0);
  signal ram_data_out_net_x9: std_logic_vector(18 downto 0);
  signal sync_delay_q_net_x0: std_logic_vector(7 downto 0);

begin
  ce_1_sg_x390 <= ce_1;
  clk_1_sg_x390 <= clk_1;
  force_im_output_port_net_x3 <= data0;
  force_im_output_port_net_x4 <= data1;
  delay52_q_net_x0 <= misc_in;
  data_out <= convert_dout_net_x0;
  misc_out <= delay9_q_net_x0;

  adder_tree_ea2e46c242: entity work.adder_tree_entity_ea2e46c242
    port map (
      ce_1 => ce_1_sg_x390,
      clk_1 => clk_1_sg_x390,
      din1 => mult_p_net_x0,
      din10 => mult9_p_net_x0,
      din11 => mult10_p_net_x0,
      din12 => mult11_p_net_x0,
      din13 => mult12_p_net_x0,
      din14 => mult13_p_net_x0,
      din15 => mult14_p_net_x0,
      din16 => mult15_p_net_x0,
      din17 => mult16_p_net_x0,
      din18 => mult17_p_net_x0,
      din2 => mult1_p_net_x0,
      din3 => mult2_p_net_x0,
      din4 => mult3_p_net_x0,
      din5 => mult4_p_net_x0,
      din6 => mult5_p_net_x0,
      din7 => mult6_p_net_x0,
      din8 => mult7_p_net_x0,
      din9 => mult8_p_net_x0,
      sync => delay16_q_net_x0,
      dout => addr20_s_net_x0,
      sync_out => sync_delay_q_net_x0
    );

  constant1: entity work.constant_5ffb58eb22
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant1_op_net
    );

  constant10: entity work.constant_9bd90577fa
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant10_op_net
    );

  constant11: entity work.constant_a6e8ddd940
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant11_op_net
    );

  constant12: entity work.constant_70566a39ae
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant12_op_net
    );

  constant13: entity work.constant_5ffb58eb22
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant13_op_net
    );

  constant14: entity work.constant_65987f1774
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant14_op_net
    );

  constant15: entity work.constant_6f91815d31
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant15_op_net
    );

  constant16: entity work.constant_b38f42a3c0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant16_op_net
    );

  constant18: entity work.constant_b38f42a3c0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant18_op_net
    );

  constant2: entity work.constant_70566a39ae
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant2_op_net
    );

  constant21: entity work.constant_d7af782a82
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant21_op_net
    );

  constant3: entity work.constant_65987f1774
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant3_op_net
    );

  constant4: entity work.constant_d7af782a82
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant4_op_net
    );

  constant5: entity work.constant_9bd90577fa
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant5_op_net
    );

  constant6: entity work.constant_6f91815d31
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant6_op_net
    );

  constant7: entity work.constant_cc00e1f180
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant7_op_net
    );

  constant8: entity work.constant_cc00e1f180
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant8_op_net
    );

  constant9: entity work.constant_a6e8ddd940
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant9_op_net
    );

  convert: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 32,
      din_width => 40,
      dout_arith => 2,
      dout_bin_pt => 17,
      dout_width => 19,
      latency => 2,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x390,
      clk => clk_1_sg_x390,
      clr => '0',
      din => addr20_s_net_x0,
      en => "1",
      dout => convert_dout_net_x0
    );

  delay16: entity work.xldelay
    generic map (
      latency => 4,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x390,
      clk => clk_1_sg_x390,
      d => delay52_q_net_x0,
      en => '1',
      rst => '1',
      q => delay16_q_net_x0
    );

  delay9: entity work.delay_23f848c85b
    port map (
      ce => ce_1_sg_x390,
      clk => clk_1_sg_x390,
      clr => '0',
      d => sync_delay_q_net_x0,
      q => delay9_q_net_x0
    );

  delay_bram10_7dfd792c35: entity work.delay_bram1_entity_c8aa799401
    port map (
      ce_1 => ce_1_sg_x390,
      clk_1 => clk_1_sg_x390,
      din => ram_data_out_net_x15,
      dout => ram_data_out_net_x3
    );

  delay_bram11_23bb8c0d1a: entity work.delay_bram1_entity_c8aa799401
    port map (
      ce_1 => ce_1_sg_x390,
      clk_1 => clk_1_sg_x390,
      din => ram_data_out_net_x16,
      dout => ram_data_out_net_x4
    );

  delay_bram12_c71c70acc6: entity work.delay_bram1_entity_c8aa799401
    port map (
      ce_1 => ce_1_sg_x390,
      clk_1 => clk_1_sg_x390,
      din => ram_data_out_net_x3,
      dout => ram_data_out_net_x5
    );

  delay_bram13_e4f447d38d: entity work.delay_bram1_entity_c8aa799401
    port map (
      ce_1 => ce_1_sg_x390,
      clk_1 => clk_1_sg_x390,
      din => ram_data_out_net_x4,
      dout => ram_data_out_net_x6
    );

  delay_bram14_e467789a9d: entity work.delay_bram1_entity_c8aa799401
    port map (
      ce_1 => ce_1_sg_x390,
      clk_1 => clk_1_sg_x390,
      din => ram_data_out_net_x5,
      dout => ram_data_out_net_x7
    );

  delay_bram15_79b58d915e: entity work.delay_bram1_entity_c8aa799401
    port map (
      ce_1 => ce_1_sg_x390,
      clk_1 => clk_1_sg_x390,
      din => ram_data_out_net_x6,
      dout => ram_data_out_net_x8
    );

  delay_bram16_97861e0fbe: entity work.delay_bram1_entity_c8aa799401
    port map (
      ce_1 => ce_1_sg_x390,
      clk_1 => clk_1_sg_x390,
      din => ram_data_out_net_x7,
      dout => ram_data_out_net_x0
    );

  delay_bram17_d3ff10f843: entity work.delay_bram1_entity_c8aa799401
    port map (
      ce_1 => ce_1_sg_x390,
      clk_1 => clk_1_sg_x390,
      din => ram_data_out_net_x8,
      dout => ram_data_out_net_x9
    );

  delay_bram1_834ea8d307: entity work.delay_bram1_entity_c8aa799401
    port map (
      ce_1 => ce_1_sg_x390,
      clk_1 => clk_1_sg_x390,
      din => force_im_output_port_net_x4,
      dout => ram_data_out_net_x1
    );

  delay_bram2_88bf7be7e1: entity work.delay_bram1_entity_c8aa799401
    port map (
      ce_1 => ce_1_sg_x390,
      clk_1 => clk_1_sg_x390,
      din => force_im_output_port_net_x3,
      dout => ram_data_out_net_x10
    );

  delay_bram3_c569e898e4: entity work.delay_bram1_entity_c8aa799401
    port map (
      ce_1 => ce_1_sg_x390,
      clk_1 => clk_1_sg_x390,
      din => ram_data_out_net_x1,
      dout => ram_data_out_net_x11
    );

  delay_bram4_561b53ed34: entity work.delay_bram1_entity_c8aa799401
    port map (
      ce_1 => ce_1_sg_x390,
      clk_1 => clk_1_sg_x390,
      din => ram_data_out_net_x10,
      dout => ram_data_out_net_x12
    );

  delay_bram5_4e6c2e6c16: entity work.delay_bram1_entity_c8aa799401
    port map (
      ce_1 => ce_1_sg_x390,
      clk_1 => clk_1_sg_x390,
      din => ram_data_out_net_x11,
      dout => ram_data_out_net_x13
    );

  delay_bram6_13cc6830cc: entity work.delay_bram1_entity_c8aa799401
    port map (
      ce_1 => ce_1_sg_x390,
      clk_1 => clk_1_sg_x390,
      din => ram_data_out_net_x12,
      dout => ram_data_out_net_x2
    );

  delay_bram7_97a7b260a4: entity work.delay_bram1_entity_c8aa799401
    port map (
      ce_1 => ce_1_sg_x390,
      clk_1 => clk_1_sg_x390,
      din => ram_data_out_net_x13,
      dout => ram_data_out_net_x14
    );

  delay_bram8_017433c5b8: entity work.delay_bram1_entity_c8aa799401
    port map (
      ce_1 => ce_1_sg_x390,
      clk_1 => clk_1_sg_x390,
      din => ram_data_out_net_x2,
      dout => ram_data_out_net_x15
    );

  delay_bram9_f75c64e749: entity work.delay_bram1_entity_c8aa799401
    port map (
      ce_1 => ce_1_sg_x390,
      clk_1 => clk_1_sg_x390,
      din => ram_data_out_net_x14,
      dout => ram_data_out_net_x16
    );

  mult: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 15,
      b_width => 16,
      c_a_type => 0,
      c_a_width => 19,
      c_b_type => 0,
      c_b_width => 16,
      c_baat => 19,
      c_output_width => 35,
      c_type => 0,
      core_name0 => "mult_11_2_645200e4043096c0",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 35,
      quantization => 1
    )
    port map (
      a => force_im_output_port_net_x3,
      b => constant21_op_net,
      ce => ce_1_sg_x390,
      clk => clk_1_sg_x390,
      clr => '0',
      core_ce => ce_1_sg_x390,
      core_clk => clk_1_sg_x390,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult_p_net_x0
    );

  mult1: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 15,
      b_width => 16,
      c_a_type => 0,
      c_a_width => 19,
      c_b_type => 0,
      c_b_width => 16,
      c_baat => 19,
      c_output_width => 35,
      c_type => 0,
      core_name0 => "mult_11_2_645200e4043096c0",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 35,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x1,
      b => constant18_op_net,
      ce => ce_1_sg_x390,
      clk => clk_1_sg_x390,
      clr => '0',
      core_ce => ce_1_sg_x390,
      core_clk => clk_1_sg_x390,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult1_p_net_x0
    );

  mult10: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 15,
      b_width => 16,
      c_a_type => 0,
      c_a_width => 19,
      c_b_type => 0,
      c_b_width => 16,
      c_baat => 19,
      c_output_width => 35,
      c_type => 0,
      core_name0 => "mult_11_2_645200e4043096c0",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 35,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x3,
      b => constant8_op_net,
      ce => ce_1_sg_x390,
      clk => clk_1_sg_x390,
      clr => '0',
      core_ce => ce_1_sg_x390,
      core_clk => clk_1_sg_x390,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult10_p_net_x0
    );

  mult11: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 15,
      b_width => 16,
      c_a_type => 0,
      c_a_width => 19,
      c_b_type => 0,
      c_b_width => 16,
      c_baat => 19,
      c_output_width => 35,
      c_type => 0,
      core_name0 => "mult_11_2_645200e4043096c0",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 35,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x4,
      b => constant10_op_net,
      ce => ce_1_sg_x390,
      clk => clk_1_sg_x390,
      clr => '0',
      core_ce => ce_1_sg_x390,
      core_clk => clk_1_sg_x390,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult11_p_net_x0
    );

  mult12: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 15,
      b_width => 16,
      c_a_type => 0,
      c_a_width => 19,
      c_b_type => 0,
      c_b_width => 16,
      c_baat => 19,
      c_output_width => 35,
      c_type => 0,
      core_name0 => "mult_11_2_645200e4043096c0",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 35,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x5,
      b => constant12_op_net,
      ce => ce_1_sg_x390,
      clk => clk_1_sg_x390,
      clr => '0',
      core_ce => ce_1_sg_x390,
      core_clk => clk_1_sg_x390,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult12_p_net_x0
    );

  mult13: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 15,
      b_width => 16,
      c_a_type => 0,
      c_a_width => 19,
      c_b_type => 0,
      c_b_width => 16,
      c_baat => 19,
      c_output_width => 35,
      c_type => 0,
      core_name0 => "mult_11_2_645200e4043096c0",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 35,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x6,
      b => constant13_op_net,
      ce => ce_1_sg_x390,
      clk => clk_1_sg_x390,
      clr => '0',
      core_ce => ce_1_sg_x390,
      core_clk => clk_1_sg_x390,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult13_p_net_x0
    );

  mult14: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 15,
      b_width => 16,
      c_a_type => 0,
      c_a_width => 19,
      c_b_type => 0,
      c_b_width => 16,
      c_baat => 19,
      c_output_width => 35,
      c_type => 0,
      core_name0 => "mult_11_2_645200e4043096c0",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 35,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x7,
      b => constant14_op_net,
      ce => ce_1_sg_x390,
      clk => clk_1_sg_x390,
      clr => '0',
      core_ce => ce_1_sg_x390,
      core_clk => clk_1_sg_x390,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult14_p_net_x0
    );

  mult15: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 15,
      b_width => 16,
      c_a_type => 0,
      c_a_width => 19,
      c_b_type => 0,
      c_b_width => 16,
      c_baat => 19,
      c_output_width => 35,
      c_type => 0,
      core_name0 => "mult_11_2_645200e4043096c0",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 35,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x8,
      b => constant15_op_net,
      ce => ce_1_sg_x390,
      clk => clk_1_sg_x390,
      clr => '0',
      core_ce => ce_1_sg_x390,
      core_clk => clk_1_sg_x390,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult15_p_net_x0
    );

  mult16: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 15,
      b_width => 16,
      c_a_type => 0,
      c_a_width => 19,
      c_b_type => 0,
      c_b_width => 16,
      c_baat => 19,
      c_output_width => 35,
      c_type => 0,
      core_name0 => "mult_11_2_645200e4043096c0",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 35,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x0,
      b => constant16_op_net,
      ce => ce_1_sg_x390,
      clk => clk_1_sg_x390,
      clr => '0',
      core_ce => ce_1_sg_x390,
      core_clk => clk_1_sg_x390,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult16_p_net_x0
    );

  mult17: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 15,
      b_width => 16,
      c_a_type => 0,
      c_a_width => 19,
      c_b_type => 0,
      c_b_width => 16,
      c_baat => 19,
      c_output_width => 35,
      c_type => 0,
      core_name0 => "mult_11_2_645200e4043096c0",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 35,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x9,
      b => constant4_op_net,
      ce => ce_1_sg_x390,
      clk => clk_1_sg_x390,
      clr => '0',
      core_ce => ce_1_sg_x390,
      core_clk => clk_1_sg_x390,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult17_p_net_x0
    );

  mult2: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 15,
      b_width => 16,
      c_a_type => 0,
      c_a_width => 19,
      c_b_type => 0,
      c_b_width => 16,
      c_baat => 19,
      c_output_width => 35,
      c_type => 0,
      core_name0 => "mult_11_2_645200e4043096c0",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 35,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x10,
      b => constant6_op_net,
      ce => ce_1_sg_x390,
      clk => clk_1_sg_x390,
      clr => '0',
      core_ce => ce_1_sg_x390,
      core_clk => clk_1_sg_x390,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult2_p_net_x0
    );

  mult3: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 15,
      b_width => 16,
      c_a_type => 0,
      c_a_width => 19,
      c_b_type => 0,
      c_b_width => 16,
      c_baat => 19,
      c_output_width => 35,
      c_type => 0,
      core_name0 => "mult_11_2_645200e4043096c0",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 35,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x11,
      b => constant3_op_net,
      ce => ce_1_sg_x390,
      clk => clk_1_sg_x390,
      clr => '0',
      core_ce => ce_1_sg_x390,
      core_clk => clk_1_sg_x390,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult3_p_net_x0
    );

  mult4: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 15,
      b_width => 16,
      c_a_type => 0,
      c_a_width => 19,
      c_b_type => 0,
      c_b_width => 16,
      c_baat => 19,
      c_output_width => 35,
      c_type => 0,
      core_name0 => "mult_11_2_645200e4043096c0",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 35,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x12,
      b => constant1_op_net,
      ce => ce_1_sg_x390,
      clk => clk_1_sg_x390,
      clr => '0',
      core_ce => ce_1_sg_x390,
      core_clk => clk_1_sg_x390,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult4_p_net_x0
    );

  mult5: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 15,
      b_width => 16,
      c_a_type => 0,
      c_a_width => 19,
      c_b_type => 0,
      c_b_width => 16,
      c_baat => 19,
      c_output_width => 35,
      c_type => 0,
      core_name0 => "mult_11_2_645200e4043096c0",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 35,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x13,
      b => constant2_op_net,
      ce => ce_1_sg_x390,
      clk => clk_1_sg_x390,
      clr => '0',
      core_ce => ce_1_sg_x390,
      core_clk => clk_1_sg_x390,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult5_p_net_x0
    );

  mult6: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 15,
      b_width => 16,
      c_a_type => 0,
      c_a_width => 19,
      c_b_type => 0,
      c_b_width => 16,
      c_baat => 19,
      c_output_width => 35,
      c_type => 0,
      core_name0 => "mult_11_2_645200e4043096c0",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 35,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x2,
      b => constant5_op_net,
      ce => ce_1_sg_x390,
      clk => clk_1_sg_x390,
      clr => '0',
      core_ce => ce_1_sg_x390,
      core_clk => clk_1_sg_x390,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult6_p_net_x0
    );

  mult7: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 15,
      b_width => 16,
      c_a_type => 0,
      c_a_width => 19,
      c_b_type => 0,
      c_b_width => 16,
      c_baat => 19,
      c_output_width => 35,
      c_type => 0,
      core_name0 => "mult_11_2_645200e4043096c0",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 35,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x14,
      b => constant7_op_net,
      ce => ce_1_sg_x390,
      clk => clk_1_sg_x390,
      clr => '0',
      core_ce => ce_1_sg_x390,
      core_clk => clk_1_sg_x390,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult7_p_net_x0
    );

  mult8: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 15,
      b_width => 16,
      c_a_type => 0,
      c_a_width => 19,
      c_b_type => 0,
      c_b_width => 16,
      c_baat => 19,
      c_output_width => 35,
      c_type => 0,
      core_name0 => "mult_11_2_645200e4043096c0",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 35,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x15,
      b => constant9_op_net,
      ce => ce_1_sg_x390,
      clk => clk_1_sg_x390,
      clr => '0',
      core_ce => ce_1_sg_x390,
      core_clk => clk_1_sg_x390,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult8_p_net_x0
    );

  mult9: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 19,
      b_arith => xlSigned,
      b_bin_pt => 15,
      b_width => 16,
      c_a_type => 0,
      c_a_width => 19,
      c_b_type => 0,
      c_b_width => 16,
      c_baat => 19,
      c_output_width => 35,
      c_type => 0,
      core_name0 => "mult_11_2_645200e4043096c0",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 35,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x16,
      b => constant11_op_net,
      ce => ce_1_sg_x390,
      clk => clk_1_sg_x390,
      clr => '0',
      core_ce => ce_1_sg_x390,
      core_clk => clk_1_sg_x390,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult9_p_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/downsample0/ri_to_c"

entity ri_to_c_entity_91cae541b1 is
  port (
    im: in std_logic_vector(18 downto 0); 
    re: in std_logic_vector(18 downto 0); 
    c: out std_logic_vector(37 downto 0)
  );
end ri_to_c_entity_91cae541b1;

architecture structural of ri_to_c_entity_91cae541b1 is
  signal concat_y_net_x0: std_logic_vector(37 downto 0);
  signal convert_dout_net_x2: std_logic_vector(18 downto 0);
  signal convert_dout_net_x3: std_logic_vector(18 downto 0);
  signal force_im_output_port_net: std_logic_vector(18 downto 0);
  signal force_re_output_port_net: std_logic_vector(18 downto 0);

begin
  convert_dout_net_x3 <= im;
  convert_dout_net_x2 <= re;
  c <= concat_y_net_x0;

  concat: entity work.concat_5a12f8f9be
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => force_re_output_port_net,
      in1 => force_im_output_port_net,
      y => concat_y_net_x0
    );

  force_im: entity work.reinterpret_bc4405cd1e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => convert_dout_net_x3,
      output_port => force_im_output_port_net
    );

  force_re: entity work.reinterpret_bc4405cd1e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => convert_dout_net_x2,
      output_port => force_re_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/downsample0"

entity downsample0_entity_dda67ea834 is
  port (
    ce_1: in std_logic; 
    ch_in: in std_logic_vector(7 downto 0); 
    clk_1: in std_logic; 
    data_in: in std_logic_vector(75 downto 0); 
    ch_out: out std_logic_vector(7 downto 0); 
    data_out: out std_logic_vector(37 downto 0)
  );
end downsample0_entity_dda67ea834;

architecture structural of downsample0_entity_dda67ea834 is
  signal ce_1_sg_x391: std_logic;
  signal clk_1_sg_x391: std_logic;
  signal concat_y_net_x1: std_logic_vector(37 downto 0);
  signal convert_dout_net_x2: std_logic_vector(18 downto 0);
  signal convert_dout_net_x3: std_logic_vector(18 downto 0);
  signal delay50_q_net_x1: std_logic_vector(75 downto 0);
  signal delay52_q_net_x1: std_logic_vector(7 downto 0);
  signal delay9_q_net_x1: std_logic_vector(7 downto 0);
  signal force_im_output_port_net_x3: std_logic_vector(18 downto 0);
  signal force_im_output_port_net_x4: std_logic_vector(18 downto 0);
  signal force_re_output_port_net_x3: std_logic_vector(18 downto 0);
  signal force_re_output_port_net_x4: std_logic_vector(18 downto 0);
  signal reinterpret1_output_port_net_x1: std_logic_vector(37 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(37 downto 0);

begin
  ce_1_sg_x391 <= ce_1;
  delay52_q_net_x1 <= ch_in;
  clk_1_sg_x391 <= clk_1;
  delay50_q_net_x1 <= data_in;
  ch_out <= delay9_q_net_x1;
  data_out <= concat_y_net_x1;

  bus_expand3_6f3d297a6d: entity work.bus_expand3_entity_6f3d297a6d
    port map (
      bus_in => delay50_q_net_x1,
      lsb_out1 => reinterpret1_output_port_net_x1,
      msb_out2 => reinterpret2_output_port_net_x1
    );

  c_to_ri1_b578a5eeb3: entity work.c_to_ri1_entity_f17f9bae25
    port map (
      c => reinterpret2_output_port_net_x1,
      im => force_im_output_port_net_x3,
      re => force_re_output_port_net_x3
    );

  c_to_ri6_3db4b84958: entity work.c_to_ri1_entity_f17f9bae25
    port map (
      c => reinterpret1_output_port_net_x1,
      im => force_im_output_port_net_x4,
      re => force_re_output_port_net_x4
    );

  lpf_fir_i1_871bd92da5: entity work.lpf_fir_i1_entity_871bd92da5
    port map (
      ce_1 => ce_1_sg_x391,
      clk_1 => clk_1_sg_x391,
      data0 => force_im_output_port_net_x3,
      data1 => force_im_output_port_net_x4,
      misc_in => delay52_q_net_x1,
      data_out => convert_dout_net_x3,
      misc_out => delay9_q_net_x1
    );

  lpf_fir_i_cfa52409f6: entity work.lpf_fir_i_entity_cfa52409f6
    port map (
      ce_1 => ce_1_sg_x391,
      clk_1 => clk_1_sg_x391,
      data0 => force_re_output_port_net_x3,
      data1 => force_re_output_port_net_x4,
      data_out => convert_dout_net_x2
    );

  ri_to_c_91cae541b1: entity work.ri_to_c_entity_91cae541b1
    port map (
      im => convert_dout_net_x3,
      re => convert_dout_net_x2,
      c => concat_y_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/gbe64/dest_ip"

entity dest_ip_entity_f282734290 is
  port (
    darkquad29_gbe64_dest_ip_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end dest_ip_entity_f282734290;

architecture structural of dest_ip_entity_f282734290 is
  signal darkquad29_gbe64_dest_ip_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_gbe64_dest_ip_user_data_out_net_x0 <= darkquad29_gbe64_dest_ip_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_gbe64_dest_ip_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/gbe64/one_gbe"

entity one_gbe_entity_ea96428be5 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    rx_ack: in std_logic; 
    tx_data: in std_logic_vector(7 downto 0); 
    tx_destip: in std_logic_vector(31 downto 0); 
    tx_destport: in std_logic_vector(15 downto 0); 
    tx_eof: in std_logic; 
    tx_rst: in std_logic; 
    tx_val: in std_logic; 
    convert_rx_ack_x0: out std_logic; 
    convert_rx_rst_x0: out std_logic; 
    convert_tx_data_x0: out std_logic_vector(7 downto 0); 
    convert_tx_dest_ip_x0: out std_logic_vector(31 downto 0); 
    convert_tx_end_of_frame_x0: out std_logic; 
    convert_tx_port_x0: out std_logic_vector(15 downto 0); 
    convert_tx_rst_x0: out std_logic; 
    convert_tx_valid_x0: out std_logic
  );
end one_gbe_entity_ea96428be5;

architecture structural of one_gbe_entity_ea96428be5 is
  signal ce_1_sg_x512: std_logic;
  signal clk_1_sg_x512: std_logic;
  signal constant3_op_net_x0: std_logic;
  signal convert_rx_ack_dout_net_x0: std_logic;
  signal convert_rx_rst_dout_net_x0: std_logic;
  signal convert_tx_data_dout_net_x0: std_logic_vector(7 downto 0);
  signal convert_tx_dest_ip_dout_net_x0: std_logic_vector(31 downto 0);
  signal convert_tx_end_of_frame_dout_net_x0: std_logic;
  signal convert_tx_port_dout_net_x0: std_logic_vector(15 downto 0);
  signal convert_tx_rst_dout_net_x0: std_logic;
  signal convert_tx_valid_dout_net_x0: std_logic;
  signal register1_q_net_x10: std_logic_vector(7 downto 0);
  signal register1_q_net_x5: std_logic;
  signal register1_q_net_x6: std_logic;
  signal register1_q_net_x7: std_logic_vector(31 downto 0);
  signal register1_q_net_x8: std_logic_vector(15 downto 0);
  signal register1_q_net_x9: std_logic;

begin
  ce_1_sg_x512 <= ce_1;
  clk_1_sg_x512 <= clk_1;
  constant3_op_net_x0 <= rx_ack;
  register1_q_net_x10 <= tx_data;
  register1_q_net_x7 <= tx_destip;
  register1_q_net_x8 <= tx_destport;
  register1_q_net_x5 <= tx_eof;
  register1_q_net_x6 <= tx_rst;
  register1_q_net_x9 <= tx_val;
  convert_rx_ack_x0 <= convert_rx_ack_dout_net_x0;
  convert_rx_rst_x0 <= convert_rx_rst_dout_net_x0;
  convert_tx_data_x0 <= convert_tx_data_dout_net_x0;
  convert_tx_dest_ip_x0 <= convert_tx_dest_ip_dout_net_x0;
  convert_tx_end_of_frame_x0 <= convert_tx_end_of_frame_dout_net_x0;
  convert_tx_port_x0 <= convert_tx_port_dout_net_x0;
  convert_tx_rst_x0 <= convert_tx_rst_dout_net_x0;
  convert_tx_valid_x0 <= convert_tx_valid_dout_net_x0;

  convert_rx_ack: entity work.xlconvert
    generic map (
      bool_conversion => 1,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x512,
      clk => clk_1_sg_x512,
      clr => '0',
      din(0) => constant3_op_net_x0,
      en => "1",
      dout(0) => convert_rx_ack_dout_net_x0
    );

  convert_rx_rst: entity work.xlconvert
    generic map (
      bool_conversion => 1,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x512,
      clk => clk_1_sg_x512,
      clr => '0',
      din(0) => register1_q_net_x6,
      en => "1",
      dout(0) => convert_rx_rst_dout_net_x0
    );

  convert_tx_data: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 8,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 8,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x512,
      clk => clk_1_sg_x512,
      clr => '0',
      din => register1_q_net_x10,
      en => "1",
      dout => convert_tx_data_dout_net_x0
    );

  convert_tx_dest_ip: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 32,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x512,
      clk => clk_1_sg_x512,
      clr => '0',
      din => register1_q_net_x7,
      en => "1",
      dout => convert_tx_dest_ip_dout_net_x0
    );

  convert_tx_end_of_frame: entity work.xlconvert
    generic map (
      bool_conversion => 1,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x512,
      clk => clk_1_sg_x512,
      clr => '0',
      din(0) => register1_q_net_x5,
      en => "1",
      dout(0) => convert_tx_end_of_frame_dout_net_x0
    );

  convert_tx_port: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 16,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 16,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x512,
      clk => clk_1_sg_x512,
      clr => '0',
      din => register1_q_net_x8,
      en => "1",
      dout => convert_tx_port_dout_net_x0
    );

  convert_tx_rst: entity work.xlconvert
    generic map (
      bool_conversion => 1,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x512,
      clk => clk_1_sg_x512,
      clr => '0',
      din(0) => register1_q_net_x6,
      en => "1",
      dout(0) => convert_tx_rst_dout_net_x0
    );

  convert_tx_valid: entity work.xlconvert
    generic map (
      bool_conversion => 1,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x512,
      clk => clk_1_sg_x512,
      clr => '0',
      din(0) => register1_q_net_x9,
      en => "1",
      dout(0) => convert_tx_valid_dout_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/gbe64/parallel_to_serial_converter/shifter_unit1"

entity shifter_unit1_entity_c759c3733a is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    pin: in std_logic_vector(63 downto 0); 
    prev: in std_logic_vector(7 downto 0); 
    reg_en: in std_logic; 
    sel: in std_logic; 
    dout: out std_logic_vector(7 downto 0)
  );
end shifter_unit1_entity_c759c3733a;

architecture structural of shifter_unit1_entity_c759c3733a is
  signal ce_1_sg_x513: std_logic;
  signal clk_1_sg_x513: std_logic;
  signal filler_op_net_x0: std_logic_vector(7 downto 0);
  signal logical1_y_net_x0: std_logic;
  signal logical_y_net_x0: std_logic;
  signal mux2_y_net: std_logic_vector(7 downto 0);
  signal mux_y_net_x0: std_logic_vector(63 downto 0);
  signal register1_q_net_x0: std_logic_vector(7 downto 0);
  signal slice_y_net: std_logic_vector(7 downto 0);

begin
  ce_1_sg_x513 <= ce_1;
  clk_1_sg_x513 <= clk_1;
  mux_y_net_x0 <= pin;
  filler_op_net_x0 <= prev;
  logical_y_net_x0 <= reg_en;
  logical1_y_net_x0 <= sel;
  dout <= register1_q_net_x0;

  mux2: entity work.mux_387191112d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0 => filler_op_net_x0,
      d1 => slice_y_net,
      sel(0) => logical1_y_net_x0,
      y => mux2_y_net
    );

  register1: entity work.xlregister
    generic map (
      d_width => 8,
      init_value => b"00000000"
    )
    port map (
      ce => ce_1_sg_x513,
      clk => clk_1_sg_x513,
      d => mux2_y_net,
      en(0) => logical_y_net_x0,
      rst => "0",
      q => register1_q_net_x0
    );

  slice: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 7,
      x_width => 64,
      y_width => 8
    )
    port map (
      x => mux_y_net_x0,
      y => slice_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/gbe64/parallel_to_serial_converter/shifter_unit2"

entity shifter_unit2_entity_e89ecc3e61 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    pin: in std_logic_vector(63 downto 0); 
    prev: in std_logic_vector(7 downto 0); 
    reg_en: in std_logic; 
    sel: in std_logic; 
    dout: out std_logic_vector(7 downto 0)
  );
end shifter_unit2_entity_e89ecc3e61;

architecture structural of shifter_unit2_entity_e89ecc3e61 is
  signal ce_1_sg_x514: std_logic;
  signal clk_1_sg_x514: std_logic;
  signal logical1_y_net_x1: std_logic;
  signal logical_y_net_x1: std_logic;
  signal mux2_y_net: std_logic_vector(7 downto 0);
  signal mux_y_net_x1: std_logic_vector(63 downto 0);
  signal register1_q_net_x1: std_logic_vector(7 downto 0);
  signal register1_q_net_x2: std_logic_vector(7 downto 0);
  signal slice_y_net: std_logic_vector(7 downto 0);

begin
  ce_1_sg_x514 <= ce_1;
  clk_1_sg_x514 <= clk_1;
  mux_y_net_x1 <= pin;
  register1_q_net_x1 <= prev;
  logical_y_net_x1 <= reg_en;
  logical1_y_net_x1 <= sel;
  dout <= register1_q_net_x2;

  mux2: entity work.mux_387191112d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0 => register1_q_net_x1,
      d1 => slice_y_net,
      sel(0) => logical1_y_net_x1,
      y => mux2_y_net
    );

  register1: entity work.xlregister
    generic map (
      d_width => 8,
      init_value => b"00000000"
    )
    port map (
      ce => ce_1_sg_x514,
      clk => clk_1_sg_x514,
      d => mux2_y_net,
      en(0) => logical_y_net_x1,
      rst => "0",
      q => register1_q_net_x2
    );

  slice: entity work.xlslice
    generic map (
      new_lsb => 8,
      new_msb => 15,
      x_width => 64,
      y_width => 8
    )
    port map (
      x => mux_y_net_x1,
      y => slice_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/gbe64/parallel_to_serial_converter/shifter_unit3"

entity shifter_unit3_entity_a30782ef45 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    pin: in std_logic_vector(63 downto 0); 
    prev: in std_logic_vector(7 downto 0); 
    reg_en: in std_logic; 
    sel: in std_logic; 
    dout: out std_logic_vector(7 downto 0)
  );
end shifter_unit3_entity_a30782ef45;

architecture structural of shifter_unit3_entity_a30782ef45 is
  signal ce_1_sg_x515: std_logic;
  signal clk_1_sg_x515: std_logic;
  signal logical1_y_net_x2: std_logic;
  signal logical_y_net_x2: std_logic;
  signal mux2_y_net: std_logic_vector(7 downto 0);
  signal mux_y_net_x2: std_logic_vector(63 downto 0);
  signal register1_q_net_x0: std_logic_vector(7 downto 0);
  signal register1_q_net_x3: std_logic_vector(7 downto 0);
  signal slice_y_net: std_logic_vector(7 downto 0);

begin
  ce_1_sg_x515 <= ce_1;
  clk_1_sg_x515 <= clk_1;
  mux_y_net_x2 <= pin;
  register1_q_net_x3 <= prev;
  logical_y_net_x2 <= reg_en;
  logical1_y_net_x2 <= sel;
  dout <= register1_q_net_x0;

  mux2: entity work.mux_387191112d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0 => register1_q_net_x3,
      d1 => slice_y_net,
      sel(0) => logical1_y_net_x2,
      y => mux2_y_net
    );

  register1: entity work.xlregister
    generic map (
      d_width => 8,
      init_value => b"00000000"
    )
    port map (
      ce => ce_1_sg_x515,
      clk => clk_1_sg_x515,
      d => mux2_y_net,
      en(0) => logical_y_net_x2,
      rst => "0",
      q => register1_q_net_x0
    );

  slice: entity work.xlslice
    generic map (
      new_lsb => 16,
      new_msb => 23,
      x_width => 64,
      y_width => 8
    )
    port map (
      x => mux_y_net_x2,
      y => slice_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/gbe64/parallel_to_serial_converter/shifter_unit4"

entity shifter_unit4_entity_a1ec328e18 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    pin: in std_logic_vector(63 downto 0); 
    prev: in std_logic_vector(7 downto 0); 
    reg_en: in std_logic; 
    sel: in std_logic; 
    dout: out std_logic_vector(7 downto 0)
  );
end shifter_unit4_entity_a1ec328e18;

architecture structural of shifter_unit4_entity_a1ec328e18 is
  signal ce_1_sg_x516: std_logic;
  signal clk_1_sg_x516: std_logic;
  signal logical1_y_net_x3: std_logic;
  signal logical_y_net_x3: std_logic;
  signal mux2_y_net: std_logic_vector(7 downto 0);
  signal mux_y_net_x3: std_logic_vector(63 downto 0);
  signal register1_q_net_x1: std_logic_vector(7 downto 0);
  signal register1_q_net_x2: std_logic_vector(7 downto 0);
  signal slice_y_net: std_logic_vector(7 downto 0);

begin
  ce_1_sg_x516 <= ce_1;
  clk_1_sg_x516 <= clk_1;
  mux_y_net_x3 <= pin;
  register1_q_net_x1 <= prev;
  logical_y_net_x3 <= reg_en;
  logical1_y_net_x3 <= sel;
  dout <= register1_q_net_x2;

  mux2: entity work.mux_387191112d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0 => register1_q_net_x1,
      d1 => slice_y_net,
      sel(0) => logical1_y_net_x3,
      y => mux2_y_net
    );

  register1: entity work.xlregister
    generic map (
      d_width => 8,
      init_value => b"00000000"
    )
    port map (
      ce => ce_1_sg_x516,
      clk => clk_1_sg_x516,
      d => mux2_y_net,
      en(0) => logical_y_net_x3,
      rst => "0",
      q => register1_q_net_x2
    );

  slice: entity work.xlslice
    generic map (
      new_lsb => 24,
      new_msb => 31,
      x_width => 64,
      y_width => 8
    )
    port map (
      x => mux_y_net_x3,
      y => slice_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/gbe64/parallel_to_serial_converter/shifter_unit5"

entity shifter_unit5_entity_a6d60cd269 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    pin: in std_logic_vector(63 downto 0); 
    prev: in std_logic_vector(7 downto 0); 
    reg_en: in std_logic; 
    sel: in std_logic; 
    dout: out std_logic_vector(7 downto 0)
  );
end shifter_unit5_entity_a6d60cd269;

architecture structural of shifter_unit5_entity_a6d60cd269 is
  signal ce_1_sg_x517: std_logic;
  signal clk_1_sg_x517: std_logic;
  signal logical1_y_net_x4: std_logic;
  signal logical_y_net_x4: std_logic;
  signal mux2_y_net: std_logic_vector(7 downto 0);
  signal mux_y_net_x4: std_logic_vector(63 downto 0);
  signal register1_q_net_x0: std_logic_vector(7 downto 0);
  signal register1_q_net_x3: std_logic_vector(7 downto 0);
  signal slice_y_net: std_logic_vector(7 downto 0);

begin
  ce_1_sg_x517 <= ce_1;
  clk_1_sg_x517 <= clk_1;
  mux_y_net_x4 <= pin;
  register1_q_net_x3 <= prev;
  logical_y_net_x4 <= reg_en;
  logical1_y_net_x4 <= sel;
  dout <= register1_q_net_x0;

  mux2: entity work.mux_387191112d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0 => register1_q_net_x3,
      d1 => slice_y_net,
      sel(0) => logical1_y_net_x4,
      y => mux2_y_net
    );

  register1: entity work.xlregister
    generic map (
      d_width => 8,
      init_value => b"00000000"
    )
    port map (
      ce => ce_1_sg_x517,
      clk => clk_1_sg_x517,
      d => mux2_y_net,
      en(0) => logical_y_net_x4,
      rst => "0",
      q => register1_q_net_x0
    );

  slice: entity work.xlslice
    generic map (
      new_lsb => 32,
      new_msb => 39,
      x_width => 64,
      y_width => 8
    )
    port map (
      x => mux_y_net_x4,
      y => slice_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/gbe64/parallel_to_serial_converter/shifter_unit6"

entity shifter_unit6_entity_e559c9f7a5 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    pin: in std_logic_vector(63 downto 0); 
    prev: in std_logic_vector(7 downto 0); 
    reg_en: in std_logic; 
    sel: in std_logic; 
    dout: out std_logic_vector(7 downto 0)
  );
end shifter_unit6_entity_e559c9f7a5;

architecture structural of shifter_unit6_entity_e559c9f7a5 is
  signal ce_1_sg_x518: std_logic;
  signal clk_1_sg_x518: std_logic;
  signal logical1_y_net_x5: std_logic;
  signal logical_y_net_x5: std_logic;
  signal mux2_y_net: std_logic_vector(7 downto 0);
  signal mux_y_net_x5: std_logic_vector(63 downto 0);
  signal register1_q_net_x1: std_logic_vector(7 downto 0);
  signal register1_q_net_x2: std_logic_vector(7 downto 0);
  signal slice_y_net: std_logic_vector(7 downto 0);

begin
  ce_1_sg_x518 <= ce_1;
  clk_1_sg_x518 <= clk_1;
  mux_y_net_x5 <= pin;
  register1_q_net_x1 <= prev;
  logical_y_net_x5 <= reg_en;
  logical1_y_net_x5 <= sel;
  dout <= register1_q_net_x2;

  mux2: entity work.mux_387191112d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0 => register1_q_net_x1,
      d1 => slice_y_net,
      sel(0) => logical1_y_net_x5,
      y => mux2_y_net
    );

  register1: entity work.xlregister
    generic map (
      d_width => 8,
      init_value => b"00000000"
    )
    port map (
      ce => ce_1_sg_x518,
      clk => clk_1_sg_x518,
      d => mux2_y_net,
      en(0) => logical_y_net_x5,
      rst => "0",
      q => register1_q_net_x2
    );

  slice: entity work.xlslice
    generic map (
      new_lsb => 40,
      new_msb => 47,
      x_width => 64,
      y_width => 8
    )
    port map (
      x => mux_y_net_x5,
      y => slice_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/gbe64/parallel_to_serial_converter/shifter_unit7"

entity shifter_unit7_entity_2f81e05175 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    pin: in std_logic_vector(63 downto 0); 
    prev: in std_logic_vector(7 downto 0); 
    reg_en: in std_logic; 
    sel: in std_logic; 
    dout: out std_logic_vector(7 downto 0)
  );
end shifter_unit7_entity_2f81e05175;

architecture structural of shifter_unit7_entity_2f81e05175 is
  signal ce_1_sg_x519: std_logic;
  signal clk_1_sg_x519: std_logic;
  signal logical1_y_net_x6: std_logic;
  signal logical_y_net_x6: std_logic;
  signal mux2_y_net: std_logic_vector(7 downto 0);
  signal mux_y_net_x6: std_logic_vector(63 downto 0);
  signal register1_q_net_x0: std_logic_vector(7 downto 0);
  signal register1_q_net_x3: std_logic_vector(7 downto 0);
  signal slice_y_net: std_logic_vector(7 downto 0);

begin
  ce_1_sg_x519 <= ce_1;
  clk_1_sg_x519 <= clk_1;
  mux_y_net_x6 <= pin;
  register1_q_net_x3 <= prev;
  logical_y_net_x6 <= reg_en;
  logical1_y_net_x6 <= sel;
  dout <= register1_q_net_x0;

  mux2: entity work.mux_387191112d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0 => register1_q_net_x3,
      d1 => slice_y_net,
      sel(0) => logical1_y_net_x6,
      y => mux2_y_net
    );

  register1: entity work.xlregister
    generic map (
      d_width => 8,
      init_value => b"00000000"
    )
    port map (
      ce => ce_1_sg_x519,
      clk => clk_1_sg_x519,
      d => mux2_y_net,
      en(0) => logical_y_net_x6,
      rst => "0",
      q => register1_q_net_x0
    );

  slice: entity work.xlslice
    generic map (
      new_lsb => 48,
      new_msb => 55,
      x_width => 64,
      y_width => 8
    )
    port map (
      x => mux_y_net_x6,
      y => slice_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/gbe64/parallel_to_serial_converter/shifter_unit8"

entity shifter_unit8_entity_a5860cc5d0 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    pin: in std_logic_vector(63 downto 0); 
    prev: in std_logic_vector(7 downto 0); 
    reg_en: in std_logic; 
    sel: in std_logic; 
    dout: out std_logic_vector(7 downto 0)
  );
end shifter_unit8_entity_a5860cc5d0;

architecture structural of shifter_unit8_entity_a5860cc5d0 is
  signal ce_1_sg_x520: std_logic;
  signal clk_1_sg_x520: std_logic;
  signal logical1_y_net_x7: std_logic;
  signal logical_y_net_x7: std_logic;
  signal mux2_y_net: std_logic_vector(7 downto 0);
  signal mux_y_net_x7: std_logic_vector(63 downto 0);
  signal register1_q_net_x1: std_logic_vector(7 downto 0);
  signal register1_q_net_x2: std_logic_vector(7 downto 0);
  signal slice_y_net: std_logic_vector(7 downto 0);

begin
  ce_1_sg_x520 <= ce_1;
  clk_1_sg_x520 <= clk_1;
  mux_y_net_x7 <= pin;
  register1_q_net_x1 <= prev;
  logical_y_net_x7 <= reg_en;
  logical1_y_net_x7 <= sel;
  dout <= register1_q_net_x2;

  mux2: entity work.mux_387191112d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0 => register1_q_net_x1,
      d1 => slice_y_net,
      sel(0) => logical1_y_net_x7,
      y => mux2_y_net
    );

  register1: entity work.xlregister
    generic map (
      d_width => 8,
      init_value => b"00000000"
    )
    port map (
      ce => ce_1_sg_x520,
      clk => clk_1_sg_x520,
      d => mux2_y_net,
      en(0) => logical_y_net_x7,
      rst => "0",
      q => register1_q_net_x2
    );

  slice: entity work.xlslice
    generic map (
      new_lsb => 56,
      new_msb => 63,
      x_width => 64,
      y_width => 8
    )
    port map (
      x => mux_y_net_x7,
      y => slice_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/gbe64/parallel_to_serial_converter"

entity parallel_to_serial_converter_entity_63483e2ebc is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    ld: in std_logic; 
    pin: in std_logic_vector(63 downto 0); 
    shift: in std_logic; 
    sout: out std_logic_vector(7 downto 0)
  );
end parallel_to_serial_converter_entity_63483e2ebc;

architecture structural of parallel_to_serial_converter_entity_63483e2ebc is
  signal ce_1_sg_x521: std_logic;
  signal clk_1_sg_x521: std_logic;
  signal constant1_op_net_x0: std_logic;
  signal filler_op_net_x0: std_logic_vector(7 downto 0);
  signal logical1_y_net_x8: std_logic;
  signal logical_y_net_x7: std_logic;
  signal mux_y_net_x8: std_logic_vector(63 downto 0);
  signal register1_q_net_x1: std_logic_vector(7 downto 0);
  signal register1_q_net_x2: std_logic_vector(7 downto 0);
  signal register1_q_net_x3: std_logic_vector(7 downto 0);
  signal register1_q_net_x4: std_logic_vector(7 downto 0);
  signal register1_q_net_x5: std_logic_vector(7 downto 0);
  signal register1_q_net_x6: std_logic_vector(7 downto 0);
  signal register1_q_net_x7: std_logic_vector(7 downto 0);
  signal register1_q_net_x9: std_logic_vector(7 downto 0);

begin
  ce_1_sg_x521 <= ce_1;
  clk_1_sg_x521 <= clk_1;
  logical1_y_net_x8 <= ld;
  mux_y_net_x8 <= pin;
  constant1_op_net_x0 <= shift;
  sout <= register1_q_net_x9;

  filler: entity work.constant_91ef1678ca
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => filler_op_net_x0
    );

  logical: entity work.logical_aacf6e1b0e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => logical1_y_net_x8,
      d1(0) => constant1_op_net_x0,
      y(0) => logical_y_net_x7
    );

  shifter_unit1_c759c3733a: entity work.shifter_unit1_entity_c759c3733a
    port map (
      ce_1 => ce_1_sg_x521,
      clk_1 => clk_1_sg_x521,
      pin => mux_y_net_x8,
      prev => filler_op_net_x0,
      reg_en => logical_y_net_x7,
      sel => logical1_y_net_x8,
      dout => register1_q_net_x1
    );

  shifter_unit2_e89ecc3e61: entity work.shifter_unit2_entity_e89ecc3e61
    port map (
      ce_1 => ce_1_sg_x521,
      clk_1 => clk_1_sg_x521,
      pin => mux_y_net_x8,
      prev => register1_q_net_x1,
      reg_en => logical_y_net_x7,
      sel => logical1_y_net_x8,
      dout => register1_q_net_x3
    );

  shifter_unit3_a30782ef45: entity work.shifter_unit3_entity_a30782ef45
    port map (
      ce_1 => ce_1_sg_x521,
      clk_1 => clk_1_sg_x521,
      pin => mux_y_net_x8,
      prev => register1_q_net_x3,
      reg_en => logical_y_net_x7,
      sel => logical1_y_net_x8,
      dout => register1_q_net_x2
    );

  shifter_unit4_a1ec328e18: entity work.shifter_unit4_entity_a1ec328e18
    port map (
      ce_1 => ce_1_sg_x521,
      clk_1 => clk_1_sg_x521,
      pin => mux_y_net_x8,
      prev => register1_q_net_x2,
      reg_en => logical_y_net_x7,
      sel => logical1_y_net_x8,
      dout => register1_q_net_x4
    );

  shifter_unit5_a6d60cd269: entity work.shifter_unit5_entity_a6d60cd269
    port map (
      ce_1 => ce_1_sg_x521,
      clk_1 => clk_1_sg_x521,
      pin => mux_y_net_x8,
      prev => register1_q_net_x4,
      reg_en => logical_y_net_x7,
      sel => logical1_y_net_x8,
      dout => register1_q_net_x5
    );

  shifter_unit6_e559c9f7a5: entity work.shifter_unit6_entity_e559c9f7a5
    port map (
      ce_1 => ce_1_sg_x521,
      clk_1 => clk_1_sg_x521,
      pin => mux_y_net_x8,
      prev => register1_q_net_x5,
      reg_en => logical_y_net_x7,
      sel => logical1_y_net_x8,
      dout => register1_q_net_x6
    );

  shifter_unit7_2f81e05175: entity work.shifter_unit7_entity_2f81e05175
    port map (
      ce_1 => ce_1_sg_x521,
      clk_1 => clk_1_sg_x521,
      pin => mux_y_net_x8,
      prev => register1_q_net_x6,
      reg_en => logical_y_net_x7,
      sel => logical1_y_net_x8,
      dout => register1_q_net_x7
    );

  shifter_unit8_a5860cc5d0: entity work.shifter_unit8_entity_a5860cc5d0
    port map (
      ce_1 => ce_1_sg_x521,
      clk_1 => clk_1_sg_x521,
      pin => mux_y_net_x8,
      prev => register1_q_net_x7,
      reg_en => logical_y_net_x7,
      sel => logical1_y_net_x8,
      dout => register1_q_net_x9
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/gbe64/pipeline4"

entity pipeline4_entity_3f38674c3b is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(15 downto 0); 
    q: out std_logic_vector(15 downto 0)
  );
end pipeline4_entity_3f38674c3b;

architecture structural of pipeline4_entity_3f38674c3b is
  signal ce_1_sg_x529: std_logic;
  signal clk_1_sg_x529: std_logic;
  signal mux1_y_net_x0: std_logic_vector(15 downto 0);
  signal register0_q_net: std_logic_vector(15 downto 0);
  signal register1_q_net_x9: std_logic_vector(15 downto 0);

begin
  ce_1_sg_x529 <= ce_1;
  clk_1_sg_x529 <= clk_1;
  mux1_y_net_x0 <= d;
  q <= register1_q_net_x9;

  register0: entity work.xlregister
    generic map (
      d_width => 16,
      init_value => b"0000000000000000"
    )
    port map (
      ce => ce_1_sg_x529,
      clk => clk_1_sg_x529,
      d => mux1_y_net_x0,
      en => "1",
      rst => "0",
      q => register0_q_net
    );

  register1: entity work.xlregister
    generic map (
      d_width => 16,
      init_value => b"0000000000000000"
    )
    port map (
      ce => ce_1_sg_x529,
      clk => clk_1_sg_x529,
      d => register0_q_net,
      en => "1",
      rst => "0",
      q => register1_q_net_x9
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/gbe64/pulse_ext"

entity pulse_ext_entity_fc00163540 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic; 
    out_x0: out std_logic
  );
end pulse_ext_entity_fc00163540;

architecture structural of pulse_ext_entity_fc00163540 is
  signal ce_1_sg_x536: std_logic;
  signal clk_1_sg_x536: std_logic;
  signal constant5_op_net: std_logic_vector(3 downto 0);
  signal counter3_op_net: std_logic_vector(3 downto 0);
  signal edge_op_y_net_x0: std_logic;
  signal logical1_y_net_x10: std_logic;
  signal relational5_op_net_x1: std_logic;

begin
  ce_1_sg_x536 <= ce_1;
  clk_1_sg_x536 <= clk_1;
  logical1_y_net_x10 <= in_x0;
  out_x0 <= relational5_op_net_x1;

  constant5: entity work.constant_145086465d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant5_op_net
    );

  counter3: entity work.xlcounter_free_darkquad29
    generic map (
      core_name0 => "cntr_11_0_68b407ad69be9ca8",
      op_arith => xlUnsigned,
      op_width => 4
    )
    port map (
      ce => ce_1_sg_x536,
      clk => clk_1_sg_x536,
      clr => '0',
      en(0) => relational5_op_net_x1,
      rst(0) => edge_op_y_net_x0,
      op => counter3_op_net
    );

  edge_detect_bd2172338e: entity work.edge_detect3_entity_2efb246ca9
    port map (
      ce_1 => ce_1_sg_x536,
      clk_1 => clk_1_sg_x536,
      in_x0 => logical1_y_net_x10,
      out_x0 => edge_op_y_net_x0
    );

  relational5: entity work.relational_d930162434
    port map (
      a => counter3_op_net,
      b => constant5_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational5_op_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/gbe64/pulse_ext1"

entity pulse_ext1_entity_e142e9180b is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic; 
    out_x0: out std_logic
  );
end pulse_ext1_entity_e142e9180b;

architecture structural of pulse_ext1_entity_e142e9180b is
  signal ce_1_sg_x538: std_logic;
  signal clk_1_sg_x538: std_logic;
  signal constant5_op_net: std_logic_vector(2 downto 0);
  signal counter3_op_net: std_logic_vector(2 downto 0);
  signal edge_op_y_net_x0: std_logic;
  signal logical6_y_net_x1: std_logic;
  signal relational5_op_net_x0: std_logic;

begin
  ce_1_sg_x538 <= ce_1;
  clk_1_sg_x538 <= clk_1;
  logical6_y_net_x1 <= in_x0;
  out_x0 <= relational5_op_net_x0;

  constant5: entity work.constant_263f209841
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant5_op_net
    );

  counter3: entity work.xlcounter_free_darkquad29
    generic map (
      core_name0 => "cntr_11_0_b8dff8f48773e3e9",
      op_arith => xlUnsigned,
      op_width => 3
    )
    port map (
      ce => ce_1_sg_x538,
      clk => clk_1_sg_x538,
      clr => '0',
      en(0) => relational5_op_net_x0,
      rst(0) => edge_op_y_net_x0,
      op => counter3_op_net
    );

  edge_detect_b820179329: entity work.edge_detect3_entity_2efb246ca9
    port map (
      ce_1 => ce_1_sg_x538,
      clk_1 => clk_1_sg_x538,
      in_x0 => logical6_y_net_x1,
      out_x0 => edge_op_y_net_x0
    );

  relational5: entity work.relational_47b317dab6
    port map (
      a => counter3_op_net,
      b => constant5_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational5_op_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/gbe64/rst"

entity rst_entity_fe59562225 is
  port (
    darkquad29_gbe64_rst_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end rst_entity_fe59562225;

architecture structural of rst_entity_fe59562225 is
  signal darkquad29_gbe64_rst_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_gbe64_rst_user_data_out_net_x0 <= darkquad29_gbe64_rst_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_gbe64_rst_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/gbe64/words_per_frame"

entity words_per_frame_entity_ec89b6e999 is
  port (
    darkquad29_gbe64_words_per_frame_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end words_per_frame_entity_ec89b6e999;

architecture structural of words_per_frame_entity_ec89b6e999 is
  signal darkquad29_gbe64_words_per_frame_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_gbe64_words_per_frame_user_data_out_net_x0 <= darkquad29_gbe64_words_per_frame_user_data_out;
  in_reg <= reint1_output_port_net_x1;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_gbe64_words_per_frame_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x1
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/gbe64"

entity gbe64_entity_1d1f7cbd44 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    darkquad29_gbe64_dest_ip_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_gbe64_one_gbe_app_tx_afull: in std_logic; 
    darkquad29_gbe64_one_gbe_app_tx_overflow: in std_logic; 
    darkquad29_gbe64_rst_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_gbe64_words_per_frame_user_data_out: in std_logic_vector(31 downto 0); 
    data: in std_logic_vector(63 downto 0); 
    dest_port: in std_logic_vector(15 downto 0); 
    hdr: in std_logic_vector(63 downto 0); 
    hdr_ts: in std_logic_vector(35 downto 0); 
    rst_ctr: in std_logic; 
    run: in std_logic; 
    we: in std_logic; 
    eof_snt: out std_logic; 
    one_gbe: out std_logic; 
    one_gbe_x0: out std_logic; 
    one_gbe_x1: out std_logic_vector(7 downto 0); 
    one_gbe_x2: out std_logic_vector(31 downto 0); 
    one_gbe_x3: out std_logic; 
    one_gbe_x4: out std_logic_vector(15 downto 0); 
    one_gbe_x5: out std_logic; 
    one_gbe_x6: out std_logic; 
    tx_afull: out std_logic_vector(31 downto 0); 
    tx_overrun: out std_logic_vector(31 downto 0)
  );
end gbe64_entity_1d1f7cbd44;

architecture structural of gbe64_entity_1d1f7cbd44 is
  signal assert_phase_dout_net_x0: std_logic_vector(63 downto 0);
  signal cast_gw_dout_net_x2: std_logic_vector(31 downto 0);
  signal cast_gw_dout_net_x3: std_logic_vector(31 downto 0);
  signal ce_1_sg_x541: std_logic;
  signal clk_1_sg_x541: std_logic;
  signal concat1_y_net: std_logic_vector(64 downto 0);
  signal concat_y_net_x0: std_logic_vector(63 downto 0);
  signal concat_y_net_x1: std_logic_vector(63 downto 0);
  signal constant1_op_net_x0: std_logic;
  signal constant2_op_net: std_logic_vector(2 downto 0);
  signal constant3_op_net_x0: std_logic;
  signal constant6_op_net: std_logic;
  signal constant7_op_net: std_logic;
  signal convert14_dout_net_x0: std_logic_vector(31 downto 0);
  signal convert1_dout_net_x0: std_logic_vector(31 downto 0);
  signal convert_rx_ack_dout_net_x1: std_logic;
  signal convert_rx_rst_dout_net_x1: std_logic;
  signal convert_tx_data_dout_net_x1: std_logic_vector(7 downto 0);
  signal convert_tx_dest_ip_dout_net_x1: std_logic_vector(31 downto 0);
  signal convert_tx_end_of_frame_dout_net_x1: std_logic;
  signal convert_tx_port_dout_net_x1: std_logic_vector(15 downto 0);
  signal convert_tx_rst_dout_net_x1: std_logic;
  signal convert_tx_valid_dout_net_x1: std_logic;
  signal counter_op_net: std_logic_vector(2 downto 0);
  signal darkquad29_gbe64_dest_ip_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal darkquad29_gbe64_one_gbe_app_tx_afull_net_x1: std_logic;
  signal darkquad29_gbe64_one_gbe_app_tx_overflow_net_x1: std_logic;
  signal darkquad29_gbe64_rst_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal darkquad29_gbe64_words_per_frame_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal delay10_q_net: std_logic;
  signal delay11_q_net: std_logic_vector(63 downto 0);
  signal delay12_q_net: std_logic;
  signal delay13_q_net: std_logic_vector(64 downto 0);
  signal delay14_q_net: std_logic;
  signal delay15_q_net: std_logic;
  signal delay16_q_net: std_logic_vector(64 downto 0);
  signal delay17_q_net: std_logic;
  signal delay18_q_net: std_logic_vector(63 downto 0);
  signal delay19_q_net: std_logic;
  signal delay1_q_net_x0: std_logic;
  signal delay1_q_net_x1: std_logic;
  signal delay20_q_net: std_logic;
  signal delay21_q_net: std_logic_vector(63 downto 0);
  signal delay22_q_net: std_logic;
  signal delay23_q_net: std_logic;
  signal delay2_q_net_x0: std_logic;
  signal delay3_q_net: std_logic;
  signal delay4_q_net: std_logic;
  signal delay5_q_net_x0: std_logic_vector(63 downto 0);
  signal delay5_q_net_x1: std_logic_vector(35 downto 0);
  signal delay6_q_net: std_logic_vector(63 downto 0);
  signal delay7_q_net_x0: std_logic;
  signal delay8_q_net: std_logic;
  signal delay9_q_net: std_logic;
  signal delay_q_net: std_logic_vector(35 downto 0);
  signal edge_op_y_net_x2: std_logic;
  signal fake_pack_lsb_op_net: std_logic_vector(31 downto 0);
  signal fake_pack_msb_op_net: std_logic_vector(31 downto 0);
  signal fifo_dout_net: std_logic_vector(64 downto 0);
  signal fifo_empty_net: std_logic;
  signal inverter1_op_net: std_logic;
  signal inverter_op_net: std_logic;
  signal logical1_y_net_x10: std_logic;
  signal logical2_y_net: std_logic;
  signal logical3_y_net: std_logic;
  signal logical5_y_net: std_logic;
  signal logical6_y_net_x1: std_logic;
  signal logical_y_net: std_logic;
  signal mux1_y_net: std_logic_vector(63 downto 0);
  signal mux1_y_net_x1: std_logic_vector(15 downto 0);
  signal mux2_y_net: std_logic;
  signal mux3_y_net: std_logic;
  signal mux5_y_net_x0: std_logic;
  signal mux_y_net_x8: std_logic_vector(63 downto 0);
  signal pkts_in_frame_op_net: std_logic_vector(11 downto 0);
  signal register1_q_net_x0: std_logic_vector(31 downto 0);
  signal register1_q_net_x1: std_logic;
  signal register1_q_net_x10: std_logic;
  signal register1_q_net_x11: std_logic_vector(7 downto 0);
  signal register1_q_net_x12: std_logic_vector(31 downto 0);
  signal register1_q_net_x13: std_logic_vector(7 downto 0);
  signal register1_q_net_x2: std_logic;
  signal register1_q_net_x3: std_logic;
  signal register1_q_net_x4: std_logic;
  signal register1_q_net_x5: std_logic;
  signal register1_q_net_x6: std_logic;
  signal register1_q_net_x7: std_logic;
  signal register1_q_net_x8: std_logic;
  signal register1_q_net_x9: std_logic_vector(15 downto 0);
  signal register_q_net_x0: std_logic;
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x2: std_logic_vector(31 downto 0);
  signal relational1_op_net_x0: std_logic;
  signal relational4_op_net: std_logic;
  signal relational5_op_net_x0: std_logic;
  signal relational5_op_net_x1: std_logic;
  signal relational_op_net: std_logic;
  signal slice1_y_net: std_logic;
  signal slice2_y_net_x0: std_logic;
  signal slice3_y_net: std_logic;
  signal slice_y_net: std_logic_vector(63 downto 0);

begin
  ce_1_sg_x541 <= ce_1;
  clk_1_sg_x541 <= clk_1;
  darkquad29_gbe64_dest_ip_user_data_out_net_x1 <= darkquad29_gbe64_dest_ip_user_data_out;
  darkquad29_gbe64_one_gbe_app_tx_afull_net_x1 <= darkquad29_gbe64_one_gbe_app_tx_afull;
  darkquad29_gbe64_one_gbe_app_tx_overflow_net_x1 <= darkquad29_gbe64_one_gbe_app_tx_overflow;
  darkquad29_gbe64_rst_user_data_out_net_x1 <= darkquad29_gbe64_rst_user_data_out;
  darkquad29_gbe64_words_per_frame_user_data_out_net_x1 <= darkquad29_gbe64_words_per_frame_user_data_out;
  assert_phase_dout_net_x0 <= data;
  mux1_y_net_x1 <= dest_port;
  concat_y_net_x1 <= hdr;
  delay5_q_net_x1 <= hdr_ts;
  edge_op_y_net_x2 <= rst_ctr;
  delay1_q_net_x1 <= run;
  mux5_y_net_x0 <= we;
  eof_snt <= delay7_q_net_x0;
  one_gbe <= convert_rx_ack_dout_net_x1;
  one_gbe_x0 <= convert_rx_rst_dout_net_x1;
  one_gbe_x1 <= convert_tx_data_dout_net_x1;
  one_gbe_x2 <= convert_tx_dest_ip_dout_net_x1;
  one_gbe_x3 <= convert_tx_end_of_frame_dout_net_x1;
  one_gbe_x4 <= convert_tx_port_dout_net_x1;
  one_gbe_x5 <= convert_tx_rst_dout_net_x1;
  one_gbe_x6 <= convert_tx_valid_dout_net_x1;
  tx_afull <= cast_gw_dout_net_x2;
  tx_overrun <= cast_gw_dout_net_x3;

  concat: entity work.concat_62c4475a80
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => fake_pack_msb_op_net,
      in1 => fake_pack_lsb_op_net,
      y => concat_y_net_x0
    );

  concat1: entity work.concat_91ba16440d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => mux1_y_net,
      in1(0) => slice1_y_net,
      y => concat1_y_net
    );

  constant1: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant1_op_net_x0
    );

  constant2: entity work.constant_822933f89b
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant2_op_net
    );

  constant3: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant3_op_net_x0
    );

  constant6: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant6_op_net
    );

  constant7: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant7_op_net
    );

  convert1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      clr => '0',
      din(0) => register1_q_net_x5,
      en => "1",
      dout => convert1_dout_net_x0
    );

  convert14: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      clr => '0',
      din(0) => register1_q_net_x4,
      en => "1",
      dout => convert14_dout_net_x0
    );

  counter: entity work.xlcounter_free_darkquad29
    generic map (
      core_name0 => "cntr_11_0_b8dff8f48773e3e9",
      op_arith => xlUnsigned,
      op_width => 3
    )
    port map (
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      clr => '0',
      en => "1",
      rst => "0",
      op => counter_op_net
    );

  delay: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 36
    )
    port map (
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      d => delay5_q_net_x1,
      en => '1',
      rst => '1',
      q => delay_q_net
    );

  delay1: entity work.xldelay
    generic map (
      latency => 8,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      d(0) => logical6_y_net_x1,
      en => '1',
      rst => '1',
      q(0) => delay1_q_net_x0
    );

  delay10: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      d(0) => logical_y_net,
      en => '1',
      rst => '1',
      q(0) => delay10_q_net
    );

  delay11: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 64
    )
    port map (
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      d => assert_phase_dout_net_x0,
      en => '1',
      rst => '1',
      q => delay11_q_net
    );

  delay12: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      d(0) => delay15_q_net,
      en => '1',
      rst => '1',
      q(0) => delay12_q_net
    );

  delay13: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 65
    )
    port map (
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      d => delay16_q_net,
      en => '1',
      rst => '1',
      q => delay13_q_net
    );

  delay14: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      d(0) => register1_q_net_x7,
      en => '1',
      rst => '1',
      q(0) => delay14_q_net
    );

  delay15: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      d(0) => mux3_y_net,
      en => '1',
      rst => '1',
      q(0) => delay15_q_net
    );

  delay16: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 65
    )
    port map (
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      d => concat1_y_net,
      en => '1',
      rst => '1',
      q => delay16_q_net
    );

  delay17: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      d(0) => delay20_q_net,
      en => '1',
      rst => '1',
      q(0) => delay17_q_net
    );

  delay18: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 64
    )
    port map (
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      d => delay21_q_net,
      en => '1',
      rst => '1',
      q => delay18_q_net
    );

  delay19: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      d(0) => logical5_y_net,
      en => '1',
      rst => '1',
      q(0) => delay19_q_net
    );

  delay2: entity work.xldelay
    generic map (
      latency => 8,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      d(0) => delay7_q_net_x0,
      en => '1',
      rst => '1',
      q(0) => delay2_q_net_x0
    );

  delay20: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      d(0) => delay9_q_net,
      en => '1',
      rst => '1',
      q(0) => delay20_q_net
    );

  delay21: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 64
    )
    port map (
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      d => delay11_q_net,
      en => '1',
      rst => '1',
      q => delay21_q_net
    );

  delay22: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      d(0) => delay1_q_net_x1,
      en => '1',
      rst => '1',
      q(0) => delay22_q_net
    );

  delay23: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      d(0) => delay19_q_net,
      en => '1',
      rst => '1',
      q(0) => delay23_q_net
    );

  delay3: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      d(0) => fifo_empty_net,
      en => '1',
      rst => '1',
      q(0) => delay3_q_net
    );

  delay4: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      d(0) => logical2_y_net,
      en => '1',
      rst => '1',
      q(0) => delay4_q_net
    );

  delay5: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 64
    )
    port map (
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      d => slice_y_net,
      en => '1',
      rst => '1',
      q => delay5_q_net_x0
    );

  delay6: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 64
    )
    port map (
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      d => delay5_q_net_x0,
      en => '1',
      rst => '1',
      q => delay6_q_net
    );

  delay7: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      d(0) => logical6_y_net_x1,
      en => '1',
      rst => '1',
      q(0) => delay7_q_net_x0
    );

  delay8: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      d(0) => slice3_y_net,
      en => '1',
      rst => '1',
      q(0) => delay8_q_net
    );

  delay9: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      d(0) => mux5_y_net_x0,
      en => '1',
      rst => '1',
      q(0) => delay9_q_net
    );

  dest_ip_f282734290: entity work.dest_ip_entity_f282734290
    port map (
      darkquad29_gbe64_dest_ip_user_data_out => darkquad29_gbe64_dest_ip_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x1
    );

  fake_pack_lsb: entity work.constant_754435d9c5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => fake_pack_lsb_op_net
    );

  fake_pack_msb: entity work.constant_38c2d03959
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => fake_pack_msb_op_net
    );

  fifo: entity work.xlfifogen_darkquad29
    generic map (
      core_name0 => "fifo_fg92_722742878aa74e71",
      data_count_width => 11,
      data_width => 65,
      has_ae => 0,
      has_af => 0,
      percent_full_width => 1
    )
    port map (
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      din => delay13_q_net,
      en => '1',
      re => logical2_y_net,
      re_ce => ce_1_sg_x541,
      rst => '1',
      we => delay12_q_net,
      we_ce => ce_1_sg_x541,
      dout => fifo_dout_net,
      empty => fifo_empty_net
    );

  inverter: entity work.inverter_e5b38cca3b
    port map (
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      clr => '0',
      ip(0) => delay3_q_net,
      op(0) => inverter_op_net
    );

  inverter1: entity work.inverter_e5b38cca3b
    port map (
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      clr => '0',
      ip(0) => relational5_op_net_x0,
      op(0) => inverter1_op_net
    );

  logical: entity work.logical_799f62af22
    port map (
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      clr => '0',
      d0(0) => inverter_op_net,
      d1(0) => delay4_q_net,
      y(0) => logical_y_net
    );

  logical1: entity work.logical_444d3f5046
    port map (
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      clr => '0',
      d0(0) => delay1_q_net_x0,
      d1(0) => delay10_q_net,
      y(0) => logical1_y_net_x10
    );

  logical2: entity work.logical_799f62af22
    port map (
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      clr => '0',
      d0(0) => inverter1_op_net,
      d1(0) => relational_op_net,
      y(0) => logical2_y_net
    );

  logical3: entity work.logical_6cb8f0ce02
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => logical5_y_net,
      d1(0) => relational1_op_net_x0,
      d2(0) => register1_q_net_x3,
      y(0) => logical3_y_net
    );

  logical5: entity work.logical_80f90b97d0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => delay22_q_net,
      d1(0) => relational4_op_net,
      y(0) => logical5_y_net
    );

  logical6: entity work.logical_799f62af22
    port map (
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      clr => '0',
      d0(0) => logical_y_net,
      d1(0) => delay8_q_net,
      y(0) => logical6_y_net_x1
    );

  mux: entity work.mux_fd01d62b53
    port map (
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      clr => '0',
      d0 => delay6_q_net,
      d1 => concat_y_net_x1,
      sel(0) => delay1_q_net_x0,
      y => mux_y_net_x8
    );

  mux1: entity work.mux_fd01d62b53
    port map (
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      clr => '0',
      d0 => concat_y_net_x0,
      d1 => delay18_q_net,
      sel(0) => delay17_q_net,
      y => mux1_y_net
    );

  mux2: entity work.mux_1e22c21d05
    port map (
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      clr => '0',
      d0(0) => delay14_q_net,
      d1(0) => constant7_op_net,
      sel(0) => delay23_q_net,
      y(0) => mux2_y_net
    );

  mux3: entity work.mux_1e22c21d05
    port map (
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      clr => '0',
      d0(0) => delay17_q_net,
      d1(0) => constant6_op_net,
      sel(0) => delay23_q_net,
      y(0) => mux3_y_net
    );

  one_gbe_ea96428be5: entity work.one_gbe_entity_ea96428be5
    port map (
      ce_1 => ce_1_sg_x541,
      clk_1 => clk_1_sg_x541,
      rx_ack => constant3_op_net_x0,
      tx_data => register1_q_net_x13,
      tx_destip => register1_q_net_x12,
      tx_destport => register1_q_net_x9,
      tx_eof => register1_q_net_x6,
      tx_rst => register1_q_net_x8,
      tx_val => register1_q_net_x10,
      convert_rx_ack_x0 => convert_rx_ack_dout_net_x1,
      convert_rx_rst_x0 => convert_rx_rst_dout_net_x1,
      convert_tx_data_x0 => convert_tx_data_dout_net_x1,
      convert_tx_dest_ip_x0 => convert_tx_dest_ip_dout_net_x1,
      convert_tx_end_of_frame_x0 => convert_tx_end_of_frame_dout_net_x1,
      convert_tx_port_x0 => convert_tx_port_dout_net_x1,
      convert_tx_rst_x0 => convert_tx_rst_dout_net_x1,
      convert_tx_valid_x0 => convert_tx_valid_dout_net_x1
    );

  parallel_to_serial_converter_63483e2ebc: entity work.parallel_to_serial_converter_entity_63483e2ebc
    port map (
      ce_1 => ce_1_sg_x541,
      clk_1 => clk_1_sg_x541,
      ld => logical1_y_net_x10,
      pin => mux_y_net_x8,
      shift => constant1_op_net_x0,
      sout => register1_q_net_x11
    );

  pipeline10_6f45665052: entity work.pipeline3_entity_fb0a315a6d
    port map (
      ce_1 => ce_1_sg_x541,
      clk_1 => clk_1_sg_x541,
      d => register1_q_net_x8,
      q => register1_q_net_x1
    );

  pipeline11_7ab4efcabe: entity work.pipeline3_entity_fb0a315a6d
    port map (
      ce_1 => ce_1_sg_x541,
      clk_1 => clk_1_sg_x541,
      d => darkquad29_gbe64_one_gbe_app_tx_overflow_net_x1,
      q => register1_q_net_x2
    );

  pipeline12_4c826e82fd: entity work.pipeline3_entity_fb0a315a6d
    port map (
      ce_1 => ce_1_sg_x541,
      clk_1 => clk_1_sg_x541,
      d => delay2_q_net_x0,
      q => register1_q_net_x6
    );

  pipeline13_ec16172496: entity work.pipeline3_entity_fb0a315a6d
    port map (
      ce_1 => ce_1_sg_x541,
      clk_1 => clk_1_sg_x541,
      d => edge_op_y_net_x2,
      q => register1_q_net_x3
    );

  pipeline1_2d5ba9e0c8: entity work.pipeline1_entity_986e3344b8
    port map (
      ce_1 => ce_1_sg_x541,
      clk_1 => clk_1_sg_x541,
      d => reint1_output_port_net_x2,
      q => register1_q_net_x0
    );

  pipeline2_cc8cf45cc8: entity work.pipeline3_entity_fb0a315a6d
    port map (
      ce_1 => ce_1_sg_x541,
      clk_1 => clk_1_sg_x541,
      d => slice2_y_net_x0,
      q => register1_q_net_x8
    );

  pipeline3_674103f473: entity work.pipeline1_entity_986e3344b8
    port map (
      ce_1 => ce_1_sg_x541,
      clk_1 => clk_1_sg_x541,
      d => reint1_output_port_net_x1,
      q => register1_q_net_x12
    );

  pipeline4_3f38674c3b: entity work.pipeline4_entity_3f38674c3b
    port map (
      ce_1 => ce_1_sg_x541,
      clk_1 => clk_1_sg_x541,
      d => mux1_y_net_x1,
      q => register1_q_net_x9
    );

  pipeline5_e38399f7c1: entity work.pipeline3_entity_fb0a315a6d
    port map (
      ce_1 => ce_1_sg_x541,
      clk_1 => clk_1_sg_x541,
      d => darkquad29_gbe64_one_gbe_app_tx_afull_net_x1,
      q => register1_q_net_x4
    );

  pipeline6_889d76973b: entity work.pipeline3_entity_fb0a315a6d
    port map (
      ce_1 => ce_1_sg_x541,
      clk_1 => clk_1_sg_x541,
      d => register_q_net_x0,
      q => register1_q_net_x5
    );

  pipeline7_6038b43e2f: entity work.pipeline3_entity_fb0a315a6d
    port map (
      ce_1 => ce_1_sg_x541,
      clk_1 => clk_1_sg_x541,
      d => relational1_op_net_x0,
      q => register1_q_net_x7
    );

  pipeline8_53d1ccf85c: entity work.pipeline3_entity_fb0a315a6d
    port map (
      ce_1 => ce_1_sg_x541,
      clk_1 => clk_1_sg_x541,
      d => relational5_op_net_x1,
      q => register1_q_net_x10
    );

  pipeline9_76113e41a8: entity work.pipeline4_entity_7ef90e571d
    port map (
      ce_1 => ce_1_sg_x541,
      clk_1 => clk_1_sg_x541,
      d => register1_q_net_x11,
      q => register1_q_net_x13
    );

  pkts_in_frame: entity work.xlcounter_free_darkquad29
    generic map (
      core_name0 => "cntr_11_0_0e7aae3b0f9694f8",
      op_arith => xlUnsigned,
      op_width => 12
    )
    port map (
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      clr => '0',
      en(0) => mux5_y_net_x0,
      rst(0) => logical3_y_net,
      op => pkts_in_frame_op_net
    );

  pulse_ext1_e142e9180b: entity work.pulse_ext1_entity_e142e9180b
    port map (
      ce_1 => ce_1_sg_x541,
      clk_1 => clk_1_sg_x541,
      in_x0 => logical6_y_net_x1,
      out_x0 => relational5_op_net_x0
    );

  pulse_ext_fc00163540: entity work.pulse_ext_entity_fc00163540
    port map (
      ce_1 => ce_1_sg_x541,
      clk_1 => clk_1_sg_x541,
      in_x0 => logical1_y_net_x10,
      out_x0 => relational5_op_net_x1
    );

  register_x0: entity work.xlregister
    generic map (
      d_width => 1,
      init_value => b"0"
    )
    port map (
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      d(0) => register1_q_net_x2,
      en(0) => register1_q_net_x2,
      rst(0) => register1_q_net_x1,
      q(0) => register_q_net_x0
    );

  relational: entity work.relational_e6c0d8ccf7
    port map (
      a => counter_op_net,
      b => constant2_op_net,
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      clr => '0',
      op(0) => relational_op_net
    );

  relational1: entity work.relational_faa984ef57
    port map (
      a => pkts_in_frame_op_net,
      b => register1_q_net_x0,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational1_op_net_x0
    );

  relational4: entity work.relational_077deae217
    port map (
      a => delay5_q_net_x1,
      b => delay_q_net,
      ce => ce_1_sg_x541,
      clk => clk_1_sg_x541,
      clr => '0',
      op(0) => relational4_op_net
    );

  rst_fe59562225: entity work.rst_entity_fe59562225
    port map (
      darkquad29_gbe64_rst_user_data_out => darkquad29_gbe64_rst_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x0
    );

  slice: entity work.xlslice
    generic map (
      new_lsb => 1,
      new_msb => 64,
      x_width => 65,
      y_width => 64
    )
    port map (
      x => fifo_dout_net,
      y => slice_y_net
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 1,
      y_width => 1
    )
    port map (
      x(0) => mux2_y_net,
      y(0) => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => reint1_output_port_net_x0,
      y(0) => slice2_y_net_x0
    );

  slice3: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 65,
      y_width => 1
    )
    port map (
      x => fifo_dout_net,
      y(0) => slice3_y_net
    );

  tx_afull_cf5f3090a5: entity work.last_tx_data_entity_4b5ba71046
    port map (
      ce_1 => ce_1_sg_x541,
      clk_1 => clk_1_sg_x541,
      out_reg => convert14_dout_net_x0,
      cast_gw_x0 => cast_gw_dout_net_x2
    );

  tx_overrun_305ea6d9f6: entity work.last_tx_data_entity_4b5ba71046
    port map (
      ce_1 => ce_1_sg_x541,
      clk_1 => clk_1_sg_x541,
      out_reg => convert1_dout_net_x0,
      cast_gw_x0 => cast_gw_dout_net_x3
    );

  words_per_frame_ec89b6e999: entity work.words_per_frame_entity_ec89b6e999
    port map (
      darkquad29_gbe64_words_per_frame_user_data_out => darkquad29_gbe64_words_per_frame_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/mixer0/bus_expand1"

entity bus_expand1_entity_0afa7cdb6c is
  port (
    bus_in: in std_logic_vector(71 downto 0); 
    lsb_out1: out std_logic_vector(17 downto 0); 
    msb_out4: out std_logic_vector(17 downto 0); 
    out2: out std_logic_vector(17 downto 0); 
    out3: out std_logic_vector(17 downto 0)
  );
end bus_expand1_entity_0afa7cdb6c;

architecture structural of bus_expand1_entity_0afa7cdb6c is
  signal delay74_q_net_x0: std_logic_vector(71 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret3_output_port_net_x0: std_logic_vector(17 downto 0);
  signal reinterpret4_output_port_net_x0: std_logic_vector(17 downto 0);
  signal slice1_y_net: std_logic_vector(17 downto 0);
  signal slice2_y_net: std_logic_vector(17 downto 0);
  signal slice3_y_net: std_logic_vector(17 downto 0);
  signal slice4_y_net: std_logic_vector(17 downto 0);

begin
  delay74_q_net_x0 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x0;
  msb_out4 <= reinterpret4_output_port_net_x0;
  out2 <= reinterpret2_output_port_net_x0;
  out3 <= reinterpret3_output_port_net_x0;

  reinterpret1: entity work.reinterpret_9a0fa0f632
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x0
    );

  reinterpret2: entity work.reinterpret_9a0fa0f632
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret2_output_port_net_x0
    );

  reinterpret3: entity work.reinterpret_9a0fa0f632
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice3_y_net,
      output_port => reinterpret3_output_port_net_x0
    );

  reinterpret4: entity work.reinterpret_9a0fa0f632
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice4_y_net,
      output_port => reinterpret4_output_port_net_x0
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 17,
      x_width => 72,
      y_width => 18
    )
    port map (
      x => delay74_q_net_x0,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 18,
      new_msb => 35,
      x_width => 72,
      y_width => 18
    )
    port map (
      x => delay74_q_net_x0,
      y => slice2_y_net
    );

  slice3: entity work.xlslice
    generic map (
      new_lsb => 36,
      new_msb => 53,
      x_width => 72,
      y_width => 18
    )
    port map (
      x => delay74_q_net_x0,
      y => slice3_y_net
    );

  slice4: entity work.xlslice
    generic map (
      new_lsb => 54,
      new_msb => 71,
      x_width => 72,
      y_width => 18
    )
    port map (
      x => delay74_q_net_x0,
      y => slice4_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/mixer0/bus_expand2"

entity bus_expand2_entity_752f6c5501 is
  port (
    bus_in: in std_logic_vector(63 downto 0); 
    lsb_out1: out std_logic_vector(15 downto 0); 
    msb_out4: out std_logic_vector(15 downto 0); 
    out2: out std_logic_vector(15 downto 0); 
    out3: out std_logic_vector(15 downto 0)
  );
end bus_expand2_entity_752f6c5501;

architecture structural of bus_expand2_entity_752f6c5501 is
  signal delay73_q_net_x0: std_logic_vector(63 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(15 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(15 downto 0);
  signal reinterpret3_output_port_net_x0: std_logic_vector(15 downto 0);
  signal reinterpret4_output_port_net_x0: std_logic_vector(15 downto 0);
  signal slice1_y_net: std_logic_vector(15 downto 0);
  signal slice2_y_net: std_logic_vector(15 downto 0);
  signal slice3_y_net: std_logic_vector(15 downto 0);
  signal slice4_y_net: std_logic_vector(15 downto 0);

begin
  delay73_q_net_x0 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x0;
  msb_out4 <= reinterpret4_output_port_net_x0;
  out2 <= reinterpret2_output_port_net_x0;
  out3 <= reinterpret3_output_port_net_x0;

  reinterpret1: entity work.reinterpret_151459306d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x0
    );

  reinterpret2: entity work.reinterpret_151459306d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret2_output_port_net_x0
    );

  reinterpret3: entity work.reinterpret_151459306d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice3_y_net,
      output_port => reinterpret3_output_port_net_x0
    );

  reinterpret4: entity work.reinterpret_151459306d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice4_y_net,
      output_port => reinterpret4_output_port_net_x0
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 15,
      x_width => 64,
      y_width => 16
    )
    port map (
      x => delay73_q_net_x0,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 16,
      new_msb => 31,
      x_width => 64,
      y_width => 16
    )
    port map (
      x => delay73_q_net_x0,
      y => slice2_y_net
    );

  slice3: entity work.xlslice
    generic map (
      new_lsb => 32,
      new_msb => 47,
      x_width => 64,
      y_width => 16
    )
    port map (
      x => delay73_q_net_x0,
      y => slice3_y_net
    );

  slice4: entity work.xlslice
    generic map (
      new_lsb => 48,
      new_msb => 63,
      x_width => 64,
      y_width => 16
    )
    port map (
      x => delay73_q_net_x0,
      y => slice4_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/mixer0/mixer0"

entity mixer0_entity_577a76fbf3 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    data_i: in std_logic_vector(17 downto 0); 
    data_q: in std_logic_vector(17 downto 0); 
    dds_i: in std_logic_vector(15 downto 0); 
    dds_q: in std_logic_vector(15 downto 0); 
    mixed_out: out std_logic_vector(37 downto 0)
  );
end mixer0_entity_577a76fbf3;

architecture structural of mixer0_entity_577a76fbf3 is
  signal addsub1_s_net_x0: std_logic_vector(18 downto 0);
  signal addsub_s_net_x0: std_logic_vector(18 downto 0);
  signal ce_1_sg_x542: std_logic;
  signal clk_1_sg_x542: std_logic;
  signal concat_y_net_x1: std_logic_vector(37 downto 0);
  signal mult1_p_net: std_logic_vector(33 downto 0);
  signal mult2_p_net: std_logic_vector(33 downto 0);
  signal mult3_p_net: std_logic_vector(33 downto 0);
  signal mult4_p_net: std_logic_vector(33 downto 0);
  signal reinterpret3_output_port_net_x2: std_logic_vector(17 downto 0);
  signal reinterpret3_output_port_net_x3: std_logic_vector(15 downto 0);
  signal reinterpret4_output_port_net_x2: std_logic_vector(17 downto 0);
  signal reinterpret4_output_port_net_x3: std_logic_vector(15 downto 0);

begin
  ce_1_sg_x542 <= ce_1;
  clk_1_sg_x542 <= clk_1;
  reinterpret4_output_port_net_x2 <= data_i;
  reinterpret3_output_port_net_x2 <= data_q;
  reinterpret4_output_port_net_x3 <= dds_i;
  reinterpret3_output_port_net_x3 <= dds_q;
  mixed_out <= concat_y_net_x1;

  addsub: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 32,
      a_width => 34,
      b_arith => xlSigned,
      b_bin_pt => 32,
      b_width => 34,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 35,
      core_name0 => "addsb_11_0_12579c2539e3bba1",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 35,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 17,
      s_width => 19
    )
    port map (
      a => mult1_p_net,
      b => mult2_p_net,
      ce => ce_1_sg_x542,
      clk => clk_1_sg_x542,
      clr => '0',
      en => "1",
      s => addsub_s_net_x0
    );

  addsub1: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 32,
      a_width => 34,
      b_arith => xlSigned,
      b_bin_pt => 32,
      b_width => 34,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 35,
      core_name0 => "addsb_11_0_6603a21774005e29",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 35,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 17,
      s_width => 19
    )
    port map (
      a => mult4_p_net,
      b => mult3_p_net,
      ce => ce_1_sg_x542,
      clk => clk_1_sg_x542,
      clr => '0',
      en => "1",
      s => addsub1_s_net_x0
    );

  mult1: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 18,
      b_arith => xlSigned,
      b_bin_pt => 15,
      b_width => 16,
      c_a_type => 0,
      c_a_width => 18,
      c_b_type => 0,
      c_b_width => 16,
      c_baat => 18,
      c_output_width => 34,
      c_type => 0,
      core_name0 => "mult_11_2_025f89b693a36f98",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 34,
      quantization => 1
    )
    port map (
      a => reinterpret3_output_port_net_x2,
      b => reinterpret4_output_port_net_x3,
      ce => ce_1_sg_x542,
      clk => clk_1_sg_x542,
      clr => '0',
      core_ce => ce_1_sg_x542,
      core_clk => clk_1_sg_x542,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult1_p_net
    );

  mult2: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 18,
      b_arith => xlSigned,
      b_bin_pt => 15,
      b_width => 16,
      c_a_type => 0,
      c_a_width => 18,
      c_b_type => 0,
      c_b_width => 16,
      c_baat => 18,
      c_output_width => 34,
      c_type => 0,
      core_name0 => "mult_11_2_025f89b693a36f98",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 34,
      quantization => 1
    )
    port map (
      a => reinterpret4_output_port_net_x2,
      b => reinterpret3_output_port_net_x3,
      ce => ce_1_sg_x542,
      clk => clk_1_sg_x542,
      clr => '0',
      core_ce => ce_1_sg_x542,
      core_clk => clk_1_sg_x542,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult2_p_net
    );

  mult3: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 18,
      b_arith => xlSigned,
      b_bin_pt => 15,
      b_width => 16,
      c_a_type => 0,
      c_a_width => 18,
      c_b_type => 0,
      c_b_width => 16,
      c_baat => 18,
      c_output_width => 34,
      c_type => 0,
      core_name0 => "mult_11_2_025f89b693a36f98",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 34,
      quantization => 1
    )
    port map (
      a => reinterpret3_output_port_net_x2,
      b => reinterpret3_output_port_net_x3,
      ce => ce_1_sg_x542,
      clk => clk_1_sg_x542,
      clr => '0',
      core_ce => ce_1_sg_x542,
      core_clk => clk_1_sg_x542,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult3_p_net
    );

  mult4: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 17,
      a_width => 18,
      b_arith => xlSigned,
      b_bin_pt => 15,
      b_width => 16,
      c_a_type => 0,
      c_a_width => 18,
      c_b_type => 0,
      c_b_width => 16,
      c_baat => 18,
      c_output_width => 34,
      c_type => 0,
      core_name0 => "mult_11_2_025f89b693a36f98",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 32,
      p_width => 34,
      quantization => 1
    )
    port map (
      a => reinterpret4_output_port_net_x2,
      b => reinterpret4_output_port_net_x3,
      ce => ce_1_sg_x542,
      clk => clk_1_sg_x542,
      clr => '0',
      core_ce => ce_1_sg_x542,
      core_clk => clk_1_sg_x542,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult4_p_net
    );

  ri_to_c1_ebc7d4fdf9: entity work.ri_to_c_entity_91cae541b1
    port map (
      im => addsub_s_net_x0,
      re => addsub1_s_net_x0,
      c => concat_y_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/mixer0"

entity mixer0_entity_b53ac8f98f is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    data_in: in std_logic_vector(71 downto 0); 
    dds_in: in std_logic_vector(63 downto 0); 
    data_out: out std_logic_vector(75 downto 0)
  );
end mixer0_entity_b53ac8f98f;

architecture structural of mixer0_entity_b53ac8f98f is
  signal ce_1_sg_x544: std_logic;
  signal clk_1_sg_x544: std_logic;
  signal concat_y_net_x0: std_logic_vector(75 downto 0);
  signal concat_y_net_x1: std_logic_vector(37 downto 0);
  signal concat_y_net_x2: std_logic_vector(37 downto 0);
  signal delay73_q_net_x1: std_logic_vector(63 downto 0);
  signal delay74_q_net_x1: std_logic_vector(71 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(17 downto 0);
  signal reinterpret1_output_port_net_x3: std_logic_vector(15 downto 0);
  signal reinterpret2_output_port_net_x2: std_logic_vector(17 downto 0);
  signal reinterpret2_output_port_net_x3: std_logic_vector(15 downto 0);
  signal reinterpret3_output_port_net_x2: std_logic_vector(17 downto 0);
  signal reinterpret3_output_port_net_x3: std_logic_vector(15 downto 0);
  signal reinterpret4_output_port_net_x2: std_logic_vector(17 downto 0);
  signal reinterpret4_output_port_net_x3: std_logic_vector(15 downto 0);

begin
  ce_1_sg_x544 <= ce_1;
  clk_1_sg_x544 <= clk_1;
  delay74_q_net_x1 <= data_in;
  delay73_q_net_x1 <= dds_in;
  data_out <= concat_y_net_x0;

  bus_expand1_0afa7cdb6c: entity work.bus_expand1_entity_0afa7cdb6c
    port map (
      bus_in => delay74_q_net_x1,
      lsb_out1 => reinterpret1_output_port_net_x2,
      msb_out4 => reinterpret4_output_port_net_x2,
      out2 => reinterpret2_output_port_net_x2,
      out3 => reinterpret3_output_port_net_x2
    );

  bus_expand2_752f6c5501: entity work.bus_expand2_entity_752f6c5501
    port map (
      bus_in => delay73_q_net_x1,
      lsb_out1 => reinterpret1_output_port_net_x3,
      msb_out4 => reinterpret4_output_port_net_x3,
      out2 => reinterpret2_output_port_net_x3,
      out3 => reinterpret3_output_port_net_x3
    );

  concat: entity work.concat_4822199898
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => concat_y_net_x1,
      in1 => concat_y_net_x2,
      y => concat_y_net_x0
    );

  mixer0_577a76fbf3: entity work.mixer0_entity_577a76fbf3
    port map (
      ce_1 => ce_1_sg_x544,
      clk_1 => clk_1_sg_x544,
      data_i => reinterpret4_output_port_net_x2,
      data_q => reinterpret3_output_port_net_x2,
      dds_i => reinterpret4_output_port_net_x3,
      dds_q => reinterpret3_output_port_net_x3,
      mixed_out => concat_y_net_x1
    );

  mixer1_d3bd437d9a: entity work.mixer0_entity_577a76fbf3
    port map (
      ce_1 => ce_1_sg_x544,
      clk_1 => clk_1_sg_x544,
      data_i => reinterpret2_output_port_net_x2,
      data_q => reinterpret1_output_port_net_x2,
      dds_i => reinterpret2_output_port_net_x3,
      dds_q => reinterpret1_output_port_net_x3,
      mixed_out => concat_y_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/pack_buf/demux"

entity demux_entity_e7f667c331 is
  port (
    ce_1: in std_logic; 
    clear: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(1 downto 0); 
    out0: out std_logic; 
    out1: out std_logic; 
    out2: out std_logic; 
    out3: out std_logic
  );
end demux_entity_e7f667c331;

architecture structural of demux_entity_e7f667c331 is
  signal ce_1_sg_x556: std_logic;
  signal clear_const_op_net: std_logic_vector(2 downto 0);
  signal clear_mux_y_net: std_logic_vector(2 downto 0);
  signal clk_1_sg_x556: std_logic;
  signal const0_op_net: std_logic_vector(1 downto 0);
  signal const1_op_net: std_logic_vector(1 downto 0);
  signal const2_op_net: std_logic_vector(1 downto 0);
  signal const3_op_net: std_logic_vector(1 downto 0);
  signal constant_op_net_x0: std_logic;
  signal counter_op_net_x0: std_logic_vector(1 downto 0);
  signal relational0_op_net_x0: std_logic;
  signal relational1_op_net_x0: std_logic;
  signal relational2_op_net_x0: std_logic;
  signal relational3_op_net_x0: std_logic;

begin
  ce_1_sg_x556 <= ce_1;
  constant_op_net_x0 <= clear;
  clk_1_sg_x556 <= clk_1;
  counter_op_net_x0 <= in_x0;
  out0 <= relational0_op_net_x0;
  out1 <= relational1_op_net_x0;
  out2 <= relational2_op_net_x0;
  out3 <= relational3_op_net_x0;

  clear_const: entity work.constant_469094441c
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => clear_const_op_net
    );

  clear_mux: entity work.mux_07eeecd0e3
    port map (
      ce => ce_1_sg_x556,
      clk => clk_1_sg_x556,
      clr => '0',
      d0 => counter_op_net_x0,
      d1 => clear_const_op_net,
      sel(0) => constant_op_net_x0,
      y => clear_mux_y_net
    );

  const0: entity work.constant_cda50df78a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const0_op_net
    );

  const1: entity work.constant_a7e2bb9e12
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const1_op_net
    );

  const2: entity work.constant_e8ddc079e9
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const2_op_net
    );

  const3: entity work.constant_3a9a3daeb9
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const3_op_net
    );

  relational0: entity work.relational_c45d84fc35
    port map (
      a => clear_mux_y_net,
      b => const0_op_net,
      ce => ce_1_sg_x556,
      clk => clk_1_sg_x556,
      clr => '0',
      op(0) => relational0_op_net_x0
    );

  relational1: entity work.relational_c45d84fc35
    port map (
      a => clear_mux_y_net,
      b => const1_op_net,
      ce => ce_1_sg_x556,
      clk => clk_1_sg_x556,
      clr => '0',
      op(0) => relational1_op_net_x0
    );

  relational2: entity work.relational_c45d84fc35
    port map (
      a => clear_mux_y_net,
      b => const2_op_net,
      ce => ce_1_sg_x556,
      clk => clk_1_sg_x556,
      clr => '0',
      op(0) => relational2_op_net_x0
    );

  relational3: entity work.relational_c45d84fc35
    port map (
      a => clear_mux_y_net,
      b => const3_op_net,
      ce => ce_1_sg_x556,
      clk => clk_1_sg_x556,
      clr => '0',
      op(0) => relational3_op_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/pack_buf"

entity pack_buf_entity_bd697fc584 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    pack0: in std_logic_vector(63 downto 0); 
    pack1: in std_logic_vector(63 downto 0); 
    pack2: in std_logic_vector(63 downto 0); 
    pack3: in std_logic_vector(63 downto 0); 
    we0: in std_logic; 
    we1: in std_logic; 
    we2: in std_logic; 
    we3: in std_logic; 
    pack_out: out std_logic_vector(63 downto 0); 
    we_out: out std_logic
  );
end pack_buf_entity_bd697fc584;

architecture structural of pack_buf_entity_bd697fc584 is
  signal ce_1_sg_x557: std_logic;
  signal clk_1_sg_x557: std_logic;
  signal constant_op_net_x0: std_logic;
  signal counter_op_net_x0: std_logic_vector(1 downto 0);
  signal delay19_q_net: std_logic_vector(1 downto 0);
  signal delay1_q_net: std_logic_vector(1 downto 0);
  signal delay2_q_net: std_logic;
  signal delay3_q_net: std_logic;
  signal delay4_q_net: std_logic;
  signal delay5_q_net: std_logic;
  signal fifo0_dout_net: std_logic_vector(63 downto 0);
  signal fifo0_empty_net: std_logic;
  signal fifo1_dout_net: std_logic_vector(63 downto 0);
  signal fifo1_empty_net: std_logic;
  signal fifo2_dout_net: std_logic_vector(63 downto 0);
  signal fifo2_empty_net: std_logic;
  signal fifo3_dout_net: std_logic_vector(63 downto 0);
  signal fifo3_empty_net: std_logic;
  signal inverter1_op_net: std_logic;
  signal inverter2_op_net: std_logic;
  signal inverter3_op_net: std_logic;
  signal inverter_op_net: std_logic;
  signal mux1_y_net_x0: std_logic;
  signal mux_y_net_x0: std_logic_vector(63 downto 0);
  signal register1_q_net_x10: std_logic;
  signal register1_q_net_x11: std_logic_vector(63 downto 0);
  signal register1_q_net_x12: std_logic;
  signal register1_q_net_x13: std_logic_vector(63 downto 0);
  signal register1_q_net_x14: std_logic;
  signal register1_q_net_x7: std_logic_vector(63 downto 0);
  signal register1_q_net_x8: std_logic;
  signal register1_q_net_x9: std_logic_vector(63 downto 0);
  signal relational0_op_net_x0: std_logic;
  signal relational1_op_net_x0: std_logic;
  signal relational2_op_net_x0: std_logic;
  signal relational3_op_net_x0: std_logic;

begin
  ce_1_sg_x557 <= ce_1;
  clk_1_sg_x557 <= clk_1;
  register1_q_net_x7 <= pack0;
  register1_q_net_x9 <= pack1;
  register1_q_net_x11 <= pack2;
  register1_q_net_x13 <= pack3;
  register1_q_net_x8 <= we0;
  register1_q_net_x10 <= we1;
  register1_q_net_x12 <= we2;
  register1_q_net_x14 <= we3;
  pack_out <= mux_y_net_x0;
  we_out <= mux1_y_net_x0;

  constant_x0: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant_op_net_x0
    );

  counter: entity work.xlcounter_free_darkquad29
    generic map (
      core_name0 => "cntr_11_0_10352c017544bebd",
      op_arith => xlUnsigned,
      op_width => 2
    )
    port map (
      ce => ce_1_sg_x557,
      clk => clk_1_sg_x557,
      clr => '0',
      en => "1",
      rst => "0",
      op => counter_op_net_x0
    );

  delay1: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 2
    )
    port map (
      ce => ce_1_sg_x557,
      clk => clk_1_sg_x557,
      d => counter_op_net_x0,
      en => '1',
      rst => '1',
      q => delay1_q_net
    );

  delay19: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 2
    )
    port map (
      ce => ce_1_sg_x557,
      clk => clk_1_sg_x557,
      d => delay1_q_net,
      en => '1',
      rst => '1',
      q => delay19_q_net
    );

  delay2: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x557,
      clk => clk_1_sg_x557,
      d(0) => fifo0_empty_net,
      en => '1',
      rst => '1',
      q(0) => delay2_q_net
    );

  delay3: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x557,
      clk => clk_1_sg_x557,
      d(0) => fifo1_empty_net,
      en => '1',
      rst => '1',
      q(0) => delay3_q_net
    );

  delay4: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x557,
      clk => clk_1_sg_x557,
      d(0) => fifo2_empty_net,
      en => '1',
      rst => '1',
      q(0) => delay4_q_net
    );

  delay5: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x557,
      clk => clk_1_sg_x557,
      d(0) => fifo3_empty_net,
      en => '1',
      rst => '1',
      q(0) => delay5_q_net
    );

  demux_e7f667c331: entity work.demux_entity_e7f667c331
    port map (
      ce_1 => ce_1_sg_x557,
      clear => constant_op_net_x0,
      clk_1 => clk_1_sg_x557,
      in_x0 => counter_op_net_x0,
      out0 => relational0_op_net_x0,
      out1 => relational1_op_net_x0,
      out2 => relational2_op_net_x0,
      out3 => relational3_op_net_x0
    );

  fifo0: entity work.xlfifogen_darkquad29
    generic map (
      core_name0 => "fifo_fg92_afda83fee974586a",
      data_count_width => 8,
      data_width => 64,
      has_ae => 0,
      has_af => 0,
      percent_full_width => 1
    )
    port map (
      ce => ce_1_sg_x557,
      clk => clk_1_sg_x557,
      din => register1_q_net_x7,
      en => '1',
      re => relational0_op_net_x0,
      re_ce => ce_1_sg_x557,
      rst => '1',
      we => register1_q_net_x8,
      we_ce => ce_1_sg_x557,
      dout => fifo0_dout_net,
      empty => fifo0_empty_net
    );

  fifo1: entity work.xlfifogen_darkquad29
    generic map (
      core_name0 => "fifo_fg92_afda83fee974586a",
      data_count_width => 8,
      data_width => 64,
      has_ae => 0,
      has_af => 0,
      percent_full_width => 1
    )
    port map (
      ce => ce_1_sg_x557,
      clk => clk_1_sg_x557,
      din => register1_q_net_x9,
      en => '1',
      re => relational1_op_net_x0,
      re_ce => ce_1_sg_x557,
      rst => '1',
      we => register1_q_net_x10,
      we_ce => ce_1_sg_x557,
      dout => fifo1_dout_net,
      empty => fifo1_empty_net
    );

  fifo2: entity work.xlfifogen_darkquad29
    generic map (
      core_name0 => "fifo_fg92_afda83fee974586a",
      data_count_width => 8,
      data_width => 64,
      has_ae => 0,
      has_af => 0,
      percent_full_width => 1
    )
    port map (
      ce => ce_1_sg_x557,
      clk => clk_1_sg_x557,
      din => register1_q_net_x11,
      en => '1',
      re => relational2_op_net_x0,
      re_ce => ce_1_sg_x557,
      rst => '1',
      we => register1_q_net_x12,
      we_ce => ce_1_sg_x557,
      dout => fifo2_dout_net,
      empty => fifo2_empty_net
    );

  fifo3: entity work.xlfifogen_darkquad29
    generic map (
      core_name0 => "fifo_fg92_afda83fee974586a",
      data_count_width => 8,
      data_width => 64,
      has_ae => 0,
      has_af => 0,
      percent_full_width => 1
    )
    port map (
      ce => ce_1_sg_x557,
      clk => clk_1_sg_x557,
      din => register1_q_net_x13,
      en => '1',
      re => relational3_op_net_x0,
      re_ce => ce_1_sg_x557,
      rst => '1',
      we => register1_q_net_x14,
      we_ce => ce_1_sg_x557,
      dout => fifo3_dout_net,
      empty => fifo3_empty_net
    );

  inverter: entity work.inverter_e5b38cca3b
    port map (
      ce => ce_1_sg_x557,
      clk => clk_1_sg_x557,
      clr => '0',
      ip(0) => delay2_q_net,
      op(0) => inverter_op_net
    );

  inverter1: entity work.inverter_e5b38cca3b
    port map (
      ce => ce_1_sg_x557,
      clk => clk_1_sg_x557,
      clr => '0',
      ip(0) => delay3_q_net,
      op(0) => inverter1_op_net
    );

  inverter2: entity work.inverter_e5b38cca3b
    port map (
      ce => ce_1_sg_x557,
      clk => clk_1_sg_x557,
      clr => '0',
      ip(0) => delay4_q_net,
      op(0) => inverter2_op_net
    );

  inverter3: entity work.inverter_e5b38cca3b
    port map (
      ce => ce_1_sg_x557,
      clk => clk_1_sg_x557,
      clr => '0',
      ip(0) => delay5_q_net,
      op(0) => inverter3_op_net
    );

  mux: entity work.mux_457b832fd1
    port map (
      ce => ce_1_sg_x557,
      clk => clk_1_sg_x557,
      clr => '0',
      d0 => fifo0_dout_net,
      d1 => fifo1_dout_net,
      d2 => fifo2_dout_net,
      d3 => fifo3_dout_net,
      sel => delay19_q_net,
      y => mux_y_net_x0
    );

  mux1: entity work.mux_629e82a6f2
    port map (
      ce => ce_1_sg_x557,
      clk => clk_1_sg_x557,
      clr => '0',
      d0(0) => inverter_op_net,
      d1(0) => inverter1_op_net,
      d2(0) => inverter2_op_net,
      d3(0) => inverter3_op_net,
      sel => delay19_q_net,
      y(0) => mux1_y_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/pfb_fft/bus_create1"

entity bus_create1_entity_39ce47819d is
  port (
    in1: in std_logic_vector(35 downto 0); 
    in10: in std_logic_vector(35 downto 0); 
    in11: in std_logic_vector(35 downto 0); 
    in12: in std_logic_vector(35 downto 0); 
    in13: in std_logic_vector(35 downto 0); 
    in14: in std_logic_vector(35 downto 0); 
    in15: in std_logic_vector(35 downto 0); 
    in16: in std_logic_vector(35 downto 0); 
    in2: in std_logic_vector(35 downto 0); 
    in3: in std_logic_vector(35 downto 0); 
    in4: in std_logic_vector(35 downto 0); 
    in5: in std_logic_vector(35 downto 0); 
    in6: in std_logic_vector(35 downto 0); 
    in7: in std_logic_vector(35 downto 0); 
    in8: in std_logic_vector(35 downto 0); 
    in9: in std_logic_vector(35 downto 0); 
    bus_out: out std_logic_vector(575 downto 0)
  );
end bus_create1_entity_39ce47819d;

architecture structural of bus_create1_entity_39ce47819d is
  signal concatenate_y_net_x0: std_logic_vector(575 downto 0);
  signal pfb_fft_bin0_t0_net_x0: std_logic_vector(35 downto 0);
  signal pfb_fft_bin0_t1_net_x0: std_logic_vector(35 downto 0);
  signal pfb_fft_bin1_t0_net_x0: std_logic_vector(35 downto 0);
  signal pfb_fft_bin1_t1_net_x0: std_logic_vector(35 downto 0);
  signal pfb_fft_bin2_t0_net_x0: std_logic_vector(35 downto 0);
  signal pfb_fft_bin2_t1_net_x0: std_logic_vector(35 downto 0);
  signal pfb_fft_bin3_t0_net_x0: std_logic_vector(35 downto 0);
  signal pfb_fft_bin3_t1_net_x0: std_logic_vector(35 downto 0);
  signal pfb_fft_bin4_t0_net_x0: std_logic_vector(35 downto 0);
  signal pfb_fft_bin4_t1_net_x0: std_logic_vector(35 downto 0);
  signal pfb_fft_bin5_t0_net_x0: std_logic_vector(35 downto 0);
  signal pfb_fft_bin5_t1_net_x0: std_logic_vector(35 downto 0);
  signal pfb_fft_bin6_t0_net_x0: std_logic_vector(35 downto 0);
  signal pfb_fft_bin6_t1_net_x0: std_logic_vector(35 downto 0);
  signal pfb_fft_bin7_t0_net_x0: std_logic_vector(35 downto 0);
  signal pfb_fft_bin7_t1_net_x0: std_logic_vector(35 downto 0);
  signal reinterpret10_output_port_net: std_logic_vector(35 downto 0);
  signal reinterpret11_output_port_net: std_logic_vector(35 downto 0);
  signal reinterpret12_output_port_net: std_logic_vector(35 downto 0);
  signal reinterpret13_output_port_net: std_logic_vector(35 downto 0);
  signal reinterpret14_output_port_net: std_logic_vector(35 downto 0);
  signal reinterpret15_output_port_net: std_logic_vector(35 downto 0);
  signal reinterpret16_output_port_net: std_logic_vector(35 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(35 downto 0);
  signal reinterpret2_output_port_net: std_logic_vector(35 downto 0);
  signal reinterpret3_output_port_net: std_logic_vector(35 downto 0);
  signal reinterpret4_output_port_net: std_logic_vector(35 downto 0);
  signal reinterpret5_output_port_net: std_logic_vector(35 downto 0);
  signal reinterpret6_output_port_net: std_logic_vector(35 downto 0);
  signal reinterpret7_output_port_net: std_logic_vector(35 downto 0);
  signal reinterpret8_output_port_net: std_logic_vector(35 downto 0);
  signal reinterpret9_output_port_net: std_logic_vector(35 downto 0);

begin
  pfb_fft_bin0_t0_net_x0 <= in1;
  pfb_fft_bin4_t1_net_x0 <= in10;
  pfb_fft_bin5_t0_net_x0 <= in11;
  pfb_fft_bin5_t1_net_x0 <= in12;
  pfb_fft_bin6_t0_net_x0 <= in13;
  pfb_fft_bin6_t1_net_x0 <= in14;
  pfb_fft_bin7_t0_net_x0 <= in15;
  pfb_fft_bin7_t1_net_x0 <= in16;
  pfb_fft_bin0_t1_net_x0 <= in2;
  pfb_fft_bin1_t0_net_x0 <= in3;
  pfb_fft_bin1_t1_net_x0 <= in4;
  pfb_fft_bin2_t0_net_x0 <= in5;
  pfb_fft_bin2_t1_net_x0 <= in6;
  pfb_fft_bin3_t0_net_x0 <= in7;
  pfb_fft_bin3_t1_net_x0 <= in8;
  pfb_fft_bin4_t0_net_x0 <= in9;
  bus_out <= concatenate_y_net_x0;

  concatenate: entity work.concat_6767bfad71
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret1_output_port_net,
      in1 => reinterpret2_output_port_net,
      in10 => reinterpret11_output_port_net,
      in11 => reinterpret12_output_port_net,
      in12 => reinterpret13_output_port_net,
      in13 => reinterpret14_output_port_net,
      in14 => reinterpret15_output_port_net,
      in15 => reinterpret16_output_port_net,
      in2 => reinterpret3_output_port_net,
      in3 => reinterpret4_output_port_net,
      in4 => reinterpret5_output_port_net,
      in5 => reinterpret6_output_port_net,
      in6 => reinterpret7_output_port_net,
      in7 => reinterpret8_output_port_net,
      in8 => reinterpret9_output_port_net,
      in9 => reinterpret10_output_port_net,
      y => concatenate_y_net_x0
    );

  reinterpret1: entity work.reinterpret_86b044698f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => pfb_fft_bin0_t0_net_x0,
      output_port => reinterpret1_output_port_net
    );

  reinterpret10: entity work.reinterpret_86b044698f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => pfb_fft_bin4_t1_net_x0,
      output_port => reinterpret10_output_port_net
    );

  reinterpret11: entity work.reinterpret_86b044698f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => pfb_fft_bin5_t0_net_x0,
      output_port => reinterpret11_output_port_net
    );

  reinterpret12: entity work.reinterpret_86b044698f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => pfb_fft_bin5_t1_net_x0,
      output_port => reinterpret12_output_port_net
    );

  reinterpret13: entity work.reinterpret_86b044698f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => pfb_fft_bin6_t0_net_x0,
      output_port => reinterpret13_output_port_net
    );

  reinterpret14: entity work.reinterpret_86b044698f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => pfb_fft_bin6_t1_net_x0,
      output_port => reinterpret14_output_port_net
    );

  reinterpret15: entity work.reinterpret_86b044698f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => pfb_fft_bin7_t0_net_x0,
      output_port => reinterpret15_output_port_net
    );

  reinterpret16: entity work.reinterpret_86b044698f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => pfb_fft_bin7_t1_net_x0,
      output_port => reinterpret16_output_port_net
    );

  reinterpret2: entity work.reinterpret_86b044698f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => pfb_fft_bin0_t1_net_x0,
      output_port => reinterpret2_output_port_net
    );

  reinterpret3: entity work.reinterpret_86b044698f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => pfb_fft_bin1_t0_net_x0,
      output_port => reinterpret3_output_port_net
    );

  reinterpret4: entity work.reinterpret_86b044698f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => pfb_fft_bin1_t1_net_x0,
      output_port => reinterpret4_output_port_net
    );

  reinterpret5: entity work.reinterpret_86b044698f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => pfb_fft_bin2_t0_net_x0,
      output_port => reinterpret5_output_port_net
    );

  reinterpret6: entity work.reinterpret_86b044698f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => pfb_fft_bin2_t1_net_x0,
      output_port => reinterpret6_output_port_net
    );

  reinterpret7: entity work.reinterpret_86b044698f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => pfb_fft_bin3_t0_net_x0,
      output_port => reinterpret7_output_port_net
    );

  reinterpret8: entity work.reinterpret_86b044698f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => pfb_fft_bin3_t1_net_x0,
      output_port => reinterpret8_output_port_net
    );

  reinterpret9: entity work.reinterpret_86b044698f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => pfb_fft_bin4_t0_net_x0,
      output_port => reinterpret9_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/pfb_fft/bus_expand11"

entity bus_expand11_entity_45271793a1 is
  port (
    bus_in: in std_logic_vector(191 downto 0); 
    lsb_out1: out std_logic_vector(23 downto 0); 
    msb_out8: out std_logic_vector(23 downto 0); 
    out2: out std_logic_vector(23 downto 0); 
    out3: out std_logic_vector(23 downto 0); 
    out4: out std_logic_vector(23 downto 0); 
    out5: out std_logic_vector(23 downto 0); 
    out6: out std_logic_vector(23 downto 0); 
    out7: out std_logic_vector(23 downto 0)
  );
end bus_expand11_entity_45271793a1;

architecture structural of bus_expand11_entity_45271793a1 is
  signal register1_q_net_x0: std_logic_vector(191 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(23 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(23 downto 0);
  signal reinterpret3_output_port_net_x0: std_logic_vector(23 downto 0);
  signal reinterpret4_output_port_net_x0: std_logic_vector(23 downto 0);
  signal reinterpret5_output_port_net_x0: std_logic_vector(23 downto 0);
  signal reinterpret6_output_port_net_x0: std_logic_vector(23 downto 0);
  signal reinterpret7_output_port_net_x0: std_logic_vector(23 downto 0);
  signal reinterpret8_output_port_net_x0: std_logic_vector(23 downto 0);
  signal slice1_y_net: std_logic_vector(23 downto 0);
  signal slice2_y_net: std_logic_vector(23 downto 0);
  signal slice3_y_net: std_logic_vector(23 downto 0);
  signal slice4_y_net: std_logic_vector(23 downto 0);
  signal slice5_y_net: std_logic_vector(23 downto 0);
  signal slice6_y_net: std_logic_vector(23 downto 0);
  signal slice7_y_net: std_logic_vector(23 downto 0);
  signal slice8_y_net: std_logic_vector(23 downto 0);

begin
  register1_q_net_x0 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x0;
  msb_out8 <= reinterpret8_output_port_net_x0;
  out2 <= reinterpret2_output_port_net_x0;
  out3 <= reinterpret3_output_port_net_x0;
  out4 <= reinterpret4_output_port_net_x0;
  out5 <= reinterpret5_output_port_net_x0;
  out6 <= reinterpret6_output_port_net_x0;
  out7 <= reinterpret7_output_port_net_x0;

  reinterpret1: entity work.reinterpret_950635102d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x0
    );

  reinterpret2: entity work.reinterpret_950635102d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice2_y_net,
      output_port => reinterpret2_output_port_net_x0
    );

  reinterpret3: entity work.reinterpret_950635102d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice3_y_net,
      output_port => reinterpret3_output_port_net_x0
    );

  reinterpret4: entity work.reinterpret_950635102d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice4_y_net,
      output_port => reinterpret4_output_port_net_x0
    );

  reinterpret5: entity work.reinterpret_950635102d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice5_y_net,
      output_port => reinterpret5_output_port_net_x0
    );

  reinterpret6: entity work.reinterpret_950635102d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice6_y_net,
      output_port => reinterpret6_output_port_net_x0
    );

  reinterpret7: entity work.reinterpret_950635102d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice7_y_net,
      output_port => reinterpret7_output_port_net_x0
    );

  reinterpret8: entity work.reinterpret_950635102d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice8_y_net,
      output_port => reinterpret8_output_port_net_x0
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 23,
      x_width => 192,
      y_width => 24
    )
    port map (
      x => register1_q_net_x0,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 24,
      new_msb => 47,
      x_width => 192,
      y_width => 24
    )
    port map (
      x => register1_q_net_x0,
      y => slice2_y_net
    );

  slice3: entity work.xlslice
    generic map (
      new_lsb => 48,
      new_msb => 71,
      x_width => 192,
      y_width => 24
    )
    port map (
      x => register1_q_net_x0,
      y => slice3_y_net
    );

  slice4: entity work.xlslice
    generic map (
      new_lsb => 72,
      new_msb => 95,
      x_width => 192,
      y_width => 24
    )
    port map (
      x => register1_q_net_x0,
      y => slice4_y_net
    );

  slice5: entity work.xlslice
    generic map (
      new_lsb => 96,
      new_msb => 119,
      x_width => 192,
      y_width => 24
    )
    port map (
      x => register1_q_net_x0,
      y => slice5_y_net
    );

  slice6: entity work.xlslice
    generic map (
      new_lsb => 120,
      new_msb => 143,
      x_width => 192,
      y_width => 24
    )
    port map (
      x => register1_q_net_x0,
      y => slice6_y_net
    );

  slice7: entity work.xlslice
    generic map (
      new_lsb => 144,
      new_msb => 167,
      x_width => 192,
      y_width => 24
    )
    port map (
      x => register1_q_net_x0,
      y => slice7_y_net
    );

  slice8: entity work.xlslice
    generic map (
      new_lsb => 168,
      new_msb => 191,
      x_width => 192,
      y_width => 24
    )
    port map (
      x => register1_q_net_x0,
      y => slice8_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/pfb_fft/check"

entity check_entity_5d066662f8 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    oflow_in: in std_logic_vector(3 downto 0); 
    rst: in std_logic; 
    fft_oflow: out std_logic_vector(31 downto 0)
  );
end check_entity_5d066662f8;

architecture structural of check_entity_5d066662f8 is
  signal cast_gw_dout_net_x1: std_logic_vector(31 downto 0);
  signal ce_1_sg_x560: std_logic;
  signal clk_1_sg_x560: std_logic;
  signal constant6_op_net: std_logic_vector(3 downto 0);
  signal pfb_fft_overflow_net_x0: std_logic_vector(3 downto 0);
  signal register0_q_net_x1: std_logic;
  signal register1_q_net_x0: std_logic;
  signal register1_q_net_x1: std_logic;
  signal relational1_op_net: std_logic;

begin
  ce_1_sg_x560 <= ce_1;
  clk_1_sg_x560 <= clk_1;
  pfb_fft_overflow_net_x0 <= oflow_in;
  register1_q_net_x0 <= rst;
  fft_oflow <= cast_gw_dout_net_x1;

  constant6: entity work.constant_4c449dd556
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant6_op_net
    );

  fft_oflow_54a7b7c683: entity work.sending_data_entity_bfe6edc6ce
    port map (
      ce_1 => ce_1_sg_x560,
      clk_1 => clk_1_sg_x560,
      out_reg => register1_q_net_x1,
      cast_gw_x0 => cast_gw_dout_net_x1
    );

  pipeline34_6198ef2586: entity work.pipeline3_entity_fb0a315a6d
    port map (
      ce_1 => ce_1_sg_x560,
      clk_1 => clk_1_sg_x560,
      d => register0_q_net_x1,
      q => register1_q_net_x1
    );

  register0: entity work.xlregister
    generic map (
      d_width => 1,
      init_value => b"0"
    )
    port map (
      ce => ce_1_sg_x560,
      clk => clk_1_sg_x560,
      d(0) => relational1_op_net,
      en(0) => relational1_op_net,
      rst(0) => register1_q_net_x0,
      q(0) => register0_q_net_x1
    );

  relational1: entity work.relational_7d31a93025
    port map (
      a => pfb_fft_overflow_net_x0,
      b => constant6_op_net,
      ce => ce_1_sg_x560,
      clk => clk_1_sg_x560,
      clr => '0',
      op(0) => relational1_op_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/pfb_fft"

entity pfb_fft_entity_e22b93a038 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    data_in: in std_logic_vector(191 downto 0); 
    sync_in: in std_logic; 
    bin_ctr: out std_logic_vector(7 downto 0); 
    check: out std_logic_vector(31 downto 0); 
    data_out: out std_logic_vector(575 downto 0); 
    fft_rdy: out std_logic
  );
end pfb_fft_entity_e22b93a038;

architecture structural of pfb_fft_entity_e22b93a038 is
  signal cast_gw_dout_net_x2: std_logic_vector(31 downto 0);
  signal ce_1_sg_x562: std_logic;
  signal clk_1_sg_x562: std_logic;
  signal concatenate_y_net_x1: std_logic_vector(575 downto 0);
  signal constant3_op_net: std_logic;
  signal delay4_q_net_x1: std_logic;
  signal pfb_fft_bin0_t0_net_x0: std_logic_vector(35 downto 0);
  signal pfb_fft_bin0_t1_net_x0: std_logic_vector(35 downto 0);
  signal pfb_fft_bin1_t0_net_x0: std_logic_vector(35 downto 0);
  signal pfb_fft_bin1_t1_net_x0: std_logic_vector(35 downto 0);
  signal pfb_fft_bin2_t0_net_x0: std_logic_vector(35 downto 0);
  signal pfb_fft_bin2_t1_net_x0: std_logic_vector(35 downto 0);
  signal pfb_fft_bin3_t0_net_x0: std_logic_vector(35 downto 0);
  signal pfb_fft_bin3_t1_net_x0: std_logic_vector(35 downto 0);
  signal pfb_fft_bin4_t0_net_x0: std_logic_vector(35 downto 0);
  signal pfb_fft_bin4_t1_net_x0: std_logic_vector(35 downto 0);
  signal pfb_fft_bin5_t0_net_x0: std_logic_vector(35 downto 0);
  signal pfb_fft_bin5_t1_net_x0: std_logic_vector(35 downto 0);
  signal pfb_fft_bin6_t0_net_x0: std_logic_vector(35 downto 0);
  signal pfb_fft_bin6_t1_net_x0: std_logic_vector(35 downto 0);
  signal pfb_fft_bin7_t0_net_x0: std_logic_vector(35 downto 0);
  signal pfb_fft_bin7_t1_net_x0: std_logic_vector(35 downto 0);
  signal pfb_fft_bin_ctr_net_x0: std_logic_vector(7 downto 0);
  signal pfb_fft_fft_rdy_net: std_logic;
  signal pfb_fft_overflow_net_x0: std_logic_vector(3 downto 0);
  signal register1_q_net_x1: std_logic;
  signal register1_q_net_x2: std_logic_vector(191 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(23 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(23 downto 0);
  signal reinterpret3_output_port_net_x0: std_logic_vector(23 downto 0);
  signal reinterpret4_output_port_net_x0: std_logic_vector(23 downto 0);
  signal reinterpret5_output_port_net_x0: std_logic_vector(23 downto 0);
  signal reinterpret6_output_port_net_x0: std_logic_vector(23 downto 0);
  signal reinterpret7_output_port_net_x0: std_logic_vector(23 downto 0);
  signal reinterpret8_output_port_net_x0: std_logic_vector(23 downto 0);
  signal slice1_y_net_x0: std_logic;

begin
  ce_1_sg_x562 <= ce_1;
  clk_1_sg_x562 <= clk_1;
  register1_q_net_x2 <= data_in;
  delay4_q_net_x1 <= sync_in;
  bin_ctr <= pfb_fft_bin_ctr_net_x0;
  check <= cast_gw_dout_net_x2;
  data_out <= concatenate_y_net_x1;
  fft_rdy <= slice1_y_net_x0;

  bus_create1_39ce47819d: entity work.bus_create1_entity_39ce47819d
    port map (
      in1 => pfb_fft_bin0_t0_net_x0,
      in10 => pfb_fft_bin4_t1_net_x0,
      in11 => pfb_fft_bin5_t0_net_x0,
      in12 => pfb_fft_bin5_t1_net_x0,
      in13 => pfb_fft_bin6_t0_net_x0,
      in14 => pfb_fft_bin6_t1_net_x0,
      in15 => pfb_fft_bin7_t0_net_x0,
      in16 => pfb_fft_bin7_t1_net_x0,
      in2 => pfb_fft_bin0_t1_net_x0,
      in3 => pfb_fft_bin1_t0_net_x0,
      in4 => pfb_fft_bin1_t1_net_x0,
      in5 => pfb_fft_bin2_t0_net_x0,
      in6 => pfb_fft_bin2_t1_net_x0,
      in7 => pfb_fft_bin3_t0_net_x0,
      in8 => pfb_fft_bin3_t1_net_x0,
      in9 => pfb_fft_bin4_t0_net_x0,
      bus_out => concatenate_y_net_x1
    );

  bus_expand11_45271793a1: entity work.bus_expand11_entity_45271793a1
    port map (
      bus_in => register1_q_net_x2,
      lsb_out1 => reinterpret1_output_port_net_x0,
      msb_out8 => reinterpret8_output_port_net_x0,
      out2 => reinterpret2_output_port_net_x0,
      out3 => reinterpret3_output_port_net_x0,
      out4 => reinterpret4_output_port_net_x0,
      out5 => reinterpret5_output_port_net_x0,
      out6 => reinterpret6_output_port_net_x0,
      out7 => reinterpret7_output_port_net_x0
    );

  check_5d066662f8: entity work.check_entity_5d066662f8
    port map (
      ce_1 => ce_1_sg_x562,
      clk_1 => clk_1_sg_x562,
      oflow_in => pfb_fft_overflow_net_x0,
      rst => register1_q_net_x1,
      fft_oflow => cast_gw_dout_net_x2
    );

  constant3: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant3_op_net
    );

  pfb_fft: entity work.dark_pfb_core10
    port map (
      ce_1 => ce_1_sg_x562,
      clk_1 => clk_1_sg_x562,
      data0 => reinterpret8_output_port_net_x0,
      data1 => reinterpret7_output_port_net_x0,
      data2 => reinterpret6_output_port_net_x0,
      data3 => reinterpret5_output_port_net_x0,
      data4 => reinterpret4_output_port_net_x0,
      data5 => reinterpret3_output_port_net_x0,
      data6 => reinterpret2_output_port_net_x0,
      data7 => reinterpret1_output_port_net_x0,
      skip_pfb => constant3_op_net,
      sync_in => delay4_q_net_x1,
      bin0_t0 => pfb_fft_bin0_t0_net_x0,
      bin0_t1 => pfb_fft_bin0_t1_net_x0,
      bin1_t0 => pfb_fft_bin1_t0_net_x0,
      bin1_t1 => pfb_fft_bin1_t1_net_x0,
      bin2_t0 => pfb_fft_bin2_t0_net_x0,
      bin2_t1 => pfb_fft_bin2_t1_net_x0,
      bin3_t0 => pfb_fft_bin3_t0_net_x0,
      bin3_t1 => pfb_fft_bin3_t1_net_x0,
      bin4_t0 => pfb_fft_bin4_t0_net_x0,
      bin4_t1 => pfb_fft_bin4_t1_net_x0,
      bin5_t0 => pfb_fft_bin5_t0_net_x0,
      bin5_t1 => pfb_fft_bin5_t1_net_x0,
      bin6_t0 => pfb_fft_bin6_t0_net_x0,
      bin6_t1 => pfb_fft_bin6_t1_net_x0,
      bin7_t0 => pfb_fft_bin7_t0_net_x0,
      bin7_t1 => pfb_fft_bin7_t1_net_x0,
      bin_ctr => pfb_fft_bin_ctr_net_x0,
      fft_rdy => pfb_fft_fft_rdy_net,
      overflow => pfb_fft_overflow_net_x0
    );

  pipeline2_cadb408798: entity work.pipeline3_entity_fb0a315a6d
    port map (
      ce_1 => ce_1_sg_x562,
      clk_1 => clk_1_sg_x562,
      d => delay4_q_net_x1,
      q => register1_q_net_x1
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 1,
      y_width => 1
    )
    port map (
      x(0) => pfb_fft_fft_rdy_net,
      y(0) => slice1_y_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/phase_dmp/bus_create"

entity bus_create_entity_82ee1db973 is
  port (
    in1: in std_logic_vector(3 downto 0); 
    in2: in std_logic_vector(11 downto 0); 
    in3: in std_logic_vector(11 downto 0); 
    in4: in std_logic_vector(11 downto 0); 
    in5: in std_logic_vector(11 downto 0); 
    in6: in std_logic_vector(11 downto 0); 
    bus_out: out std_logic_vector(63 downto 0)
  );
end bus_create_entity_82ee1db973;

architecture structural of bus_create_entity_82ee1db973 is
  signal concatenate_y_net_x0: std_logic_vector(63 downto 0);
  signal constant9_op_net_x0: std_logic_vector(3 downto 0);
  signal delay3_q_net_x0: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x3: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x4: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x5: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x6: std_logic_vector(11 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(3 downto 0);
  signal reinterpret2_output_port_net: std_logic_vector(11 downto 0);
  signal reinterpret3_output_port_net: std_logic_vector(11 downto 0);
  signal reinterpret4_output_port_net: std_logic_vector(11 downto 0);
  signal reinterpret5_output_port_net: std_logic_vector(11 downto 0);
  signal reinterpret6_output_port_net: std_logic_vector(11 downto 0);

begin
  constant9_op_net_x0 <= in1;
  delay3_q_net_x0 <= in2;
  ram_data_out_net_x5 <= in3;
  ram_data_out_net_x3 <= in4;
  ram_data_out_net_x4 <= in5;
  ram_data_out_net_x6 <= in6;
  bus_out <= concatenate_y_net_x0;

  concatenate: entity work.concat_b2d311b112
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret1_output_port_net,
      in1 => reinterpret2_output_port_net,
      in2 => reinterpret3_output_port_net,
      in3 => reinterpret4_output_port_net,
      in4 => reinterpret5_output_port_net,
      in5 => reinterpret6_output_port_net,
      y => concatenate_y_net_x0
    );

  reinterpret1: entity work.reinterpret_d610556e85
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => constant9_op_net_x0,
      output_port => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_a106f99236
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => delay3_q_net_x0,
      output_port => reinterpret2_output_port_net
    );

  reinterpret3: entity work.reinterpret_a106f99236
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => ram_data_out_net_x5,
      output_port => reinterpret3_output_port_net
    );

  reinterpret4: entity work.reinterpret_a106f99236
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => ram_data_out_net_x3,
      output_port => reinterpret4_output_port_net
    );

  reinterpret5: entity work.reinterpret_a106f99236
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => ram_data_out_net_x4,
      output_port => reinterpret5_output_port_net
    );

  reinterpret6: entity work.reinterpret_a106f99236
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => ram_data_out_net_x6,
      output_port => reinterpret6_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/phase_dmp/ch_we"

entity ch_we_entity_de27eab464 is
  port (
    darkquad29_phase_dmp_ch_we_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end ch_we_entity_de27eab464;

architecture structural of ch_we_entity_de27eab464 is
  signal darkquad29_phase_dmp_ch_we_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_phase_dmp_ch_we_user_data_out_net_x0 <= darkquad29_phase_dmp_ch_we_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_phase_dmp_ch_we_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/phase_dmp/delay_bram1"

entity delay_bram1_entity_f18a60d3ce is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din: in std_logic_vector(11 downto 0); 
    dout: out std_logic_vector(11 downto 0)
  );
end delay_bram1_entity_f18a60d3ce;

architecture structural of delay_bram1_entity_f18a60d3ce is
  signal ce_1_sg_x563: std_logic;
  signal clk_1_sg_x563: std_logic;
  signal constant_op_net: std_logic;
  signal counter_op_net: std_logic_vector(7 downto 0);
  signal ram_data_out_net_x6: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x7: std_logic_vector(11 downto 0);

begin
  ce_1_sg_x563 <= ce_1;
  clk_1_sg_x563 <= clk_1;
  ram_data_out_net_x6 <= din;
  dout <= ram_data_out_net_x7;

  constant_x0: entity work.constant_6293007044
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant_op_net
    );

  counter: entity work.xlcounter_limit_darkquad29
    generic map (
      cnt_15_0 => 253,
      cnt_31_16 => 0,
      cnt_47_32 => 0,
      cnt_63_48 => 0,
      core_name0 => "cntr_11_0_564d43d07a40ef72",
      count_limited => 1,
      op_arith => xlUnsigned,
      op_width => 8
    )
    port map (
      ce => ce_1_sg_x563,
      clk => clk_1_sg_x563,
      clr => '0',
      en => "1",
      rst => "0",
      op => counter_op_net
    );

  ram: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_a5223615887f70b9",
      latency => 1
    )
    port map (
      addr => counter_op_net,
      ce => ce_1_sg_x563,
      clk => clk_1_sg_x563,
      data_in => ram_data_out_net_x6,
      en => "1",
      rst => "0",
      we(0) => constant_op_net,
      data_out => ram_data_out_net_x7
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/phase_dmp/on"

entity on_entity_ca6decc6d0 is
  port (
    darkquad29_phase_dmp_on_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end on_entity_ca6decc6d0;

architecture structural of on_entity_ca6decc6d0 is
  signal darkquad29_phase_dmp_on_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_phase_dmp_on_user_data_out_net_x0 <= darkquad29_phase_dmp_on_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_phase_dmp_on_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/phase_dmp"

entity phase_dmp_entity_b612ec57bc is
  port (
    ce_1: in std_logic; 
    ch_in: in std_logic_vector(7 downto 0); 
    clk_1: in std_logic; 
    darkquad29_phase_dmp_ch_we_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_phase_dmp_on_user_data_out: in std_logic_vector(31 downto 0); 
    data0: in std_logic_vector(11 downto 0); 
    data1: in std_logic_vector(11 downto 0); 
    data2: in std_logic_vector(11 downto 0); 
    data3: in std_logic_vector(11 downto 0); 
    gbe_data: out std_logic_vector(63 downto 0); 
    gbe_we: out std_logic
  );
end phase_dmp_entity_b612ec57bc;

architecture structural of phase_dmp_entity_b612ec57bc is
  signal ce_1_sg_x567: std_logic;
  signal clk_1_sg_x567: std_logic;
  signal concatenate_y_net_x0: std_logic_vector(63 downto 0);
  signal constant1_op_net: std_logic_vector(3 downto 0);
  signal constant9_op_net_x0: std_logic_vector(3 downto 0);
  signal darkquad29_phase_dmp_ch_we_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal darkquad29_phase_dmp_on_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal delay10_q_net_x2: std_logic_vector(11 downto 0);
  signal delay125_q_net: std_logic_vector(31 downto 0);
  signal delay126_q_net: std_logic_vector(31 downto 0);
  signal delay13_q_net_x3: std_logic_vector(7 downto 0);
  signal delay1_q_net: std_logic;
  signal delay33_q_net_x2: std_logic_vector(11 downto 0);
  signal delay3_q_net_x1: std_logic_vector(11 downto 0);
  signal delay45_q_net_x2: std_logic_vector(11 downto 0);
  signal delay4_q_net: std_logic;
  signal delay7_q_net_x0: std_logic_vector(63 downto 0);
  signal delay8_q_net_x2: std_logic_vector(11 downto 0);
  signal en1_y_net: std_logic;
  signal en2_y_net: std_logic_vector(1 downto 0);
  signal en3_y_net: std_logic_vector(7 downto 0);
  signal logical1_y_net_x0: std_logic;
  signal mux2_y_net: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x10: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x11: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x7: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x8: std_logic_vector(11 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal relational2_op_net: std_logic;
  signal relational_op_net: std_logic;
  signal vals_op_net: std_logic_vector(3 downto 0);

begin
  ce_1_sg_x567 <= ce_1;
  delay13_q_net_x3 <= ch_in;
  clk_1_sg_x567 <= clk_1;
  darkquad29_phase_dmp_ch_we_user_data_out_net_x1 <= darkquad29_phase_dmp_ch_we_user_data_out;
  darkquad29_phase_dmp_on_user_data_out_net_x1 <= darkquad29_phase_dmp_on_user_data_out;
  delay10_q_net_x2 <= data0;
  delay8_q_net_x2 <= data1;
  delay33_q_net_x2 <= data2;
  delay45_q_net_x2 <= data3;
  gbe_data <= delay7_q_net_x0;
  gbe_we <= logical1_y_net_x0;

  bus_create_82ee1db973: entity work.bus_create_entity_82ee1db973
    port map (
      in1 => constant9_op_net_x0,
      in2 => delay3_q_net_x1,
      in3 => ram_data_out_net_x7,
      in4 => ram_data_out_net_x8,
      in5 => ram_data_out_net_x10,
      in6 => ram_data_out_net_x11,
      bus_out => concatenate_y_net_x0
    );

  ch_we_de27eab464: entity work.ch_we_entity_de27eab464
    port map (
      darkquad29_phase_dmp_ch_we_user_data_out => darkquad29_phase_dmp_ch_we_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x0
    );

  constant1: entity work.constant_98c496058e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant1_op_net
    );

  constant9: entity work.constant_4c449dd556
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant9_op_net_x0
    );

  delay1: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x567,
      clk => clk_1_sg_x567,
      clr => '0',
      d(0) => en1_y_net,
      q(0) => delay1_q_net
    );

  delay125: entity work.delay_672d2b8d1e
    port map (
      ce => ce_1_sg_x567,
      clk => clk_1_sg_x567,
      clr => '0',
      d => reint1_output_port_net_x1,
      q => delay125_q_net
    );

  delay126: entity work.delay_672d2b8d1e
    port map (
      ce => ce_1_sg_x567,
      clk => clk_1_sg_x567,
      clr => '0',
      d => reint1_output_port_net_x0,
      q => delay126_q_net
    );

  delay3: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 12
    )
    port map (
      ce => ce_1_sg_x567,
      clk => clk_1_sg_x567,
      d => mux2_y_net,
      en => '1',
      rst => '1',
      q => delay3_q_net_x1
    );

  delay4: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x567,
      clk => clk_1_sg_x567,
      clr => '0',
      d(0) => delay1_q_net,
      q(0) => delay4_q_net
    );

  delay7: entity work.delay_e2d047c154
    port map (
      ce => ce_1_sg_x567,
      clk => clk_1_sg_x567,
      clr => '0',
      d => concatenate_y_net_x0,
      q => delay7_q_net_x0
    );

  delay_bram1_f18a60d3ce: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x567,
      clk_1 => clk_1_sg_x567,
      din => ram_data_out_net_x7,
      dout => ram_data_out_net_x8
    );

  delay_bram2_26208ad157: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x567,
      clk_1 => clk_1_sg_x567,
      din => ram_data_out_net_x8,
      dout => ram_data_out_net_x10
    );

  delay_bram3_fedf31e6d4: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x567,
      clk_1 => clk_1_sg_x567,
      din => delay3_q_net_x1,
      dout => ram_data_out_net_x7
    );

  delay_bram4_7401f78293: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x567,
      clk_1 => clk_1_sg_x567,
      din => ram_data_out_net_x10,
      dout => ram_data_out_net_x11
    );

  en1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => delay125_q_net,
      y(0) => en1_y_net
    );

  en2: entity work.xlslice
    generic map (
      new_lsb => 8,
      new_msb => 9,
      x_width => 32,
      y_width => 2
    )
    port map (
      x => delay126_q_net,
      y => en2_y_net
    );

  en3: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 7,
      x_width => 32,
      y_width => 8
    )
    port map (
      x => delay126_q_net,
      y => en3_y_net
    );

  logical1: entity work.logical_799f62af22
    port map (
      ce => ce_1_sg_x567,
      clk => clk_1_sg_x567,
      clr => '0',
      d0(0) => relational_op_net,
      d1(0) => delay4_q_net,
      y(0) => logical1_y_net_x0
    );

  mux2: entity work.mux_154cbccbb1
    port map (
      ce => ce_1_sg_x567,
      clk => clk_1_sg_x567,
      clr => '0',
      d0 => delay10_q_net_x2,
      d1 => delay8_q_net_x2,
      d2 => delay33_q_net_x2,
      d3 => delay45_q_net_x2,
      sel => en2_y_net,
      y => mux2_y_net
    );

  on_ca6decc6d0: entity work.on_entity_ca6decc6d0
    port map (
      darkquad29_phase_dmp_on_user_data_out => darkquad29_phase_dmp_on_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x1
    );

  relational: entity work.relational_588bf593b1
    port map (
      a => vals_op_net,
      b => constant1_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational_op_net
    );

  relational2: entity work.relational_deb0401f42
    port map (
      a => delay13_q_net_x3,
      b => en3_y_net,
      ce => ce_1_sg_x567,
      clk => clk_1_sg_x567,
      clr => '0',
      op(0) => relational2_op_net
    );

  vals: entity work.xlcounter_free_darkquad29
    generic map (
      core_name0 => "cntr_11_0_68b407ad69be9ca8",
      op_arith => xlUnsigned,
      op_width => 4
    )
    port map (
      ce => ce_1_sg_x567,
      clk => clk_1_sg_x567,
      clr => '0',
      en(0) => relational2_op_net,
      rst(0) => relational_op_net,
      op => vals_op_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/phase_port"

entity phase_port_entity_f9871a72ee is
  port (
    darkquad29_phase_port_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end phase_port_entity_f9871a72ee;

architecture structural of phase_port_entity_f9871a72ee is
  signal darkquad29_phase_port_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_phase_port_user_data_out_net_x0 <= darkquad29_phase_port_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_phase_port_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/photon_port"

entity photon_port_entity_7880d661a3 is
  port (
    darkquad29_photon_port_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end photon_port_entity_7880d661a3;

architecture structural of photon_port_entity_7880d661a3 is
  signal darkquad29_photon_port_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_photon_port_user_data_out_net_x0 <= darkquad29_photon_port_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_photon_port_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/pipeline1"

entity pipeline1_entity_dac2d70fc1 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(575 downto 0); 
    q: out std_logic_vector(575 downto 0)
  );
end pipeline1_entity_dac2d70fc1;

architecture structural of pipeline1_entity_dac2d70fc1 is
  signal ce_1_sg_x568: std_logic;
  signal clk_1_sg_x568: std_logic;
  signal concatenate_y_net_x2: std_logic_vector(575 downto 0);
  signal register0_q_net: std_logic_vector(575 downto 0);
  signal register1_q_net_x1: std_logic_vector(575 downto 0);

begin
  ce_1_sg_x568 <= ce_1;
  clk_1_sg_x568 <= clk_1;
  concatenate_y_net_x2 <= d;
  q <= register1_q_net_x1;

  register0: entity work.xlregister
    generic map (
      d_width => 576,
      init_value => b"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
    )
    port map (
      ce => ce_1_sg_x568,
      clk => clk_1_sg_x568,
      d => concatenate_y_net_x2,
      en => "1",
      rst => "0",
      q => register0_q_net
    );

  register1: entity work.xlregister
    generic map (
      d_width => 576,
      init_value => b"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
    )
    port map (
      ce => ce_1_sg_x568,
      clk => clk_1_sg_x568,
      d => register0_q_net,
      en => "1",
      rst => "0",
      q => register1_q_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/pipeline10"

entity pipeline10_entity_744174dac8 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(63 downto 0); 
    q: out std_logic_vector(63 downto 0)
  );
end pipeline10_entity_744174dac8;

architecture structural of pipeline10_entity_744174dac8 is
  signal ce_1_sg_x569: std_logic;
  signal clk_1_sg_x569: std_logic;
  signal mux_y_net_x1: std_logic_vector(63 downto 0);
  signal register0_q_net: std_logic_vector(63 downto 0);
  signal register1_q_net_x0: std_logic_vector(63 downto 0);

begin
  ce_1_sg_x569 <= ce_1;
  clk_1_sg_x569 <= clk_1;
  mux_y_net_x1 <= d;
  q <= register1_q_net_x0;

  register0: entity work.xlregister
    generic map (
      d_width => 64,
      init_value => b"0000000000000000000000000000000000000000000000000000000000000000"
    )
    port map (
      ce => ce_1_sg_x569,
      clk => clk_1_sg_x569,
      d => mux_y_net_x1,
      en => "1",
      rst => "0",
      q => register0_q_net
    );

  register1: entity work.xlregister
    generic map (
      d_width => 64,
      init_value => b"0000000000000000000000000000000000000000000000000000000000000000"
    )
    port map (
      ce => ce_1_sg_x569,
      clk => clk_1_sg_x569,
      d => register0_q_net,
      en => "1",
      rst => "0",
      q => register1_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/pipeline14"

entity pipeline14_entity_5b68b86bd8 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(75 downto 0); 
    q: out std_logic_vector(75 downto 0)
  );
end pipeline14_entity_5b68b86bd8;

architecture structural of pipeline14_entity_5b68b86bd8 is
  signal ce_1_sg_x573: std_logic;
  signal clk_1_sg_x573: std_logic;
  signal concat_y_net_x1: std_logic_vector(75 downto 0);
  signal register0_q_net: std_logic_vector(75 downto 0);
  signal register1_q_net_x5: std_logic_vector(75 downto 0);

begin
  ce_1_sg_x573 <= ce_1;
  clk_1_sg_x573 <= clk_1;
  concat_y_net_x1 <= d;
  q <= register1_q_net_x5;

  register0: entity work.xlregister
    generic map (
      d_width => 76,
      init_value => b"0000000000000000000000000000000000000000000000000000000000000000000000000000"
    )
    port map (
      ce => ce_1_sg_x573,
      clk => clk_1_sg_x573,
      d => concat_y_net_x1,
      en => "1",
      rst => "0",
      q => register0_q_net
    );

  register1: entity work.xlregister
    generic map (
      d_width => 76,
      init_value => b"0000000000000000000000000000000000000000000000000000000000000000000000000000"
    )
    port map (
      ce => ce_1_sg_x573,
      clk => clk_1_sg_x573,
      d => register0_q_net,
      en => "1",
      rst => "0",
      q => register1_q_net_x5
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/pipeline2"

entity pipeline2_entity_67c1158a1a is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(191 downto 0); 
    q: out std_logic_vector(191 downto 0)
  );
end pipeline2_entity_67c1158a1a;

architecture structural of pipeline2_entity_67c1158a1a is
  signal ce_1_sg_x579: std_logic;
  signal clk_1_sg_x579: std_logic;
  signal concatenate_y_net_x2: std_logic_vector(191 downto 0);
  signal register0_q_net: std_logic_vector(191 downto 0);
  signal register1_q_net_x3: std_logic_vector(191 downto 0);

begin
  ce_1_sg_x579 <= ce_1;
  clk_1_sg_x579 <= clk_1;
  concatenate_y_net_x2 <= d;
  q <= register1_q_net_x3;

  register0: entity work.xlregister
    generic map (
      d_width => 192,
      init_value => b"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
    )
    port map (
      ce => ce_1_sg_x579,
      clk => clk_1_sg_x579,
      d => concatenate_y_net_x2,
      en => "1",
      rst => "0",
      q => register0_q_net
    );

  register1: entity work.xlregister
    generic map (
      d_width => 192,
      init_value => b"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
    )
    port map (
      ce => ce_1_sg_x579,
      clk => clk_1_sg_x579,
      d => register0_q_net,
      en => "1",
      rst => "0",
      q => register1_q_net_x3
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/pipeline23"

entity pipeline23_entity_b97e8b3020 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(275 downto 0); 
    q: out std_logic_vector(275 downto 0)
  );
end pipeline23_entity_b97e8b3020;

architecture structural of pipeline23_entity_b97e8b3020 is
  signal ce_1_sg_x583: std_logic;
  signal clk_1_sg_x583: std_logic;
  signal dual_port_ram_doutb_net_x1: std_logic_vector(275 downto 0);
  signal register0_q_net: std_logic_vector(275 downto 0);
  signal register1_q_net_x1: std_logic_vector(275 downto 0);

begin
  ce_1_sg_x583 <= ce_1;
  clk_1_sg_x583 <= clk_1;
  dual_port_ram_doutb_net_x1 <= d;
  q <= register1_q_net_x1;

  register0: entity work.xlregister
    generic map (
      d_width => 276,
      init_value => b"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
    )
    port map (
      ce => ce_1_sg_x583,
      clk => clk_1_sg_x583,
      d => dual_port_ram_doutb_net_x1,
      en => "1",
      rst => "0",
      q => register0_q_net
    );

  register1: entity work.xlregister
    generic map (
      d_width => 276,
      init_value => b"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
    )
    port map (
      ce => ce_1_sg_x583,
      clk => clk_1_sg_x583,
      d => register0_q_net,
      en => "1",
      rst => "0",
      q => register1_q_net_x1
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/pipeline30"

entity pipeline30_entity_beeb8ae1a6 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(15 downto 0); 
    q: out std_logic_vector(15 downto 0)
  );
end pipeline30_entity_beeb8ae1a6;

architecture structural of pipeline30_entity_beeb8ae1a6 is
  signal ce_1_sg_x591: std_logic;
  signal clk_1_sg_x591: std_logic;
  signal delay58_q_net_x1: std_logic_vector(15 downto 0);
  signal register0_q_net_x0: std_logic_vector(15 downto 0);

begin
  ce_1_sg_x591 <= ce_1;
  clk_1_sg_x591 <= clk_1;
  delay58_q_net_x1 <= d;
  q <= register0_q_net_x0;

  register0: entity work.xlregister
    generic map (
      d_width => 16,
      init_value => b"0000000000000000"
    )
    port map (
      ce => ce_1_sg_x591,
      clk => clk_1_sg_x591,
      d => delay58_q_net_x1,
      en => "1",
      rst => "0",
      q => register0_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/pipeline4"

entity pipeline4_entity_f4fac8adb0 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(8 downto 0); 
    q: out std_logic_vector(8 downto 0)
  );
end pipeline4_entity_f4fac8adb0;

architecture structural of pipeline4_entity_f4fac8adb0 is
  signal ce_1_sg_x598: std_logic;
  signal clk_1_sg_x598: std_logic;
  signal register0_q_net: std_logic_vector(8 downto 0);
  signal register1_q_net_x2: std_logic_vector(8 downto 0);
  signal slice6_y_net_x0: std_logic_vector(8 downto 0);

begin
  ce_1_sg_x598 <= ce_1;
  clk_1_sg_x598 <= clk_1;
  slice6_y_net_x0 <= d;
  q <= register1_q_net_x2;

  register0: entity work.xlregister
    generic map (
      d_width => 9,
      init_value => b"000000000"
    )
    port map (
      ce => ce_1_sg_x598,
      clk => clk_1_sg_x598,
      d => slice6_y_net_x0,
      en => "1",
      rst => "0",
      q => register0_q_net
    );

  register1: entity work.xlregister
    generic map (
      d_width => 9,
      init_value => b"000000000"
    )
    port map (
      ce => ce_1_sg_x598,
      clk => clk_1_sg_x598,
      d => register0_q_net,
      en => "1",
      rst => "0",
      q => register1_q_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/pipeline6"

entity pipeline6_entity_f8a2b1329a is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(35 downto 0); 
    q: out std_logic_vector(35 downto 0)
  );
end pipeline6_entity_f8a2b1329a;

architecture structural of pipeline6_entity_f8a2b1329a is
  signal ce_1_sg_x600: std_logic;
  signal clk_1_sg_x600: std_logic;
  signal delay2_q_net_x0: std_logic_vector(35 downto 0);
  signal register0_q_net: std_logic_vector(35 downto 0);
  signal register1_q_net_x0: std_logic_vector(35 downto 0);

begin
  ce_1_sg_x600 <= ce_1;
  clk_1_sg_x600 <= clk_1;
  delay2_q_net_x0 <= d;
  q <= register1_q_net_x0;

  register0: entity work.xlregister
    generic map (
      d_width => 36,
      init_value => b"000000000000000000000000000000000000"
    )
    port map (
      ce => ce_1_sg_x600,
      clk => clk_1_sg_x600,
      d => delay2_q_net_x0,
      en => "1",
      rst => "0",
      q => register0_q_net
    );

  register1: entity work.xlregister
    generic map (
      d_width => 36,
      init_value => b"000000000000000000000000000000000000"
    )
    port map (
      ce => ce_1_sg_x600,
      clk => clk_1_sg_x600,
      d => register0_q_net,
      en => "1",
      rst => "0",
      q => register1_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/prog_fir0/bus_expand2"

entity bus_expand2_entity_3496d923b6 is
  port (
    bus_in: in std_logic_vector(31 downto 0); 
    lsb_out1: out std_logic_vector(7 downto 0); 
    out2: out std_logic
  );
end bus_expand2_entity_3496d923b6;

architecture structural of bus_expand2_entity_3496d923b6 is
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(7 downto 0);
  signal slice1_y_net: std_logic_vector(7 downto 0);
  signal slice2_y_net_x0: std_logic;

begin
  reint1_output_port_net_x0 <= bus_in;
  lsb_out1 <= reinterpret1_output_port_net_x0;
  out2 <= slice2_y_net_x0;

  reinterpret1: entity work.reinterpret_f21e7f2ddf
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x0
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 7,
      x_width => 32,
      y_width => 8
    )
    port map (
      x => reint1_output_port_net_x0,
      y => slice1_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 8,
      new_msb => 8,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => reint1_output_port_net_x0,
      y(0) => slice2_y_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/prog_fir0/fir/ch_dly0"

entity ch_dly0_entity_04048bfc8c is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(7 downto 0); 
    q: out std_logic_vector(7 downto 0)
  );
end ch_dly0_entity_04048bfc8c;

architecture structural of ch_dly0_entity_04048bfc8c is
  signal ce_1_sg_x605: std_logic;
  signal ch_mux_y_net_x0: std_logic_vector(7 downto 0);
  signal clk_1_sg_x605: std_logic;
  signal register0_q_net_x0: std_logic_vector(7 downto 0);

begin
  ce_1_sg_x605 <= ce_1;
  clk_1_sg_x605 <= clk_1;
  ch_mux_y_net_x0 <= d;
  q <= register0_q_net_x0;

  register0: entity work.xlregister
    generic map (
      d_width => 8,
      init_value => b"00000000"
    )
    port map (
      ce => ce_1_sg_x605,
      clk => clk_1_sg_x605,
      d => ch_mux_y_net_x0,
      en => "1",
      rst => "0",
      q => register0_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/prog_fir0/fir/coeff_in_dly0"

entity coeff_in_dly0_entity_f7e4d41e30 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(11 downto 0); 
    q: out std_logic_vector(11 downto 0)
  );
end coeff_in_dly0_entity_f7e4d41e30;

architecture structural of coeff_in_dly0_entity_f7e4d41e30 is
  signal ce_1_sg_x626: std_logic;
  signal clk_1_sg_x626: std_logic;
  signal register0_q_net: std_logic_vector(11 downto 0);
  signal register1_q_net_x1: std_logic_vector(11 downto 0);
  signal register1_q_net_x2: std_logic_vector(11 downto 0);

begin
  ce_1_sg_x626 <= ce_1;
  clk_1_sg_x626 <= clk_1;
  register1_q_net_x1 <= d;
  q <= register1_q_net_x2;

  register0: entity work.xlregister
    generic map (
      d_width => 12,
      init_value => b"000000000000"
    )
    port map (
      ce => ce_1_sg_x626,
      clk => clk_1_sg_x626,
      d => register1_q_net_x1,
      en => "1",
      rst => "0",
      q => register0_q_net
    );

  register1: entity work.xlregister
    generic map (
      d_width => 12,
      init_value => b"000000000000"
    )
    port map (
      ce => ce_1_sg_x626,
      clk => clk_1_sg_x626,
      d => register0_q_net,
      en => "1",
      rst => "0",
      q => register1_q_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/prog_fir0/fir/coeff_in_dly11"

entity coeff_in_dly11_entity_0bdba45676 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(11 downto 0); 
    q: out std_logic_vector(11 downto 0)
  );
end coeff_in_dly11_entity_0bdba45676;

architecture structural of coeff_in_dly11_entity_0bdba45676 is
  signal ce_1_sg_x627: std_logic;
  signal clk_1_sg_x627: std_logic;
  signal register0_q_net_x0: std_logic_vector(11 downto 0);
  signal register1_q_net_x3: std_logic_vector(11 downto 0);

begin
  ce_1_sg_x627 <= ce_1;
  clk_1_sg_x627 <= clk_1;
  register1_q_net_x3 <= d;
  q <= register0_q_net_x0;

  register0: entity work.xlregister
    generic map (
      d_width => 12,
      init_value => b"000000000000"
    )
    port map (
      ce => ce_1_sg_x627,
      clk => clk_1_sg_x627,
      d => register1_q_net_x3,
      en => "1",
      rst => "0",
      q => register0_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/prog_fir0/fir/demux"

entity demux_entity_6d04537eec is
  port (
    ce_1: in std_logic; 
    clear: in std_logic; 
    clk_1: in std_logic; 
    in_x0: in std_logic_vector(7 downto 0); 
    out0: out std_logic; 
    out1: out std_logic; 
    out10: out std_logic; 
    out11: out std_logic; 
    out12: out std_logic; 
    out13: out std_logic; 
    out14: out std_logic; 
    out15: out std_logic; 
    out16: out std_logic; 
    out17: out std_logic; 
    out18: out std_logic; 
    out19: out std_logic; 
    out2: out std_logic; 
    out20: out std_logic; 
    out21: out std_logic; 
    out22: out std_logic; 
    out23: out std_logic; 
    out24: out std_logic; 
    out25: out std_logic; 
    out26: out std_logic; 
    out27: out std_logic; 
    out28: out std_logic; 
    out29: out std_logic; 
    out3: out std_logic; 
    out30: out std_logic; 
    out31: out std_logic; 
    out32: out std_logic; 
    out33: out std_logic; 
    out34: out std_logic; 
    out35: out std_logic; 
    out36: out std_logic; 
    out37: out std_logic; 
    out38: out std_logic; 
    out39: out std_logic; 
    out4: out std_logic; 
    out40: out std_logic; 
    out41: out std_logic; 
    out42: out std_logic; 
    out43: out std_logic; 
    out44: out std_logic; 
    out45: out std_logic; 
    out46: out std_logic; 
    out47: out std_logic; 
    out48: out std_logic; 
    out49: out std_logic; 
    out5: out std_logic; 
    out6: out std_logic; 
    out7: out std_logic; 
    out8: out std_logic; 
    out9: out std_logic
  );
end demux_entity_6d04537eec;

architecture structural of demux_entity_6d04537eec is
  signal ce_1_sg_x696: std_logic;
  signal clear_const_op_net: std_logic_vector(5 downto 0);
  signal clear_mux_y_net: std_logic_vector(7 downto 0);
  signal clk_1_sg_x696: std_logic;
  signal const0_op_net: std_logic_vector(5 downto 0);
  signal const10_op_net: std_logic_vector(5 downto 0);
  signal const11_op_net: std_logic_vector(5 downto 0);
  signal const12_op_net: std_logic_vector(5 downto 0);
  signal const13_op_net: std_logic_vector(5 downto 0);
  signal const14_op_net: std_logic_vector(5 downto 0);
  signal const15_op_net: std_logic_vector(5 downto 0);
  signal const16_op_net: std_logic_vector(5 downto 0);
  signal const17_op_net: std_logic_vector(5 downto 0);
  signal const18_op_net: std_logic_vector(5 downto 0);
  signal const19_op_net: std_logic_vector(5 downto 0);
  signal const1_op_net: std_logic_vector(5 downto 0);
  signal const20_op_net: std_logic_vector(5 downto 0);
  signal const21_op_net: std_logic_vector(5 downto 0);
  signal const22_op_net: std_logic_vector(5 downto 0);
  signal const23_op_net: std_logic_vector(5 downto 0);
  signal const24_op_net: std_logic_vector(5 downto 0);
  signal const25_op_net: std_logic_vector(5 downto 0);
  signal const26_op_net: std_logic_vector(5 downto 0);
  signal const27_op_net: std_logic_vector(5 downto 0);
  signal const28_op_net: std_logic_vector(5 downto 0);
  signal const29_op_net: std_logic_vector(5 downto 0);
  signal const2_op_net: std_logic_vector(5 downto 0);
  signal const30_op_net: std_logic_vector(5 downto 0);
  signal const31_op_net: std_logic_vector(5 downto 0);
  signal const32_op_net: std_logic_vector(5 downto 0);
  signal const33_op_net: std_logic_vector(5 downto 0);
  signal const34_op_net: std_logic_vector(5 downto 0);
  signal const35_op_net: std_logic_vector(5 downto 0);
  signal const36_op_net: std_logic_vector(5 downto 0);
  signal const37_op_net: std_logic_vector(5 downto 0);
  signal const38_op_net: std_logic_vector(5 downto 0);
  signal const39_op_net: std_logic_vector(5 downto 0);
  signal const3_op_net: std_logic_vector(5 downto 0);
  signal const40_op_net: std_logic_vector(5 downto 0);
  signal const41_op_net: std_logic_vector(5 downto 0);
  signal const42_op_net: std_logic_vector(5 downto 0);
  signal const43_op_net: std_logic_vector(5 downto 0);
  signal const44_op_net: std_logic_vector(5 downto 0);
  signal const45_op_net: std_logic_vector(5 downto 0);
  signal const46_op_net: std_logic_vector(5 downto 0);
  signal const47_op_net: std_logic_vector(5 downto 0);
  signal const48_op_net: std_logic_vector(5 downto 0);
  signal const49_op_net: std_logic_vector(5 downto 0);
  signal const4_op_net: std_logic_vector(5 downto 0);
  signal const5_op_net: std_logic_vector(5 downto 0);
  signal const6_op_net: std_logic_vector(5 downto 0);
  signal const7_op_net: std_logic_vector(5 downto 0);
  signal const8_op_net: std_logic_vector(5 downto 0);
  signal const9_op_net: std_logic_vector(5 downto 0);
  signal not_clear_op_net_x0: std_logic;
  signal relational0_op_net_x0: std_logic;
  signal relational10_op_net_x0: std_logic;
  signal relational11_op_net_x0: std_logic;
  signal relational12_op_net_x0: std_logic;
  signal relational13_op_net_x0: std_logic;
  signal relational14_op_net_x0: std_logic;
  signal relational15_op_net_x0: std_logic;
  signal relational16_op_net_x0: std_logic;
  signal relational17_op_net_x0: std_logic;
  signal relational18_op_net_x0: std_logic;
  signal relational19_op_net_x0: std_logic;
  signal relational1_op_net_x0: std_logic;
  signal relational20_op_net_x0: std_logic;
  signal relational21_op_net_x0: std_logic;
  signal relational22_op_net_x0: std_logic;
  signal relational23_op_net_x0: std_logic;
  signal relational24_op_net_x0: std_logic;
  signal relational25_op_net_x0: std_logic;
  signal relational26_op_net_x0: std_logic;
  signal relational27_op_net_x0: std_logic;
  signal relational28_op_net_x0: std_logic;
  signal relational29_op_net_x0: std_logic;
  signal relational2_op_net_x0: std_logic;
  signal relational30_op_net_x0: std_logic;
  signal relational31_op_net_x0: std_logic;
  signal relational32_op_net_x0: std_logic;
  signal relational33_op_net_x0: std_logic;
  signal relational34_op_net_x0: std_logic;
  signal relational35_op_net_x0: std_logic;
  signal relational36_op_net_x0: std_logic;
  signal relational37_op_net_x0: std_logic;
  signal relational38_op_net_x0: std_logic;
  signal relational39_op_net_x0: std_logic;
  signal relational3_op_net_x0: std_logic;
  signal relational40_op_net_x0: std_logic;
  signal relational41_op_net_x0: std_logic;
  signal relational42_op_net_x0: std_logic;
  signal relational43_op_net_x0: std_logic;
  signal relational44_op_net_x0: std_logic;
  signal relational45_op_net_x0: std_logic;
  signal relational46_op_net_x0: std_logic;
  signal relational47_op_net_x0: std_logic;
  signal relational48_op_net_x0: std_logic;
  signal relational49_op_net_x0: std_logic;
  signal relational4_op_net_x0: std_logic;
  signal relational5_op_net_x0: std_logic;
  signal relational6_op_net_x0: std_logic;
  signal relational7_op_net_x0: std_logic;
  signal relational8_op_net_x0: std_logic;
  signal relational9_op_net_x0: std_logic;
  signal tap_dly_q_net_x0: std_logic_vector(7 downto 0);

begin
  ce_1_sg_x696 <= ce_1;
  not_clear_op_net_x0 <= clear;
  clk_1_sg_x696 <= clk_1;
  tap_dly_q_net_x0 <= in_x0;
  out0 <= relational0_op_net_x0;
  out1 <= relational1_op_net_x0;
  out10 <= relational10_op_net_x0;
  out11 <= relational11_op_net_x0;
  out12 <= relational12_op_net_x0;
  out13 <= relational13_op_net_x0;
  out14 <= relational14_op_net_x0;
  out15 <= relational15_op_net_x0;
  out16 <= relational16_op_net_x0;
  out17 <= relational17_op_net_x0;
  out18 <= relational18_op_net_x0;
  out19 <= relational19_op_net_x0;
  out2 <= relational2_op_net_x0;
  out20 <= relational20_op_net_x0;
  out21 <= relational21_op_net_x0;
  out22 <= relational22_op_net_x0;
  out23 <= relational23_op_net_x0;
  out24 <= relational24_op_net_x0;
  out25 <= relational25_op_net_x0;
  out26 <= relational26_op_net_x0;
  out27 <= relational27_op_net_x0;
  out28 <= relational28_op_net_x0;
  out29 <= relational29_op_net_x0;
  out3 <= relational3_op_net_x0;
  out30 <= relational30_op_net_x0;
  out31 <= relational31_op_net_x0;
  out32 <= relational32_op_net_x0;
  out33 <= relational33_op_net_x0;
  out34 <= relational34_op_net_x0;
  out35 <= relational35_op_net_x0;
  out36 <= relational36_op_net_x0;
  out37 <= relational37_op_net_x0;
  out38 <= relational38_op_net_x0;
  out39 <= relational39_op_net_x0;
  out4 <= relational4_op_net_x0;
  out40 <= relational40_op_net_x0;
  out41 <= relational41_op_net_x0;
  out42 <= relational42_op_net_x0;
  out43 <= relational43_op_net_x0;
  out44 <= relational44_op_net_x0;
  out45 <= relational45_op_net_x0;
  out46 <= relational46_op_net_x0;
  out47 <= relational47_op_net_x0;
  out48 <= relational48_op_net_x0;
  out49 <= relational49_op_net_x0;
  out5 <= relational5_op_net_x0;
  out6 <= relational6_op_net_x0;
  out7 <= relational7_op_net_x0;
  out8 <= relational8_op_net_x0;
  out9 <= relational9_op_net_x0;

  clear_const: entity work.constant_15f77a5e60
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => clear_const_op_net
    );

  clear_mux: entity work.mux_3b3085a060
    port map (
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      d0 => tap_dly_q_net_x0,
      d1 => clear_const_op_net,
      sel(0) => not_clear_op_net_x0,
      y => clear_mux_y_net
    );

  const0: entity work.constant_7ea0f2fff7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const0_op_net
    );

  const1: entity work.constant_a267c870be
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const1_op_net
    );

  const10: entity work.constant_a28c2d1fea
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const10_op_net
    );

  const11: entity work.constant_83bfa6ed5c
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const11_op_net
    );

  const12: entity work.constant_867183d3c8
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const12_op_net
    );

  const13: entity work.constant_ca26f59938
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const13_op_net
    );

  const14: entity work.constant_f8030ea7db
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const14_op_net
    );

  const15: entity work.constant_c11beaf011
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const15_op_net
    );

  const16: entity work.constant_ce6cc530c8
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const16_op_net
    );

  const17: entity work.constant_5a107baba8
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const17_op_net
    );

  const18: entity work.constant_6cb0cf84c0
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const18_op_net
    );

  const19: entity work.constant_3bc8629db1
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const19_op_net
    );

  const2: entity work.constant_dfb485d67e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const2_op_net
    );

  const20: entity work.constant_de3da86eed
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const20_op_net
    );

  const21: entity work.constant_1f05b15a2d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const21_op_net
    );

  const22: entity work.constant_f36e0964bd
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const22_op_net
    );

  const23: entity work.constant_78bff27356
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const23_op_net
    );

  const24: entity work.constant_a0835b7af4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const24_op_net
    );

  const25: entity work.constant_dadb07d1b2
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const25_op_net
    );

  const26: entity work.constant_882e6dd45b
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const26_op_net
    );

  const27: entity work.constant_cc8c690106
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const27_op_net
    );

  const28: entity work.constant_bff4dd53be
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const28_op_net
    );

  const29: entity work.constant_c51d3b69e7
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const29_op_net
    );

  const3: entity work.constant_7838f1fc2f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const3_op_net
    );

  const30: entity work.constant_59f0bb8b82
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const30_op_net
    );

  const31: entity work.constant_81c0b8ae9e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const31_op_net
    );

  const32: entity work.constant_961b61f8a1
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const32_op_net
    );

  const33: entity work.constant_876b8ff9e3
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const33_op_net
    );

  const34: entity work.constant_b8537696ec
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const34_op_net
    );

  const35: entity work.constant_26b082061e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const35_op_net
    );

  const36: entity work.constant_1bd990e6f6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const36_op_net
    );

  const37: entity work.constant_b75e4fee82
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const37_op_net
    );

  const38: entity work.constant_9a9c207efc
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const38_op_net
    );

  const39: entity work.constant_469b4baee5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const39_op_net
    );

  const4: entity work.constant_faaf314423
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const4_op_net
    );

  const40: entity work.constant_bc23896e85
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const40_op_net
    );

  const41: entity work.constant_438191f757
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const41_op_net
    );

  const42: entity work.constant_04d08db870
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const42_op_net
    );

  const43: entity work.constant_8207020ee3
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const43_op_net
    );

  const44: entity work.constant_da99e60c9f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const44_op_net
    );

  const45: entity work.constant_f108a6e809
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const45_op_net
    );

  const46: entity work.constant_dc83107194
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const46_op_net
    );

  const47: entity work.constant_ef95fb0eb4
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const47_op_net
    );

  const48: entity work.constant_5c27e02321
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const48_op_net
    );

  const49: entity work.constant_0a4912b51f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const49_op_net
    );

  const5: entity work.constant_136a80e78d
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const5_op_net
    );

  const6: entity work.constant_f934e043ef
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const6_op_net
    );

  const7: entity work.constant_330e503d71
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const7_op_net
    );

  const8: entity work.constant_5606c09bd1
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const8_op_net
    );

  const9: entity work.constant_abe23f8d53
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => const9_op_net
    );

  relational0: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const0_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational0_op_net_x0
    );

  relational1: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const1_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational1_op_net_x0
    );

  relational10: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const10_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational10_op_net_x0
    );

  relational11: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const11_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational11_op_net_x0
    );

  relational12: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const12_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational12_op_net_x0
    );

  relational13: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const13_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational13_op_net_x0
    );

  relational14: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const14_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational14_op_net_x0
    );

  relational15: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const15_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational15_op_net_x0
    );

  relational16: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const16_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational16_op_net_x0
    );

  relational17: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const17_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational17_op_net_x0
    );

  relational18: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const18_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational18_op_net_x0
    );

  relational19: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const19_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational19_op_net_x0
    );

  relational2: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const2_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational2_op_net_x0
    );

  relational20: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const20_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational20_op_net_x0
    );

  relational21: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const21_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational21_op_net_x0
    );

  relational22: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const22_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational22_op_net_x0
    );

  relational23: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const23_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational23_op_net_x0
    );

  relational24: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const24_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational24_op_net_x0
    );

  relational25: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const25_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational25_op_net_x0
    );

  relational26: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const26_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational26_op_net_x0
    );

  relational27: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const27_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational27_op_net_x0
    );

  relational28: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const28_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational28_op_net_x0
    );

  relational29: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const29_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational29_op_net_x0
    );

  relational3: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const3_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational3_op_net_x0
    );

  relational30: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const30_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational30_op_net_x0
    );

  relational31: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const31_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational31_op_net_x0
    );

  relational32: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const32_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational32_op_net_x0
    );

  relational33: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const33_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational33_op_net_x0
    );

  relational34: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const34_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational34_op_net_x0
    );

  relational35: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const35_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational35_op_net_x0
    );

  relational36: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const36_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational36_op_net_x0
    );

  relational37: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const37_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational37_op_net_x0
    );

  relational38: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const38_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational38_op_net_x0
    );

  relational39: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const39_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational39_op_net_x0
    );

  relational4: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const4_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational4_op_net_x0
    );

  relational40: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const40_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational40_op_net_x0
    );

  relational41: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const41_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational41_op_net_x0
    );

  relational42: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const42_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational42_op_net_x0
    );

  relational43: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const43_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational43_op_net_x0
    );

  relational44: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const44_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational44_op_net_x0
    );

  relational45: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const45_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational45_op_net_x0
    );

  relational46: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const46_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational46_op_net_x0
    );

  relational47: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const47_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational47_op_net_x0
    );

  relational48: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const48_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational48_op_net_x0
    );

  relational49: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const49_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational49_op_net_x0
    );

  relational5: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const5_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational5_op_net_x0
    );

  relational6: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const6_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational6_op_net_x0
    );

  relational7: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const7_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational7_op_net_x0
    );

  relational8: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const8_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational8_op_net_x0
    );

  relational9: entity work.relational_87bfab432c
    port map (
      a => clear_mux_y_net,
      b => const9_op_net,
      ce => ce_1_sg_x696,
      clk => clk_1_sg_x696,
      clr => '0',
      op(0) => relational9_op_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/prog_fir0/fir/sum"

entity sum_entity_808a632832 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    din1: in std_logic_vector(23 downto 0); 
    din10: in std_logic_vector(23 downto 0); 
    din11: in std_logic_vector(23 downto 0); 
    din12: in std_logic_vector(23 downto 0); 
    din13: in std_logic_vector(23 downto 0); 
    din14: in std_logic_vector(23 downto 0); 
    din15: in std_logic_vector(23 downto 0); 
    din16: in std_logic_vector(23 downto 0); 
    din17: in std_logic_vector(23 downto 0); 
    din18: in std_logic_vector(23 downto 0); 
    din19: in std_logic_vector(23 downto 0); 
    din2: in std_logic_vector(23 downto 0); 
    din20: in std_logic_vector(23 downto 0); 
    din21: in std_logic_vector(23 downto 0); 
    din22: in std_logic_vector(23 downto 0); 
    din23: in std_logic_vector(23 downto 0); 
    din24: in std_logic_vector(23 downto 0); 
    din25: in std_logic_vector(23 downto 0); 
    din26: in std_logic_vector(23 downto 0); 
    din27: in std_logic_vector(23 downto 0); 
    din28: in std_logic_vector(23 downto 0); 
    din29: in std_logic_vector(23 downto 0); 
    din3: in std_logic_vector(23 downto 0); 
    din30: in std_logic_vector(23 downto 0); 
    din31: in std_logic_vector(23 downto 0); 
    din32: in std_logic_vector(23 downto 0); 
    din33: in std_logic_vector(23 downto 0); 
    din34: in std_logic_vector(23 downto 0); 
    din35: in std_logic_vector(23 downto 0); 
    din36: in std_logic_vector(23 downto 0); 
    din37: in std_logic_vector(23 downto 0); 
    din38: in std_logic_vector(23 downto 0); 
    din39: in std_logic_vector(23 downto 0); 
    din4: in std_logic_vector(23 downto 0); 
    din40: in std_logic_vector(23 downto 0); 
    din41: in std_logic_vector(23 downto 0); 
    din42: in std_logic_vector(23 downto 0); 
    din43: in std_logic_vector(23 downto 0); 
    din44: in std_logic_vector(23 downto 0); 
    din45: in std_logic_vector(23 downto 0); 
    din46: in std_logic_vector(23 downto 0); 
    din47: in std_logic_vector(23 downto 0); 
    din48: in std_logic_vector(23 downto 0); 
    din49: in std_logic_vector(23 downto 0); 
    din5: in std_logic_vector(23 downto 0); 
    din50: in std_logic_vector(23 downto 0); 
    din6: in std_logic_vector(23 downto 0); 
    din7: in std_logic_vector(23 downto 0); 
    din8: in std_logic_vector(23 downto 0); 
    din9: in std_logic_vector(23 downto 0); 
    sync: in std_logic_vector(7 downto 0); 
    dout: out std_logic_vector(29 downto 0); 
    sync_out: out std_logic_vector(7 downto 0)
  );
end sum_entity_808a632832;

architecture structural of sum_entity_808a632832 is
  signal addr10_s_net: std_logic_vector(24 downto 0);
  signal addr11_s_net: std_logic_vector(24 downto 0);
  signal addr12_s_net: std_logic_vector(24 downto 0);
  signal addr13_s_net: std_logic_vector(24 downto 0);
  signal addr14_s_net: std_logic_vector(24 downto 0);
  signal addr15_s_net: std_logic_vector(24 downto 0);
  signal addr16_s_net: std_logic_vector(24 downto 0);
  signal addr17_s_net: std_logic_vector(24 downto 0);
  signal addr18_s_net: std_logic_vector(24 downto 0);
  signal addr19_s_net: std_logic_vector(24 downto 0);
  signal addr1_s_net: std_logic_vector(24 downto 0);
  signal addr20_s_net: std_logic_vector(24 downto 0);
  signal addr21_s_net: std_logic_vector(24 downto 0);
  signal addr22_s_net: std_logic_vector(24 downto 0);
  signal addr23_s_net: std_logic_vector(24 downto 0);
  signal addr24_s_net: std_logic_vector(24 downto 0);
  signal addr25_s_net: std_logic_vector(24 downto 0);
  signal addr26_s_net: std_logic_vector(25 downto 0);
  signal addr27_s_net: std_logic_vector(25 downto 0);
  signal addr28_s_net: std_logic_vector(25 downto 0);
  signal addr29_s_net: std_logic_vector(25 downto 0);
  signal addr2_s_net: std_logic_vector(24 downto 0);
  signal addr30_s_net: std_logic_vector(25 downto 0);
  signal addr31_s_net: std_logic_vector(25 downto 0);
  signal addr32_s_net: std_logic_vector(25 downto 0);
  signal addr33_s_net: std_logic_vector(25 downto 0);
  signal addr34_s_net: std_logic_vector(25 downto 0);
  signal addr35_s_net: std_logic_vector(25 downto 0);
  signal addr36_s_net: std_logic_vector(25 downto 0);
  signal addr37_s_net: std_logic_vector(25 downto 0);
  signal addr39_s_net: std_logic_vector(26 downto 0);
  signal addr3_s_net: std_logic_vector(24 downto 0);
  signal addr40_s_net: std_logic_vector(26 downto 0);
  signal addr41_s_net: std_logic_vector(26 downto 0);
  signal addr42_s_net: std_logic_vector(26 downto 0);
  signal addr43_s_net: std_logic_vector(26 downto 0);
  signal addr44_s_net: std_logic_vector(26 downto 0);
  signal addr46_s_net: std_logic_vector(27 downto 0);
  signal addr47_s_net: std_logic_vector(27 downto 0);
  signal addr48_s_net: std_logic_vector(27 downto 0);
  signal addr4_s_net: std_logic_vector(24 downto 0);
  signal addr50_s_net: std_logic_vector(28 downto 0);
  signal addr51_s_net: std_logic_vector(28 downto 0);
  signal addr52_s_net_x0: std_logic_vector(29 downto 0);
  signal addr5_s_net: std_logic_vector(24 downto 0);
  signal addr6_s_net: std_logic_vector(24 downto 0);
  signal addr7_s_net: std_logic_vector(24 downto 0);
  signal addr8_s_net: std_logic_vector(24 downto 0);
  signal addr9_s_net: std_logic_vector(24 downto 0);
  signal ce_1_sg_x697: std_logic;
  signal clk_1_sg_x697: std_logic;
  signal dly38_q_net: std_logic_vector(24 downto 0);
  signal dly45_q_net: std_logic_vector(24 downto 0);
  signal dly49_q_net: std_logic_vector(24 downto 0);
  signal mult10_p_net_x0: std_logic_vector(23 downto 0);
  signal mult11_p_net_x0: std_logic_vector(23 downto 0);
  signal mult12_p_net_x0: std_logic_vector(23 downto 0);
  signal mult13_p_net_x0: std_logic_vector(23 downto 0);
  signal mult14_p_net_x0: std_logic_vector(23 downto 0);
  signal mult15_p_net_x0: std_logic_vector(23 downto 0);
  signal mult16_p_net_x0: std_logic_vector(23 downto 0);
  signal mult17_p_net_x0: std_logic_vector(23 downto 0);
  signal mult18_p_net_x0: std_logic_vector(23 downto 0);
  signal mult19_p_net_x0: std_logic_vector(23 downto 0);
  signal mult1_p_net_x0: std_logic_vector(23 downto 0);
  signal mult20_p_net_x0: std_logic_vector(23 downto 0);
  signal mult21_p_net_x0: std_logic_vector(23 downto 0);
  signal mult22_p_net_x0: std_logic_vector(23 downto 0);
  signal mult23_p_net_x0: std_logic_vector(23 downto 0);
  signal mult24_p_net_x0: std_logic_vector(23 downto 0);
  signal mult25_p_net_x0: std_logic_vector(23 downto 0);
  signal mult26_p_net_x0: std_logic_vector(23 downto 0);
  signal mult27_p_net_x0: std_logic_vector(23 downto 0);
  signal mult28_p_net_x0: std_logic_vector(23 downto 0);
  signal mult29_p_net_x0: std_logic_vector(23 downto 0);
  signal mult2_p_net_x0: std_logic_vector(23 downto 0);
  signal mult30_p_net_x0: std_logic_vector(23 downto 0);
  signal mult31_p_net_x0: std_logic_vector(23 downto 0);
  signal mult32_p_net_x0: std_logic_vector(23 downto 0);
  signal mult33_p_net_x0: std_logic_vector(23 downto 0);
  signal mult34_p_net_x0: std_logic_vector(23 downto 0);
  signal mult35_p_net_x0: std_logic_vector(23 downto 0);
  signal mult36_p_net_x0: std_logic_vector(23 downto 0);
  signal mult37_p_net_x0: std_logic_vector(23 downto 0);
  signal mult38_p_net_x0: std_logic_vector(23 downto 0);
  signal mult39_p_net_x0: std_logic_vector(23 downto 0);
  signal mult3_p_net_x0: std_logic_vector(23 downto 0);
  signal mult40_p_net_x0: std_logic_vector(23 downto 0);
  signal mult41_p_net_x0: std_logic_vector(23 downto 0);
  signal mult42_p_net_x0: std_logic_vector(23 downto 0);
  signal mult43_p_net_x0: std_logic_vector(23 downto 0);
  signal mult44_p_net_x0: std_logic_vector(23 downto 0);
  signal mult45_p_net_x0: std_logic_vector(23 downto 0);
  signal mult46_p_net_x0: std_logic_vector(23 downto 0);
  signal mult47_p_net_x0: std_logic_vector(23 downto 0);
  signal mult48_p_net_x0: std_logic_vector(23 downto 0);
  signal mult49_p_net_x0: std_logic_vector(23 downto 0);
  signal mult4_p_net_x0: std_logic_vector(23 downto 0);
  signal mult50_p_net_x0: std_logic_vector(23 downto 0);
  signal mult5_p_net_x0: std_logic_vector(23 downto 0);
  signal mult6_p_net_x0: std_logic_vector(23 downto 0);
  signal mult7_p_net_x0: std_logic_vector(23 downto 0);
  signal mult8_p_net_x0: std_logic_vector(23 downto 0);
  signal mult9_p_net_x0: std_logic_vector(23 downto 0);
  signal sync_delay_q_net_x1: std_logic_vector(7 downto 0);
  signal sync_delay_q_net_x2: std_logic_vector(7 downto 0);

begin
  ce_1_sg_x697 <= ce_1;
  clk_1_sg_x697 <= clk_1;
  mult50_p_net_x0 <= din1;
  mult41_p_net_x0 <= din10;
  mult40_p_net_x0 <= din11;
  mult39_p_net_x0 <= din12;
  mult38_p_net_x0 <= din13;
  mult37_p_net_x0 <= din14;
  mult36_p_net_x0 <= din15;
  mult35_p_net_x0 <= din16;
  mult34_p_net_x0 <= din17;
  mult33_p_net_x0 <= din18;
  mult32_p_net_x0 <= din19;
  mult49_p_net_x0 <= din2;
  mult31_p_net_x0 <= din20;
  mult30_p_net_x0 <= din21;
  mult29_p_net_x0 <= din22;
  mult28_p_net_x0 <= din23;
  mult27_p_net_x0 <= din24;
  mult26_p_net_x0 <= din25;
  mult25_p_net_x0 <= din26;
  mult24_p_net_x0 <= din27;
  mult23_p_net_x0 <= din28;
  mult22_p_net_x0 <= din29;
  mult48_p_net_x0 <= din3;
  mult21_p_net_x0 <= din30;
  mult20_p_net_x0 <= din31;
  mult19_p_net_x0 <= din32;
  mult18_p_net_x0 <= din33;
  mult17_p_net_x0 <= din34;
  mult16_p_net_x0 <= din35;
  mult15_p_net_x0 <= din36;
  mult14_p_net_x0 <= din37;
  mult13_p_net_x0 <= din38;
  mult12_p_net_x0 <= din39;
  mult47_p_net_x0 <= din4;
  mult11_p_net_x0 <= din40;
  mult10_p_net_x0 <= din41;
  mult9_p_net_x0 <= din42;
  mult8_p_net_x0 <= din43;
  mult7_p_net_x0 <= din44;
  mult6_p_net_x0 <= din45;
  mult5_p_net_x0 <= din46;
  mult4_p_net_x0 <= din47;
  mult3_p_net_x0 <= din48;
  mult2_p_net_x0 <= din49;
  mult46_p_net_x0 <= din5;
  mult1_p_net_x0 <= din50;
  mult45_p_net_x0 <= din6;
  mult44_p_net_x0 <= din7;
  mult43_p_net_x0 <= din8;
  mult42_p_net_x0 <= din9;
  sync_delay_q_net_x1 <= sync;
  dout <= addr52_s_net_x0;
  sync_out <= sync_delay_q_net_x2;

  addr1: entity work.addsub_7b135dcb24
    port map (
      a => mult50_p_net_x0,
      b => mult49_p_net_x0,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      s => addr1_s_net
    );

  addr10: entity work.addsub_7b135dcb24
    port map (
      a => mult32_p_net_x0,
      b => mult31_p_net_x0,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      s => addr10_s_net
    );

  addr11: entity work.addsub_7b135dcb24
    port map (
      a => mult30_p_net_x0,
      b => mult29_p_net_x0,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      s => addr11_s_net
    );

  addr12: entity work.addsub_7b135dcb24
    port map (
      a => mult28_p_net_x0,
      b => mult27_p_net_x0,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      s => addr12_s_net
    );

  addr13: entity work.addsub_7b135dcb24
    port map (
      a => mult26_p_net_x0,
      b => mult25_p_net_x0,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      s => addr13_s_net
    );

  addr14: entity work.addsub_7b135dcb24
    port map (
      a => mult24_p_net_x0,
      b => mult23_p_net_x0,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      s => addr14_s_net
    );

  addr15: entity work.addsub_7b135dcb24
    port map (
      a => mult22_p_net_x0,
      b => mult21_p_net_x0,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      s => addr15_s_net
    );

  addr16: entity work.addsub_7b135dcb24
    port map (
      a => mult20_p_net_x0,
      b => mult19_p_net_x0,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      s => addr16_s_net
    );

  addr17: entity work.addsub_7b135dcb24
    port map (
      a => mult18_p_net_x0,
      b => mult17_p_net_x0,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      s => addr17_s_net
    );

  addr18: entity work.addsub_7b135dcb24
    port map (
      a => mult16_p_net_x0,
      b => mult15_p_net_x0,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      s => addr18_s_net
    );

  addr19: entity work.addsub_7b135dcb24
    port map (
      a => mult14_p_net_x0,
      b => mult13_p_net_x0,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      s => addr19_s_net
    );

  addr2: entity work.addsub_7b135dcb24
    port map (
      a => mult48_p_net_x0,
      b => mult47_p_net_x0,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      s => addr2_s_net
    );

  addr20: entity work.addsub_7b135dcb24
    port map (
      a => mult12_p_net_x0,
      b => mult11_p_net_x0,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      s => addr20_s_net
    );

  addr21: entity work.addsub_7b135dcb24
    port map (
      a => mult10_p_net_x0,
      b => mult9_p_net_x0,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      s => addr21_s_net
    );

  addr22: entity work.addsub_7b135dcb24
    port map (
      a => mult8_p_net_x0,
      b => mult7_p_net_x0,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      s => addr22_s_net
    );

  addr23: entity work.addsub_7b135dcb24
    port map (
      a => mult6_p_net_x0,
      b => mult5_p_net_x0,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      s => addr23_s_net
    );

  addr24: entity work.addsub_7b135dcb24
    port map (
      a => mult4_p_net_x0,
      b => mult3_p_net_x0,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      s => addr24_s_net
    );

  addr25: entity work.addsub_7b135dcb24
    port map (
      a => mult2_p_net_x0,
      b => mult1_p_net_x0,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      s => addr25_s_net
    );

  addr26: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 18,
      a_width => 25,
      b_arith => xlSigned,
      b_bin_pt => 18,
      b_width => 25,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 26,
      core_name0 => "addsb_11_0_905df78b66389ded",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 26,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 18,
      s_width => 26
    )
    port map (
      a => addr1_s_net,
      b => addr2_s_net,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      en => "1",
      s => addr26_s_net
    );

  addr27: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 18,
      a_width => 25,
      b_arith => xlSigned,
      b_bin_pt => 18,
      b_width => 25,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 26,
      core_name0 => "addsb_11_0_905df78b66389ded",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 26,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 18,
      s_width => 26
    )
    port map (
      a => addr3_s_net,
      b => addr4_s_net,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      en => "1",
      s => addr27_s_net
    );

  addr28: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 18,
      a_width => 25,
      b_arith => xlSigned,
      b_bin_pt => 18,
      b_width => 25,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 26,
      core_name0 => "addsb_11_0_905df78b66389ded",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 26,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 18,
      s_width => 26
    )
    port map (
      a => addr5_s_net,
      b => addr6_s_net,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      en => "1",
      s => addr28_s_net
    );

  addr29: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 18,
      a_width => 25,
      b_arith => xlSigned,
      b_bin_pt => 18,
      b_width => 25,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 26,
      core_name0 => "addsb_11_0_905df78b66389ded",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 26,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 18,
      s_width => 26
    )
    port map (
      a => addr7_s_net,
      b => addr8_s_net,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      en => "1",
      s => addr29_s_net
    );

  addr3: entity work.addsub_7b135dcb24
    port map (
      a => mult46_p_net_x0,
      b => mult45_p_net_x0,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      s => addr3_s_net
    );

  addr30: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 18,
      a_width => 25,
      b_arith => xlSigned,
      b_bin_pt => 18,
      b_width => 25,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 26,
      core_name0 => "addsb_11_0_905df78b66389ded",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 26,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 18,
      s_width => 26
    )
    port map (
      a => addr9_s_net,
      b => addr10_s_net,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      en => "1",
      s => addr30_s_net
    );

  addr31: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 18,
      a_width => 25,
      b_arith => xlSigned,
      b_bin_pt => 18,
      b_width => 25,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 26,
      core_name0 => "addsb_11_0_905df78b66389ded",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 26,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 18,
      s_width => 26
    )
    port map (
      a => addr11_s_net,
      b => addr12_s_net,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      en => "1",
      s => addr31_s_net
    );

  addr32: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 18,
      a_width => 25,
      b_arith => xlSigned,
      b_bin_pt => 18,
      b_width => 25,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 26,
      core_name0 => "addsb_11_0_905df78b66389ded",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 26,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 18,
      s_width => 26
    )
    port map (
      a => addr13_s_net,
      b => addr14_s_net,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      en => "1",
      s => addr32_s_net
    );

  addr33: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 18,
      a_width => 25,
      b_arith => xlSigned,
      b_bin_pt => 18,
      b_width => 25,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 26,
      core_name0 => "addsb_11_0_905df78b66389ded",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 26,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 18,
      s_width => 26
    )
    port map (
      a => addr15_s_net,
      b => addr16_s_net,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      en => "1",
      s => addr33_s_net
    );

  addr34: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 18,
      a_width => 25,
      b_arith => xlSigned,
      b_bin_pt => 18,
      b_width => 25,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 26,
      core_name0 => "addsb_11_0_905df78b66389ded",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 26,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 18,
      s_width => 26
    )
    port map (
      a => addr17_s_net,
      b => addr18_s_net,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      en => "1",
      s => addr34_s_net
    );

  addr35: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 18,
      a_width => 25,
      b_arith => xlSigned,
      b_bin_pt => 18,
      b_width => 25,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 26,
      core_name0 => "addsb_11_0_905df78b66389ded",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 26,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 18,
      s_width => 26
    )
    port map (
      a => addr19_s_net,
      b => addr20_s_net,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      en => "1",
      s => addr35_s_net
    );

  addr36: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 18,
      a_width => 25,
      b_arith => xlSigned,
      b_bin_pt => 18,
      b_width => 25,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 26,
      core_name0 => "addsb_11_0_905df78b66389ded",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 26,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 18,
      s_width => 26
    )
    port map (
      a => addr21_s_net,
      b => addr22_s_net,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      en => "1",
      s => addr36_s_net
    );

  addr37: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 18,
      a_width => 25,
      b_arith => xlSigned,
      b_bin_pt => 18,
      b_width => 25,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 26,
      core_name0 => "addsb_11_0_905df78b66389ded",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 26,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 18,
      s_width => 26
    )
    port map (
      a => addr23_s_net,
      b => addr24_s_net,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      en => "1",
      s => addr37_s_net
    );

  addr39: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 18,
      a_width => 26,
      b_arith => xlSigned,
      b_bin_pt => 18,
      b_width => 26,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 27,
      core_name0 => "addsb_11_0_4e2bc60003cf26be",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 27,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 18,
      s_width => 27
    )
    port map (
      a => addr26_s_net,
      b => addr27_s_net,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      en => "1",
      s => addr39_s_net
    );

  addr4: entity work.addsub_7b135dcb24
    port map (
      a => mult44_p_net_x0,
      b => mult43_p_net_x0,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      s => addr4_s_net
    );

  addr40: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 18,
      a_width => 26,
      b_arith => xlSigned,
      b_bin_pt => 18,
      b_width => 26,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 27,
      core_name0 => "addsb_11_0_4e2bc60003cf26be",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 27,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 18,
      s_width => 27
    )
    port map (
      a => addr28_s_net,
      b => addr29_s_net,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      en => "1",
      s => addr40_s_net
    );

  addr41: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 18,
      a_width => 26,
      b_arith => xlSigned,
      b_bin_pt => 18,
      b_width => 26,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 27,
      core_name0 => "addsb_11_0_4e2bc60003cf26be",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 27,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 18,
      s_width => 27
    )
    port map (
      a => addr30_s_net,
      b => addr31_s_net,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      en => "1",
      s => addr41_s_net
    );

  addr42: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 18,
      a_width => 26,
      b_arith => xlSigned,
      b_bin_pt => 18,
      b_width => 26,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 27,
      core_name0 => "addsb_11_0_4e2bc60003cf26be",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 27,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 18,
      s_width => 27
    )
    port map (
      a => addr32_s_net,
      b => addr33_s_net,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      en => "1",
      s => addr42_s_net
    );

  addr43: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 18,
      a_width => 26,
      b_arith => xlSigned,
      b_bin_pt => 18,
      b_width => 26,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 27,
      core_name0 => "addsb_11_0_4e2bc60003cf26be",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 27,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 18,
      s_width => 27
    )
    port map (
      a => addr34_s_net,
      b => addr35_s_net,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      en => "1",
      s => addr43_s_net
    );

  addr44: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 18,
      a_width => 26,
      b_arith => xlSigned,
      b_bin_pt => 18,
      b_width => 26,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 27,
      core_name0 => "addsb_11_0_4e2bc60003cf26be",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 27,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 18,
      s_width => 27
    )
    port map (
      a => addr36_s_net,
      b => addr37_s_net,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      en => "1",
      s => addr44_s_net
    );

  addr46: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 18,
      a_width => 27,
      b_arith => xlSigned,
      b_bin_pt => 18,
      b_width => 27,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 28,
      core_name0 => "addsb_11_0_837b9ca36be57173",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 28,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 18,
      s_width => 28
    )
    port map (
      a => addr39_s_net,
      b => addr40_s_net,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      en => "1",
      s => addr46_s_net
    );

  addr47: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 18,
      a_width => 27,
      b_arith => xlSigned,
      b_bin_pt => 18,
      b_width => 27,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 28,
      core_name0 => "addsb_11_0_837b9ca36be57173",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 28,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 18,
      s_width => 28
    )
    port map (
      a => addr41_s_net,
      b => addr42_s_net,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      en => "1",
      s => addr47_s_net
    );

  addr48: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 18,
      a_width => 27,
      b_arith => xlSigned,
      b_bin_pt => 18,
      b_width => 27,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 28,
      core_name0 => "addsb_11_0_837b9ca36be57173",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 28,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 18,
      s_width => 28
    )
    port map (
      a => addr43_s_net,
      b => addr44_s_net,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      en => "1",
      s => addr48_s_net
    );

  addr5: entity work.addsub_7b135dcb24
    port map (
      a => mult42_p_net_x0,
      b => mult41_p_net_x0,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      s => addr5_s_net
    );

  addr50: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 18,
      a_width => 28,
      b_arith => xlSigned,
      b_bin_pt => 18,
      b_width => 28,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 29,
      core_name0 => "addsb_11_0_9875f8c5f2e232ba",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 29,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 18,
      s_width => 29
    )
    port map (
      a => addr46_s_net,
      b => addr47_s_net,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      en => "1",
      s => addr50_s_net
    );

  addr51: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 18,
      a_width => 28,
      b_arith => xlSigned,
      b_bin_pt => 18,
      b_width => 25,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 29,
      core_name0 => "addsb_11_0_9875f8c5f2e232ba",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 29,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 18,
      s_width => 29
    )
    port map (
      a => addr48_s_net,
      b => dly49_q_net,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      en => "1",
      s => addr51_s_net
    );

  addr52: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 18,
      a_width => 29,
      b_arith => xlSigned,
      b_bin_pt => 18,
      b_width => 29,
      c_has_c_out => 0,
      c_latency => 2,
      c_output_width => 30,
      core_name0 => "addsb_11_0_9ec4483802d81769",
      extra_registers => 1,
      full_s_arith => 2,
      full_s_width => 30,
      latency => 3,
      overflow => 1,
      quantization => 1,
      s_arith => xlSigned,
      s_bin_pt => 18,
      s_width => 30
    )
    port map (
      a => addr50_s_net,
      b => addr51_s_net,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      en => "1",
      s => addr52_s_net_x0
    );

  addr6: entity work.addsub_7b135dcb24
    port map (
      a => mult40_p_net_x0,
      b => mult39_p_net_x0,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      s => addr6_s_net
    );

  addr7: entity work.addsub_7b135dcb24
    port map (
      a => mult38_p_net_x0,
      b => mult37_p_net_x0,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      s => addr7_s_net
    );

  addr8: entity work.addsub_7b135dcb24
    port map (
      a => mult36_p_net_x0,
      b => mult35_p_net_x0,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      s => addr8_s_net
    );

  addr9: entity work.addsub_7b135dcb24
    port map (
      a => mult34_p_net_x0,
      b => mult33_p_net_x0,
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      s => addr9_s_net
    );

  dly38: entity work.delay_09169cf4fc
    port map (
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      d => addr25_s_net,
      q => dly38_q_net
    );

  dly45: entity work.delay_09169cf4fc
    port map (
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      d => dly38_q_net,
      q => dly45_q_net
    );

  dly49: entity work.delay_09169cf4fc
    port map (
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      d => dly45_q_net,
      q => dly49_q_net
    );

  sync_delay: entity work.delay_d9490c4c59
    port map (
      ce => ce_1_sg_x697,
      clk => clk_1_sg_x697,
      clr => '0',
      d => sync_delay_q_net_x1,
      q => sync_delay_q_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/prog_fir0/fir"

entity fir_entity_10a996dabf is
  port (
    ce_1: in std_logic; 
    ch_in: in std_logic_vector(7 downto 0); 
    ch_to_write: in std_logic_vector(7 downto 0); 
    clk_1: in std_logic; 
    coeff_to_write: in std_logic_vector(11 downto 0); 
    data_in: in std_logic_vector(11 downto 0); 
    tap_to_write: in std_logic_vector(7 downto 0); 
    write_coeff: in std_logic; 
    ch_out: out std_logic_vector(7 downto 0); 
    data_out: out std_logic_vector(29 downto 0)
  );
end fir_entity_10a996dabf;

architecture structural of fir_entity_10a996dabf is
  signal addr52_s_net_x1: std_logic_vector(29 downto 0);
  signal bram10_data_out_net: std_logic_vector(11 downto 0);
  signal bram11_data_out_net: std_logic_vector(11 downto 0);
  signal bram12_data_out_net: std_logic_vector(11 downto 0);
  signal bram13_data_out_net: std_logic_vector(11 downto 0);
  signal bram14_data_out_net: std_logic_vector(11 downto 0);
  signal bram15_data_out_net: std_logic_vector(11 downto 0);
  signal bram16_data_out_net: std_logic_vector(11 downto 0);
  signal bram17_data_out_net: std_logic_vector(11 downto 0);
  signal bram18_data_out_net: std_logic_vector(11 downto 0);
  signal bram19_data_out_net: std_logic_vector(11 downto 0);
  signal bram1_data_out_net: std_logic_vector(11 downto 0);
  signal bram20_data_out_net: std_logic_vector(11 downto 0);
  signal bram21_data_out_net: std_logic_vector(11 downto 0);
  signal bram22_data_out_net: std_logic_vector(11 downto 0);
  signal bram23_data_out_net: std_logic_vector(11 downto 0);
  signal bram24_data_out_net: std_logic_vector(11 downto 0);
  signal bram25_data_out_net: std_logic_vector(11 downto 0);
  signal bram26_data_out_net: std_logic_vector(11 downto 0);
  signal bram27_data_out_net: std_logic_vector(11 downto 0);
  signal bram28_data_out_net: std_logic_vector(11 downto 0);
  signal bram29_data_out_net: std_logic_vector(11 downto 0);
  signal bram2_data_out_net: std_logic_vector(11 downto 0);
  signal bram30_data_out_net: std_logic_vector(11 downto 0);
  signal bram31_data_out_net: std_logic_vector(11 downto 0);
  signal bram32_data_out_net: std_logic_vector(11 downto 0);
  signal bram33_data_out_net: std_logic_vector(11 downto 0);
  signal bram34_data_out_net: std_logic_vector(11 downto 0);
  signal bram35_data_out_net: std_logic_vector(11 downto 0);
  signal bram36_data_out_net: std_logic_vector(11 downto 0);
  signal bram37_data_out_net: std_logic_vector(11 downto 0);
  signal bram38_data_out_net: std_logic_vector(11 downto 0);
  signal bram39_data_out_net: std_logic_vector(11 downto 0);
  signal bram3_data_out_net: std_logic_vector(11 downto 0);
  signal bram40_data_out_net: std_logic_vector(11 downto 0);
  signal bram41_data_out_net: std_logic_vector(11 downto 0);
  signal bram42_data_out_net: std_logic_vector(11 downto 0);
  signal bram43_data_out_net: std_logic_vector(11 downto 0);
  signal bram44_data_out_net: std_logic_vector(11 downto 0);
  signal bram45_data_out_net: std_logic_vector(11 downto 0);
  signal bram46_data_out_net: std_logic_vector(11 downto 0);
  signal bram47_data_out_net: std_logic_vector(11 downto 0);
  signal bram48_data_out_net: std_logic_vector(11 downto 0);
  signal bram49_data_out_net: std_logic_vector(11 downto 0);
  signal bram4_data_out_net: std_logic_vector(11 downto 0);
  signal bram50_data_out_net: std_logic_vector(11 downto 0);
  signal bram5_data_out_net: std_logic_vector(11 downto 0);
  signal bram6_data_out_net: std_logic_vector(11 downto 0);
  signal bram7_data_out_net: std_logic_vector(11 downto 0);
  signal bram8_data_out_net: std_logic_vector(11 downto 0);
  signal bram9_data_out_net: std_logic_vector(11 downto 0);
  signal ce_1_sg_x698: std_logic;
  signal ch_mux_y_net_x0: std_logic_vector(7 downto 0);
  signal clk_1_sg_x698: std_logic;
  signal data_dly_q_net_x0: std_logic_vector(11 downto 0);
  signal misc_dly_q_net: std_logic_vector(7 downto 0);
  signal mult10_p_net_x0: std_logic_vector(23 downto 0);
  signal mult11_p_net_x0: std_logic_vector(23 downto 0);
  signal mult12_p_net_x0: std_logic_vector(23 downto 0);
  signal mult13_p_net_x0: std_logic_vector(23 downto 0);
  signal mult14_p_net_x0: std_logic_vector(23 downto 0);
  signal mult15_p_net_x0: std_logic_vector(23 downto 0);
  signal mult16_p_net_x0: std_logic_vector(23 downto 0);
  signal mult17_p_net_x0: std_logic_vector(23 downto 0);
  signal mult18_p_net_x0: std_logic_vector(23 downto 0);
  signal mult19_p_net_x0: std_logic_vector(23 downto 0);
  signal mult1_p_net_x0: std_logic_vector(23 downto 0);
  signal mult20_p_net_x0: std_logic_vector(23 downto 0);
  signal mult21_p_net_x0: std_logic_vector(23 downto 0);
  signal mult22_p_net_x0: std_logic_vector(23 downto 0);
  signal mult23_p_net_x0: std_logic_vector(23 downto 0);
  signal mult24_p_net_x0: std_logic_vector(23 downto 0);
  signal mult25_p_net_x0: std_logic_vector(23 downto 0);
  signal mult26_p_net_x0: std_logic_vector(23 downto 0);
  signal mult27_p_net_x0: std_logic_vector(23 downto 0);
  signal mult28_p_net_x0: std_logic_vector(23 downto 0);
  signal mult29_p_net_x0: std_logic_vector(23 downto 0);
  signal mult2_p_net_x0: std_logic_vector(23 downto 0);
  signal mult30_p_net_x0: std_logic_vector(23 downto 0);
  signal mult31_p_net_x0: std_logic_vector(23 downto 0);
  signal mult32_p_net_x0: std_logic_vector(23 downto 0);
  signal mult33_p_net_x0: std_logic_vector(23 downto 0);
  signal mult34_p_net_x0: std_logic_vector(23 downto 0);
  signal mult35_p_net_x0: std_logic_vector(23 downto 0);
  signal mult36_p_net_x0: std_logic_vector(23 downto 0);
  signal mult37_p_net_x0: std_logic_vector(23 downto 0);
  signal mult38_p_net_x0: std_logic_vector(23 downto 0);
  signal mult39_p_net_x0: std_logic_vector(23 downto 0);
  signal mult3_p_net_x0: std_logic_vector(23 downto 0);
  signal mult40_p_net_x0: std_logic_vector(23 downto 0);
  signal mult41_p_net_x0: std_logic_vector(23 downto 0);
  signal mult42_p_net_x0: std_logic_vector(23 downto 0);
  signal mult43_p_net_x0: std_logic_vector(23 downto 0);
  signal mult44_p_net_x0: std_logic_vector(23 downto 0);
  signal mult45_p_net_x0: std_logic_vector(23 downto 0);
  signal mult46_p_net_x0: std_logic_vector(23 downto 0);
  signal mult47_p_net_x0: std_logic_vector(23 downto 0);
  signal mult48_p_net_x0: std_logic_vector(23 downto 0);
  signal mult49_p_net_x0: std_logic_vector(23 downto 0);
  signal mult4_p_net_x0: std_logic_vector(23 downto 0);
  signal mult50_p_net_x0: std_logic_vector(23 downto 0);
  signal mult5_p_net_x0: std_logic_vector(23 downto 0);
  signal mult6_p_net_x0: std_logic_vector(23 downto 0);
  signal mult7_p_net_x0: std_logic_vector(23 downto 0);
  signal mult8_p_net_x0: std_logic_vector(23 downto 0);
  signal mult9_p_net_x0: std_logic_vector(23 downto 0);
  signal not_clear_op_net_x0: std_logic;
  signal ram_data_out_net_x0: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x1: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x10: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x11: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x12: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x13: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x14: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x15: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x16: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x17: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x18: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x19: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x2: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x20: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x21: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x22: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x23: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x24: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x25: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x26: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x27: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x28: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x29: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x3: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x30: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x31: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x32: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x33: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x34: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x35: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x36: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x37: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x38: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x39: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x4: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x40: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x41: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x42: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x43: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x44: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x45: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x46: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x47: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x48: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x5: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x6: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x7: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x8: std_logic_vector(11 downto 0);
  signal ram_data_out_net_x9: std_logic_vector(11 downto 0);
  signal register0_q_net_x0: std_logic_vector(7 downto 0);
  signal register0_q_net_x10: std_logic_vector(7 downto 0);
  signal register0_q_net_x11: std_logic_vector(7 downto 0);
  signal register0_q_net_x12: std_logic_vector(7 downto 0);
  signal register0_q_net_x13: std_logic_vector(7 downto 0);
  signal register0_q_net_x14: std_logic_vector(7 downto 0);
  signal register0_q_net_x15: std_logic_vector(7 downto 0);
  signal register0_q_net_x16: std_logic_vector(7 downto 0);
  signal register0_q_net_x17: std_logic_vector(7 downto 0);
  signal register0_q_net_x18: std_logic_vector(7 downto 0);
  signal register0_q_net_x19: std_logic_vector(7 downto 0);
  signal register0_q_net_x2: std_logic_vector(7 downto 0);
  signal register0_q_net_x20: std_logic_vector(7 downto 0);
  signal register0_q_net_x21: std_logic_vector(7 downto 0);
  signal register0_q_net_x22: std_logic_vector(7 downto 0);
  signal register0_q_net_x23: std_logic_vector(11 downto 0);
  signal register0_q_net_x24: std_logic_vector(11 downto 0);
  signal register0_q_net_x25: std_logic_vector(11 downto 0);
  signal register0_q_net_x26: std_logic_vector(11 downto 0);
  signal register0_q_net_x27: std_logic_vector(11 downto 0);
  signal register0_q_net_x28: std_logic_vector(11 downto 0);
  signal register0_q_net_x29: std_logic_vector(11 downto 0);
  signal register0_q_net_x30: std_logic_vector(11 downto 0);
  signal register0_q_net_x31: std_logic_vector(11 downto 0);
  signal register0_q_net_x32: std_logic_vector(11 downto 0);
  signal register0_q_net_x33: std_logic_vector(11 downto 0);
  signal register0_q_net_x34: std_logic_vector(11 downto 0);
  signal register0_q_net_x35: std_logic_vector(11 downto 0);
  signal register0_q_net_x36: std_logic_vector(11 downto 0);
  signal register0_q_net_x37: std_logic_vector(11 downto 0);
  signal register0_q_net_x38: std_logic_vector(11 downto 0);
  signal register0_q_net_x39: std_logic_vector(11 downto 0);
  signal register0_q_net_x4: std_logic_vector(7 downto 0);
  signal register0_q_net_x40: std_logic_vector(11 downto 0);
  signal register0_q_net_x41: std_logic_vector(11 downto 0);
  signal register0_q_net_x42: std_logic_vector(11 downto 0);
  signal register0_q_net_x5: std_logic_vector(7 downto 0);
  signal register0_q_net_x6: std_logic_vector(7 downto 0);
  signal register0_q_net_x7: std_logic_vector(7 downto 0);
  signal register0_q_net_x8: std_logic_vector(7 downto 0);
  signal register0_q_net_x9: std_logic_vector(7 downto 0);
  signal register1_q_net_x10: std_logic_vector(7 downto 0);
  signal register1_q_net_x11: std_logic;
  signal register1_q_net_x12: std_logic_vector(7 downto 0);
  signal register1_q_net_x6: std_logic_vector(11 downto 0);
  signal register1_q_net_x7: std_logic_vector(11 downto 0);
  signal register1_q_net_x8: std_logic_vector(7 downto 0);
  signal register1_q_net_x9: std_logic_vector(11 downto 0);
  signal relational0_op_net_x0: std_logic;
  signal relational10_op_net_x0: std_logic;
  signal relational11_op_net_x0: std_logic;
  signal relational12_op_net_x0: std_logic;
  signal relational13_op_net_x0: std_logic;
  signal relational14_op_net_x0: std_logic;
  signal relational15_op_net_x0: std_logic;
  signal relational16_op_net_x0: std_logic;
  signal relational17_op_net_x0: std_logic;
  signal relational18_op_net_x0: std_logic;
  signal relational19_op_net_x0: std_logic;
  signal relational1_op_net_x0: std_logic;
  signal relational20_op_net_x0: std_logic;
  signal relational21_op_net_x0: std_logic;
  signal relational22_op_net_x0: std_logic;
  signal relational23_op_net_x0: std_logic;
  signal relational24_op_net_x0: std_logic;
  signal relational25_op_net_x0: std_logic;
  signal relational26_op_net_x0: std_logic;
  signal relational27_op_net_x0: std_logic;
  signal relational28_op_net_x0: std_logic;
  signal relational29_op_net_x0: std_logic;
  signal relational2_op_net_x0: std_logic;
  signal relational30_op_net_x0: std_logic;
  signal relational31_op_net_x0: std_logic;
  signal relational32_op_net_x0: std_logic;
  signal relational33_op_net_x0: std_logic;
  signal relational34_op_net_x0: std_logic;
  signal relational35_op_net_x0: std_logic;
  signal relational36_op_net_x0: std_logic;
  signal relational37_op_net_x0: std_logic;
  signal relational38_op_net_x0: std_logic;
  signal relational39_op_net_x0: std_logic;
  signal relational3_op_net_x0: std_logic;
  signal relational40_op_net_x0: std_logic;
  signal relational41_op_net_x0: std_logic;
  signal relational42_op_net_x0: std_logic;
  signal relational43_op_net_x0: std_logic;
  signal relational44_op_net_x0: std_logic;
  signal relational45_op_net_x0: std_logic;
  signal relational46_op_net_x0: std_logic;
  signal relational47_op_net_x0: std_logic;
  signal relational48_op_net_x0: std_logic;
  signal relational49_op_net_x0: std_logic;
  signal relational4_op_net_x0: std_logic;
  signal relational5_op_net_x0: std_logic;
  signal relational6_op_net_x0: std_logic;
  signal relational7_op_net_x0: std_logic;
  signal relational8_op_net_x0: std_logic;
  signal relational9_op_net_x0: std_logic;
  signal sync_delay_q_net_x1: std_logic_vector(7 downto 0);
  signal sync_delay_q_net_x3: std_logic_vector(7 downto 0);
  signal tap_dly_q_net_x0: std_logic_vector(7 downto 0);

begin
  ce_1_sg_x698 <= ce_1;
  register1_q_net_x10 <= ch_in;
  register1_q_net_x8 <= ch_to_write;
  clk_1_sg_x698 <= clk_1;
  register1_q_net_x7 <= coeff_to_write;
  register1_q_net_x9 <= data_in;
  register1_q_net_x12 <= tap_to_write;
  register1_q_net_x11 <= write_coeff;
  ch_out <= sync_delay_q_net_x3;
  data_out <= addr52_s_net_x1;

  bram1: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x0,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x27,
      en => "1",
      rst => "0",
      we(0) => relational0_op_net_x0,
      data_out => bram1_data_out_net
    );

  bram10: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x17,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x37,
      en => "1",
      rst => "0",
      we(0) => relational9_op_net_x0,
      data_out => bram10_data_out_net
    );

  bram11: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x17,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x37,
      en => "1",
      rst => "0",
      we(0) => relational10_op_net_x0,
      data_out => bram11_data_out_net
    );

  bram12: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x17,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x37,
      en => "1",
      rst => "0",
      we(0) => relational11_op_net_x0,
      data_out => bram12_data_out_net
    );

  bram13: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x18,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x38,
      en => "1",
      rst => "0",
      we(0) => relational12_op_net_x0,
      data_out => bram13_data_out_net
    );

  bram14: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x18,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x38,
      en => "1",
      rst => "0",
      we(0) => relational13_op_net_x0,
      data_out => bram14_data_out_net
    );

  bram15: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x18,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x38,
      en => "1",
      rst => "0",
      we(0) => relational14_op_net_x0,
      data_out => bram15_data_out_net
    );

  bram16: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x19,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x39,
      en => "1",
      rst => "0",
      we(0) => relational15_op_net_x0,
      data_out => bram16_data_out_net
    );

  bram17: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x19,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x39,
      en => "1",
      rst => "0",
      we(0) => relational16_op_net_x0,
      data_out => bram17_data_out_net
    );

  bram18: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x19,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x39,
      en => "1",
      rst => "0",
      we(0) => relational17_op_net_x0,
      data_out => bram18_data_out_net
    );

  bram19: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x20,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x40,
      en => "1",
      rst => "0",
      we(0) => relational18_op_net_x0,
      data_out => bram19_data_out_net
    );

  bram2: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x0,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x27,
      en => "1",
      rst => "0",
      we(0) => relational1_op_net_x0,
      data_out => bram2_data_out_net
    );

  bram20: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x20,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x40,
      en => "1",
      rst => "0",
      we(0) => relational19_op_net_x0,
      data_out => bram20_data_out_net
    );

  bram21: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x20,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x40,
      en => "1",
      rst => "0",
      we(0) => relational20_op_net_x0,
      data_out => bram21_data_out_net
    );

  bram22: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x21,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x41,
      en => "1",
      rst => "0",
      we(0) => relational21_op_net_x0,
      data_out => bram22_data_out_net
    );

  bram23: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x21,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x41,
      en => "1",
      rst => "0",
      we(0) => relational22_op_net_x0,
      data_out => bram23_data_out_net
    );

  bram24: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x21,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x41,
      en => "1",
      rst => "0",
      we(0) => relational23_op_net_x0,
      data_out => bram24_data_out_net
    );

  bram25: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x22,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x42,
      en => "1",
      rst => "0",
      we(0) => relational24_op_net_x0,
      data_out => bram25_data_out_net
    );

  bram26: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x22,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x42,
      en => "1",
      rst => "0",
      we(0) => relational25_op_net_x0,
      data_out => bram26_data_out_net
    );

  bram27: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x22,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x42,
      en => "1",
      rst => "0",
      we(0) => relational26_op_net_x0,
      data_out => bram27_data_out_net
    );

  bram28: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x2,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x28,
      en => "1",
      rst => "0",
      we(0) => relational27_op_net_x0,
      data_out => bram28_data_out_net
    );

  bram29: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x2,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x28,
      en => "1",
      rst => "0",
      we(0) => relational28_op_net_x0,
      data_out => bram29_data_out_net
    );

  bram3: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x0,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x27,
      en => "1",
      rst => "0",
      we(0) => relational2_op_net_x0,
      data_out => bram3_data_out_net
    );

  bram30: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x2,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x28,
      en => "1",
      rst => "0",
      we(0) => relational29_op_net_x0,
      data_out => bram30_data_out_net
    );

  bram31: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x9,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x29,
      en => "1",
      rst => "0",
      we(0) => relational30_op_net_x0,
      data_out => bram31_data_out_net
    );

  bram32: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x9,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x29,
      en => "1",
      rst => "0",
      we(0) => relational31_op_net_x0,
      data_out => bram32_data_out_net
    );

  bram33: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x9,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x29,
      en => "1",
      rst => "0",
      we(0) => relational32_op_net_x0,
      data_out => bram33_data_out_net
    );

  bram34: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x10,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x30,
      en => "1",
      rst => "0",
      we(0) => relational33_op_net_x0,
      data_out => bram34_data_out_net
    );

  bram35: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x10,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x30,
      en => "1",
      rst => "0",
      we(0) => relational34_op_net_x0,
      data_out => bram35_data_out_net
    );

  bram36: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x10,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x30,
      en => "1",
      rst => "0",
      we(0) => relational35_op_net_x0,
      data_out => bram36_data_out_net
    );

  bram37: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x11,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x31,
      en => "1",
      rst => "0",
      we(0) => relational36_op_net_x0,
      data_out => bram37_data_out_net
    );

  bram38: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x11,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x31,
      en => "1",
      rst => "0",
      we(0) => relational37_op_net_x0,
      data_out => bram38_data_out_net
    );

  bram39: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x11,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x31,
      en => "1",
      rst => "0",
      we(0) => relational38_op_net_x0,
      data_out => bram39_data_out_net
    );

  bram4: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x15,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x35,
      en => "1",
      rst => "0",
      we(0) => relational3_op_net_x0,
      data_out => bram4_data_out_net
    );

  bram40: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x12,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x32,
      en => "1",
      rst => "0",
      we(0) => relational39_op_net_x0,
      data_out => bram40_data_out_net
    );

  bram41: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x12,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x32,
      en => "1",
      rst => "0",
      we(0) => relational40_op_net_x0,
      data_out => bram41_data_out_net
    );

  bram42: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x12,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x32,
      en => "1",
      rst => "0",
      we(0) => relational41_op_net_x0,
      data_out => bram42_data_out_net
    );

  bram43: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x13,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x33,
      en => "1",
      rst => "0",
      we(0) => relational42_op_net_x0,
      data_out => bram43_data_out_net
    );

  bram44: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x13,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x33,
      en => "1",
      rst => "0",
      we(0) => relational43_op_net_x0,
      data_out => bram44_data_out_net
    );

  bram45: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x13,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x33,
      en => "1",
      rst => "0",
      we(0) => relational44_op_net_x0,
      data_out => bram45_data_out_net
    );

  bram46: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x13,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x33,
      en => "1",
      rst => "0",
      we(0) => relational45_op_net_x0,
      data_out => bram46_data_out_net
    );

  bram47: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x14,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x34,
      en => "1",
      rst => "0",
      we(0) => relational46_op_net_x0,
      data_out => bram47_data_out_net
    );

  bram48: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x14,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x34,
      en => "1",
      rst => "0",
      we(0) => relational47_op_net_x0,
      data_out => bram48_data_out_net
    );

  bram49: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x14,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x34,
      en => "1",
      rst => "0",
      we(0) => relational48_op_net_x0,
      data_out => bram49_data_out_net
    );

  bram5: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x15,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x35,
      en => "1",
      rst => "0",
      we(0) => relational4_op_net_x0,
      data_out => bram5_data_out_net
    );

  bram50: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x14,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x34,
      en => "1",
      rst => "0",
      we(0) => relational49_op_net_x0,
      data_out => bram50_data_out_net
    );

  bram6: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x15,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x35,
      en => "1",
      rst => "0",
      we(0) => relational5_op_net_x0,
      data_out => bram6_data_out_net
    );

  bram7: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x16,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x36,
      en => "1",
      rst => "0",
      we(0) => relational6_op_net_x0,
      data_out => bram7_data_out_net
    );

  bram8: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x16,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x36,
      en => "1",
      rst => "0",
      we(0) => relational7_op_net_x0,
      data_out => bram8_data_out_net
    );

  bram9: entity work.xlspram_darkquad29
    generic map (
      c_address_width => 8,
      c_width => 12,
      core_name0 => "bmg_72_3b6e667e30cd6119",
      latency => 2
    )
    port map (
      addr => register0_q_net_x16,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      data_in => register0_q_net_x36,
      en => "1",
      rst => "0",
      we(0) => relational8_op_net_x0,
      data_out => bram9_data_out_net
    );

  ch_dly0_04048bfc8c: entity work.ch_dly0_entity_04048bfc8c
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => ch_mux_y_net_x0,
      q => register0_q_net_x4
    );

  ch_dly11_cc4b012b54: entity work.ch_dly0_entity_04048bfc8c
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => register0_q_net_x4,
      q => register0_q_net_x6
    );

  ch_dly12_adbfa9e5bd: entity work.ch_dly0_entity_04048bfc8c
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => register0_q_net_x4,
      q => register0_q_net_x5
    );

  ch_dly13_850d784991: entity work.ch_dly0_entity_04048bfc8c
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => register0_q_net_x4,
      q => register0_q_net_x7
    );

  ch_dly14_18e979bec4: entity work.ch_dly0_entity_04048bfc8c
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => register0_q_net_x4,
      q => register0_q_net_x8
    );

  ch_dly210_8b4db92f02: entity work.ch_dly0_entity_04048bfc8c
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => register0_q_net_x7,
      q => register0_q_net_x2
    );

  ch_dly211_796118b557: entity work.ch_dly0_entity_04048bfc8c
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => register0_q_net_x7,
      q => register0_q_net_x9
    );

  ch_dly212_6b7f3467fa: entity work.ch_dly0_entity_04048bfc8c
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => register0_q_net_x7,
      q => register0_q_net_x10
    );

  ch_dly213_fd8ae96f19: entity work.ch_dly0_entity_04048bfc8c
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => register0_q_net_x8,
      q => register0_q_net_x11
    );

  ch_dly214_576a18a1bc: entity work.ch_dly0_entity_04048bfc8c
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => register0_q_net_x8,
      q => register0_q_net_x12
    );

  ch_dly215_7bdba123e2: entity work.ch_dly0_entity_04048bfc8c
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => register0_q_net_x8,
      q => register0_q_net_x13
    );

  ch_dly216_ac7a6a2472: entity work.ch_dly0_entity_04048bfc8c
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => register0_q_net_x8,
      q => register0_q_net_x14
    );

  ch_dly21_9de89edf7d: entity work.ch_dly0_entity_04048bfc8c
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => register0_q_net_x6,
      q => register0_q_net_x0
    );

  ch_dly22_952ce9ce2b: entity work.ch_dly0_entity_04048bfc8c
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => register0_q_net_x6,
      q => register0_q_net_x15
    );

  ch_dly23_9f273be186: entity work.ch_dly0_entity_04048bfc8c
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => register0_q_net_x6,
      q => register0_q_net_x16
    );

  ch_dly24_760823ffb5: entity work.ch_dly0_entity_04048bfc8c
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => register0_q_net_x6,
      q => register0_q_net_x17
    );

  ch_dly25_0833895a85: entity work.ch_dly0_entity_04048bfc8c
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => register0_q_net_x5,
      q => register0_q_net_x18
    );

  ch_dly26_036e6afa9b: entity work.ch_dly0_entity_04048bfc8c
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => register0_q_net_x5,
      q => register0_q_net_x19
    );

  ch_dly27_969c5797fa: entity work.ch_dly0_entity_04048bfc8c
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => register0_q_net_x5,
      q => register0_q_net_x20
    );

  ch_dly28_57c87beff1: entity work.ch_dly0_entity_04048bfc8c
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => register0_q_net_x5,
      q => register0_q_net_x21
    );

  ch_dly29_af17d5a2f5: entity work.ch_dly0_entity_04048bfc8c
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => register0_q_net_x7,
      q => register0_q_net_x22
    );

  ch_mux: entity work.mux_cc14a035dc
    port map (
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      d0 => register1_q_net_x10,
      d1 => register1_q_net_x8,
      sel(0) => register1_q_net_x11,
      y => ch_mux_y_net_x0
    );

  coeff_in_dly0_f7e4d41e30: entity work.coeff_in_dly0_entity_f7e4d41e30
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => register1_q_net_x7,
      q => register1_q_net_x6
    );

  coeff_in_dly11_0bdba45676: entity work.coeff_in_dly11_entity_0bdba45676
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => register1_q_net_x6,
      q => register0_q_net_x23
    );

  coeff_in_dly12_af8fbfa40b: entity work.coeff_in_dly11_entity_0bdba45676
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => register1_q_net_x6,
      q => register0_q_net_x24
    );

  coeff_in_dly13_c1b7626fa4: entity work.coeff_in_dly11_entity_0bdba45676
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => register1_q_net_x6,
      q => register0_q_net_x25
    );

  coeff_in_dly14_e91fdeb734: entity work.coeff_in_dly11_entity_0bdba45676
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => register1_q_net_x6,
      q => register0_q_net_x26
    );

  coeff_in_dly210_fffd5611b2: entity work.coeff_in_dly11_entity_0bdba45676
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => register0_q_net_x25,
      q => register0_q_net_x28
    );

  coeff_in_dly211_efa767b186: entity work.coeff_in_dly11_entity_0bdba45676
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => register0_q_net_x25,
      q => register0_q_net_x29
    );

  coeff_in_dly212_077c1ca752: entity work.coeff_in_dly11_entity_0bdba45676
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => register0_q_net_x25,
      q => register0_q_net_x30
    );

  coeff_in_dly213_ded2893eaf: entity work.coeff_in_dly11_entity_0bdba45676
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => register0_q_net_x26,
      q => register0_q_net_x31
    );

  coeff_in_dly214_204c3c9285: entity work.coeff_in_dly11_entity_0bdba45676
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => register0_q_net_x26,
      q => register0_q_net_x32
    );

  coeff_in_dly215_ddf7a7a072: entity work.coeff_in_dly11_entity_0bdba45676
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => register0_q_net_x26,
      q => register0_q_net_x33
    );

  coeff_in_dly216_38032fcf28: entity work.coeff_in_dly11_entity_0bdba45676
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => register0_q_net_x26,
      q => register0_q_net_x34
    );

  coeff_in_dly21_e6682d31f5: entity work.coeff_in_dly11_entity_0bdba45676
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => register0_q_net_x23,
      q => register0_q_net_x27
    );

  coeff_in_dly22_0c7df556ae: entity work.coeff_in_dly11_entity_0bdba45676
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => register0_q_net_x23,
      q => register0_q_net_x35
    );

  coeff_in_dly23_686253d7ba: entity work.coeff_in_dly11_entity_0bdba45676
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => register0_q_net_x23,
      q => register0_q_net_x36
    );

  coeff_in_dly24_8a1d21f83f: entity work.coeff_in_dly11_entity_0bdba45676
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => register0_q_net_x23,
      q => register0_q_net_x37
    );

  coeff_in_dly25_5413788866: entity work.coeff_in_dly11_entity_0bdba45676
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => register0_q_net_x24,
      q => register0_q_net_x38
    );

  coeff_in_dly26_7a35cc7228: entity work.coeff_in_dly11_entity_0bdba45676
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => register0_q_net_x24,
      q => register0_q_net_x39
    );

  coeff_in_dly27_c8263f6ffc: entity work.coeff_in_dly11_entity_0bdba45676
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => register0_q_net_x24,
      q => register0_q_net_x40
    );

  coeff_in_dly28_297583abea: entity work.coeff_in_dly11_entity_0bdba45676
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => register0_q_net_x24,
      q => register0_q_net_x41
    );

  coeff_in_dly29_44a301fbfb: entity work.coeff_in_dly11_entity_0bdba45676
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      d => register0_q_net_x25,
      q => register0_q_net_x42
    );

  data_dly: entity work.xldelay
    generic map (
      latency => 7,
      reg_retiming => 0,
      reset => 0,
      width => 12
    )
    port map (
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      d => register1_q_net_x9,
      en => '1',
      rst => '1',
      q => data_dly_q_net_x0
    );

  delay10_dc07a97668: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x48,
      dout => ram_data_out_net_x3
    );

  delay11_edbbb296ff: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x3,
      dout => ram_data_out_net_x2
    );

  delay12_7871c96aca: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x2,
      dout => ram_data_out_net_x4
    );

  delay13_0f11781dc8: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x4,
      dout => ram_data_out_net_x5
    );

  delay14_b660c47e99: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x5,
      dout => ram_data_out_net_x6
    );

  delay15_6203a7234f: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x6,
      dout => ram_data_out_net_x7
    );

  delay16_e8ab7adefe: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x7,
      dout => ram_data_out_net_x8
    );

  delay17_14397950d9: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x8,
      dout => ram_data_out_net_x9
    );

  delay18_e862a88e4a: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x9,
      dout => ram_data_out_net_x10
    );

  delay19_200eb45b90: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x10,
      dout => ram_data_out_net_x11
    );

  delay1_9ff61b736d: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => data_dly_q_net_x0,
      dout => ram_data_out_net_x1
    );

  delay20_969d941ff8: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x11,
      dout => ram_data_out_net_x13
    );

  delay21_c0bb63faf1: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x13,
      dout => ram_data_out_net_x14
    );

  delay22_dceacf96da: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x14,
      dout => ram_data_out_net_x15
    );

  delay23_398d40af57: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x15,
      dout => ram_data_out_net_x16
    );

  delay24_d27e774e82: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x16,
      dout => ram_data_out_net_x17
    );

  delay25_0e9eb638a1: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x17,
      dout => ram_data_out_net_x18
    );

  delay26_d0c5a79baa: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x18,
      dout => ram_data_out_net_x19
    );

  delay27_55d239b8a7: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x19,
      dout => ram_data_out_net_x20
    );

  delay28_45453edb70: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x20,
      dout => ram_data_out_net_x21
    );

  delay29_3e3bdf29a7: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x21,
      dout => ram_data_out_net_x22
    );

  delay2_f5e75d0604: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x1,
      dout => ram_data_out_net_x12
    );

  delay30_409f3ed7b1: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x22,
      dout => ram_data_out_net_x24
    );

  delay31_245860fc34: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x24,
      dout => ram_data_out_net_x25
    );

  delay32_551a1aedaa: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x25,
      dout => ram_data_out_net_x26
    );

  delay33_e1cd443127: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x26,
      dout => ram_data_out_net_x27
    );

  delay34_3f57e1e0ce: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x27,
      dout => ram_data_out_net_x28
    );

  delay35_b6b22e073f: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x28,
      dout => ram_data_out_net_x29
    );

  delay36_915fbf47f6: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x29,
      dout => ram_data_out_net_x30
    );

  delay37_536199b54b: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x30,
      dout => ram_data_out_net_x31
    );

  delay38_66ce20fb52: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x31,
      dout => ram_data_out_net_x32
    );

  delay39_e225f85254: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x32,
      dout => ram_data_out_net_x33
    );

  delay3_095e23305f: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x12,
      dout => ram_data_out_net_x23
    );

  delay40_ac3c338cda: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x33,
      dout => ram_data_out_net_x35
    );

  delay41_8714a4bf63: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x35,
      dout => ram_data_out_net_x36
    );

  delay42_9e33d4d4c2: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x36,
      dout => ram_data_out_net_x37
    );

  delay43_3566f66d43: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x37,
      dout => ram_data_out_net_x38
    );

  delay44_6941e3d250: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x38,
      dout => ram_data_out_net_x39
    );

  delay45_051669b333: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x39,
      dout => ram_data_out_net_x40
    );

  delay46_392f251194: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x40,
      dout => ram_data_out_net_x41
    );

  delay47_4543b4aa2c: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x41,
      dout => ram_data_out_net_x42
    );

  delay48_803dd3f4c2: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x42,
      dout => ram_data_out_net_x43
    );

  delay49_06e2e9b17f: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x43,
      dout => ram_data_out_net_x0
    );

  delay4_187d26d3b2: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x23,
      dout => ram_data_out_net_x34
    );

  delay5_b41fe82d47: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x34,
      dout => ram_data_out_net_x44
    );

  delay6_bd297e61d5: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x44,
      dout => ram_data_out_net_x45
    );

  delay7_80b17fea57: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x45,
      dout => ram_data_out_net_x46
    );

  delay8_6fd14eaefc: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x46,
      dout => ram_data_out_net_x47
    );

  delay9_4374679907: entity work.delay_bram1_entity_f18a60d3ce
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din => ram_data_out_net_x47,
      dout => ram_data_out_net_x48
    );

  demux_6d04537eec: entity work.demux_entity_6d04537eec
    port map (
      ce_1 => ce_1_sg_x698,
      clear => not_clear_op_net_x0,
      clk_1 => clk_1_sg_x698,
      in_x0 => tap_dly_q_net_x0,
      out0 => relational0_op_net_x0,
      out1 => relational1_op_net_x0,
      out10 => relational10_op_net_x0,
      out11 => relational11_op_net_x0,
      out12 => relational12_op_net_x0,
      out13 => relational13_op_net_x0,
      out14 => relational14_op_net_x0,
      out15 => relational15_op_net_x0,
      out16 => relational16_op_net_x0,
      out17 => relational17_op_net_x0,
      out18 => relational18_op_net_x0,
      out19 => relational19_op_net_x0,
      out2 => relational2_op_net_x0,
      out20 => relational20_op_net_x0,
      out21 => relational21_op_net_x0,
      out22 => relational22_op_net_x0,
      out23 => relational23_op_net_x0,
      out24 => relational24_op_net_x0,
      out25 => relational25_op_net_x0,
      out26 => relational26_op_net_x0,
      out27 => relational27_op_net_x0,
      out28 => relational28_op_net_x0,
      out29 => relational29_op_net_x0,
      out3 => relational3_op_net_x0,
      out30 => relational30_op_net_x0,
      out31 => relational31_op_net_x0,
      out32 => relational32_op_net_x0,
      out33 => relational33_op_net_x0,
      out34 => relational34_op_net_x0,
      out35 => relational35_op_net_x0,
      out36 => relational36_op_net_x0,
      out37 => relational37_op_net_x0,
      out38 => relational38_op_net_x0,
      out39 => relational39_op_net_x0,
      out4 => relational4_op_net_x0,
      out40 => relational40_op_net_x0,
      out41 => relational41_op_net_x0,
      out42 => relational42_op_net_x0,
      out43 => relational43_op_net_x0,
      out44 => relational44_op_net_x0,
      out45 => relational45_op_net_x0,
      out46 => relational46_op_net_x0,
      out47 => relational47_op_net_x0,
      out48 => relational48_op_net_x0,
      out49 => relational49_op_net_x0,
      out5 => relational5_op_net_x0,
      out6 => relational6_op_net_x0,
      out7 => relational7_op_net_x0,
      out8 => relational8_op_net_x0,
      out9 => relational9_op_net_x0
    );

  misc_dly: entity work.xldelay
    generic map (
      latency => 7,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      d => register1_q_net_x10,
      en => '1',
      rst => '1',
      q => misc_dly_q_net
    );

  mult1: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => data_dly_q_net_x0,
      b => bram1_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult1_p_net_x0
    );

  mult10: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x48,
      b => bram10_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult10_p_net_x0
    );

  mult11: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x3,
      b => bram11_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult11_p_net_x0
    );

  mult12: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x2,
      b => bram12_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult12_p_net_x0
    );

  mult13: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x4,
      b => bram13_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult13_p_net_x0
    );

  mult14: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x5,
      b => bram14_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult14_p_net_x0
    );

  mult15: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x6,
      b => bram15_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult15_p_net_x0
    );

  mult16: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x7,
      b => bram16_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult16_p_net_x0
    );

  mult17: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x8,
      b => bram17_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult17_p_net_x0
    );

  mult18: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x9,
      b => bram18_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult18_p_net_x0
    );

  mult19: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x10,
      b => bram19_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult19_p_net_x0
    );

  mult2: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x1,
      b => bram2_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult2_p_net_x0
    );

  mult20: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x11,
      b => bram20_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult20_p_net_x0
    );

  mult21: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x13,
      b => bram21_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult21_p_net_x0
    );

  mult22: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x14,
      b => bram22_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult22_p_net_x0
    );

  mult23: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x15,
      b => bram23_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult23_p_net_x0
    );

  mult24: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x16,
      b => bram24_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult24_p_net_x0
    );

  mult25: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x17,
      b => bram25_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult25_p_net_x0
    );

  mult26: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x18,
      b => bram26_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult26_p_net_x0
    );

  mult27: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x19,
      b => bram27_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult27_p_net_x0
    );

  mult28: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x20,
      b => bram28_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult28_p_net_x0
    );

  mult29: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x21,
      b => bram29_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult29_p_net_x0
    );

  mult3: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x12,
      b => bram3_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult3_p_net_x0
    );

  mult30: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x22,
      b => bram30_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult30_p_net_x0
    );

  mult31: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x24,
      b => bram31_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult31_p_net_x0
    );

  mult32: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x25,
      b => bram32_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult32_p_net_x0
    );

  mult33: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x26,
      b => bram33_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult33_p_net_x0
    );

  mult34: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x27,
      b => bram34_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult34_p_net_x0
    );

  mult35: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x28,
      b => bram35_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult35_p_net_x0
    );

  mult36: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x29,
      b => bram36_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult36_p_net_x0
    );

  mult37: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x30,
      b => bram37_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult37_p_net_x0
    );

  mult38: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x31,
      b => bram38_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult38_p_net_x0
    );

  mult39: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x32,
      b => bram39_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult39_p_net_x0
    );

  mult4: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x23,
      b => bram4_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult4_p_net_x0
    );

  mult40: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x33,
      b => bram40_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult40_p_net_x0
    );

  mult41: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x35,
      b => bram41_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult41_p_net_x0
    );

  mult42: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x36,
      b => bram42_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult42_p_net_x0
    );

  mult43: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x37,
      b => bram43_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult43_p_net_x0
    );

  mult44: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x38,
      b => bram44_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult44_p_net_x0
    );

  mult45: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x39,
      b => bram45_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult45_p_net_x0
    );

  mult46: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x40,
      b => bram46_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult46_p_net_x0
    );

  mult47: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x41,
      b => bram47_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult47_p_net_x0
    );

  mult48: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x42,
      b => bram48_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult48_p_net_x0
    );

  mult49: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x43,
      b => bram49_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult49_p_net_x0
    );

  mult5: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x34,
      b => bram5_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult5_p_net_x0
    );

  mult50: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x0,
      b => bram50_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult50_p_net_x0
    );

  mult6: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x44,
      b => bram6_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult6_p_net_x0
    );

  mult7: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x45,
      b => bram7_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult7_p_net_x0
    );

  mult8: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x46,
      b => bram8_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult8_p_net_x0
    );

  mult9: entity work.xlmult_darkquad29
    generic map (
      a_arith => xlSigned,
      a_bin_pt => 9,
      a_width => 12,
      b_arith => xlSigned,
      b_bin_pt => 9,
      b_width => 12,
      c_a_type => 0,
      c_a_width => 12,
      c_b_type => 0,
      c_b_width => 12,
      c_baat => 12,
      c_output_width => 24,
      c_type => 0,
      core_name0 => "mult_11_2_603515128dc5baa2",
      extra_registers => 0,
      multsign => 2,
      overflow => 1,
      p_arith => xlSigned,
      p_bin_pt => 18,
      p_width => 24,
      quantization => 1
    )
    port map (
      a => ram_data_out_net_x47,
      b => bram9_data_out_net,
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      core_ce => ce_1_sg_x698,
      core_clk => clk_1_sg_x698,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => mult9_p_net_x0
    );

  not_clear: entity work.inverter_251f82b86b
    port map (
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      clr => '0',
      ip(0) => register1_q_net_x11,
      op(0) => not_clear_op_net_x0
    );

  sum_808a632832: entity work.sum_entity_808a632832
    port map (
      ce_1 => ce_1_sg_x698,
      clk_1 => clk_1_sg_x698,
      din1 => mult50_p_net_x0,
      din10 => mult41_p_net_x0,
      din11 => mult40_p_net_x0,
      din12 => mult39_p_net_x0,
      din13 => mult38_p_net_x0,
      din14 => mult37_p_net_x0,
      din15 => mult36_p_net_x0,
      din16 => mult35_p_net_x0,
      din17 => mult34_p_net_x0,
      din18 => mult33_p_net_x0,
      din19 => mult32_p_net_x0,
      din2 => mult49_p_net_x0,
      din20 => mult31_p_net_x0,
      din21 => mult30_p_net_x0,
      din22 => mult29_p_net_x0,
      din23 => mult28_p_net_x0,
      din24 => mult27_p_net_x0,
      din25 => mult26_p_net_x0,
      din26 => mult25_p_net_x0,
      din27 => mult24_p_net_x0,
      din28 => mult23_p_net_x0,
      din29 => mult22_p_net_x0,
      din3 => mult48_p_net_x0,
      din30 => mult21_p_net_x0,
      din31 => mult20_p_net_x0,
      din32 => mult19_p_net_x0,
      din33 => mult18_p_net_x0,
      din34 => mult17_p_net_x0,
      din35 => mult16_p_net_x0,
      din36 => mult15_p_net_x0,
      din37 => mult14_p_net_x0,
      din38 => mult13_p_net_x0,
      din39 => mult12_p_net_x0,
      din4 => mult47_p_net_x0,
      din40 => mult11_p_net_x0,
      din41 => mult10_p_net_x0,
      din42 => mult9_p_net_x0,
      din43 => mult8_p_net_x0,
      din44 => mult7_p_net_x0,
      din45 => mult6_p_net_x0,
      din46 => mult5_p_net_x0,
      din47 => mult4_p_net_x0,
      din48 => mult3_p_net_x0,
      din49 => mult2_p_net_x0,
      din5 => mult46_p_net_x0,
      din50 => mult1_p_net_x0,
      din6 => mult45_p_net_x0,
      din7 => mult44_p_net_x0,
      din8 => mult43_p_net_x0,
      din9 => mult42_p_net_x0,
      sync => sync_delay_q_net_x1,
      dout => addr52_s_net_x1,
      sync_out => sync_delay_q_net_x3
    );

  sync_delay: entity work.xldelay
    generic map (
      latency => 4,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      d => misc_dly_q_net,
      en => '1',
      rst => '1',
      q => sync_delay_q_net_x1
    );

  tap_dly: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x698,
      clk => clk_1_sg_x698,
      d => register1_q_net_x12,
      en => '1',
      rst => '1',
      q => tap_dly_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/prog_fir0/load_chan"

entity load_chan_entity_028b630507 is
  port (
    darkquad29_prog_fir0_load_chan_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end load_chan_entity_028b630507;

architecture structural of load_chan_entity_028b630507 is
  signal darkquad29_prog_fir0_load_chan_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_prog_fir0_load_chan_user_data_out_net_x0 <= darkquad29_prog_fir0_load_chan_user_data_out;
  in_reg <= reint1_output_port_net_x1;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_prog_fir0_load_chan_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x1
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/prog_fir0/pipeline"

entity pipeline_entity_3439e462fc is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(11 downto 0); 
    q: out std_logic_vector(11 downto 0)
  );
end pipeline_entity_3439e462fc;

architecture structural of pipeline_entity_3439e462fc is
  signal ce_1_sg_x699: std_logic;
  signal clk_1_sg_x699: std_logic;
  signal delay7_q_net_x0: std_logic_vector(11 downto 0);
  signal register0_q_net: std_logic_vector(11 downto 0);
  signal register1_q_net: std_logic_vector(11 downto 0);
  signal register2_q_net_x0: std_logic_vector(11 downto 0);

begin
  ce_1_sg_x699 <= ce_1;
  clk_1_sg_x699 <= clk_1;
  delay7_q_net_x0 <= d;
  q <= register2_q_net_x0;

  register0: entity work.xlregister
    generic map (
      d_width => 12,
      init_value => b"000000000000"
    )
    port map (
      ce => ce_1_sg_x699,
      clk => clk_1_sg_x699,
      d => delay7_q_net_x0,
      en => "1",
      rst => "0",
      q => register0_q_net
    );

  register1: entity work.xlregister
    generic map (
      d_width => 12,
      init_value => b"000000000000"
    )
    port map (
      ce => ce_1_sg_x699,
      clk => clk_1_sg_x699,
      d => register0_q_net,
      en => "1",
      rst => "0",
      q => register1_q_net
    );

  register2: entity work.xlregister
    generic map (
      d_width => 12,
      init_value => b"000000000000"
    )
    port map (
      ce => ce_1_sg_x699,
      clk => clk_1_sg_x699,
      d => register1_q_net,
      en => "1",
      rst => "0",
      q => register2_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/prog_fir0/pipeline2"

entity pipeline2_entity_0ea9dfbc83 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic_vector(7 downto 0); 
    q: out std_logic_vector(7 downto 0)
  );
end pipeline2_entity_0ea9dfbc83;

architecture structural of pipeline2_entity_0ea9dfbc83 is
  signal ce_1_sg_x702: std_logic;
  signal clk_1_sg_x702: std_logic;
  signal delay17_q_net_x0: std_logic_vector(7 downto 0);
  signal register0_q_net: std_logic_vector(7 downto 0);
  signal register1_q_net: std_logic_vector(7 downto 0);
  signal register2_q_net_x0: std_logic_vector(7 downto 0);

begin
  ce_1_sg_x702 <= ce_1;
  clk_1_sg_x702 <= clk_1;
  delay17_q_net_x0 <= d;
  q <= register2_q_net_x0;

  register0: entity work.xlregister
    generic map (
      d_width => 8,
      init_value => b"00000000"
    )
    port map (
      ce => ce_1_sg_x702,
      clk => clk_1_sg_x702,
      d => delay17_q_net_x0,
      en => "1",
      rst => "0",
      q => register0_q_net
    );

  register1: entity work.xlregister
    generic map (
      d_width => 8,
      init_value => b"00000000"
    )
    port map (
      ce => ce_1_sg_x702,
      clk => clk_1_sg_x702,
      d => register0_q_net,
      en => "1",
      rst => "0",
      q => register1_q_net
    );

  register2: entity work.xlregister
    generic map (
      d_width => 8,
      init_value => b"00000000"
    )
    port map (
      ce => ce_1_sg_x702,
      clk => clk_1_sg_x702,
      d => register1_q_net,
      en => "1",
      rst => "0",
      q => register2_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/prog_fir0/pipeline3"

entity pipeline3_entity_e470f59772 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    d: in std_logic; 
    q: out std_logic
  );
end pipeline3_entity_e470f59772;

architecture structural of pipeline3_entity_e470f59772 is
  signal ce_1_sg_x703: std_logic;
  signal clk_1_sg_x703: std_logic;
  signal delay3_q_net_x0: std_logic;
  signal register0_q_net: std_logic;
  signal register1_q_net: std_logic;
  signal register2_q_net_x0: std_logic;

begin
  ce_1_sg_x703 <= ce_1;
  clk_1_sg_x703 <= clk_1;
  delay3_q_net_x0 <= d;
  q <= register2_q_net_x0;

  register0: entity work.xlregister
    generic map (
      d_width => 1,
      init_value => b"0"
    )
    port map (
      ce => ce_1_sg_x703,
      clk => clk_1_sg_x703,
      d(0) => delay3_q_net_x0,
      en => "1",
      rst => "0",
      q(0) => register0_q_net
    );

  register1: entity work.xlregister
    generic map (
      d_width => 1,
      init_value => b"0"
    )
    port map (
      ce => ce_1_sg_x703,
      clk => clk_1_sg_x703,
      d(0) => register0_q_net,
      en => "1",
      rst => "0",
      q(0) => register1_q_net
    );

  register2: entity work.xlregister
    generic map (
      d_width => 1,
      init_value => b"0"
    )
    port map (
      ce => ce_1_sg_x703,
      clk => clk_1_sg_x703,
      d(0) => register1_q_net,
      en => "1",
      rst => "0",
      q(0) => register2_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/prog_fir0/single_chan_coeffs/munge_in"

entity munge_in_entity_916b2ba5b9 is
  port (
    din: in std_logic_vector(31 downto 0); 
    dout: out std_logic_vector(31 downto 0)
  );
end munge_in_entity_916b2ba5b9;

architecture structural of munge_in_entity_916b2ba5b9 is
  signal constant2_op_net_x0: std_logic_vector(31 downto 0);
  signal reinterpret_out_output_port_net_x0: std_logic_vector(31 downto 0);

begin
  constant2_op_net_x0 <= din;
  dout <= reinterpret_out_output_port_net_x0;

  reinterpret_out: entity work.reinterpret_3f7e3674f6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => constant2_op_net_x0,
      output_port => reinterpret_out_output_port_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/prog_fir0/single_chan_coeffs"

entity single_chan_coeffs_entity_d52a6dc2f3 is
  port (
    addr: in std_logic_vector(7 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    darkquad29_prog_fir0_single_chan_coeffs_data_out: in std_logic_vector(31 downto 0); 
    data_in: in std_logic_vector(31 downto 0); 
    we: in std_logic; 
    convert_addr_x0: out std_logic_vector(9 downto 0); 
    convert_din1_x0: out std_logic_vector(31 downto 0); 
    convert_we_x0: out std_logic; 
    data_out: out std_logic_vector(31 downto 0)
  );
end single_chan_coeffs_entity_d52a6dc2f3;

architecture structural of single_chan_coeffs_entity_d52a6dc2f3 is
  signal ce_1_sg_x711: std_logic;
  signal clk_1_sg_x711: std_logic;
  signal constant1_op_net_x0: std_logic;
  signal constant2_op_net_x1: std_logic_vector(31 downto 0);
  signal convert_addr_dout_net_x0: std_logic_vector(9 downto 0);
  signal convert_din1_dout_net_x0: std_logic_vector(31 downto 0);
  signal convert_we_dout_net_x0: std_logic;
  signal counter_op_net_x2: std_logic_vector(7 downto 0);
  signal darkquad29_prog_fir0_single_chan_coeffs_data_out_net_x1: std_logic_vector(31 downto 0);
  signal mux_y_net_x0: std_logic_vector(9 downto 0);
  signal reinterpret_out_output_port_net_x0: std_logic_vector(31 downto 0);
  signal reinterpret_out_output_port_net_x2: std_logic_vector(31 downto 0);

begin
  counter_op_net_x2 <= addr;
  ce_1_sg_x711 <= ce_1;
  clk_1_sg_x711 <= clk_1;
  darkquad29_prog_fir0_single_chan_coeffs_data_out_net_x1 <= darkquad29_prog_fir0_single_chan_coeffs_data_out;
  constant2_op_net_x1 <= data_in;
  constant1_op_net_x0 <= we;
  convert_addr_x0 <= convert_addr_dout_net_x0;
  convert_din1_x0 <= convert_din1_dout_net_x0;
  convert_we_x0 <= convert_we_dout_net_x0;
  data_out <= reinterpret_out_output_port_net_x2;

  calc_add_fd0b953861: entity work.calc_add_entity_27b5517daf
    port map (
      ce_1 => ce_1_sg_x711,
      clk_1 => clk_1_sg_x711,
      in_x0 => counter_op_net_x2,
      out_x0 => mux_y_net_x0
    );

  convert_addr: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 10,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 10,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x711,
      clk => clk_1_sg_x711,
      clr => '0',
      din => mux_y_net_x0,
      en => "1",
      dout => convert_addr_dout_net_x0
    );

  convert_din1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 32,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x711,
      clk => clk_1_sg_x711,
      clr => '0',
      din => reinterpret_out_output_port_net_x0,
      en => "1",
      dout => convert_din1_dout_net_x0
    );

  convert_we: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x711,
      clk => clk_1_sg_x711,
      clr => '0',
      din(0) => constant1_op_net_x0,
      en => "1",
      dout(0) => convert_we_dout_net_x0
    );

  munge_in_916b2ba5b9: entity work.munge_in_entity_916b2ba5b9
    port map (
      din => constant2_op_net_x1,
      dout => reinterpret_out_output_port_net_x0
    );

  munge_out_cc3f25a820: entity work.munge_in_entity_9341d54c73
    port map (
      din => darkquad29_prog_fir0_single_chan_coeffs_data_out_net_x1,
      dout => reinterpret_out_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/prog_fir0"

entity prog_fir0_entity_fe8268b744 is
  port (
    ce_1: in std_logic; 
    ch_in: in std_logic_vector(7 downto 0); 
    clk_1: in std_logic; 
    darkquad29_prog_fir0_load_chan_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_prog_fir0_single_chan_coeffs_data_out: in std_logic_vector(31 downto 0); 
    data_in: in std_logic_vector(11 downto 0); 
    ch_out: out std_logic_vector(7 downto 0); 
    data_out: out std_logic_vector(11 downto 0); 
    single_chan_coeffs: out std_logic_vector(9 downto 0); 
    single_chan_coeffs_x0: out std_logic_vector(31 downto 0); 
    single_chan_coeffs_x1: out std_logic
  );
end prog_fir0_entity_fe8268b744;

architecture structural of prog_fir0_entity_fe8268b744 is
  signal addr52_s_net_x1: std_logic_vector(29 downto 0);
  signal ce_1_sg_x712: std_logic;
  signal clk_1_sg_x712: std_logic;
  signal constant1_op_net_x0: std_logic;
  signal constant2_op_net_x1: std_logic_vector(31 downto 0);
  signal convert_addr_dout_net_x1: std_logic_vector(9 downto 0);
  signal convert_din1_dout_net_x1: std_logic_vector(31 downto 0);
  signal convert_dout_net_x0: std_logic_vector(11 downto 0);
  signal convert_we_dout_net_x1: std_logic;
  signal counter_op_net_x2: std_logic_vector(7 downto 0);
  signal darkquad29_prog_fir0_load_chan_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal darkquad29_prog_fir0_single_chan_coeffs_data_out_net_x2: std_logic_vector(31 downto 0);
  signal delay12_q_net_x0: std_logic_vector(7 downto 0);
  signal delay13_q_net: std_logic_vector(7 downto 0);
  signal delay14_q_net_x0: std_logic_vector(7 downto 0);
  signal delay16_q_net: std_logic_vector(7 downto 0);
  signal delay17_q_net_x0: std_logic_vector(7 downto 0);
  signal delay25_q_net_x0: std_logic_vector(11 downto 0);
  signal delay27_q_net_x0: std_logic_vector(7 downto 0);
  signal delay3_q_net_x0: std_logic;
  signal delay4_q_net: std_logic;
  signal delay5_q_net: std_logic_vector(11 downto 0);
  signal delay7_q_net_x0: std_logic_vector(11 downto 0);
  signal edge_op_y_net_x0: std_logic;
  signal register1_q_net_x10: std_logic_vector(11 downto 0);
  signal register1_q_net_x11: std_logic_vector(7 downto 0);
  signal register1_q_net_x12: std_logic;
  signal register1_q_net_x13: std_logic_vector(7 downto 0);
  signal register1_q_net_x8: std_logic_vector(11 downto 0);
  signal register1_q_net_x9: std_logic_vector(7 downto 0);
  signal register2_q_net_x1: std_logic_vector(11 downto 0);
  signal register2_q_net_x2: std_logic_vector(7 downto 0);
  signal register2_q_net_x3: std_logic;
  signal register2_q_net_x4: std_logic_vector(7 downto 0);
  signal register2_q_net_x5: std_logic_vector(7 downto 0);
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(7 downto 0);
  signal reinterpret1_output_port_net_x1: std_logic_vector(11 downto 0);
  signal reinterpret_out_output_port_net_x2: std_logic_vector(31 downto 0);
  signal slice1_y_net: std_logic_vector(11 downto 0);
  signal slice2_y_net_x1: std_logic;
  signal sync_delay_q_net_x3: std_logic_vector(7 downto 0);

begin
  ce_1_sg_x712 <= ce_1;
  delay27_q_net_x0 <= ch_in;
  clk_1_sg_x712 <= clk_1;
  darkquad29_prog_fir0_load_chan_user_data_out_net_x1 <= darkquad29_prog_fir0_load_chan_user_data_out;
  darkquad29_prog_fir0_single_chan_coeffs_data_out_net_x2 <= darkquad29_prog_fir0_single_chan_coeffs_data_out;
  delay25_q_net_x0 <= data_in;
  ch_out <= delay14_q_net_x0;
  data_out <= convert_dout_net_x0;
  single_chan_coeffs <= convert_addr_dout_net_x1;
  single_chan_coeffs_x0 <= convert_din1_dout_net_x1;
  single_chan_coeffs_x1 <= convert_we_dout_net_x1;

  bus_expand2_3496d923b6: entity work.bus_expand2_entity_3496d923b6
    port map (
      bus_in => reint1_output_port_net_x1,
      lsb_out1 => reinterpret1_output_port_net_x0,
      out2 => slice2_y_net_x1
    );

  constant1: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant1_op_net_x0
    );

  constant2: entity work.constant_37567836aa
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant2_op_net_x1
    );

  convert: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 18,
      din_width => 30,
      dout_arith => 2,
      dout_bin_pt => 9,
      dout_width => 12,
      latency => 2,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x712,
      clk => clk_1_sg_x712,
      clr => '0',
      din => addr52_s_net_x1,
      en => "1",
      dout => convert_dout_net_x0
    );

  counter: entity work.xlcounter_free_darkquad29
    generic map (
      core_name0 => "cntr_11_0_564d43d07a40ef72",
      op_arith => xlUnsigned,
      op_width => 8
    )
    port map (
      ce => ce_1_sg_x712,
      clk => clk_1_sg_x712,
      clr => '0',
      en(0) => delay4_q_net,
      rst(0) => edge_op_y_net_x0,
      op => counter_op_net_x2
    );

  delay12: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x712,
      clk => clk_1_sg_x712,
      d => delay13_q_net,
      en => '1',
      rst => '1',
      q => delay12_q_net_x0
    );

  delay13: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x712,
      clk => clk_1_sg_x712,
      d => reinterpret1_output_port_net_x0,
      en => '1',
      rst => '1',
      q => delay13_q_net
    );

  delay14: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x712,
      clk => clk_1_sg_x712,
      d => sync_delay_q_net_x3,
      en => '1',
      rst => '1',
      q => delay14_q_net_x0
    );

  delay16: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x712,
      clk => clk_1_sg_x712,
      d => delay27_q_net_x0,
      en => '1',
      rst => '1',
      q => delay16_q_net
    );

  delay17: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x712,
      clk => clk_1_sg_x712,
      d => delay16_q_net,
      en => '1',
      rst => '1',
      q => delay17_q_net_x0
    );

  delay3: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x712,
      clk => clk_1_sg_x712,
      d(0) => delay4_q_net,
      en => '1',
      rst => '1',
      q(0) => delay3_q_net_x0
    );

  delay4: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x712,
      clk => clk_1_sg_x712,
      d(0) => slice2_y_net_x1,
      en => '1',
      rst => '1',
      q(0) => delay4_q_net
    );

  delay5: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 12
    )
    port map (
      ce => ce_1_sg_x712,
      clk => clk_1_sg_x712,
      d => delay25_q_net_x0,
      en => '1',
      rst => '1',
      q => delay5_q_net
    );

  delay7: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 12
    )
    port map (
      ce => ce_1_sg_x712,
      clk => clk_1_sg_x712,
      d => delay5_q_net,
      en => '1',
      rst => '1',
      q => delay7_q_net_x0
    );

  edge_detect_7b0ae1a84f: entity work.edge_detect3_entity_2efb246ca9
    port map (
      ce_1 => ce_1_sg_x712,
      clk_1 => clk_1_sg_x712,
      in_x0 => slice2_y_net_x1,
      out_x0 => edge_op_y_net_x0
    );

  fir_10a996dabf: entity work.fir_entity_10a996dabf
    port map (
      ce_1 => ce_1_sg_x712,
      ch_in => register1_q_net_x11,
      ch_to_write => register1_q_net_x9,
      clk_1 => clk_1_sg_x712,
      coeff_to_write => register1_q_net_x8,
      data_in => register1_q_net_x10,
      tap_to_write => register1_q_net_x13,
      write_coeff => register1_q_net_x12,
      ch_out => sync_delay_q_net_x3,
      data_out => addr52_s_net_x1
    );

  load_chan_028b630507: entity work.load_chan_entity_028b630507
    port map (
      darkquad29_prog_fir0_load_chan_user_data_out => darkquad29_prog_fir0_load_chan_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x1
    );

  pipeline10_81312c0cf5: entity work.pipeline4_entity_7ef90e571d
    port map (
      ce_1 => ce_1_sg_x712,
      clk_1 => clk_1_sg_x712,
      d => register2_q_net_x5,
      q => register1_q_net_x9
    );

  pipeline1_bb7f75f6cc: entity work.coeff_in_dly0_entity_f7e4d41e30
    port map (
      ce_1 => ce_1_sg_x712,
      clk_1 => clk_1_sg_x712,
      d => reinterpret1_output_port_net_x1,
      q => register1_q_net_x8
    );

  pipeline2_0ea9dfbc83: entity work.pipeline2_entity_0ea9dfbc83
    port map (
      ce_1 => ce_1_sg_x712,
      clk_1 => clk_1_sg_x712,
      d => delay17_q_net_x0,
      q => register2_q_net_x2
    );

  pipeline3_e470f59772: entity work.pipeline3_entity_e470f59772
    port map (
      ce_1 => ce_1_sg_x712,
      clk_1 => clk_1_sg_x712,
      d => delay3_q_net_x0,
      q => register2_q_net_x3
    );

  pipeline4_c58e8e077a: entity work.pipeline2_entity_0ea9dfbc83
    port map (
      ce_1 => ce_1_sg_x712,
      clk_1 => clk_1_sg_x712,
      d => counter_op_net_x2,
      q => register2_q_net_x4
    );

  pipeline5_c86ea02027: entity work.pipeline2_entity_0ea9dfbc83
    port map (
      ce_1 => ce_1_sg_x712,
      clk_1 => clk_1_sg_x712,
      d => delay12_q_net_x0,
      q => register2_q_net_x5
    );

  pipeline6_a6004fd07c: entity work.coeff_in_dly0_entity_f7e4d41e30
    port map (
      ce_1 => ce_1_sg_x712,
      clk_1 => clk_1_sg_x712,
      d => register2_q_net_x1,
      q => register1_q_net_x10
    );

  pipeline7_47cc11665b: entity work.pipeline4_entity_7ef90e571d
    port map (
      ce_1 => ce_1_sg_x712,
      clk_1 => clk_1_sg_x712,
      d => register2_q_net_x2,
      q => register1_q_net_x11
    );

  pipeline8_3cb198fa6f: entity work.pipeline3_entity_fb0a315a6d
    port map (
      ce_1 => ce_1_sg_x712,
      clk_1 => clk_1_sg_x712,
      d => register2_q_net_x3,
      q => register1_q_net_x12
    );

  pipeline9_d5388aff16: entity work.pipeline4_entity_7ef90e571d
    port map (
      ce_1 => ce_1_sg_x712,
      clk_1 => clk_1_sg_x712,
      d => register2_q_net_x4,
      q => register1_q_net_x13
    );

  pipeline_3439e462fc: entity work.pipeline_entity_3439e462fc
    port map (
      ce_1 => ce_1_sg_x712,
      clk_1 => clk_1_sg_x712,
      d => delay7_q_net_x0,
      q => register2_q_net_x1
    );

  reinterpret1: entity work.reinterpret_8f5500aea5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x1
    );

  single_chan_coeffs_d52a6dc2f3: entity work.single_chan_coeffs_entity_d52a6dc2f3
    port map (
      addr => counter_op_net_x2,
      ce_1 => ce_1_sg_x712,
      clk_1 => clk_1_sg_x712,
      darkquad29_prog_fir0_single_chan_coeffs_data_out => darkquad29_prog_fir0_single_chan_coeffs_data_out_net_x2,
      data_in => constant2_op_net_x1,
      we => constant1_op_net_x0,
      convert_addr_x0 => convert_addr_dout_net_x1,
      convert_din1_x0 => convert_din1_dout_net_x1,
      convert_we_x0 => convert_we_dout_net_x1,
      data_out => reinterpret_out_output_port_net_x2
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 11,
      x_width => 32,
      y_width => 12
    )
    port map (
      x => reinterpret_out_output_port_net_x2,
      y => slice1_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/prog_fir1/load_chan"

entity load_chan_entity_b7ce4ce7eb is
  port (
    darkquad29_prog_fir1_load_chan_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end load_chan_entity_b7ce4ce7eb;

architecture structural of load_chan_entity_b7ce4ce7eb is
  signal darkquad29_prog_fir1_load_chan_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_prog_fir1_load_chan_user_data_out_net_x0 <= darkquad29_prog_fir1_load_chan_user_data_out;
  in_reg <= reint1_output_port_net_x1;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_prog_fir1_load_chan_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x1
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/prog_fir1/single_chan_coeffs"

entity single_chan_coeffs_entity_85026a668f is
  port (
    addr: in std_logic_vector(7 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    darkquad29_prog_fir1_single_chan_coeffs_data_out: in std_logic_vector(31 downto 0); 
    data_in: in std_logic_vector(31 downto 0); 
    we: in std_logic; 
    convert_addr_x0: out std_logic_vector(9 downto 0); 
    convert_din1_x0: out std_logic_vector(31 downto 0); 
    convert_we_x0: out std_logic; 
    data_out: out std_logic_vector(31 downto 0)
  );
end single_chan_coeffs_entity_85026a668f;

architecture structural of single_chan_coeffs_entity_85026a668f is
  signal ce_1_sg_x820: std_logic;
  signal clk_1_sg_x820: std_logic;
  signal constant1_op_net_x0: std_logic;
  signal constant2_op_net_x1: std_logic_vector(31 downto 0);
  signal convert_addr_dout_net_x0: std_logic_vector(9 downto 0);
  signal convert_din1_dout_net_x0: std_logic_vector(31 downto 0);
  signal convert_we_dout_net_x0: std_logic;
  signal counter_op_net_x2: std_logic_vector(7 downto 0);
  signal darkquad29_prog_fir1_single_chan_coeffs_data_out_net_x1: std_logic_vector(31 downto 0);
  signal mux_y_net_x0: std_logic_vector(9 downto 0);
  signal reinterpret_out_output_port_net_x0: std_logic_vector(31 downto 0);
  signal reinterpret_out_output_port_net_x2: std_logic_vector(31 downto 0);

begin
  counter_op_net_x2 <= addr;
  ce_1_sg_x820 <= ce_1;
  clk_1_sg_x820 <= clk_1;
  darkquad29_prog_fir1_single_chan_coeffs_data_out_net_x1 <= darkquad29_prog_fir1_single_chan_coeffs_data_out;
  constant2_op_net_x1 <= data_in;
  constant1_op_net_x0 <= we;
  convert_addr_x0 <= convert_addr_dout_net_x0;
  convert_din1_x0 <= convert_din1_dout_net_x0;
  convert_we_x0 <= convert_we_dout_net_x0;
  data_out <= reinterpret_out_output_port_net_x2;

  calc_add_7e65838607: entity work.calc_add_entity_27b5517daf
    port map (
      ce_1 => ce_1_sg_x820,
      clk_1 => clk_1_sg_x820,
      in_x0 => counter_op_net_x2,
      out_x0 => mux_y_net_x0
    );

  convert_addr: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 10,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 10,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x820,
      clk => clk_1_sg_x820,
      clr => '0',
      din => mux_y_net_x0,
      en => "1",
      dout => convert_addr_dout_net_x0
    );

  convert_din1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 32,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x820,
      clk => clk_1_sg_x820,
      clr => '0',
      din => reinterpret_out_output_port_net_x0,
      en => "1",
      dout => convert_din1_dout_net_x0
    );

  convert_we: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x820,
      clk => clk_1_sg_x820,
      clr => '0',
      din(0) => constant1_op_net_x0,
      en => "1",
      dout(0) => convert_we_dout_net_x0
    );

  munge_in_8ca92c74df: entity work.munge_in_entity_916b2ba5b9
    port map (
      din => constant2_op_net_x1,
      dout => reinterpret_out_output_port_net_x0
    );

  munge_out_b6dc398e6a: entity work.munge_in_entity_9341d54c73
    port map (
      din => darkquad29_prog_fir1_single_chan_coeffs_data_out_net_x1,
      dout => reinterpret_out_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/prog_fir1"

entity prog_fir1_entity_b14c72270e is
  port (
    ce_1: in std_logic; 
    ch_in: in std_logic_vector(7 downto 0); 
    clk_1: in std_logic; 
    darkquad29_prog_fir1_load_chan_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_prog_fir1_single_chan_coeffs_data_out: in std_logic_vector(31 downto 0); 
    data_in: in std_logic_vector(11 downto 0); 
    ch_out: out std_logic_vector(7 downto 0); 
    data_out: out std_logic_vector(11 downto 0); 
    single_chan_coeffs: out std_logic_vector(9 downto 0); 
    single_chan_coeffs_x0: out std_logic_vector(31 downto 0); 
    single_chan_coeffs_x1: out std_logic
  );
end prog_fir1_entity_b14c72270e;

architecture structural of prog_fir1_entity_b14c72270e is
  signal addr52_s_net_x1: std_logic_vector(29 downto 0);
  signal ce_1_sg_x821: std_logic;
  signal clk_1_sg_x821: std_logic;
  signal constant1_op_net_x0: std_logic;
  signal constant2_op_net_x1: std_logic_vector(31 downto 0);
  signal convert_addr_dout_net_x1: std_logic_vector(9 downto 0);
  signal convert_din1_dout_net_x1: std_logic_vector(31 downto 0);
  signal convert_dout_net_x0: std_logic_vector(11 downto 0);
  signal convert_we_dout_net_x1: std_logic;
  signal counter_op_net_x2: std_logic_vector(7 downto 0);
  signal darkquad29_prog_fir1_load_chan_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal darkquad29_prog_fir1_single_chan_coeffs_data_out_net_x2: std_logic_vector(31 downto 0);
  signal delay11_q_net_x0: std_logic_vector(11 downto 0);
  signal delay12_q_net_x0: std_logic_vector(7 downto 0);
  signal delay13_q_net: std_logic_vector(7 downto 0);
  signal delay14_q_net_x0: std_logic_vector(7 downto 0);
  signal delay15_q_net_x0: std_logic_vector(7 downto 0);
  signal delay16_q_net: std_logic_vector(7 downto 0);
  signal delay17_q_net_x0: std_logic_vector(7 downto 0);
  signal delay3_q_net_x0: std_logic;
  signal delay4_q_net: std_logic;
  signal delay5_q_net: std_logic_vector(11 downto 0);
  signal delay7_q_net_x0: std_logic_vector(11 downto 0);
  signal edge_op_y_net_x0: std_logic;
  signal register1_q_net_x10: std_logic_vector(11 downto 0);
  signal register1_q_net_x11: std_logic_vector(7 downto 0);
  signal register1_q_net_x12: std_logic;
  signal register1_q_net_x13: std_logic_vector(7 downto 0);
  signal register1_q_net_x8: std_logic_vector(11 downto 0);
  signal register1_q_net_x9: std_logic_vector(7 downto 0);
  signal register2_q_net_x1: std_logic_vector(11 downto 0);
  signal register2_q_net_x2: std_logic_vector(7 downto 0);
  signal register2_q_net_x3: std_logic;
  signal register2_q_net_x4: std_logic_vector(7 downto 0);
  signal register2_q_net_x5: std_logic_vector(7 downto 0);
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(7 downto 0);
  signal reinterpret1_output_port_net_x1: std_logic_vector(11 downto 0);
  signal reinterpret_out_output_port_net_x2: std_logic_vector(31 downto 0);
  signal slice1_y_net: std_logic_vector(11 downto 0);
  signal slice2_y_net_x1: std_logic;
  signal sync_delay_q_net_x3: std_logic_vector(7 downto 0);

begin
  ce_1_sg_x821 <= ce_1;
  delay15_q_net_x0 <= ch_in;
  clk_1_sg_x821 <= clk_1;
  darkquad29_prog_fir1_load_chan_user_data_out_net_x1 <= darkquad29_prog_fir1_load_chan_user_data_out;
  darkquad29_prog_fir1_single_chan_coeffs_data_out_net_x2 <= darkquad29_prog_fir1_single_chan_coeffs_data_out;
  delay11_q_net_x0 <= data_in;
  ch_out <= delay14_q_net_x0;
  data_out <= convert_dout_net_x0;
  single_chan_coeffs <= convert_addr_dout_net_x1;
  single_chan_coeffs_x0 <= convert_din1_dout_net_x1;
  single_chan_coeffs_x1 <= convert_we_dout_net_x1;

  bus_expand2_53aa76bb89: entity work.bus_expand2_entity_3496d923b6
    port map (
      bus_in => reint1_output_port_net_x1,
      lsb_out1 => reinterpret1_output_port_net_x0,
      out2 => slice2_y_net_x1
    );

  constant1: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant1_op_net_x0
    );

  constant2: entity work.constant_37567836aa
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant2_op_net_x1
    );

  convert: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 18,
      din_width => 30,
      dout_arith => 2,
      dout_bin_pt => 9,
      dout_width => 12,
      latency => 2,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x821,
      clk => clk_1_sg_x821,
      clr => '0',
      din => addr52_s_net_x1,
      en => "1",
      dout => convert_dout_net_x0
    );

  counter: entity work.xlcounter_free_darkquad29
    generic map (
      core_name0 => "cntr_11_0_564d43d07a40ef72",
      op_arith => xlUnsigned,
      op_width => 8
    )
    port map (
      ce => ce_1_sg_x821,
      clk => clk_1_sg_x821,
      clr => '0',
      en(0) => delay4_q_net,
      rst(0) => edge_op_y_net_x0,
      op => counter_op_net_x2
    );

  delay12: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x821,
      clk => clk_1_sg_x821,
      d => delay13_q_net,
      en => '1',
      rst => '1',
      q => delay12_q_net_x0
    );

  delay13: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x821,
      clk => clk_1_sg_x821,
      d => reinterpret1_output_port_net_x0,
      en => '1',
      rst => '1',
      q => delay13_q_net
    );

  delay14: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x821,
      clk => clk_1_sg_x821,
      d => sync_delay_q_net_x3,
      en => '1',
      rst => '1',
      q => delay14_q_net_x0
    );

  delay16: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x821,
      clk => clk_1_sg_x821,
      d => delay15_q_net_x0,
      en => '1',
      rst => '1',
      q => delay16_q_net
    );

  delay17: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x821,
      clk => clk_1_sg_x821,
      d => delay16_q_net,
      en => '1',
      rst => '1',
      q => delay17_q_net_x0
    );

  delay3: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x821,
      clk => clk_1_sg_x821,
      d(0) => delay4_q_net,
      en => '1',
      rst => '1',
      q(0) => delay3_q_net_x0
    );

  delay4: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x821,
      clk => clk_1_sg_x821,
      d(0) => slice2_y_net_x1,
      en => '1',
      rst => '1',
      q(0) => delay4_q_net
    );

  delay5: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 12
    )
    port map (
      ce => ce_1_sg_x821,
      clk => clk_1_sg_x821,
      d => delay11_q_net_x0,
      en => '1',
      rst => '1',
      q => delay5_q_net
    );

  delay7: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 12
    )
    port map (
      ce => ce_1_sg_x821,
      clk => clk_1_sg_x821,
      d => delay5_q_net,
      en => '1',
      rst => '1',
      q => delay7_q_net_x0
    );

  edge_detect_04dd6f554f: entity work.edge_detect3_entity_2efb246ca9
    port map (
      ce_1 => ce_1_sg_x821,
      clk_1 => clk_1_sg_x821,
      in_x0 => slice2_y_net_x1,
      out_x0 => edge_op_y_net_x0
    );

  fir_418706452c: entity work.fir_entity_10a996dabf
    port map (
      ce_1 => ce_1_sg_x821,
      ch_in => register1_q_net_x11,
      ch_to_write => register1_q_net_x9,
      clk_1 => clk_1_sg_x821,
      coeff_to_write => register1_q_net_x8,
      data_in => register1_q_net_x10,
      tap_to_write => register1_q_net_x13,
      write_coeff => register1_q_net_x12,
      ch_out => sync_delay_q_net_x3,
      data_out => addr52_s_net_x1
    );

  load_chan_b7ce4ce7eb: entity work.load_chan_entity_b7ce4ce7eb
    port map (
      darkquad29_prog_fir1_load_chan_user_data_out => darkquad29_prog_fir1_load_chan_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x1
    );

  pipeline10_c1394cff73: entity work.pipeline4_entity_7ef90e571d
    port map (
      ce_1 => ce_1_sg_x821,
      clk_1 => clk_1_sg_x821,
      d => register2_q_net_x5,
      q => register1_q_net_x9
    );

  pipeline1_50f29e59f9: entity work.coeff_in_dly0_entity_f7e4d41e30
    port map (
      ce_1 => ce_1_sg_x821,
      clk_1 => clk_1_sg_x821,
      d => reinterpret1_output_port_net_x1,
      q => register1_q_net_x8
    );

  pipeline2_f8e280ea57: entity work.pipeline2_entity_0ea9dfbc83
    port map (
      ce_1 => ce_1_sg_x821,
      clk_1 => clk_1_sg_x821,
      d => delay17_q_net_x0,
      q => register2_q_net_x2
    );

  pipeline3_b0ff55f77b: entity work.pipeline3_entity_e470f59772
    port map (
      ce_1 => ce_1_sg_x821,
      clk_1 => clk_1_sg_x821,
      d => delay3_q_net_x0,
      q => register2_q_net_x3
    );

  pipeline4_43a354b925: entity work.pipeline2_entity_0ea9dfbc83
    port map (
      ce_1 => ce_1_sg_x821,
      clk_1 => clk_1_sg_x821,
      d => counter_op_net_x2,
      q => register2_q_net_x4
    );

  pipeline5_c75b2ff510: entity work.pipeline2_entity_0ea9dfbc83
    port map (
      ce_1 => ce_1_sg_x821,
      clk_1 => clk_1_sg_x821,
      d => delay12_q_net_x0,
      q => register2_q_net_x5
    );

  pipeline6_bc1a7a0370: entity work.coeff_in_dly0_entity_f7e4d41e30
    port map (
      ce_1 => ce_1_sg_x821,
      clk_1 => clk_1_sg_x821,
      d => register2_q_net_x1,
      q => register1_q_net_x10
    );

  pipeline7_decfe0b62f: entity work.pipeline4_entity_7ef90e571d
    port map (
      ce_1 => ce_1_sg_x821,
      clk_1 => clk_1_sg_x821,
      d => register2_q_net_x2,
      q => register1_q_net_x11
    );

  pipeline8_be3d1de3f6: entity work.pipeline3_entity_fb0a315a6d
    port map (
      ce_1 => ce_1_sg_x821,
      clk_1 => clk_1_sg_x821,
      d => register2_q_net_x3,
      q => register1_q_net_x12
    );

  pipeline9_d194c6f63a: entity work.pipeline4_entity_7ef90e571d
    port map (
      ce_1 => ce_1_sg_x821,
      clk_1 => clk_1_sg_x821,
      d => register2_q_net_x4,
      q => register1_q_net_x13
    );

  pipeline_0be1689ea5: entity work.pipeline_entity_3439e462fc
    port map (
      ce_1 => ce_1_sg_x821,
      clk_1 => clk_1_sg_x821,
      d => delay7_q_net_x0,
      q => register2_q_net_x1
    );

  reinterpret1: entity work.reinterpret_8f5500aea5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x1
    );

  single_chan_coeffs_85026a668f: entity work.single_chan_coeffs_entity_85026a668f
    port map (
      addr => counter_op_net_x2,
      ce_1 => ce_1_sg_x821,
      clk_1 => clk_1_sg_x821,
      darkquad29_prog_fir1_single_chan_coeffs_data_out => darkquad29_prog_fir1_single_chan_coeffs_data_out_net_x2,
      data_in => constant2_op_net_x1,
      we => constant1_op_net_x0,
      convert_addr_x0 => convert_addr_dout_net_x1,
      convert_din1_x0 => convert_din1_dout_net_x1,
      convert_we_x0 => convert_we_dout_net_x1,
      data_out => reinterpret_out_output_port_net_x2
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 11,
      x_width => 32,
      y_width => 12
    )
    port map (
      x => reinterpret_out_output_port_net_x2,
      y => slice1_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/prog_fir2/load_chan"

entity load_chan_entity_b76993d6ce is
  port (
    darkquad29_prog_fir2_load_chan_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end load_chan_entity_b76993d6ce;

architecture structural of load_chan_entity_b76993d6ce is
  signal darkquad29_prog_fir2_load_chan_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_prog_fir2_load_chan_user_data_out_net_x0 <= darkquad29_prog_fir2_load_chan_user_data_out;
  in_reg <= reint1_output_port_net_x1;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_prog_fir2_load_chan_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x1
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/prog_fir2/single_chan_coeffs"

entity single_chan_coeffs_entity_5c0a9d03d2 is
  port (
    addr: in std_logic_vector(7 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    darkquad29_prog_fir2_single_chan_coeffs_data_out: in std_logic_vector(31 downto 0); 
    data_in: in std_logic_vector(31 downto 0); 
    we: in std_logic; 
    convert_addr_x0: out std_logic_vector(9 downto 0); 
    convert_din1_x0: out std_logic_vector(31 downto 0); 
    convert_we_x0: out std_logic; 
    data_out: out std_logic_vector(31 downto 0)
  );
end single_chan_coeffs_entity_5c0a9d03d2;

architecture structural of single_chan_coeffs_entity_5c0a9d03d2 is
  signal ce_1_sg_x929: std_logic;
  signal clk_1_sg_x929: std_logic;
  signal constant1_op_net_x0: std_logic;
  signal constant2_op_net_x1: std_logic_vector(31 downto 0);
  signal convert_addr_dout_net_x0: std_logic_vector(9 downto 0);
  signal convert_din1_dout_net_x0: std_logic_vector(31 downto 0);
  signal convert_we_dout_net_x0: std_logic;
  signal counter_op_net_x2: std_logic_vector(7 downto 0);
  signal darkquad29_prog_fir2_single_chan_coeffs_data_out_net_x1: std_logic_vector(31 downto 0);
  signal mux_y_net_x0: std_logic_vector(9 downto 0);
  signal reinterpret_out_output_port_net_x0: std_logic_vector(31 downto 0);
  signal reinterpret_out_output_port_net_x2: std_logic_vector(31 downto 0);

begin
  counter_op_net_x2 <= addr;
  ce_1_sg_x929 <= ce_1;
  clk_1_sg_x929 <= clk_1;
  darkquad29_prog_fir2_single_chan_coeffs_data_out_net_x1 <= darkquad29_prog_fir2_single_chan_coeffs_data_out;
  constant2_op_net_x1 <= data_in;
  constant1_op_net_x0 <= we;
  convert_addr_x0 <= convert_addr_dout_net_x0;
  convert_din1_x0 <= convert_din1_dout_net_x0;
  convert_we_x0 <= convert_we_dout_net_x0;
  data_out <= reinterpret_out_output_port_net_x2;

  calc_add_c8398160f7: entity work.calc_add_entity_27b5517daf
    port map (
      ce_1 => ce_1_sg_x929,
      clk_1 => clk_1_sg_x929,
      in_x0 => counter_op_net_x2,
      out_x0 => mux_y_net_x0
    );

  convert_addr: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 10,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 10,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x929,
      clk => clk_1_sg_x929,
      clr => '0',
      din => mux_y_net_x0,
      en => "1",
      dout => convert_addr_dout_net_x0
    );

  convert_din1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 32,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x929,
      clk => clk_1_sg_x929,
      clr => '0',
      din => reinterpret_out_output_port_net_x0,
      en => "1",
      dout => convert_din1_dout_net_x0
    );

  convert_we: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x929,
      clk => clk_1_sg_x929,
      clr => '0',
      din(0) => constant1_op_net_x0,
      en => "1",
      dout(0) => convert_we_dout_net_x0
    );

  munge_in_2ae149c0ca: entity work.munge_in_entity_916b2ba5b9
    port map (
      din => constant2_op_net_x1,
      dout => reinterpret_out_output_port_net_x0
    );

  munge_out_61b839c398: entity work.munge_in_entity_9341d54c73
    port map (
      din => darkquad29_prog_fir2_single_chan_coeffs_data_out_net_x1,
      dout => reinterpret_out_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/prog_fir2"

entity prog_fir2_entity_7a88e27847 is
  port (
    ce_1: in std_logic; 
    ch_in: in std_logic_vector(7 downto 0); 
    clk_1: in std_logic; 
    darkquad29_prog_fir2_load_chan_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_prog_fir2_single_chan_coeffs_data_out: in std_logic_vector(31 downto 0); 
    data_in: in std_logic_vector(11 downto 0); 
    ch_out: out std_logic_vector(7 downto 0); 
    data_out: out std_logic_vector(11 downto 0); 
    single_chan_coeffs: out std_logic_vector(9 downto 0); 
    single_chan_coeffs_x0: out std_logic_vector(31 downto 0); 
    single_chan_coeffs_x1: out std_logic
  );
end prog_fir2_entity_7a88e27847;

architecture structural of prog_fir2_entity_7a88e27847 is
  signal addr52_s_net_x1: std_logic_vector(29 downto 0);
  signal ce_1_sg_x930: std_logic;
  signal clk_1_sg_x930: std_logic;
  signal constant1_op_net_x0: std_logic;
  signal constant2_op_net_x1: std_logic_vector(31 downto 0);
  signal convert_addr_dout_net_x1: std_logic_vector(9 downto 0);
  signal convert_din1_dout_net_x1: std_logic_vector(31 downto 0);
  signal convert_dout_net_x0: std_logic_vector(11 downto 0);
  signal convert_we_dout_net_x1: std_logic;
  signal counter_op_net_x2: std_logic_vector(7 downto 0);
  signal darkquad29_prog_fir2_load_chan_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal darkquad29_prog_fir2_single_chan_coeffs_data_out_net_x2: std_logic_vector(31 downto 0);
  signal delay12_q_net_x0: std_logic_vector(7 downto 0);
  signal delay13_q_net: std_logic_vector(7 downto 0);
  signal delay14_q_net_x0: std_logic_vector(7 downto 0);
  signal delay16_q_net: std_logic_vector(7 downto 0);
  signal delay17_q_net_x0: std_logic_vector(7 downto 0);
  signal delay23_q_net_x0: std_logic_vector(11 downto 0);
  signal delay24_q_net_x0: std_logic_vector(7 downto 0);
  signal delay3_q_net_x0: std_logic;
  signal delay4_q_net: std_logic;
  signal delay5_q_net: std_logic_vector(11 downto 0);
  signal delay7_q_net_x0: std_logic_vector(11 downto 0);
  signal edge_op_y_net_x0: std_logic;
  signal register1_q_net_x10: std_logic_vector(11 downto 0);
  signal register1_q_net_x11: std_logic_vector(7 downto 0);
  signal register1_q_net_x12: std_logic;
  signal register1_q_net_x13: std_logic_vector(7 downto 0);
  signal register1_q_net_x8: std_logic_vector(11 downto 0);
  signal register1_q_net_x9: std_logic_vector(7 downto 0);
  signal register2_q_net_x1: std_logic_vector(11 downto 0);
  signal register2_q_net_x2: std_logic_vector(7 downto 0);
  signal register2_q_net_x3: std_logic;
  signal register2_q_net_x4: std_logic_vector(7 downto 0);
  signal register2_q_net_x5: std_logic_vector(7 downto 0);
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(7 downto 0);
  signal reinterpret1_output_port_net_x1: std_logic_vector(11 downto 0);
  signal reinterpret_out_output_port_net_x2: std_logic_vector(31 downto 0);
  signal slice1_y_net: std_logic_vector(11 downto 0);
  signal slice2_y_net_x1: std_logic;
  signal sync_delay_q_net_x3: std_logic_vector(7 downto 0);

begin
  ce_1_sg_x930 <= ce_1;
  delay24_q_net_x0 <= ch_in;
  clk_1_sg_x930 <= clk_1;
  darkquad29_prog_fir2_load_chan_user_data_out_net_x1 <= darkquad29_prog_fir2_load_chan_user_data_out;
  darkquad29_prog_fir2_single_chan_coeffs_data_out_net_x2 <= darkquad29_prog_fir2_single_chan_coeffs_data_out;
  delay23_q_net_x0 <= data_in;
  ch_out <= delay14_q_net_x0;
  data_out <= convert_dout_net_x0;
  single_chan_coeffs <= convert_addr_dout_net_x1;
  single_chan_coeffs_x0 <= convert_din1_dout_net_x1;
  single_chan_coeffs_x1 <= convert_we_dout_net_x1;

  bus_expand2_44d2fc3a65: entity work.bus_expand2_entity_3496d923b6
    port map (
      bus_in => reint1_output_port_net_x1,
      lsb_out1 => reinterpret1_output_port_net_x0,
      out2 => slice2_y_net_x1
    );

  constant1: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant1_op_net_x0
    );

  constant2: entity work.constant_37567836aa
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant2_op_net_x1
    );

  convert: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 18,
      din_width => 30,
      dout_arith => 2,
      dout_bin_pt => 9,
      dout_width => 12,
      latency => 2,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x930,
      clk => clk_1_sg_x930,
      clr => '0',
      din => addr52_s_net_x1,
      en => "1",
      dout => convert_dout_net_x0
    );

  counter: entity work.xlcounter_free_darkquad29
    generic map (
      core_name0 => "cntr_11_0_564d43d07a40ef72",
      op_arith => xlUnsigned,
      op_width => 8
    )
    port map (
      ce => ce_1_sg_x930,
      clk => clk_1_sg_x930,
      clr => '0',
      en(0) => delay4_q_net,
      rst(0) => edge_op_y_net_x0,
      op => counter_op_net_x2
    );

  delay12: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x930,
      clk => clk_1_sg_x930,
      d => delay13_q_net,
      en => '1',
      rst => '1',
      q => delay12_q_net_x0
    );

  delay13: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x930,
      clk => clk_1_sg_x930,
      d => reinterpret1_output_port_net_x0,
      en => '1',
      rst => '1',
      q => delay13_q_net
    );

  delay14: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x930,
      clk => clk_1_sg_x930,
      d => sync_delay_q_net_x3,
      en => '1',
      rst => '1',
      q => delay14_q_net_x0
    );

  delay16: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x930,
      clk => clk_1_sg_x930,
      d => delay24_q_net_x0,
      en => '1',
      rst => '1',
      q => delay16_q_net
    );

  delay17: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x930,
      clk => clk_1_sg_x930,
      d => delay16_q_net,
      en => '1',
      rst => '1',
      q => delay17_q_net_x0
    );

  delay3: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x930,
      clk => clk_1_sg_x930,
      d(0) => delay4_q_net,
      en => '1',
      rst => '1',
      q(0) => delay3_q_net_x0
    );

  delay4: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x930,
      clk => clk_1_sg_x930,
      d(0) => slice2_y_net_x1,
      en => '1',
      rst => '1',
      q(0) => delay4_q_net
    );

  delay5: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 12
    )
    port map (
      ce => ce_1_sg_x930,
      clk => clk_1_sg_x930,
      d => delay23_q_net_x0,
      en => '1',
      rst => '1',
      q => delay5_q_net
    );

  delay7: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 12
    )
    port map (
      ce => ce_1_sg_x930,
      clk => clk_1_sg_x930,
      d => delay5_q_net,
      en => '1',
      rst => '1',
      q => delay7_q_net_x0
    );

  edge_detect_7d7537d57a: entity work.edge_detect3_entity_2efb246ca9
    port map (
      ce_1 => ce_1_sg_x930,
      clk_1 => clk_1_sg_x930,
      in_x0 => slice2_y_net_x1,
      out_x0 => edge_op_y_net_x0
    );

  fir_c2f5dffea8: entity work.fir_entity_10a996dabf
    port map (
      ce_1 => ce_1_sg_x930,
      ch_in => register1_q_net_x11,
      ch_to_write => register1_q_net_x9,
      clk_1 => clk_1_sg_x930,
      coeff_to_write => register1_q_net_x8,
      data_in => register1_q_net_x10,
      tap_to_write => register1_q_net_x13,
      write_coeff => register1_q_net_x12,
      ch_out => sync_delay_q_net_x3,
      data_out => addr52_s_net_x1
    );

  load_chan_b76993d6ce: entity work.load_chan_entity_b76993d6ce
    port map (
      darkquad29_prog_fir2_load_chan_user_data_out => darkquad29_prog_fir2_load_chan_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x1
    );

  pipeline10_8977a34880: entity work.pipeline4_entity_7ef90e571d
    port map (
      ce_1 => ce_1_sg_x930,
      clk_1 => clk_1_sg_x930,
      d => register2_q_net_x5,
      q => register1_q_net_x9
    );

  pipeline1_59ece4a76f: entity work.coeff_in_dly0_entity_f7e4d41e30
    port map (
      ce_1 => ce_1_sg_x930,
      clk_1 => clk_1_sg_x930,
      d => reinterpret1_output_port_net_x1,
      q => register1_q_net_x8
    );

  pipeline2_f04c43c6b0: entity work.pipeline2_entity_0ea9dfbc83
    port map (
      ce_1 => ce_1_sg_x930,
      clk_1 => clk_1_sg_x930,
      d => delay17_q_net_x0,
      q => register2_q_net_x2
    );

  pipeline3_a2c6483eff: entity work.pipeline3_entity_e470f59772
    port map (
      ce_1 => ce_1_sg_x930,
      clk_1 => clk_1_sg_x930,
      d => delay3_q_net_x0,
      q => register2_q_net_x3
    );

  pipeline4_bbffcfb76e: entity work.pipeline2_entity_0ea9dfbc83
    port map (
      ce_1 => ce_1_sg_x930,
      clk_1 => clk_1_sg_x930,
      d => counter_op_net_x2,
      q => register2_q_net_x4
    );

  pipeline5_45077529fd: entity work.pipeline2_entity_0ea9dfbc83
    port map (
      ce_1 => ce_1_sg_x930,
      clk_1 => clk_1_sg_x930,
      d => delay12_q_net_x0,
      q => register2_q_net_x5
    );

  pipeline6_f6f6085db8: entity work.coeff_in_dly0_entity_f7e4d41e30
    port map (
      ce_1 => ce_1_sg_x930,
      clk_1 => clk_1_sg_x930,
      d => register2_q_net_x1,
      q => register1_q_net_x10
    );

  pipeline7_14faad6afe: entity work.pipeline4_entity_7ef90e571d
    port map (
      ce_1 => ce_1_sg_x930,
      clk_1 => clk_1_sg_x930,
      d => register2_q_net_x2,
      q => register1_q_net_x11
    );

  pipeline8_0dcddec39e: entity work.pipeline3_entity_fb0a315a6d
    port map (
      ce_1 => ce_1_sg_x930,
      clk_1 => clk_1_sg_x930,
      d => register2_q_net_x3,
      q => register1_q_net_x12
    );

  pipeline9_6ab53e2789: entity work.pipeline4_entity_7ef90e571d
    port map (
      ce_1 => ce_1_sg_x930,
      clk_1 => clk_1_sg_x930,
      d => register2_q_net_x4,
      q => register1_q_net_x13
    );

  pipeline_320223e4cf: entity work.pipeline_entity_3439e462fc
    port map (
      ce_1 => ce_1_sg_x930,
      clk_1 => clk_1_sg_x930,
      d => delay7_q_net_x0,
      q => register2_q_net_x1
    );

  reinterpret1: entity work.reinterpret_8f5500aea5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x1
    );

  single_chan_coeffs_5c0a9d03d2: entity work.single_chan_coeffs_entity_5c0a9d03d2
    port map (
      addr => counter_op_net_x2,
      ce_1 => ce_1_sg_x930,
      clk_1 => clk_1_sg_x930,
      darkquad29_prog_fir2_single_chan_coeffs_data_out => darkquad29_prog_fir2_single_chan_coeffs_data_out_net_x2,
      data_in => constant2_op_net_x1,
      we => constant1_op_net_x0,
      convert_addr_x0 => convert_addr_dout_net_x1,
      convert_din1_x0 => convert_din1_dout_net_x1,
      convert_we_x0 => convert_we_dout_net_x1,
      data_out => reinterpret_out_output_port_net_x2
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 11,
      x_width => 32,
      y_width => 12
    )
    port map (
      x => reinterpret_out_output_port_net_x2,
      y => slice1_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/prog_fir3/load_chan"

entity load_chan_entity_7c875a60b9 is
  port (
    darkquad29_prog_fir3_load_chan_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end load_chan_entity_7c875a60b9;

architecture structural of load_chan_entity_7c875a60b9 is
  signal darkquad29_prog_fir3_load_chan_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_prog_fir3_load_chan_user_data_out_net_x0 <= darkquad29_prog_fir3_load_chan_user_data_out;
  in_reg <= reint1_output_port_net_x1;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_prog_fir3_load_chan_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x1
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/prog_fir3/single_chan_coeffs"

entity single_chan_coeffs_entity_5152bcd2e7 is
  port (
    addr: in std_logic_vector(7 downto 0); 
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    darkquad29_prog_fir3_single_chan_coeffs_data_out: in std_logic_vector(31 downto 0); 
    data_in: in std_logic_vector(31 downto 0); 
    we: in std_logic; 
    convert_addr_x0: out std_logic_vector(9 downto 0); 
    convert_din1_x0: out std_logic_vector(31 downto 0); 
    convert_we_x0: out std_logic; 
    data_out: out std_logic_vector(31 downto 0)
  );
end single_chan_coeffs_entity_5152bcd2e7;

architecture structural of single_chan_coeffs_entity_5152bcd2e7 is
  signal ce_1_sg_x1038: std_logic;
  signal clk_1_sg_x1038: std_logic;
  signal constant1_op_net_x0: std_logic;
  signal constant2_op_net_x1: std_logic_vector(31 downto 0);
  signal convert_addr_dout_net_x0: std_logic_vector(9 downto 0);
  signal convert_din1_dout_net_x0: std_logic_vector(31 downto 0);
  signal convert_we_dout_net_x0: std_logic;
  signal counter_op_net_x2: std_logic_vector(7 downto 0);
  signal darkquad29_prog_fir3_single_chan_coeffs_data_out_net_x1: std_logic_vector(31 downto 0);
  signal mux_y_net_x0: std_logic_vector(9 downto 0);
  signal reinterpret_out_output_port_net_x0: std_logic_vector(31 downto 0);
  signal reinterpret_out_output_port_net_x2: std_logic_vector(31 downto 0);

begin
  counter_op_net_x2 <= addr;
  ce_1_sg_x1038 <= ce_1;
  clk_1_sg_x1038 <= clk_1;
  darkquad29_prog_fir3_single_chan_coeffs_data_out_net_x1 <= darkquad29_prog_fir3_single_chan_coeffs_data_out;
  constant2_op_net_x1 <= data_in;
  constant1_op_net_x0 <= we;
  convert_addr_x0 <= convert_addr_dout_net_x0;
  convert_din1_x0 <= convert_din1_dout_net_x0;
  convert_we_x0 <= convert_we_dout_net_x0;
  data_out <= reinterpret_out_output_port_net_x2;

  calc_add_9ee628a52d: entity work.calc_add_entity_27b5517daf
    port map (
      ce_1 => ce_1_sg_x1038,
      clk_1 => clk_1_sg_x1038,
      in_x0 => counter_op_net_x2,
      out_x0 => mux_y_net_x0
    );

  convert_addr: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 10,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 10,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x1038,
      clk => clk_1_sg_x1038,
      clr => '0',
      din => mux_y_net_x0,
      en => "1",
      dout => convert_addr_dout_net_x0
    );

  convert_din1: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 32,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x1038,
      clk => clk_1_sg_x1038,
      clr => '0',
      din => reinterpret_out_output_port_net_x0,
      en => "1",
      dout => convert_din1_dout_net_x0
    );

  convert_we: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 1,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 1,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x1038,
      clk => clk_1_sg_x1038,
      clr => '0',
      din(0) => constant1_op_net_x0,
      en => "1",
      dout(0) => convert_we_dout_net_x0
    );

  munge_in_e0bd81384d: entity work.munge_in_entity_916b2ba5b9
    port map (
      din => constant2_op_net_x1,
      dout => reinterpret_out_output_port_net_x0
    );

  munge_out_468473193f: entity work.munge_in_entity_9341d54c73
    port map (
      din => darkquad29_prog_fir3_single_chan_coeffs_data_out_net_x1,
      dout => reinterpret_out_output_port_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/prog_fir3"

entity prog_fir3_entity_f2fb14267e is
  port (
    ce_1: in std_logic; 
    ch_in: in std_logic_vector(7 downto 0); 
    clk_1: in std_logic; 
    darkquad29_prog_fir3_load_chan_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_prog_fir3_single_chan_coeffs_data_out: in std_logic_vector(31 downto 0); 
    data_in: in std_logic_vector(11 downto 0); 
    ch_out: out std_logic_vector(7 downto 0); 
    data_out: out std_logic_vector(11 downto 0); 
    single_chan_coeffs: out std_logic_vector(9 downto 0); 
    single_chan_coeffs_x0: out std_logic_vector(31 downto 0); 
    single_chan_coeffs_x1: out std_logic
  );
end prog_fir3_entity_f2fb14267e;

architecture structural of prog_fir3_entity_f2fb14267e is
  signal addr52_s_net_x1: std_logic_vector(29 downto 0);
  signal ce_1_sg_x1039: std_logic;
  signal clk_1_sg_x1039: std_logic;
  signal constant1_op_net_x0: std_logic;
  signal constant2_op_net_x1: std_logic_vector(31 downto 0);
  signal convert_addr_dout_net_x1: std_logic_vector(9 downto 0);
  signal convert_din1_dout_net_x1: std_logic_vector(31 downto 0);
  signal convert_dout_net_x0: std_logic_vector(11 downto 0);
  signal convert_we_dout_net_x1: std_logic;
  signal counter_op_net_x2: std_logic_vector(7 downto 0);
  signal darkquad29_prog_fir3_load_chan_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal darkquad29_prog_fir3_single_chan_coeffs_data_out_net_x2: std_logic_vector(31 downto 0);
  signal delay12_q_net_x0: std_logic_vector(7 downto 0);
  signal delay13_q_net: std_logic_vector(7 downto 0);
  signal delay14_q_net_x0: std_logic_vector(7 downto 0);
  signal delay16_q_net: std_logic_vector(7 downto 0);
  signal delay17_q_net_x0: std_logic_vector(7 downto 0);
  signal delay37_q_net_x0: std_logic_vector(11 downto 0);
  signal delay38_q_net_x0: std_logic_vector(7 downto 0);
  signal delay3_q_net_x0: std_logic;
  signal delay4_q_net: std_logic;
  signal delay5_q_net: std_logic_vector(11 downto 0);
  signal delay7_q_net_x0: std_logic_vector(11 downto 0);
  signal edge_op_y_net_x0: std_logic;
  signal register1_q_net_x10: std_logic_vector(11 downto 0);
  signal register1_q_net_x11: std_logic_vector(7 downto 0);
  signal register1_q_net_x12: std_logic;
  signal register1_q_net_x13: std_logic_vector(7 downto 0);
  signal register1_q_net_x8: std_logic_vector(11 downto 0);
  signal register1_q_net_x9: std_logic_vector(7 downto 0);
  signal register2_q_net_x1: std_logic_vector(11 downto 0);
  signal register2_q_net_x2: std_logic_vector(7 downto 0);
  signal register2_q_net_x3: std_logic;
  signal register2_q_net_x4: std_logic_vector(7 downto 0);
  signal register2_q_net_x5: std_logic_vector(7 downto 0);
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal reinterpret1_output_port_net_x0: std_logic_vector(7 downto 0);
  signal reinterpret1_output_port_net_x1: std_logic_vector(11 downto 0);
  signal reinterpret_out_output_port_net_x2: std_logic_vector(31 downto 0);
  signal slice1_y_net: std_logic_vector(11 downto 0);
  signal slice2_y_net_x1: std_logic;
  signal sync_delay_q_net_x3: std_logic_vector(7 downto 0);

begin
  ce_1_sg_x1039 <= ce_1;
  delay38_q_net_x0 <= ch_in;
  clk_1_sg_x1039 <= clk_1;
  darkquad29_prog_fir3_load_chan_user_data_out_net_x1 <= darkquad29_prog_fir3_load_chan_user_data_out;
  darkquad29_prog_fir3_single_chan_coeffs_data_out_net_x2 <= darkquad29_prog_fir3_single_chan_coeffs_data_out;
  delay37_q_net_x0 <= data_in;
  ch_out <= delay14_q_net_x0;
  data_out <= convert_dout_net_x0;
  single_chan_coeffs <= convert_addr_dout_net_x1;
  single_chan_coeffs_x0 <= convert_din1_dout_net_x1;
  single_chan_coeffs_x1 <= convert_we_dout_net_x1;

  bus_expand2_c4967f9021: entity work.bus_expand2_entity_3496d923b6
    port map (
      bus_in => reint1_output_port_net_x1,
      lsb_out1 => reinterpret1_output_port_net_x0,
      out2 => slice2_y_net_x1
    );

  constant1: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => constant1_op_net_x0
    );

  constant2: entity work.constant_37567836aa
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant2_op_net_x1
    );

  convert: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 2,
      din_bin_pt => 18,
      din_width => 30,
      dout_arith => 2,
      dout_bin_pt => 9,
      dout_width => 12,
      latency => 2,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x1039,
      clk => clk_1_sg_x1039,
      clr => '0',
      din => addr52_s_net_x1,
      en => "1",
      dout => convert_dout_net_x0
    );

  counter: entity work.xlcounter_free_darkquad29
    generic map (
      core_name0 => "cntr_11_0_564d43d07a40ef72",
      op_arith => xlUnsigned,
      op_width => 8
    )
    port map (
      ce => ce_1_sg_x1039,
      clk => clk_1_sg_x1039,
      clr => '0',
      en(0) => delay4_q_net,
      rst(0) => edge_op_y_net_x0,
      op => counter_op_net_x2
    );

  delay12: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x1039,
      clk => clk_1_sg_x1039,
      d => delay13_q_net,
      en => '1',
      rst => '1',
      q => delay12_q_net_x0
    );

  delay13: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x1039,
      clk => clk_1_sg_x1039,
      d => reinterpret1_output_port_net_x0,
      en => '1',
      rst => '1',
      q => delay13_q_net
    );

  delay14: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x1039,
      clk => clk_1_sg_x1039,
      d => sync_delay_q_net_x3,
      en => '1',
      rst => '1',
      q => delay14_q_net_x0
    );

  delay16: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x1039,
      clk => clk_1_sg_x1039,
      d => delay38_q_net_x0,
      en => '1',
      rst => '1',
      q => delay16_q_net
    );

  delay17: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x1039,
      clk => clk_1_sg_x1039,
      d => delay16_q_net,
      en => '1',
      rst => '1',
      q => delay17_q_net_x0
    );

  delay3: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x1039,
      clk => clk_1_sg_x1039,
      d(0) => delay4_q_net,
      en => '1',
      rst => '1',
      q(0) => delay3_q_net_x0
    );

  delay4: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x1039,
      clk => clk_1_sg_x1039,
      d(0) => slice2_y_net_x1,
      en => '1',
      rst => '1',
      q(0) => delay4_q_net
    );

  delay5: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 12
    )
    port map (
      ce => ce_1_sg_x1039,
      clk => clk_1_sg_x1039,
      d => delay37_q_net_x0,
      en => '1',
      rst => '1',
      q => delay5_q_net
    );

  delay7: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 12
    )
    port map (
      ce => ce_1_sg_x1039,
      clk => clk_1_sg_x1039,
      d => delay5_q_net,
      en => '1',
      rst => '1',
      q => delay7_q_net_x0
    );

  edge_detect_ed861e2cac: entity work.edge_detect3_entity_2efb246ca9
    port map (
      ce_1 => ce_1_sg_x1039,
      clk_1 => clk_1_sg_x1039,
      in_x0 => slice2_y_net_x1,
      out_x0 => edge_op_y_net_x0
    );

  fir_896f2169f6: entity work.fir_entity_10a996dabf
    port map (
      ce_1 => ce_1_sg_x1039,
      ch_in => register1_q_net_x11,
      ch_to_write => register1_q_net_x9,
      clk_1 => clk_1_sg_x1039,
      coeff_to_write => register1_q_net_x8,
      data_in => register1_q_net_x10,
      tap_to_write => register1_q_net_x13,
      write_coeff => register1_q_net_x12,
      ch_out => sync_delay_q_net_x3,
      data_out => addr52_s_net_x1
    );

  load_chan_7c875a60b9: entity work.load_chan_entity_7c875a60b9
    port map (
      darkquad29_prog_fir3_load_chan_user_data_out => darkquad29_prog_fir3_load_chan_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x1
    );

  pipeline10_6ea30db108: entity work.pipeline4_entity_7ef90e571d
    port map (
      ce_1 => ce_1_sg_x1039,
      clk_1 => clk_1_sg_x1039,
      d => register2_q_net_x5,
      q => register1_q_net_x9
    );

  pipeline1_fb6bdf055c: entity work.coeff_in_dly0_entity_f7e4d41e30
    port map (
      ce_1 => ce_1_sg_x1039,
      clk_1 => clk_1_sg_x1039,
      d => reinterpret1_output_port_net_x1,
      q => register1_q_net_x8
    );

  pipeline2_ada558be96: entity work.pipeline2_entity_0ea9dfbc83
    port map (
      ce_1 => ce_1_sg_x1039,
      clk_1 => clk_1_sg_x1039,
      d => delay17_q_net_x0,
      q => register2_q_net_x2
    );

  pipeline3_f6dffa8979: entity work.pipeline3_entity_e470f59772
    port map (
      ce_1 => ce_1_sg_x1039,
      clk_1 => clk_1_sg_x1039,
      d => delay3_q_net_x0,
      q => register2_q_net_x3
    );

  pipeline4_ec0e55fe37: entity work.pipeline2_entity_0ea9dfbc83
    port map (
      ce_1 => ce_1_sg_x1039,
      clk_1 => clk_1_sg_x1039,
      d => counter_op_net_x2,
      q => register2_q_net_x4
    );

  pipeline5_268511c030: entity work.pipeline2_entity_0ea9dfbc83
    port map (
      ce_1 => ce_1_sg_x1039,
      clk_1 => clk_1_sg_x1039,
      d => delay12_q_net_x0,
      q => register2_q_net_x5
    );

  pipeline6_dcb323558a: entity work.coeff_in_dly0_entity_f7e4d41e30
    port map (
      ce_1 => ce_1_sg_x1039,
      clk_1 => clk_1_sg_x1039,
      d => register2_q_net_x1,
      q => register1_q_net_x10
    );

  pipeline7_97aad15286: entity work.pipeline4_entity_7ef90e571d
    port map (
      ce_1 => ce_1_sg_x1039,
      clk_1 => clk_1_sg_x1039,
      d => register2_q_net_x2,
      q => register1_q_net_x11
    );

  pipeline8_dae538df02: entity work.pipeline3_entity_fb0a315a6d
    port map (
      ce_1 => ce_1_sg_x1039,
      clk_1 => clk_1_sg_x1039,
      d => register2_q_net_x3,
      q => register1_q_net_x12
    );

  pipeline9_5b89d60781: entity work.pipeline4_entity_7ef90e571d
    port map (
      ce_1 => ce_1_sg_x1039,
      clk_1 => clk_1_sg_x1039,
      d => register2_q_net_x4,
      q => register1_q_net_x13
    );

  pipeline_3e782781c1: entity work.pipeline_entity_3439e462fc
    port map (
      ce_1 => ce_1_sg_x1039,
      clk_1 => clk_1_sg_x1039,
      d => delay7_q_net_x0,
      q => register2_q_net_x1
    );

  reinterpret1: entity work.reinterpret_8f5500aea5
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice1_y_net,
      output_port => reinterpret1_output_port_net_x1
    );

  single_chan_coeffs_5152bcd2e7: entity work.single_chan_coeffs_entity_5152bcd2e7
    port map (
      addr => counter_op_net_x2,
      ce_1 => ce_1_sg_x1039,
      clk_1 => clk_1_sg_x1039,
      darkquad29_prog_fir3_single_chan_coeffs_data_out => darkquad29_prog_fir3_single_chan_coeffs_data_out_net_x2,
      data_in => constant2_op_net_x1,
      we => constant1_op_net_x0,
      convert_addr_x0 => convert_addr_dout_net_x1,
      convert_din1_x0 => convert_din1_dout_net_x1,
      convert_we_x0 => convert_we_dout_net_x1,
      data_out => reinterpret_out_output_port_net_x2
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 11,
      x_width => 32,
      y_width => 12
    )
    port map (
      x => reinterpret_out_output_port_net_x2,
      y => slice1_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/run"

entity run_entity_d5b94f8831 is
  port (
    darkquad29_run_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end run_entity_d5b94f8831;

architecture structural of run_entity_d5b94f8831 is
  signal darkquad29_run_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_run_user_data_out_net_x0 <= darkquad29_run_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_run_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/sel_ch"

entity sel_ch_entity_9462bb8e75 is
  port (
    darkquad29_sel_ch_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end sel_ch_entity_9462bb8e75;

architecture structural of sel_ch_entity_9462bb8e75 is
  signal darkquad29_sel_ch_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_sel_ch_user_data_out_net_x0 <= darkquad29_sel_ch_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_sel_ch_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/snp_phs/buscreate"

entity buscreate_entity_9c73f02f7d is
  port (
    in1: in std_logic_vector(15 downto 0); 
    in2: in std_logic; 
    bus_out: out std_logic_vector(16 downto 0)
  );
end buscreate_entity_9c73f02f7d;

architecture structural of buscreate_entity_9c73f02f7d is
  signal assert_phase_dout_net_x0: std_logic_vector(15 downto 0);
  signal assert_trig_dout_net_x0: std_logic;
  signal concatenate_y_net_x0: std_logic_vector(16 downto 0);
  signal reinterpret1_output_port_net: std_logic_vector(15 downto 0);
  signal reinterpret2_output_port_net: std_logic;

begin
  assert_phase_dout_net_x0 <= in1;
  assert_trig_dout_net_x0 <= in2;
  bus_out <= concatenate_y_net_x0;

  concatenate: entity work.concat_066b498729
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => reinterpret1_output_port_net,
      in1(0) => reinterpret2_output_port_net,
      y => concatenate_y_net_x0
    );

  reinterpret1: entity work.reinterpret_7025463ea8
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => assert_phase_dout_net_x0,
      output_port => reinterpret1_output_port_net
    );

  reinterpret2: entity work.reinterpret_112d91c147
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port(0) => assert_trig_dout_net_x0,
      output_port(0) => reinterpret2_output_port_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/snp_phs/ss/ctrl"

entity ctrl_entity_b52a2d3904 is
  port (
    darkquad29_snp_phs_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end ctrl_entity_b52a2d3904;

architecture structural of ctrl_entity_b52a2d3904 is
  signal darkquad29_snp_phs_ss_ctrl_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_snp_phs_ss_ctrl_user_data_out_net_x0 <= darkquad29_snp_phs_ss_ctrl_user_data_out;
  in_reg <= reint1_output_port_net_x1;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_snp_phs_ss_ctrl_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x1
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/snp_phs/ss"

entity ss_entity_86739151fa is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    darkquad29_snp_phs_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    din: in std_logic_vector(16 downto 0); 
    trig: in std_logic; 
    we: in std_logic; 
    bram: out std_logic_vector(8 downto 0); 
    bram_x0: out std_logic_vector(63 downto 0); 
    bram_x1: out std_logic; 
    status: out std_logic_vector(31 downto 0)
  );
end ss_entity_86739151fa;

architecture structural of ss_entity_86739151fa is
  signal add_del_q_net_x1: std_logic_vector(8 downto 0);
  signal cast_dout_net_x1: std_logic_vector(63 downto 0);
  signal cast_gw_dout_net_x1: std_logic_vector(31 downto 0);
  signal ce_1_sg_x1048: std_logic;
  signal clk_1_sg_x1048: std_logic;
  signal concat_y_net_x1: std_logic_vector(31 downto 0);
  signal concatenate_y_net_x1: std_logic_vector(16 downto 0);
  signal convert_addr_dout_net_x1: std_logic_vector(8 downto 0);
  signal convert_din1_dout_net_x1: std_logic_vector(63 downto 0);
  signal convert_we_dout_net_x1: std_logic;
  signal darkquad29_snp_phs_ss_ctrl_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal dat_del_q_net_x1: std_logic_vector(63 downto 0);
  signal data_choice_y_net_x2: std_logic_vector(63 downto 0);
  signal delay6_q_net_x1: std_logic_vector(63 downto 0);
  signal delay6_q_net_x2: std_logic;
  signal edge_op_y_net_x4: std_logic;
  signal logical6_y_net_x0: std_logic;
  signal never_op_net_x0: std_logic;
  signal register1_q_net_x2: std_logic;
  signal register6_q_net_x1: std_logic;
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal ri_output_port_net: std_logic_vector(16 downto 0);
  signal slice2_y_net_x0: std_logic_vector(8 downto 0);
  signal we_choice_y_net_x2: std_logic;
  signal we_del_q_net_x0: std_logic;

begin
  ce_1_sg_x1048 <= ce_1;
  clk_1_sg_x1048 <= clk_1;
  darkquad29_snp_phs_ss_ctrl_user_data_out_net_x1 <= darkquad29_snp_phs_ss_ctrl_user_data_out;
  concatenate_y_net_x1 <= din;
  register1_q_net_x2 <= trig;
  delay6_q_net_x2 <= we;
  bram <= convert_addr_dout_net_x1;
  bram_x0 <= convert_din1_dout_net_x1;
  bram_x1 <= convert_we_dout_net_x1;
  status <= cast_gw_dout_net_x1;

  add_del: entity work.delay_09771002d6
    port map (
      ce => ce_1_sg_x1048,
      clk => clk_1_sg_x1048,
      clr => '0',
      d => slice2_y_net_x0,
      q => add_del_q_net_x1
    );

  add_gen_19cbb93e86: entity work.add_gen_entity_3bd86cf2a5
    port map (
      ce_1 => ce_1_sg_x1048,
      clk_1 => clk_1_sg_x1048,
      cont => never_op_net_x0,
      din => data_choice_y_net_x2,
      go => register6_q_net_x1,
      init => edge_op_y_net_x4,
      we => we_choice_y_net_x2,
      add => slice2_y_net_x0,
      dout => delay6_q_net_x1,
      status => concat_y_net_x1,
      we_o => logical6_y_net_x0
    );

  basic_ctrl_df332c8ec1: entity work.basic_ctrl_entity_877c836a9e
    port map (
      ce_1 => ce_1_sg_x1048,
      clk_1 => clk_1_sg_x1048,
      ctrl => reint1_output_port_net_x1,
      din => cast_dout_net_x1,
      trig => register1_q_net_x2,
      we => delay6_q_net_x2,
      dout => data_choice_y_net_x2,
      go => register6_q_net_x1,
      init => edge_op_y_net_x4,
      we_o => we_choice_y_net_x2
    );

  bram_a0e98e8eac: entity work.bram_entity_2be072e628
    port map (
      addr => add_del_q_net_x1,
      ce_1 => ce_1_sg_x1048,
      clk_1 => clk_1_sg_x1048,
      data_in => dat_del_q_net_x1,
      we => we_del_q_net_x0,
      convert_addr_x0 => convert_addr_dout_net_x1,
      convert_din1_x0 => convert_din1_dout_net_x1,
      convert_we_x0 => convert_we_dout_net_x1
    );

  cast: entity work.xlconvert
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 17,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 64,
      latency => 0,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x1048,
      clk => clk_1_sg_x1048,
      clr => '0',
      din => ri_output_port_net,
      en => "1",
      dout => cast_dout_net_x1
    );

  ctrl_b52a2d3904: entity work.ctrl_entity_b52a2d3904
    port map (
      darkquad29_snp_phs_ss_ctrl_user_data_out => darkquad29_snp_phs_ss_ctrl_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x1
    );

  dat_del: entity work.delay_e2d047c154
    port map (
      ce => ce_1_sg_x1048,
      clk => clk_1_sg_x1048,
      clr => '0',
      d => delay6_q_net_x1,
      q => dat_del_q_net_x1
    );

  never: entity work.constant_963ed6358a
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => never_op_net_x0
    );

  ri: entity work.reinterpret_d109c65ff6
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => concatenate_y_net_x1,
      output_port => ri_output_port_net
    );

  status_a833d1f284: entity work.last_tx_data_entity_4b5ba71046
    port map (
      ce_1 => ce_1_sg_x1048,
      clk_1 => clk_1_sg_x1048,
      out_reg => concat_y_net_x1,
      cast_gw_x0 => cast_gw_dout_net_x1
    );

  we_del: entity work.delay_9f02caa990
    port map (
      ce => ce_1_sg_x1048,
      clk => clk_1_sg_x1048,
      clr => '0',
      d(0) => logical6_y_net_x0,
      q(0) => we_del_q_net_x0
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/snp_phs"

entity snp_phs_entity_5ab5aa3d1e is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    darkquad29_snp_phs_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    in_phase: in std_logic_vector(15 downto 0); 
    in_trig: in std_logic; 
    trig: in std_logic; 
    we: in std_logic; 
    ss: out std_logic_vector(8 downto 0); 
    ss_x0: out std_logic_vector(63 downto 0); 
    ss_x1: out std_logic; 
    ss_x2: out std_logic_vector(31 downto 0)
  );
end snp_phs_entity_5ab5aa3d1e;

architecture structural of snp_phs_entity_5ab5aa3d1e is
  signal assert_phase_dout_net_x0: std_logic_vector(15 downto 0);
  signal assert_trig_dout_net_x0: std_logic;
  signal cast_gw_dout_net_x2: std_logic_vector(31 downto 0);
  signal ce_1_sg_x1049: std_logic;
  signal clk_1_sg_x1049: std_logic;
  signal concatenate_y_net_x1: std_logic_vector(16 downto 0);
  signal convert_addr_dout_net_x2: std_logic_vector(8 downto 0);
  signal convert_din1_dout_net_x2: std_logic_vector(63 downto 0);
  signal convert_we_dout_net_x2: std_logic;
  signal darkquad29_snp_phs_ss_ctrl_user_data_out_net_x2: std_logic_vector(31 downto 0);
  signal delay6_q_net_x3: std_logic;
  signal mux2_y_net_x0: std_logic_vector(15 downto 0);
  signal register1_q_net_x3: std_logic;
  signal register1_q_net_x4: std_logic;

begin
  ce_1_sg_x1049 <= ce_1;
  clk_1_sg_x1049 <= clk_1;
  darkquad29_snp_phs_ss_ctrl_user_data_out_net_x2 <= darkquad29_snp_phs_ss_ctrl_user_data_out;
  mux2_y_net_x0 <= in_phase;
  register1_q_net_x4 <= in_trig;
  register1_q_net_x3 <= trig;
  delay6_q_net_x3 <= we;
  ss <= convert_addr_dout_net_x2;
  ss_x0 <= convert_din1_dout_net_x2;
  ss_x1 <= convert_we_dout_net_x2;
  ss_x2 <= cast_gw_dout_net_x2;

  assert_phase: entity work.xlpassthrough
    generic map (
      din_width => 16,
      dout_width => 16
    )
    port map (
      din => mux2_y_net_x0,
      dout => assert_phase_dout_net_x0
    );

  assert_trig: entity work.xlpassthrough
    generic map (
      din_width => 1,
      dout_width => 1
    )
    port map (
      din(0) => register1_q_net_x4,
      dout(0) => assert_trig_dout_net_x0
    );

  buscreate_9c73f02f7d: entity work.buscreate_entity_9c73f02f7d
    port map (
      in1 => assert_phase_dout_net_x0,
      in2 => assert_trig_dout_net_x0,
      bus_out => concatenate_y_net_x1
    );

  ss_86739151fa: entity work.ss_entity_86739151fa
    port map (
      ce_1 => ce_1_sg_x1049,
      clk_1 => clk_1_sg_x1049,
      darkquad29_snp_phs_ss_ctrl_user_data_out => darkquad29_snp_phs_ss_ctrl_user_data_out_net_x2,
      din => concatenate_y_net_x1,
      trig => register1_q_net_x3,
      we => delay6_q_net_x3,
      bram => convert_addr_dout_net_x2,
      bram_x0 => convert_din1_dout_net_x2,
      bram_x1 => convert_we_dout_net_x2,
      status => cast_gw_dout_net_x2
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/start_cap"

entity start_cap_entity_8dd836ec5d is
  port (
    darkquad29_start_cap_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end start_cap_entity_8dd836ec5d;

architecture structural of start_cap_entity_8dd836ec5d is
  signal darkquad29_start_cap_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_start_cap_user_data_out_net_x0 <= darkquad29_start_cap_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_start_cap_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/timekeeper/base_ts"

entity base_ts_entity_0d572e949f is
  port (
    darkquad29_timekeeper_base_ts_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end base_ts_entity_0d572e949f;

architecture structural of base_ts_entity_0d572e949f is
  signal darkquad29_timekeeper_base_ts_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_timekeeper_base_ts_user_data_out_net_x0 <= darkquad29_timekeeper_base_ts_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_timekeeper_base_ts_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/timekeeper"

entity timekeeper_entity_3a138ccb56 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    darkquad29_timekeeper_base_ts_user_data_out: in std_logic_vector(31 downto 0); 
    pps: in std_logic; 
    ms_out: out std_logic_vector(35 downto 0); 
    pps_out: out std_logic; 
    sec_now: out std_logic_vector(31 downto 0); 
    us_since_halfms: out std_logic_vector(8 downto 0)
  );
end timekeeper_entity_3a138ccb56;

architecture structural of timekeeper_entity_3a138ccb56 is
  signal addsub2_s_net: std_logic_vector(36 downto 0);
  signal addsub_s_net: std_logic_vector(32 downto 0);
  signal cast_gw_dout_net_x1: std_logic_vector(31 downto 0);
  signal ce_1_sg_x1053: std_logic;
  signal clk_1_sg_x1053: std_logic;
  signal cmult_p_net: std_logic_vector(43 downto 0);
  signal constant1_op_net: std_logic_vector(17 downto 0);
  signal constant2_op_net: std_logic_vector(17 downto 0);
  signal constant3_op_net: std_logic_vector(17 downto 0);
  signal constant_op_net: std_logic_vector(17 downto 0);
  signal convert1_dout_net: std_logic_vector(35 downto 0);
  signal convert2_dout_net: std_logic_vector(8 downto 0);
  signal convert3_dout_net_x0: std_logic_vector(31 downto 0);
  signal convert_dout_net_x0: std_logic_vector(35 downto 0);
  signal cyc_ctr1_op_net: std_logic_vector(9 downto 0);
  signal cyc_ctr_op_net: std_logic_vector(27 downto 0);
  signal darkquad29_timekeeper_base_ts_user_data_out_net_x1: std_logic_vector(31 downto 0);
  signal delay10_q_net: std_logic;
  signal delay11_q_net: std_logic;
  signal delay12_q_net: std_logic;
  signal delay13_q_net: std_logic;
  signal delay14_q_net_x5: std_logic;
  signal delay15_q_net: std_logic_vector(31 downto 0);
  signal delay1_q_net: std_logic_vector(32 downto 0);
  signal delay20_q_net: std_logic_vector(32 downto 0);
  signal delay21_q_net: std_logic_vector(32 downto 0);
  signal delay24_q_net: std_logic_vector(19 downto 0);
  signal delay25_q_net: std_logic_vector(31 downto 0);
  signal delay26_q_net: std_logic;
  signal delay2_q_net: std_logic_vector(32 downto 0);
  signal delay3_q_net: std_logic;
  signal delay4_q_net: std_logic_vector(11 downto 0);
  signal delay6_q_net: std_logic_vector(19 downto 0);
  signal delay7_q_net: std_logic_vector(19 downto 0);
  signal delay8_q_net: std_logic_vector(8 downto 0);
  signal delay9_q_net_x6: std_logic_vector(8 downto 0);
  signal half_ms_ctr_op_net: std_logic_vector(19 downto 0);
  signal logical1_y_net: std_logic;
  signal logical2_y_net: std_logic;
  signal logical_y_net: std_logic;
  signal register1_q_net_x1: std_logic_vector(31 downto 0);
  signal register1_q_net_x2: std_logic_vector(31 downto 0);
  signal register1_q_net_x3: std_logic;
  signal register_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal reinterpret_output_port_net: std_logic_vector(19 downto 0);
  signal relational1_op_net: std_logic;
  signal relational2_op_net: std_logic;
  signal relational3_op_net: std_logic;
  signal relational4_op_net: std_logic;
  signal relational_op_net: std_logic;
  signal sec_ctr_op_net: std_logic_vector(19 downto 0);
  signal us_ctr_op_net: std_logic_vector(11 downto 0);

begin
  ce_1_sg_x1053 <= ce_1;
  clk_1_sg_x1053 <= clk_1;
  darkquad29_timekeeper_base_ts_user_data_out_net_x1 <= darkquad29_timekeeper_base_ts_user_data_out;
  register1_q_net_x3 <= pps;
  ms_out <= convert_dout_net_x0;
  pps_out <= delay14_q_net_x5;
  sec_now <= cast_gw_dout_net_x1;
  us_since_halfms <= delay9_q_net_x6;

  addsub: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlUnsigned,
      a_bin_pt => 0,
      a_width => 20,
      b_arith => xlUnsigned,
      b_bin_pt => 0,
      b_width => 32,
      c_has_c_out => 0,
      c_latency => 1,
      c_output_width => 33,
      core_name0 => "addsb_11_0_62b4a1a618c40b84",
      extra_registers => 0,
      full_s_arith => 1,
      full_s_width => 33,
      latency => 1,
      overflow => 1,
      quantization => 1,
      s_arith => xlUnsigned,
      s_bin_pt => 0,
      s_width => 33
    )
    port map (
      a => delay24_q_net,
      b => delay25_q_net,
      ce => ce_1_sg_x1053,
      clk => clk_1_sg_x1053,
      clr => '0',
      en => "1",
      s => addsub_s_net
    );

  addsub2: entity work.xladdsub_darkquad29
    generic map (
      a_arith => xlUnsigned,
      a_bin_pt => 1,
      a_width => 36,
      b_arith => xlUnsigned,
      b_bin_pt => 1,
      b_width => 20,
      c_has_c_out => 0,
      c_latency => 1,
      c_output_width => 37,
      core_name0 => "addsb_11_0_ca3b6f528ea85846",
      extra_registers => 0,
      full_s_arith => 1,
      full_s_width => 37,
      latency => 1,
      overflow => 1,
      quantization => 1,
      s_arith => xlUnsigned,
      s_bin_pt => 1,
      s_width => 37
    )
    port map (
      a => convert1_dout_net,
      b => reinterpret_output_port_net,
      ce => ce_1_sg_x1053,
      clk => clk_1_sg_x1053,
      clr => '0',
      en => "1",
      s => addsub2_s_net
    );

  base_ts_0d572e949f: entity work.base_ts_entity_0d572e949f
    port map (
      darkquad29_timekeeper_base_ts_user_data_out => darkquad29_timekeeper_base_ts_user_data_out_net_x1,
      in_reg => reint1_output_port_net_x1
    );

  cmult: entity work.xlcmult_darkquad29
    generic map (
      a_arith => xlUnsigned,
      a_bin_pt => 0,
      a_width => 33,
      b_bin_pt => 1,
      c_a_type => 1,
      c_a_width => 33,
      c_b_type => 1,
      c_b_width => 11,
      c_output_width => 44,
      core_name0 => "cmlt_11_2_4ea31a3fb6c988bc",
      extra_registers => 0,
      multsign => 1,
      overflow => 1,
      p_arith => xlUnsigned,
      p_bin_pt => 1,
      p_width => 44,
      quantization => 1,
      zero_const => 0
    )
    port map (
      a => addsub_s_net,
      ce => ce_1_sg_x1053,
      clk => clk_1_sg_x1053,
      clr => '0',
      core_ce => ce_1_sg_x1053,
      core_clk => clk_1_sg_x1053,
      core_clr => '1',
      en => "1",
      rst => "0",
      p => cmult_p_net
    );

  constant1: entity work.constant_79d704dc19
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant1_op_net
    );

  constant2: entity work.constant_95b0f967bc
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant2_op_net
    );

  constant3: entity work.constant_95b0f967bc
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant3_op_net
    );

  constant_x0: entity work.constant_7360ecf266
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant_op_net
    );

  convert: entity work.xlconvert_pipeline
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 1,
      din_width => 37,
      dout_arith => 1,
      dout_bin_pt => 1,
      dout_width => 36,
      latency => 2,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x1053,
      clk => clk_1_sg_x1053,
      clr => '0',
      din => addsub2_s_net,
      en => "1",
      dout => convert_dout_net_x0
    );

  convert1: entity work.xlconvert_pipeline
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 1,
      din_width => 44,
      dout_arith => 1,
      dout_bin_pt => 1,
      dout_width => 36,
      latency => 2,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x1053,
      clk => clk_1_sg_x1053,
      clr => '0',
      din => cmult_p_net,
      en => "1",
      dout => convert1_dout_net
    );

  convert2: entity work.xlconvert_pipeline
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 12,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 9,
      latency => 2,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x1053,
      clk => clk_1_sg_x1053,
      clr => '0',
      din => delay4_q_net,
      en => "1",
      dout => convert2_dout_net
    );

  convert3: entity work.xlconvert_pipeline
    generic map (
      bool_conversion => 0,
      din_arith => 1,
      din_bin_pt => 0,
      din_width => 33,
      dout_arith => 1,
      dout_bin_pt => 0,
      dout_width => 32,
      latency => 2,
      overflow => xlWrap,
      quantization => xlTruncate
    )
    port map (
      ce => ce_1_sg_x1053,
      clk => clk_1_sg_x1053,
      clr => '0',
      din => delay2_q_net,
      en => "1",
      dout => convert3_dout_net_x0
    );

  cyc_ctr: entity work.xlcounter_free_darkquad29
    generic map (
      core_name0 => "cntr_11_0_4d961a297cbb815e",
      op_arith => xlUnsigned,
      op_width => 28
    )
    port map (
      ce => ce_1_sg_x1053,
      clk => clk_1_sg_x1053,
      clr => '0',
      en => "1",
      rst(0) => logical_y_net,
      op => cyc_ctr_op_net
    );

  cyc_ctr1: entity work.xlcounter_free_darkquad29
    generic map (
      core_name0 => "cntr_11_0_9e131a76d2321c17",
      op_arith => xlUnsigned,
      op_width => 10
    )
    port map (
      ce => ce_1_sg_x1053,
      clk => clk_1_sg_x1053,
      clr => '0',
      en => "1",
      rst(0) => logical1_y_net,
      op => cyc_ctr1_op_net
    );

  delay1: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 33
    )
    port map (
      ce => ce_1_sg_x1053,
      clk => clk_1_sg_x1053,
      d => delay21_q_net,
      en => '1',
      rst => '1',
      q => delay1_q_net
    );

  delay10: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x1053,
      clk => clk_1_sg_x1053,
      d(0) => delay26_q_net,
      en => '1',
      rst => '1',
      q(0) => delay10_q_net
    );

  delay11: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x1053,
      clk => clk_1_sg_x1053,
      d(0) => delay10_q_net,
      en => '1',
      rst => '1',
      q(0) => delay11_q_net
    );

  delay12: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x1053,
      clk => clk_1_sg_x1053,
      d(0) => delay11_q_net,
      en => '1',
      rst => '1',
      q(0) => delay12_q_net
    );

  delay13: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x1053,
      clk => clk_1_sg_x1053,
      d(0) => delay12_q_net,
      en => '1',
      rst => '1',
      q(0) => delay13_q_net
    );

  delay14: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x1053,
      clk => clk_1_sg_x1053,
      d(0) => delay13_q_net,
      en => '1',
      rst => '1',
      q(0) => delay14_q_net_x5
    );

  delay15: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 32
    )
    port map (
      ce => ce_1_sg_x1053,
      clk => clk_1_sg_x1053,
      d => register1_q_net_x2,
      en => '1',
      rst => '1',
      q => delay15_q_net
    );

  delay2: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 33
    )
    port map (
      ce => ce_1_sg_x1053,
      clk => clk_1_sg_x1053,
      d => delay1_q_net,
      en => '1',
      rst => '1',
      q => delay2_q_net
    );

  delay20: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 33
    )
    port map (
      ce => ce_1_sg_x1053,
      clk => clk_1_sg_x1053,
      d => addsub_s_net,
      en => '1',
      rst => '1',
      q => delay20_q_net
    );

  delay21: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 33
    )
    port map (
      ce => ce_1_sg_x1053,
      clk => clk_1_sg_x1053,
      d => delay20_q_net,
      en => '1',
      rst => '1',
      q => delay21_q_net
    );

  delay24: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 20
    )
    port map (
      ce => ce_1_sg_x1053,
      clk => clk_1_sg_x1053,
      d => sec_ctr_op_net,
      en => '1',
      rst => '1',
      q => delay24_q_net
    );

  delay25: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 32
    )
    port map (
      ce => ce_1_sg_x1053,
      clk => clk_1_sg_x1053,
      d => delay15_q_net,
      en => '1',
      rst => '1',
      q => delay25_q_net
    );

  delay26: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x1053,
      clk => clk_1_sg_x1053,
      d(0) => delay3_q_net,
      en => '1',
      rst => '1',
      q(0) => delay26_q_net
    );

  delay3: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x1053,
      clk => clk_1_sg_x1053,
      d(0) => register1_q_net_x3,
      en => '1',
      rst => '1',
      q(0) => delay3_q_net
    );

  delay4: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 12
    )
    port map (
      ce => ce_1_sg_x1053,
      clk => clk_1_sg_x1053,
      d => us_ctr_op_net,
      en => '1',
      rst => '1',
      q => delay4_q_net
    );

  delay6: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 20
    )
    port map (
      ce => ce_1_sg_x1053,
      clk => clk_1_sg_x1053,
      d => delay7_q_net,
      en => '1',
      rst => '1',
      q => delay6_q_net
    );

  delay7: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 20
    )
    port map (
      ce => ce_1_sg_x1053,
      clk => clk_1_sg_x1053,
      d => half_ms_ctr_op_net,
      en => '1',
      rst => '1',
      q => delay7_q_net
    );

  delay8: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 9
    )
    port map (
      ce => ce_1_sg_x1053,
      clk => clk_1_sg_x1053,
      d => convert2_dout_net,
      en => '1',
      rst => '1',
      q => delay8_q_net
    );

  delay9: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 9
    )
    port map (
      ce => ce_1_sg_x1053,
      clk => clk_1_sg_x1053,
      d => delay8_q_net,
      en => '1',
      rst => '1',
      q => delay9_q_net_x6
    );

  half_ms_ctr: entity work.xlcounter_free_darkquad29
    generic map (
      core_name0 => "cntr_11_0_45eea7380a7f544c",
      op_arith => xlUnsigned,
      op_width => 20
    )
    port map (
      ce => ce_1_sg_x1053,
      clk => clk_1_sg_x1053,
      clr => '0',
      en(0) => relational3_op_net,
      rst(0) => delay26_q_net,
      op => half_ms_ctr_op_net
    );

  logical: entity work.logical_aacf6e1b0e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => relational1_op_net,
      d1(0) => register1_q_net_x3,
      y(0) => logical_y_net
    );

  logical1: entity work.logical_aacf6e1b0e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => relational2_op_net,
      d1(0) => register1_q_net_x3,
      y(0) => logical1_y_net
    );

  logical2: entity work.logical_aacf6e1b0e
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d0(0) => relational3_op_net,
      d1(0) => delay26_q_net,
      y(0) => logical2_y_net
    );

  pipeline6_9363a0e90c: entity work.pipeline1_entity_986e3344b8
    port map (
      ce_1 => ce_1_sg_x1053,
      clk_1 => clk_1_sg_x1053,
      d => convert3_dout_net_x0,
      q => register1_q_net_x1
    );

  pipeline9_21df8e6c99: entity work.pipeline1_entity_986e3344b8
    port map (
      ce_1 => ce_1_sg_x1053,
      clk_1 => clk_1_sg_x1053,
      d => reint1_output_port_net_x1,
      q => register1_q_net_x2
    );

  register_x0: entity work.xlregister
    generic map (
      d_width => 32,
      init_value => b"00000000000000000000000000000000"
    )
    port map (
      ce => ce_1_sg_x1053,
      clk => clk_1_sg_x1053,
      d => register1_q_net_x2,
      en => "1",
      rst => "0",
      q => register_q_net
    );

  reinterpret: entity work.reinterpret_713b6c5d29
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => delay6_q_net,
      output_port => reinterpret_output_port_net
    );

  relational: entity work.relational_14f77d7b05
    port map (
      a => register1_q_net_x2,
      b => register_q_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational_op_net
    );

  relational1: entity work.relational_d7ca0c4e6b
    port map (
      a => constant_op_net,
      b => cyc_ctr_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational1_op_net
    );

  relational2: entity work.relational_4a12466dac
    port map (
      a => constant1_op_net,
      b => cyc_ctr1_op_net,
      ce => '0',
      clk => '0',
      clr => '0',
      op(0) => relational2_op_net
    );

  relational3: entity work.relational_5aa7219969
    port map (
      a => cyc_ctr_op_net,
      b => constant2_op_net,
      ce => ce_1_sg_x1053,
      clk => clk_1_sg_x1053,
      clr => '0',
      op(0) => relational3_op_net
    );

  relational4: entity work.relational_f4e3c98493
    port map (
      a => cyc_ctr1_op_net,
      b => constant3_op_net,
      ce => ce_1_sg_x1053,
      clk => clk_1_sg_x1053,
      clr => '0',
      op(0) => relational4_op_net
    );

  sec_ctr: entity work.xlcounter_free_darkquad29
    generic map (
      core_name0 => "cntr_11_0_ed5c08cc07bca813",
      op_arith => xlUnsigned,
      op_width => 20
    )
    port map (
      ce => ce_1_sg_x1053,
      clk => clk_1_sg_x1053,
      clr => '0',
      en(0) => register1_q_net_x3,
      rst(0) => relational_op_net,
      op => sec_ctr_op_net
    );

  sec_now_ccf959983d: entity work.last_tx_data_entity_4b5ba71046
    port map (
      ce_1 => ce_1_sg_x1053,
      clk_1 => clk_1_sg_x1053,
      out_reg => register1_q_net_x1,
      cast_gw_x0 => cast_gw_dout_net_x1
    );

  us_ctr: entity work.xlcounter_free_darkquad29
    generic map (
      core_name0 => "cntr_11_0_0e7aae3b0f9694f8",
      op_arith => xlUnsigned,
      op_width => 12
    )
    port map (
      ce => ce_1_sg_x1053,
      clk => clk_1_sg_x1053,
      clr => '0',
      en(0) => relational4_op_net,
      rst(0) => logical2_y_net,
      op => us_ctr_op_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29/trig_snp"

entity trig_snp_entity_db92f5316d is
  port (
    darkquad29_trig_snp_user_data_out: in std_logic_vector(31 downto 0); 
    in_reg: out std_logic_vector(31 downto 0)
  );
end trig_snp_entity_db92f5316d;

architecture structural of trig_snp_entity_db92f5316d is
  signal darkquad29_trig_snp_user_data_out_net_x0: std_logic_vector(31 downto 0);
  signal io_delay_q_net: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal slice_reg_y_net: std_logic_vector(31 downto 0);

begin
  darkquad29_trig_snp_user_data_out_net_x0 <= darkquad29_trig_snp_user_data_out;
  in_reg <= reint1_output_port_net_x0;

  io_delay: entity work.delay_2b0feb00fb
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      d => darkquad29_trig_snp_user_data_out_net_x0,
      q => io_delay_q_net
    );

  reint1: entity work.reinterpret_c5d4d59b73
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => slice_reg_y_net,
      output_port => reint1_output_port_net_x0
    );

  slice_reg: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 31,
      x_width => 32,
      y_width => 32
    )
    port map (
      x => io_delay_q_net,
      y => slice_reg_y_net
    );

end structural;
library IEEE;
use IEEE.std_logic_1164.all;
use work.conv_pkg.all;

-- Generated from Simulink block "darkquad29"

entity darkquad29 is
  port (
    ce_1: in std_logic; 
    clk_1: in std_logic; 
    darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_rx_data: in std_logic_vector(7 downto 0); 
    darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_rx_full: in std_logic; 
    darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_rx_val: in std_logic; 
    darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_tx_full: in std_logic; 
    darkquad29_a2g_ctrl_en_bram_dump_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_a2g_ctrl_in_val_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_a2g_ctrl_lut_dump_buffer_size_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_a2g_ctrl_lut_dump_dac_lut_buffer_data_out: in std_logic_vector(7 downto 0); 
    darkquad29_a2g_ctrl_lut_dump_data_period_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_a2g_ctrl_rst_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_a2g_ctrl_tx_en_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_acc_iq_avg0_ss_bram_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_acc_iq_avg0_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_acc_iq_avg1_ss_bram_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_acc_iq_avg1_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_acc_iq_avg2_ss_bram_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_acc_iq_avg2_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_acc_iq_avg3_ss_bram_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_acc_iq_avg3_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_acc_iq_start_acc_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_data_i0: in std_logic_vector(11 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_data_i1: in std_logic_vector(11 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_data_i2: in std_logic_vector(11 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_data_i3: in std_logic_vector(11 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_data_i4: in std_logic_vector(11 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_data_i5: in std_logic_vector(11 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_data_i6: in std_logic_vector(11 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_data_i7: in std_logic_vector(11 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_data_q0: in std_logic_vector(11 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_data_q1: in std_logic_vector(11 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_data_q2: in std_logic_vector(11 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_data_q3: in std_logic_vector(11 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_data_q4: in std_logic_vector(11 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_data_q5: in std_logic_vector(11 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_data_q6: in std_logic_vector(11 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_data_q7: in std_logic_vector(11 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_info_i0: in std_logic_vector(1 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_info_i1: in std_logic_vector(1 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_info_i2: in std_logic_vector(1 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_info_i3: in std_logic_vector(1 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_info_i4: in std_logic_vector(1 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_info_i5: in std_logic_vector(1 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_info_i6: in std_logic_vector(1 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_info_i7: in std_logic_vector(1 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_info_q0: in std_logic_vector(1 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_info_q1: in std_logic_vector(1 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_info_q2: in std_logic_vector(1 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_info_q3: in std_logic_vector(1 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_info_q4: in std_logic_vector(1 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_info_q5: in std_logic_vector(1 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_info_q6: in std_logic_vector(1 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_info_q7: in std_logic_vector(1 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_mmcm_locked: in std_logic; 
    darkquad29_adc_in_adcdac_2g_user_sync: in std_logic; 
    darkquad29_adc_in_adcdac_2g_user_valid: in std_logic; 
    darkquad29_adc_in_dly_val_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_adc_in_i_scale_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_adc_in_inc_phs_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_adc_in_load_dly_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_adc_in_pos_phs_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_adc_in_snp_cal0_ss_bram_data_out: in std_logic_vector(63 downto 0); 
    darkquad29_adc_in_snp_cal0_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_adc_in_snp_cal1_ss_bram_data_out: in std_logic_vector(63 downto 0); 
    darkquad29_adc_in_snp_cal1_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_adc_in_snp_cal2_ss_bram_data_out: in std_logic_vector(63 downto 0); 
    darkquad29_adc_in_snp_cal2_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_adc_in_snp_cal3_ss_bram_data_out: in std_logic_vector(63 downto 0); 
    darkquad29_adc_in_snp_cal3_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_adc_in_trig_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_board_num_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture0_base_kf_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture0_base_kq_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture0_cps_lim_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture0_load_thresh_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture0_pix_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture0_threshold_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture1_base_kf_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture1_base_kq_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture1_cps_lim_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture1_load_thresh_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture1_pix_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture1_threshold_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture2_base_kf_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture2_base_kq_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture2_cps_lim_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture2_load_thresh_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture2_pix_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture2_threshold_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture3_base_kf_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture3_base_kq_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture3_cps_lim_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture3_load_thresh_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture3_pix_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_capture3_threshold_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_chan_sel_ch_bin0_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_chan_sel_ch_bin1_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_chan_sel_ch_bin2_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_chan_sel_ch_bin3_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_chan_sel_load_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_check_lag_latch_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_conv_phase0_centers_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_conv_phase0_load_centers_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_conv_phase1_centers_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_conv_phase1_load_centers_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_conv_phase2_centers_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_conv_phase2_load_centers_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_conv_phase3_centers_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_conv_phase3_load_centers_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_dds_lut_qdr0_ack: in std_logic; 
    darkquad29_dds_lut_qdr0_cal_fail: in std_logic; 
    darkquad29_dds_lut_qdr0_data_out: in std_logic_vector(71 downto 0); 
    darkquad29_dds_lut_qdr0_data_valid: in std_logic; 
    darkquad29_dds_lut_qdr0_phy_ready: in std_logic; 
    darkquad29_dds_lut_qdr1_ack: in std_logic; 
    darkquad29_dds_lut_qdr1_cal_fail: in std_logic; 
    darkquad29_dds_lut_qdr1_data_out: in std_logic_vector(71 downto 0); 
    darkquad29_dds_lut_qdr1_data_valid: in std_logic; 
    darkquad29_dds_lut_qdr1_phy_ready: in std_logic; 
    darkquad29_dds_lut_qdr2_ack: in std_logic; 
    darkquad29_dds_lut_qdr2_cal_fail: in std_logic; 
    darkquad29_dds_lut_qdr2_data_out: in std_logic_vector(71 downto 0); 
    darkquad29_dds_lut_qdr2_data_valid: in std_logic; 
    darkquad29_dds_lut_qdr2_phy_ready: in std_logic; 
    darkquad29_dds_lut_qdr3_ack: in std_logic; 
    darkquad29_dds_lut_qdr3_cal_fail: in std_logic; 
    darkquad29_dds_lut_qdr3_data_out: in std_logic_vector(71 downto 0); 
    darkquad29_dds_lut_qdr3_data_valid: in std_logic; 
    darkquad29_dds_lut_qdr3_phy_ready: in std_logic; 
    darkquad29_dds_lut_run_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_dds_shift_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_gbe64_dest_ip_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_gbe64_one_gbe_app_dbg_data: in std_logic_vector(31 downto 0); 
    darkquad29_gbe64_one_gbe_app_dbg_dvld: in std_logic; 
    darkquad29_gbe64_one_gbe_app_rx_badframe: in std_logic; 
    darkquad29_gbe64_one_gbe_app_rx_data: in std_logic_vector(7 downto 0); 
    darkquad29_gbe64_one_gbe_app_rx_dvld: in std_logic; 
    darkquad29_gbe64_one_gbe_app_rx_eof: in std_logic; 
    darkquad29_gbe64_one_gbe_app_rx_overrun: in std_logic; 
    darkquad29_gbe64_one_gbe_app_rx_srcip: in std_logic_vector(31 downto 0); 
    darkquad29_gbe64_one_gbe_app_rx_srcport: in std_logic_vector(15 downto 0); 
    darkquad29_gbe64_one_gbe_app_tx_afull: in std_logic; 
    darkquad29_gbe64_one_gbe_app_tx_overflow: in std_logic; 
    darkquad29_gbe64_rst_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_gbe64_words_per_frame_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_phase_dmp_ch_we_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_phase_dmp_on_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_phase_port_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_photon_port_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_prog_fir0_load_chan_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_prog_fir0_single_chan_coeffs_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_prog_fir1_load_chan_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_prog_fir1_single_chan_coeffs_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_prog_fir2_load_chan_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_prog_fir2_single_chan_coeffs_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_prog_fir3_load_chan_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_prog_fir3_single_chan_coeffs_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_run_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_sel_ch_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_snp_phs_ss_bram_data_out: in std_logic_vector(63 downto 0); 
    darkquad29_snp_phs_ss_ctrl_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_start_cap_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_timekeeper_base_ts_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_trig_snp_user_data_out: in std_logic_vector(31 downto 0); 
    darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_rx_rst: out std_logic; 
    darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_tx_data: out std_logic_vector(7 downto 0); 
    darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_tx_rst: out std_logic; 
    darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_tx_val: out std_logic; 
    darkquad29_a2g_ctrl_last_tx_data_user_data_in: out std_logic_vector(31 downto 0); 
    darkquad29_a2g_ctrl_lut_dump_dac_lut_buffer_addr: out std_logic_vector(11 downto 0); 
    darkquad29_a2g_ctrl_lut_dump_dac_lut_buffer_data_in: out std_logic_vector(7 downto 0); 
    darkquad29_a2g_ctrl_lut_dump_dac_lut_buffer_we: out std_logic; 
    darkquad29_a2g_ctrl_lut_dump_sending_data_user_data_in: out std_logic_vector(31 downto 0); 
    darkquad29_a2g_ctrl_reg_rx_full_user_data_in: out std_logic_vector(31 downto 0); 
    darkquad29_a2g_ctrl_reg_tx_full_user_data_in: out std_logic_vector(31 downto 0); 
    darkquad29_a2g_ctrl_v7_ready_user_data_in: out std_logic_vector(31 downto 0); 
    darkquad29_acc_iq_avg0_ss_bram_addr: out std_logic_vector(9 downto 0); 
    darkquad29_acc_iq_avg0_ss_bram_data_in: out std_logic_vector(31 downto 0); 
    darkquad29_acc_iq_avg0_ss_bram_we: out std_logic; 
    darkquad29_acc_iq_avg0_ss_status_user_data_in: out std_logic_vector(31 downto 0); 
    darkquad29_acc_iq_avg1_ss_bram_addr: out std_logic_vector(9 downto 0); 
    darkquad29_acc_iq_avg1_ss_bram_data_in: out std_logic_vector(31 downto 0); 
    darkquad29_acc_iq_avg1_ss_bram_we: out std_logic; 
    darkquad29_acc_iq_avg1_ss_status_user_data_in: out std_logic_vector(31 downto 0); 
    darkquad29_acc_iq_avg2_ss_bram_addr: out std_logic_vector(9 downto 0); 
    darkquad29_acc_iq_avg2_ss_bram_data_in: out std_logic_vector(31 downto 0); 
    darkquad29_acc_iq_avg2_ss_bram_we: out std_logic; 
    darkquad29_acc_iq_avg2_ss_status_user_data_in: out std_logic_vector(31 downto 0); 
    darkquad29_acc_iq_avg3_ss_bram_addr: out std_logic_vector(9 downto 0); 
    darkquad29_acc_iq_avg3_ss_bram_data_in: out std_logic_vector(31 downto 0); 
    darkquad29_acc_iq_avg3_ss_bram_we: out std_logic; 
    darkquad29_acc_iq_avg3_ss_status_user_data_in: out std_logic_vector(31 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_dly_val: out std_logic_vector(4 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_inc_mmcm_phs: out std_logic; 
    darkquad29_adc_in_adcdac_2g_user_load_dly0: out std_logic_vector(5 downto 0); 
    darkquad29_adc_in_adcdac_2g_user_pos_mmcm_phs: out std_logic; 
    darkquad29_adc_in_adcdac_2g_user_rdy_i0: out std_logic; 
    darkquad29_adc_in_locked_user_data_in: out std_logic_vector(31 downto 0); 
    darkquad29_adc_in_n_miss_pps_user_data_in: out std_logic_vector(31 downto 0); 
    darkquad29_adc_in_raw_pps_user_data_in: out std_logic_vector(31 downto 0); 
    darkquad29_adc_in_snp_cal0_ss_bram_addr: out std_logic_vector(8 downto 0); 
    darkquad29_adc_in_snp_cal0_ss_bram_data_in: out std_logic_vector(63 downto 0); 
    darkquad29_adc_in_snp_cal0_ss_bram_we: out std_logic; 
    darkquad29_adc_in_snp_cal0_ss_status_user_data_in: out std_logic_vector(31 downto 0); 
    darkquad29_adc_in_snp_cal1_ss_bram_addr: out std_logic_vector(8 downto 0); 
    darkquad29_adc_in_snp_cal1_ss_bram_data_in: out std_logic_vector(63 downto 0); 
    darkquad29_adc_in_snp_cal1_ss_bram_we: out std_logic; 
    darkquad29_adc_in_snp_cal1_ss_status_user_data_in: out std_logic_vector(31 downto 0); 
    darkquad29_adc_in_snp_cal2_ss_bram_addr: out std_logic_vector(8 downto 0); 
    darkquad29_adc_in_snp_cal2_ss_bram_data_in: out std_logic_vector(63 downto 0); 
    darkquad29_adc_in_snp_cal2_ss_bram_we: out std_logic; 
    darkquad29_adc_in_snp_cal2_ss_status_user_data_in: out std_logic_vector(31 downto 0); 
    darkquad29_adc_in_snp_cal3_ss_bram_addr: out std_logic_vector(8 downto 0); 
    darkquad29_adc_in_snp_cal3_ss_bram_data_in: out std_logic_vector(63 downto 0); 
    darkquad29_adc_in_snp_cal3_ss_bram_we: out std_logic; 
    darkquad29_adc_in_snp_cal3_ss_status_user_data_in: out std_logic_vector(31 downto 0); 
    darkquad29_adc_in_ts0_user_data_in: out std_logic_vector(31 downto 0); 
    darkquad29_adc_in_ts1_user_data_in: out std_logic_vector(31 downto 0); 
    darkquad29_adc_in_ts2_user_data_in: out std_logic_vector(31 downto 0); 
    darkquad29_adc_in_ts3_user_data_in: out std_logic_vector(31 downto 0); 
    darkquad29_adc_in_valid_user_data_in: out std_logic_vector(31 downto 0); 
    darkquad29_capture0_pix_addr: out std_logic_vector(9 downto 0); 
    darkquad29_capture0_pix_data_in: out std_logic_vector(31 downto 0); 
    darkquad29_capture0_pix_we: out std_logic; 
    darkquad29_capture1_pix_addr: out std_logic_vector(9 downto 0); 
    darkquad29_capture1_pix_data_in: out std_logic_vector(31 downto 0); 
    darkquad29_capture1_pix_we: out std_logic; 
    darkquad29_capture2_pix_addr: out std_logic_vector(9 downto 0); 
    darkquad29_capture2_pix_data_in: out std_logic_vector(31 downto 0); 
    darkquad29_capture2_pix_we: out std_logic; 
    darkquad29_capture3_pix_addr: out std_logic_vector(9 downto 0); 
    darkquad29_capture3_pix_data_in: out std_logic_vector(31 downto 0); 
    darkquad29_capture3_pix_we: out std_logic; 
    darkquad29_check_lag_data_ch_user_data_in: out std_logic_vector(31 downto 0); 
    darkquad29_check_lag_dds_ch_user_data_in: out std_logic_vector(31 downto 0); 
    darkquad29_dds_lut_qdr0_address: out std_logic_vector(31 downto 0); 
    darkquad29_dds_lut_qdr0_be: out std_logic_vector(7 downto 0); 
    darkquad29_dds_lut_qdr0_data_in: out std_logic_vector(71 downto 0); 
    darkquad29_dds_lut_qdr0_rd_en: out std_logic; 
    darkquad29_dds_lut_qdr0_wr_en: out std_logic; 
    darkquad29_dds_lut_qdr1_address: out std_logic_vector(31 downto 0); 
    darkquad29_dds_lut_qdr1_be: out std_logic_vector(7 downto 0); 
    darkquad29_dds_lut_qdr1_data_in: out std_logic_vector(71 downto 0); 
    darkquad29_dds_lut_qdr1_rd_en: out std_logic; 
    darkquad29_dds_lut_qdr1_wr_en: out std_logic; 
    darkquad29_dds_lut_qdr2_address: out std_logic_vector(31 downto 0); 
    darkquad29_dds_lut_qdr2_be: out std_logic_vector(7 downto 0); 
    darkquad29_dds_lut_qdr2_data_in: out std_logic_vector(71 downto 0); 
    darkquad29_dds_lut_qdr2_rd_en: out std_logic; 
    darkquad29_dds_lut_qdr2_wr_en: out std_logic; 
    darkquad29_dds_lut_qdr3_address: out std_logic_vector(31 downto 0); 
    darkquad29_dds_lut_qdr3_be: out std_logic_vector(7 downto 0); 
    darkquad29_dds_lut_qdr3_data_in: out std_logic_vector(71 downto 0); 
    darkquad29_dds_lut_qdr3_rd_en: out std_logic; 
    darkquad29_dds_lut_qdr3_wr_en: out std_logic; 
    darkquad29_gbe64_one_gbe_app_rx_ack: out std_logic; 
    darkquad29_gbe64_one_gbe_app_rx_rst: out std_logic; 
    darkquad29_gbe64_one_gbe_app_tx_data: out std_logic_vector(7 downto 0); 
    darkquad29_gbe64_one_gbe_app_tx_destip: out std_logic_vector(31 downto 0); 
    darkquad29_gbe64_one_gbe_app_tx_destport: out std_logic_vector(15 downto 0); 
    darkquad29_gbe64_one_gbe_app_tx_dvld: out std_logic; 
    darkquad29_gbe64_one_gbe_app_tx_eof: out std_logic; 
    darkquad29_gbe64_one_gbe_app_tx_rst: out std_logic; 
    darkquad29_gbe64_tx_afull_user_data_in: out std_logic_vector(31 downto 0); 
    darkquad29_gbe64_tx_overrun_user_data_in: out std_logic_vector(31 downto 0); 
    darkquad29_n_eof_sent_user_data_in: out std_logic_vector(31 downto 0); 
    darkquad29_n_photons_user_data_in: out std_logic_vector(31 downto 0); 
    darkquad29_pfb_fft_check_fft_oflow_user_data_in: out std_logic_vector(31 downto 0); 
    darkquad29_prog_fir0_single_chan_coeffs_addr: out std_logic_vector(9 downto 0); 
    darkquad29_prog_fir0_single_chan_coeffs_data_in: out std_logic_vector(31 downto 0); 
    darkquad29_prog_fir0_single_chan_coeffs_we: out std_logic; 
    darkquad29_prog_fir1_single_chan_coeffs_addr: out std_logic_vector(9 downto 0); 
    darkquad29_prog_fir1_single_chan_coeffs_data_in: out std_logic_vector(31 downto 0); 
    darkquad29_prog_fir1_single_chan_coeffs_we: out std_logic; 
    darkquad29_prog_fir2_single_chan_coeffs_addr: out std_logic_vector(9 downto 0); 
    darkquad29_prog_fir2_single_chan_coeffs_data_in: out std_logic_vector(31 downto 0); 
    darkquad29_prog_fir2_single_chan_coeffs_we: out std_logic; 
    darkquad29_prog_fir3_single_chan_coeffs_addr: out std_logic_vector(9 downto 0); 
    darkquad29_prog_fir3_single_chan_coeffs_data_in: out std_logic_vector(31 downto 0); 
    darkquad29_prog_fir3_single_chan_coeffs_we: out std_logic; 
    darkquad29_snp_phs_ss_bram_addr: out std_logic_vector(8 downto 0); 
    darkquad29_snp_phs_ss_bram_data_in: out std_logic_vector(63 downto 0); 
    darkquad29_snp_phs_ss_bram_we: out std_logic; 
    darkquad29_snp_phs_ss_status_user_data_in: out std_logic_vector(31 downto 0); 
    darkquad29_timekeeper_sec_now_user_data_in: out std_logic_vector(31 downto 0)
  );
end darkquad29;

architecture structural of darkquad29 is
  attribute core_generation_info: string;
  attribute core_generation_info of structural : architecture is "darkquad29,sysgen_core,{clock_period=4.00000000,clocking=Clock_Enables,compilation=NGC_Netlist,sample_periods=1.00000000000,testbench=0,total_blocks=13921,xilinx_adder_subtracter_block=452,xilinx_arithmetic_relational_operator_block=289,xilinx_assert_block=53,xilinx_binary_shift_operator_block=9,xilinx_bit_slice_extractor_block=554,xilinx_bitbasher_block=8,xilinx_black_box_block=1,xilinx_bus_concatenator_block=130,xilinx_bus_multiplexer_block=174,xilinx_constant_block_block=1047,xilinx_constant_multiplier_block=1,xilinx_cordic_4_0_block=4,xilinx_counter_block=491,xilinx_delay_block=1202,xilinx_disregard_subsystem_for_generation_block=22,xilinx_dual_port_random_access_memory_block=5,xilinx_fifo_block_block=5,xilinx_gateway_in_block=233,xilinx_gateway_out_block=147,xilinx_inverter_block=105,xilinx_logical_block_block=167,xilinx_multiplier_block=396,xilinx_register_block=678,xilinx_single_port_random_access_memory_block=715,xilinx_system_generator_block=1,xilinx_type_converter_block=266,xilinx_type_reinterpreter_block=707,}";

  signal arctan_phase_out_net_x0: std_logic_vector(11 downto 0);
  signal arctan_phase_out_net_x1: std_logic_vector(11 downto 0);
  signal arctan_phase_out_net_x2: std_logic_vector(11 downto 0);
  signal arctan_phase_out_net_x3: std_logic_vector(11 downto 0);
  signal assert_phase_dout_net_x0: std_logic_vector(63 downto 0);
  signal ce_1_sg_x1054: std_logic;
  signal clk_1_sg_x1054: std_logic;
  signal concat_y_net_x1: std_logic_vector(63 downto 0);
  signal concat_y_net_x2: std_logic_vector(37 downto 0);
  signal concat_y_net_x3: std_logic_vector(37 downto 0);
  signal concat_y_net_x4: std_logic_vector(37 downto 0);
  signal concat_y_net_x5: std_logic_vector(37 downto 0);
  signal concat_y_net_x6: std_logic_vector(75 downto 0);
  signal concat_y_net_x7: std_logic_vector(75 downto 0);
  signal concat_y_net_x8: std_logic_vector(75 downto 0);
  signal concat_y_net_x9: std_logic_vector(75 downto 0);
  signal concatenate_y_net_x1: std_logic_vector(275 downto 0);
  signal concatenate_y_net_x2: std_logic_vector(191 downto 0);
  signal concatenate_y_net_x3: std_logic_vector(575 downto 0);
  signal constant3_op_net: std_logic_vector(7 downto 0);
  signal convert3_dout_net_x3: std_logic_vector(63 downto 0);
  signal convert4_dout_net_x3: std_logic_vector(63 downto 0);
  signal convert6_dout_net_x1: std_logic_vector(63 downto 0);
  signal convert9_dout_net_x1: std_logic_vector(63 downto 0);
  signal convert_dout_net_x0: std_logic_vector(11 downto 0);
  signal convert_dout_net_x1: std_logic_vector(11 downto 0);
  signal convert_dout_net_x2: std_logic_vector(11 downto 0);
  signal convert_dout_net_x3: std_logic_vector(11 downto 0);
  signal convert_dout_net_x4: std_logic_vector(35 downto 0);
  signal darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_rx_data_net: std_logic_vector(7 downto 0);
  signal darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_rx_full_net: std_logic;
  signal darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_rx_rst_net: std_logic;
  signal darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_rx_val_net: std_logic;
  signal darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_tx_data_net: std_logic_vector(7 downto 0);
  signal darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_tx_full_net: std_logic;
  signal darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_tx_rst_net: std_logic;
  signal darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_tx_val_net: std_logic;
  signal darkquad29_a2g_ctrl_en_bram_dump_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_a2g_ctrl_in_val_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_a2g_ctrl_last_tx_data_user_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_a2g_ctrl_lut_dump_buffer_size_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_a2g_ctrl_lut_dump_dac_lut_buffer_addr_net: std_logic_vector(11 downto 0);
  signal darkquad29_a2g_ctrl_lut_dump_dac_lut_buffer_data_in_net: std_logic_vector(7 downto 0);
  signal darkquad29_a2g_ctrl_lut_dump_dac_lut_buffer_data_out_net: std_logic_vector(7 downto 0);
  signal darkquad29_a2g_ctrl_lut_dump_dac_lut_buffer_we_net: std_logic;
  signal darkquad29_a2g_ctrl_lut_dump_data_period_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_a2g_ctrl_lut_dump_sending_data_user_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_a2g_ctrl_reg_rx_full_user_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_a2g_ctrl_reg_tx_full_user_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_a2g_ctrl_rst_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_a2g_ctrl_tx_en_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_a2g_ctrl_v7_ready_user_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_acc_iq_avg0_ss_bram_addr_net: std_logic_vector(9 downto 0);
  signal darkquad29_acc_iq_avg0_ss_bram_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_acc_iq_avg0_ss_bram_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_acc_iq_avg0_ss_bram_we_net: std_logic;
  signal darkquad29_acc_iq_avg0_ss_ctrl_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_acc_iq_avg0_ss_status_user_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_acc_iq_avg1_ss_bram_addr_net: std_logic_vector(9 downto 0);
  signal darkquad29_acc_iq_avg1_ss_bram_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_acc_iq_avg1_ss_bram_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_acc_iq_avg1_ss_bram_we_net: std_logic;
  signal darkquad29_acc_iq_avg1_ss_ctrl_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_acc_iq_avg1_ss_status_user_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_acc_iq_avg2_ss_bram_addr_net: std_logic_vector(9 downto 0);
  signal darkquad29_acc_iq_avg2_ss_bram_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_acc_iq_avg2_ss_bram_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_acc_iq_avg2_ss_bram_we_net: std_logic;
  signal darkquad29_acc_iq_avg2_ss_ctrl_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_acc_iq_avg2_ss_status_user_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_acc_iq_avg3_ss_bram_addr_net: std_logic_vector(9 downto 0);
  signal darkquad29_acc_iq_avg3_ss_bram_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_acc_iq_avg3_ss_bram_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_acc_iq_avg3_ss_bram_we_net: std_logic;
  signal darkquad29_acc_iq_avg3_ss_ctrl_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_acc_iq_avg3_ss_status_user_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_acc_iq_start_acc_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_data_i0_net: std_logic_vector(11 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_data_i1_net: std_logic_vector(11 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_data_i2_net: std_logic_vector(11 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_data_i3_net: std_logic_vector(11 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_data_i4_net: std_logic_vector(11 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_data_i5_net: std_logic_vector(11 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_data_i6_net: std_logic_vector(11 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_data_i7_net: std_logic_vector(11 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_data_q0_net: std_logic_vector(11 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_data_q1_net: std_logic_vector(11 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_data_q2_net: std_logic_vector(11 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_data_q3_net: std_logic_vector(11 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_data_q4_net: std_logic_vector(11 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_data_q5_net: std_logic_vector(11 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_data_q6_net: std_logic_vector(11 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_data_q7_net: std_logic_vector(11 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_dly_val_net: std_logic_vector(4 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_inc_mmcm_phs_net: std_logic;
  signal darkquad29_adc_in_adcdac_2g_user_info_i0_net: std_logic_vector(1 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_info_i1_net: std_logic_vector(1 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_info_i2_net: std_logic_vector(1 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_info_i3_net: std_logic_vector(1 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_info_i4_net: std_logic_vector(1 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_info_i5_net: std_logic_vector(1 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_info_i6_net: std_logic_vector(1 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_info_i7_net: std_logic_vector(1 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_info_q0_net: std_logic_vector(1 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_info_q1_net: std_logic_vector(1 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_info_q2_net: std_logic_vector(1 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_info_q3_net: std_logic_vector(1 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_info_q4_net: std_logic_vector(1 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_info_q5_net: std_logic_vector(1 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_info_q6_net: std_logic_vector(1 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_info_q7_net: std_logic_vector(1 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_load_dly0_net: std_logic_vector(5 downto 0);
  signal darkquad29_adc_in_adcdac_2g_user_mmcm_locked_net: std_logic;
  signal darkquad29_adc_in_adcdac_2g_user_pos_mmcm_phs_net: std_logic;
  signal darkquad29_adc_in_adcdac_2g_user_rdy_i0_net: std_logic;
  signal darkquad29_adc_in_adcdac_2g_user_sync_net: std_logic;
  signal darkquad29_adc_in_adcdac_2g_user_valid_net: std_logic;
  signal darkquad29_adc_in_dly_val_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_adc_in_i_scale_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_adc_in_inc_phs_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_adc_in_load_dly_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_adc_in_locked_user_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_adc_in_n_miss_pps_user_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_adc_in_pos_phs_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_adc_in_raw_pps_user_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_adc_in_snp_cal0_ss_bram_addr_net: std_logic_vector(8 downto 0);
  signal darkquad29_adc_in_snp_cal0_ss_bram_data_in_net: std_logic_vector(63 downto 0);
  signal darkquad29_adc_in_snp_cal0_ss_bram_data_out_net: std_logic_vector(63 downto 0);
  signal darkquad29_adc_in_snp_cal0_ss_bram_we_net: std_logic;
  signal darkquad29_adc_in_snp_cal0_ss_ctrl_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_adc_in_snp_cal0_ss_status_user_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_adc_in_snp_cal1_ss_bram_addr_net: std_logic_vector(8 downto 0);
  signal darkquad29_adc_in_snp_cal1_ss_bram_data_in_net: std_logic_vector(63 downto 0);
  signal darkquad29_adc_in_snp_cal1_ss_bram_data_out_net: std_logic_vector(63 downto 0);
  signal darkquad29_adc_in_snp_cal1_ss_bram_we_net: std_logic;
  signal darkquad29_adc_in_snp_cal1_ss_ctrl_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_adc_in_snp_cal1_ss_status_user_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_adc_in_snp_cal2_ss_bram_addr_net: std_logic_vector(8 downto 0);
  signal darkquad29_adc_in_snp_cal2_ss_bram_data_in_net: std_logic_vector(63 downto 0);
  signal darkquad29_adc_in_snp_cal2_ss_bram_data_out_net: std_logic_vector(63 downto 0);
  signal darkquad29_adc_in_snp_cal2_ss_bram_we_net: std_logic;
  signal darkquad29_adc_in_snp_cal2_ss_ctrl_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_adc_in_snp_cal2_ss_status_user_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_adc_in_snp_cal3_ss_bram_addr_net: std_logic_vector(8 downto 0);
  signal darkquad29_adc_in_snp_cal3_ss_bram_data_in_net: std_logic_vector(63 downto 0);
  signal darkquad29_adc_in_snp_cal3_ss_bram_data_out_net: std_logic_vector(63 downto 0);
  signal darkquad29_adc_in_snp_cal3_ss_bram_we_net: std_logic;
  signal darkquad29_adc_in_snp_cal3_ss_ctrl_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_adc_in_snp_cal3_ss_status_user_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_adc_in_trig_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_adc_in_ts0_user_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_adc_in_ts1_user_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_adc_in_ts2_user_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_adc_in_ts3_user_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_adc_in_valid_user_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_board_num_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_capture0_base_kf_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_capture0_base_kq_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_capture0_cps_lim_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_capture0_load_thresh_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_capture0_pix_addr_net: std_logic_vector(9 downto 0);
  signal darkquad29_capture0_pix_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_capture0_pix_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_capture0_pix_we_net: std_logic;
  signal darkquad29_capture0_threshold_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_capture1_base_kf_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_capture1_base_kq_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_capture1_cps_lim_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_capture1_load_thresh_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_capture1_pix_addr_net: std_logic_vector(9 downto 0);
  signal darkquad29_capture1_pix_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_capture1_pix_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_capture1_pix_we_net: std_logic;
  signal darkquad29_capture1_threshold_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_capture2_base_kf_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_capture2_base_kq_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_capture2_cps_lim_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_capture2_load_thresh_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_capture2_pix_addr_net: std_logic_vector(9 downto 0);
  signal darkquad29_capture2_pix_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_capture2_pix_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_capture2_pix_we_net: std_logic;
  signal darkquad29_capture2_threshold_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_capture3_base_kf_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_capture3_base_kq_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_capture3_cps_lim_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_capture3_load_thresh_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_capture3_pix_addr_net: std_logic_vector(9 downto 0);
  signal darkquad29_capture3_pix_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_capture3_pix_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_capture3_pix_we_net: std_logic;
  signal darkquad29_capture3_threshold_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_chan_sel_ch_bin0_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_chan_sel_ch_bin1_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_chan_sel_ch_bin2_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_chan_sel_ch_bin3_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_chan_sel_load_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_check_lag_data_ch_user_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_check_lag_dds_ch_user_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_check_lag_latch_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_conv_phase0_centers_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_conv_phase0_load_centers_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_conv_phase1_centers_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_conv_phase1_load_centers_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_conv_phase2_centers_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_conv_phase2_load_centers_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_conv_phase3_centers_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_conv_phase3_load_centers_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_dds_lut_qdr0_ack_net: std_logic;
  signal darkquad29_dds_lut_qdr0_address_net: std_logic_vector(31 downto 0);
  signal darkquad29_dds_lut_qdr0_be_net: std_logic_vector(7 downto 0);
  signal darkquad29_dds_lut_qdr0_cal_fail_net: std_logic;
  signal darkquad29_dds_lut_qdr0_data_in_net: std_logic_vector(71 downto 0);
  signal darkquad29_dds_lut_qdr0_data_out_net: std_logic_vector(71 downto 0);
  signal darkquad29_dds_lut_qdr0_data_valid_net: std_logic;
  signal darkquad29_dds_lut_qdr0_phy_ready_net: std_logic;
  signal darkquad29_dds_lut_qdr0_rd_en_net: std_logic;
  signal darkquad29_dds_lut_qdr0_wr_en_net: std_logic;
  signal darkquad29_dds_lut_qdr1_ack_net: std_logic;
  signal darkquad29_dds_lut_qdr1_address_net: std_logic_vector(31 downto 0);
  signal darkquad29_dds_lut_qdr1_be_net: std_logic_vector(7 downto 0);
  signal darkquad29_dds_lut_qdr1_cal_fail_net: std_logic;
  signal darkquad29_dds_lut_qdr1_data_in_net: std_logic_vector(71 downto 0);
  signal darkquad29_dds_lut_qdr1_data_out_net: std_logic_vector(71 downto 0);
  signal darkquad29_dds_lut_qdr1_data_valid_net: std_logic;
  signal darkquad29_dds_lut_qdr1_phy_ready_net: std_logic;
  signal darkquad29_dds_lut_qdr1_rd_en_net: std_logic;
  signal darkquad29_dds_lut_qdr1_wr_en_net: std_logic;
  signal darkquad29_dds_lut_qdr2_ack_net: std_logic;
  signal darkquad29_dds_lut_qdr2_address_net: std_logic_vector(31 downto 0);
  signal darkquad29_dds_lut_qdr2_be_net: std_logic_vector(7 downto 0);
  signal darkquad29_dds_lut_qdr2_cal_fail_net: std_logic;
  signal darkquad29_dds_lut_qdr2_data_in_net: std_logic_vector(71 downto 0);
  signal darkquad29_dds_lut_qdr2_data_out_net: std_logic_vector(71 downto 0);
  signal darkquad29_dds_lut_qdr2_data_valid_net: std_logic;
  signal darkquad29_dds_lut_qdr2_phy_ready_net: std_logic;
  signal darkquad29_dds_lut_qdr2_rd_en_net: std_logic;
  signal darkquad29_dds_lut_qdr2_wr_en_net: std_logic;
  signal darkquad29_dds_lut_qdr3_ack_net: std_logic;
  signal darkquad29_dds_lut_qdr3_address_net: std_logic_vector(31 downto 0);
  signal darkquad29_dds_lut_qdr3_be_net: std_logic_vector(7 downto 0);
  signal darkquad29_dds_lut_qdr3_cal_fail_net: std_logic;
  signal darkquad29_dds_lut_qdr3_data_in_net: std_logic_vector(71 downto 0);
  signal darkquad29_dds_lut_qdr3_data_out_net: std_logic_vector(71 downto 0);
  signal darkquad29_dds_lut_qdr3_data_valid_net: std_logic;
  signal darkquad29_dds_lut_qdr3_phy_ready_net: std_logic;
  signal darkquad29_dds_lut_qdr3_rd_en_net: std_logic;
  signal darkquad29_dds_lut_qdr3_wr_en_net: std_logic;
  signal darkquad29_dds_lut_run_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_dds_shift_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_gbe64_dest_ip_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_gbe64_one_gbe_app_dbg_data_net: std_logic_vector(31 downto 0);
  signal darkquad29_gbe64_one_gbe_app_dbg_dvld_net: std_logic;
  signal darkquad29_gbe64_one_gbe_app_rx_ack_net: std_logic;
  signal darkquad29_gbe64_one_gbe_app_rx_badframe_net: std_logic;
  signal darkquad29_gbe64_one_gbe_app_rx_data_net: std_logic_vector(7 downto 0);
  signal darkquad29_gbe64_one_gbe_app_rx_dvld_net: std_logic;
  signal darkquad29_gbe64_one_gbe_app_rx_eof_net: std_logic;
  signal darkquad29_gbe64_one_gbe_app_rx_overrun_net: std_logic;
  signal darkquad29_gbe64_one_gbe_app_rx_rst_net: std_logic;
  signal darkquad29_gbe64_one_gbe_app_rx_srcip_net: std_logic_vector(31 downto 0);
  signal darkquad29_gbe64_one_gbe_app_rx_srcport_net: std_logic_vector(15 downto 0);
  signal darkquad29_gbe64_one_gbe_app_tx_afull_net: std_logic;
  signal darkquad29_gbe64_one_gbe_app_tx_data_net: std_logic_vector(7 downto 0);
  signal darkquad29_gbe64_one_gbe_app_tx_destip_net: std_logic_vector(31 downto 0);
  signal darkquad29_gbe64_one_gbe_app_tx_destport_net: std_logic_vector(15 downto 0);
  signal darkquad29_gbe64_one_gbe_app_tx_dvld_net: std_logic;
  signal darkquad29_gbe64_one_gbe_app_tx_eof_net: std_logic;
  signal darkquad29_gbe64_one_gbe_app_tx_overflow_net: std_logic;
  signal darkquad29_gbe64_one_gbe_app_tx_rst_net: std_logic;
  signal darkquad29_gbe64_rst_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_gbe64_tx_afull_user_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_gbe64_tx_overrun_user_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_gbe64_words_per_frame_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_n_eof_sent_user_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_n_photons_user_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_pfb_fft_check_fft_oflow_user_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_phase_dmp_ch_we_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_phase_dmp_on_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_phase_port_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_photon_port_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_prog_fir0_load_chan_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_prog_fir0_single_chan_coeffs_addr_net: std_logic_vector(9 downto 0);
  signal darkquad29_prog_fir0_single_chan_coeffs_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_prog_fir0_single_chan_coeffs_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_prog_fir0_single_chan_coeffs_we_net: std_logic;
  signal darkquad29_prog_fir1_load_chan_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_prog_fir1_single_chan_coeffs_addr_net: std_logic_vector(9 downto 0);
  signal darkquad29_prog_fir1_single_chan_coeffs_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_prog_fir1_single_chan_coeffs_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_prog_fir1_single_chan_coeffs_we_net: std_logic;
  signal darkquad29_prog_fir2_load_chan_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_prog_fir2_single_chan_coeffs_addr_net: std_logic_vector(9 downto 0);
  signal darkquad29_prog_fir2_single_chan_coeffs_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_prog_fir2_single_chan_coeffs_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_prog_fir2_single_chan_coeffs_we_net: std_logic;
  signal darkquad29_prog_fir3_load_chan_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_prog_fir3_single_chan_coeffs_addr_net: std_logic_vector(9 downto 0);
  signal darkquad29_prog_fir3_single_chan_coeffs_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_prog_fir3_single_chan_coeffs_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_prog_fir3_single_chan_coeffs_we_net: std_logic;
  signal darkquad29_run_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_sel_ch_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_snp_phs_ss_bram_addr_net: std_logic_vector(8 downto 0);
  signal darkquad29_snp_phs_ss_bram_data_in_net: std_logic_vector(63 downto 0);
  signal darkquad29_snp_phs_ss_bram_data_out_net: std_logic_vector(63 downto 0);
  signal darkquad29_snp_phs_ss_bram_we_net: std_logic;
  signal darkquad29_snp_phs_ss_ctrl_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_snp_phs_ss_status_user_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_start_cap_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_timekeeper_base_ts_user_data_out_net: std_logic_vector(31 downto 0);
  signal darkquad29_timekeeper_sec_now_user_data_in_net: std_logic_vector(31 downto 0);
  signal darkquad29_trig_snp_user_data_out_net: std_logic_vector(31 downto 0);
  signal delay10_q_net_x2: std_logic_vector(11 downto 0);
  signal delay11_q_net_x0: std_logic_vector(11 downto 0);
  signal delay12_q_net_x1: std_logic;
  signal delay13_q_net_x3: std_logic_vector(7 downto 0);
  signal delay14_q_net_x0: std_logic_vector(7 downto 0);
  signal delay14_q_net_x1: std_logic_vector(7 downto 0);
  signal delay14_q_net_x2: std_logic_vector(7 downto 0);
  signal delay14_q_net_x3: std_logic_vector(7 downto 0);
  signal delay14_q_net_x4: std_logic_vector(7 downto 0);
  signal delay14_q_net_x5: std_logic;
  signal delay15_q_net_x0: std_logic_vector(7 downto 0);
  signal delay16_q_net: std_logic;
  signal delay17_q_net_x0: std_logic_vector(37 downto 0);
  signal delay18_q_net_x0: std_logic_vector(7 downto 0);
  signal delay19_q_net_x1: std_logic_vector(75 downto 0);
  signal delay1_q_net_x0: std_logic_vector(7 downto 0);
  signal delay1_q_net_x1: std_logic;
  signal delay1_q_net_x2: std_logic_vector(7 downto 0);
  signal delay1_q_net_x3: std_logic_vector(7 downto 0);
  signal delay1_q_net_x4: std_logic_vector(7 downto 0);
  signal delay20_q_net_x1: std_logic_vector(7 downto 0);
  signal delay21_q_net_x1: std_logic_vector(63 downto 0);
  signal delay22_q_net_x1: std_logic_vector(71 downto 0);
  signal delay23_q_net_x0: std_logic_vector(11 downto 0);
  signal delay24_q_net_x0: std_logic_vector(7 downto 0);
  signal delay25_q_net_x0: std_logic_vector(11 downto 0);
  signal delay26_q_net_x0: std_logic_vector(37 downto 0);
  signal delay27_q_net_x0: std_logic_vector(7 downto 0);
  signal delay28_q_net_x0: std_logic_vector(7 downto 0);
  signal delay29_q_net_x1: std_logic_vector(75 downto 0);
  signal delay2_q_net_x0: std_logic_vector(35 downto 0);
  signal delay30_q_net_x1: std_logic_vector(7 downto 0);
  signal delay31_q_net_x1: std_logic_vector(63 downto 0);
  signal delay32_q_net_x1: std_logic_vector(71 downto 0);
  signal delay33_q_net_x2: std_logic_vector(11 downto 0);
  signal delay34_q_net_x1: std_logic_vector(7 downto 0);
  signal delay35_q_net_x0: std_logic_vector(37 downto 0);
  signal delay36_q_net_x0: std_logic_vector(7 downto 0);
  signal delay37_q_net_x0: std_logic_vector(11 downto 0);
  signal delay38_q_net_x0: std_logic_vector(7 downto 0);
  signal delay39_q_net_x0: std_logic_vector(37 downto 0);
  signal delay3_q_net: std_logic_vector(35 downto 0);
  signal delay40_q_net_x0: std_logic_vector(7 downto 0);
  signal delay41_q_net_x1: std_logic_vector(75 downto 0);
  signal delay42_q_net_x1: std_logic_vector(7 downto 0);
  signal delay43_q_net_x1: std_logic_vector(63 downto 0);
  signal delay44_q_net_x1: std_logic_vector(71 downto 0);
  signal delay45_q_net_x2: std_logic_vector(11 downto 0);
  signal delay46_q_net_x0: std_logic_vector(7 downto 0);
  signal delay49_q_net_x0: std_logic_vector(7 downto 0);
  signal delay4_q_net_x1: std_logic;
  signal delay50_q_net_x1: std_logic_vector(75 downto 0);
  signal delay52_q_net_x1: std_logic_vector(7 downto 0);
  signal delay58_q_net_x1: std_logic_vector(15 downto 0);
  signal delay58_q_net_x2: std_logic_vector(15 downto 0);
  signal delay58_q_net_x3: std_logic_vector(15 downto 0);
  signal delay58_q_net_x4: std_logic_vector(15 downto 0);
  signal delay5_q_net_x1: std_logic_vector(35 downto 0);
  signal delay6_q_net_x2: std_logic_vector(7 downto 0);
  signal delay6_q_net_x3: std_logic;
  signal delay73_q_net_x1: std_logic_vector(63 downto 0);
  signal delay74_q_net_x1: std_logic_vector(71 downto 0);
  signal delay75_q_net: std_logic_vector(7 downto 0);
  signal delay76_q_net_x1: std_logic_vector(19 downto 0);
  signal delay7_q_net: std_logic_vector(35 downto 0);
  signal delay7_q_net_x0: std_logic;
  signal delay7_q_net_x1: std_logic_vector(63 downto 0);
  signal delay87_q_net_x1: std_logic_vector(63 downto 0);
  signal delay87_q_net_x2: std_logic_vector(63 downto 0);
  signal delay87_q_net_x3: std_logic_vector(63 downto 0);
  signal delay87_q_net_x4: std_logic_vector(63 downto 0);
  signal delay8_q_net_x2: std_logic_vector(11 downto 0);
  signal delay95_q_net_x0: std_logic_vector(7 downto 0);
  signal delay9_q_net_x1: std_logic_vector(7 downto 0);
  signal delay9_q_net_x2: std_logic_vector(7 downto 0);
  signal delay9_q_net_x3: std_logic_vector(7 downto 0);
  signal delay9_q_net_x4: std_logic_vector(7 downto 0);
  signal delay9_q_net_x5: std_logic_vector(7 downto 0);
  signal delay9_q_net_x6: std_logic_vector(8 downto 0);
  signal dual_port_ram_doutb_net_x1: std_logic_vector(275 downto 0);
  signal edge_op_y_net_x0: std_logic;
  signal edge_op_y_net_x2: std_logic;
  signal edge_op_y_net_x4: std_logic;
  signal en6_y_net_x0: std_logic;
  signal eof_ctr_op_net_x0: std_logic_vector(31 downto 0);
  signal logical1_y_net_x1: std_logic;
  signal logical1_y_net_x2: std_logic;
  signal logical2_y_net_x1: std_logic;
  signal logical2_y_net_x2: std_logic;
  signal logical2_y_net_x3: std_logic;
  signal logical2_y_net_x4: std_logic;
  signal mux1_y_net_x1: std_logic_vector(15 downto 0);
  signal mux1_y_net_x2: std_logic;
  signal mux2_y_net_x0: std_logic_vector(15 downto 0);
  signal mux4_y_net: std_logic_vector(63 downto 0);
  signal mux5_y_net_x0: std_logic;
  signal mux_y_net_x1: std_logic_vector(63 downto 0);
  signal pfb_fft_bin_ctr_net_x0: std_logic_vector(7 downto 0);
  signal ph_ctr_op_net_x0: std_logic_vector(31 downto 0);
  signal register0_q_net_x0: std_logic_vector(15 downto 0);
  signal register0_q_net_x1: std_logic_vector(15 downto 0);
  signal register0_q_net_x2: std_logic_vector(15 downto 0);
  signal register0_q_net_x3: std_logic_vector(15 downto 0);
  signal register1_q_net_x0: std_logic_vector(63 downto 0);
  signal register1_q_net_x1: std_logic_vector(575 downto 0);
  signal register1_q_net_x10: std_logic_vector(31 downto 0);
  signal register1_q_net_x11: std_logic_vector(7 downto 0);
  signal register1_q_net_x12: std_logic_vector(191 downto 0);
  signal register1_q_net_x13: std_logic_vector(63 downto 0);
  signal register1_q_net_x14: std_logic;
  signal register1_q_net_x15: std_logic;
  signal register1_q_net_x16: std_logic_vector(275 downto 0);
  signal register1_q_net_x17: std_logic_vector(63 downto 0);
  signal register1_q_net_x18: std_logic;
  signal register1_q_net_x19: std_logic_vector(63 downto 0);
  signal register1_q_net_x2: std_logic;
  signal register1_q_net_x20: std_logic;
  signal register1_q_net_x21: std_logic;
  signal register1_q_net_x22: std_logic_vector(75 downto 0);
  signal register1_q_net_x23: std_logic_vector(31 downto 0);
  signal register1_q_net_x24: std_logic_vector(63 downto 0);
  signal register1_q_net_x25: std_logic;
  signal register1_q_net_x26: std_logic_vector(8 downto 0);
  signal register1_q_net_x27: std_logic_vector(275 downto 0);
  signal register1_q_net_x28: std_logic_vector(35 downto 0);
  signal register1_q_net_x29: std_logic;
  signal register1_q_net_x3: std_logic_vector(7 downto 0);
  signal register1_q_net_x30: std_logic_vector(7 downto 0);
  signal register1_q_net_x4: std_logic;
  signal register1_q_net_x40: std_logic;
  signal register1_q_net_x5: std_logic_vector(75 downto 0);
  signal register1_q_net_x6: std_logic_vector(75 downto 0);
  signal register1_q_net_x7: std_logic_vector(75 downto 0);
  signal register1_q_net_x8: std_logic_vector(63 downto 0);
  signal register1_q_net_x9: std_logic;
  signal reint1_output_port_net_x0: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x1: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x2: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x3: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x4: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x5: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x6: std_logic_vector(31 downto 0);
  signal reint1_output_port_net_x7: std_logic_vector(31 downto 0);
  signal reinterpret1_output_port_net_x1: std_logic_vector(19 downto 0);
  signal reinterpret1_output_port_net_x2: std_logic_vector(71 downto 0);
  signal reinterpret2_output_port_net_x0: std_logic_vector(63 downto 0);
  signal reinterpret2_output_port_net_x1: std_logic_vector(71 downto 0);
  signal reinterpret3_output_port_net_x0: std_logic_vector(63 downto 0);
  signal reinterpret3_output_port_net_x1: std_logic_vector(71 downto 0);
  signal reinterpret4_output_port_net_x0: std_logic_vector(63 downto 0);
  signal reinterpret4_output_port_net_x1: std_logic_vector(71 downto 0);
  signal reinterpret5_output_port_net_x0: std_logic_vector(63 downto 0);
  signal reinterpret_output_port_net: std_logic_vector(35 downto 0);
  signal relational5_op_net: std_logic;
  signal slice10_y_net: std_logic_vector(15 downto 0);
  signal slice1_y_net: std_logic_vector(11 downto 0);
  signal slice1_y_net_x0: std_logic;
  signal slice2_y_net_x0: std_logic;
  signal slice3_y_net_x0: std_logic;
  signal slice4_y_net: std_logic_vector(1 downto 0);
  signal slice5_y_net_x0: std_logic_vector(7 downto 0);
  signal slice6_y_net_x0: std_logic_vector(8 downto 0);
  signal slice7_y_net_x0: std_logic_vector(7 downto 0);
  signal slice_y_net: std_logic_vector(15 downto 0);

begin
  ce_1_sg_x1054 <= ce_1;
  clk_1_sg_x1054 <= clk_1;
  darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_rx_data_net <= darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_rx_data;
  darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_rx_full_net <= darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_rx_full;
  darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_rx_val_net <= darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_rx_val;
  darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_tx_full_net <= darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_tx_full;
  darkquad29_a2g_ctrl_en_bram_dump_user_data_out_net <= darkquad29_a2g_ctrl_en_bram_dump_user_data_out;
  darkquad29_a2g_ctrl_in_val_user_data_out_net <= darkquad29_a2g_ctrl_in_val_user_data_out;
  darkquad29_a2g_ctrl_lut_dump_buffer_size_user_data_out_net <= darkquad29_a2g_ctrl_lut_dump_buffer_size_user_data_out;
  darkquad29_a2g_ctrl_lut_dump_dac_lut_buffer_data_out_net <= darkquad29_a2g_ctrl_lut_dump_dac_lut_buffer_data_out;
  darkquad29_a2g_ctrl_lut_dump_data_period_user_data_out_net <= darkquad29_a2g_ctrl_lut_dump_data_period_user_data_out;
  darkquad29_a2g_ctrl_rst_user_data_out_net <= darkquad29_a2g_ctrl_rst_user_data_out;
  darkquad29_a2g_ctrl_tx_en_user_data_out_net <= darkquad29_a2g_ctrl_tx_en_user_data_out;
  darkquad29_acc_iq_avg0_ss_bram_data_out_net <= darkquad29_acc_iq_avg0_ss_bram_data_out;
  darkquad29_acc_iq_avg0_ss_ctrl_user_data_out_net <= darkquad29_acc_iq_avg0_ss_ctrl_user_data_out;
  darkquad29_acc_iq_avg1_ss_bram_data_out_net <= darkquad29_acc_iq_avg1_ss_bram_data_out;
  darkquad29_acc_iq_avg1_ss_ctrl_user_data_out_net <= darkquad29_acc_iq_avg1_ss_ctrl_user_data_out;
  darkquad29_acc_iq_avg2_ss_bram_data_out_net <= darkquad29_acc_iq_avg2_ss_bram_data_out;
  darkquad29_acc_iq_avg2_ss_ctrl_user_data_out_net <= darkquad29_acc_iq_avg2_ss_ctrl_user_data_out;
  darkquad29_acc_iq_avg3_ss_bram_data_out_net <= darkquad29_acc_iq_avg3_ss_bram_data_out;
  darkquad29_acc_iq_avg3_ss_ctrl_user_data_out_net <= darkquad29_acc_iq_avg3_ss_ctrl_user_data_out;
  darkquad29_acc_iq_start_acc_user_data_out_net <= darkquad29_acc_iq_start_acc_user_data_out;
  darkquad29_adc_in_adcdac_2g_user_data_i0_net <= darkquad29_adc_in_adcdac_2g_user_data_i0;
  darkquad29_adc_in_adcdac_2g_user_data_i1_net <= darkquad29_adc_in_adcdac_2g_user_data_i1;
  darkquad29_adc_in_adcdac_2g_user_data_i2_net <= darkquad29_adc_in_adcdac_2g_user_data_i2;
  darkquad29_adc_in_adcdac_2g_user_data_i3_net <= darkquad29_adc_in_adcdac_2g_user_data_i3;
  darkquad29_adc_in_adcdac_2g_user_data_i4_net <= darkquad29_adc_in_adcdac_2g_user_data_i4;
  darkquad29_adc_in_adcdac_2g_user_data_i5_net <= darkquad29_adc_in_adcdac_2g_user_data_i5;
  darkquad29_adc_in_adcdac_2g_user_data_i6_net <= darkquad29_adc_in_adcdac_2g_user_data_i6;
  darkquad29_adc_in_adcdac_2g_user_data_i7_net <= darkquad29_adc_in_adcdac_2g_user_data_i7;
  darkquad29_adc_in_adcdac_2g_user_data_q0_net <= darkquad29_adc_in_adcdac_2g_user_data_q0;
  darkquad29_adc_in_adcdac_2g_user_data_q1_net <= darkquad29_adc_in_adcdac_2g_user_data_q1;
  darkquad29_adc_in_adcdac_2g_user_data_q2_net <= darkquad29_adc_in_adcdac_2g_user_data_q2;
  darkquad29_adc_in_adcdac_2g_user_data_q3_net <= darkquad29_adc_in_adcdac_2g_user_data_q3;
  darkquad29_adc_in_adcdac_2g_user_data_q4_net <= darkquad29_adc_in_adcdac_2g_user_data_q4;
  darkquad29_adc_in_adcdac_2g_user_data_q5_net <= darkquad29_adc_in_adcdac_2g_user_data_q5;
  darkquad29_adc_in_adcdac_2g_user_data_q6_net <= darkquad29_adc_in_adcdac_2g_user_data_q6;
  darkquad29_adc_in_adcdac_2g_user_data_q7_net <= darkquad29_adc_in_adcdac_2g_user_data_q7;
  darkquad29_adc_in_adcdac_2g_user_info_i0_net <= darkquad29_adc_in_adcdac_2g_user_info_i0;
  darkquad29_adc_in_adcdac_2g_user_info_i1_net <= darkquad29_adc_in_adcdac_2g_user_info_i1;
  darkquad29_adc_in_adcdac_2g_user_info_i2_net <= darkquad29_adc_in_adcdac_2g_user_info_i2;
  darkquad29_adc_in_adcdac_2g_user_info_i3_net <= darkquad29_adc_in_adcdac_2g_user_info_i3;
  darkquad29_adc_in_adcdac_2g_user_info_i4_net <= darkquad29_adc_in_adcdac_2g_user_info_i4;
  darkquad29_adc_in_adcdac_2g_user_info_i5_net <= darkquad29_adc_in_adcdac_2g_user_info_i5;
  darkquad29_adc_in_adcdac_2g_user_info_i6_net <= darkquad29_adc_in_adcdac_2g_user_info_i6;
  darkquad29_adc_in_adcdac_2g_user_info_i7_net <= darkquad29_adc_in_adcdac_2g_user_info_i7;
  darkquad29_adc_in_adcdac_2g_user_info_q0_net <= darkquad29_adc_in_adcdac_2g_user_info_q0;
  darkquad29_adc_in_adcdac_2g_user_info_q1_net <= darkquad29_adc_in_adcdac_2g_user_info_q1;
  darkquad29_adc_in_adcdac_2g_user_info_q2_net <= darkquad29_adc_in_adcdac_2g_user_info_q2;
  darkquad29_adc_in_adcdac_2g_user_info_q3_net <= darkquad29_adc_in_adcdac_2g_user_info_q3;
  darkquad29_adc_in_adcdac_2g_user_info_q4_net <= darkquad29_adc_in_adcdac_2g_user_info_q4;
  darkquad29_adc_in_adcdac_2g_user_info_q5_net <= darkquad29_adc_in_adcdac_2g_user_info_q5;
  darkquad29_adc_in_adcdac_2g_user_info_q6_net <= darkquad29_adc_in_adcdac_2g_user_info_q6;
  darkquad29_adc_in_adcdac_2g_user_info_q7_net <= darkquad29_adc_in_adcdac_2g_user_info_q7;
  darkquad29_adc_in_adcdac_2g_user_mmcm_locked_net <= darkquad29_adc_in_adcdac_2g_user_mmcm_locked;
  darkquad29_adc_in_adcdac_2g_user_sync_net <= darkquad29_adc_in_adcdac_2g_user_sync;
  darkquad29_adc_in_adcdac_2g_user_valid_net <= darkquad29_adc_in_adcdac_2g_user_valid;
  darkquad29_adc_in_dly_val_user_data_out_net <= darkquad29_adc_in_dly_val_user_data_out;
  darkquad29_adc_in_i_scale_user_data_out_net <= darkquad29_adc_in_i_scale_user_data_out;
  darkquad29_adc_in_inc_phs_user_data_out_net <= darkquad29_adc_in_inc_phs_user_data_out;
  darkquad29_adc_in_load_dly_user_data_out_net <= darkquad29_adc_in_load_dly_user_data_out;
  darkquad29_adc_in_pos_phs_user_data_out_net <= darkquad29_adc_in_pos_phs_user_data_out;
  darkquad29_adc_in_snp_cal0_ss_bram_data_out_net <= darkquad29_adc_in_snp_cal0_ss_bram_data_out;
  darkquad29_adc_in_snp_cal0_ss_ctrl_user_data_out_net <= darkquad29_adc_in_snp_cal0_ss_ctrl_user_data_out;
  darkquad29_adc_in_snp_cal1_ss_bram_data_out_net <= darkquad29_adc_in_snp_cal1_ss_bram_data_out;
  darkquad29_adc_in_snp_cal1_ss_ctrl_user_data_out_net <= darkquad29_adc_in_snp_cal1_ss_ctrl_user_data_out;
  darkquad29_adc_in_snp_cal2_ss_bram_data_out_net <= darkquad29_adc_in_snp_cal2_ss_bram_data_out;
  darkquad29_adc_in_snp_cal2_ss_ctrl_user_data_out_net <= darkquad29_adc_in_snp_cal2_ss_ctrl_user_data_out;
  darkquad29_adc_in_snp_cal3_ss_bram_data_out_net <= darkquad29_adc_in_snp_cal3_ss_bram_data_out;
  darkquad29_adc_in_snp_cal3_ss_ctrl_user_data_out_net <= darkquad29_adc_in_snp_cal3_ss_ctrl_user_data_out;
  darkquad29_adc_in_trig_user_data_out_net <= darkquad29_adc_in_trig_user_data_out;
  darkquad29_board_num_user_data_out_net <= darkquad29_board_num_user_data_out;
  darkquad29_capture0_base_kf_user_data_out_net <= darkquad29_capture0_base_kf_user_data_out;
  darkquad29_capture0_base_kq_user_data_out_net <= darkquad29_capture0_base_kq_user_data_out;
  darkquad29_capture0_cps_lim_user_data_out_net <= darkquad29_capture0_cps_lim_user_data_out;
  darkquad29_capture0_load_thresh_user_data_out_net <= darkquad29_capture0_load_thresh_user_data_out;
  darkquad29_capture0_pix_data_out_net <= darkquad29_capture0_pix_data_out;
  darkquad29_capture0_threshold_user_data_out_net <= darkquad29_capture0_threshold_user_data_out;
  darkquad29_capture1_base_kf_user_data_out_net <= darkquad29_capture1_base_kf_user_data_out;
  darkquad29_capture1_base_kq_user_data_out_net <= darkquad29_capture1_base_kq_user_data_out;
  darkquad29_capture1_cps_lim_user_data_out_net <= darkquad29_capture1_cps_lim_user_data_out;
  darkquad29_capture1_load_thresh_user_data_out_net <= darkquad29_capture1_load_thresh_user_data_out;
  darkquad29_capture1_pix_data_out_net <= darkquad29_capture1_pix_data_out;
  darkquad29_capture1_threshold_user_data_out_net <= darkquad29_capture1_threshold_user_data_out;
  darkquad29_capture2_base_kf_user_data_out_net <= darkquad29_capture2_base_kf_user_data_out;
  darkquad29_capture2_base_kq_user_data_out_net <= darkquad29_capture2_base_kq_user_data_out;
  darkquad29_capture2_cps_lim_user_data_out_net <= darkquad29_capture2_cps_lim_user_data_out;
  darkquad29_capture2_load_thresh_user_data_out_net <= darkquad29_capture2_load_thresh_user_data_out;
  darkquad29_capture2_pix_data_out_net <= darkquad29_capture2_pix_data_out;
  darkquad29_capture2_threshold_user_data_out_net <= darkquad29_capture2_threshold_user_data_out;
  darkquad29_capture3_base_kf_user_data_out_net <= darkquad29_capture3_base_kf_user_data_out;
  darkquad29_capture3_base_kq_user_data_out_net <= darkquad29_capture3_base_kq_user_data_out;
  darkquad29_capture3_cps_lim_user_data_out_net <= darkquad29_capture3_cps_lim_user_data_out;
  darkquad29_capture3_load_thresh_user_data_out_net <= darkquad29_capture3_load_thresh_user_data_out;
  darkquad29_capture3_pix_data_out_net <= darkquad29_capture3_pix_data_out;
  darkquad29_capture3_threshold_user_data_out_net <= darkquad29_capture3_threshold_user_data_out;
  darkquad29_chan_sel_ch_bin0_user_data_out_net <= darkquad29_chan_sel_ch_bin0_user_data_out;
  darkquad29_chan_sel_ch_bin1_user_data_out_net <= darkquad29_chan_sel_ch_bin1_user_data_out;
  darkquad29_chan_sel_ch_bin2_user_data_out_net <= darkquad29_chan_sel_ch_bin2_user_data_out;
  darkquad29_chan_sel_ch_bin3_user_data_out_net <= darkquad29_chan_sel_ch_bin3_user_data_out;
  darkquad29_chan_sel_load_user_data_out_net <= darkquad29_chan_sel_load_user_data_out;
  darkquad29_check_lag_latch_user_data_out_net <= darkquad29_check_lag_latch_user_data_out;
  darkquad29_conv_phase0_centers_user_data_out_net <= darkquad29_conv_phase0_centers_user_data_out;
  darkquad29_conv_phase0_load_centers_user_data_out_net <= darkquad29_conv_phase0_load_centers_user_data_out;
  darkquad29_conv_phase1_centers_user_data_out_net <= darkquad29_conv_phase1_centers_user_data_out;
  darkquad29_conv_phase1_load_centers_user_data_out_net <= darkquad29_conv_phase1_load_centers_user_data_out;
  darkquad29_conv_phase2_centers_user_data_out_net <= darkquad29_conv_phase2_centers_user_data_out;
  darkquad29_conv_phase2_load_centers_user_data_out_net <= darkquad29_conv_phase2_load_centers_user_data_out;
  darkquad29_conv_phase3_centers_user_data_out_net <= darkquad29_conv_phase3_centers_user_data_out;
  darkquad29_conv_phase3_load_centers_user_data_out_net <= darkquad29_conv_phase3_load_centers_user_data_out;
  darkquad29_dds_lut_qdr0_ack_net <= darkquad29_dds_lut_qdr0_ack;
  darkquad29_dds_lut_qdr0_cal_fail_net <= darkquad29_dds_lut_qdr0_cal_fail;
  darkquad29_dds_lut_qdr0_data_out_net <= darkquad29_dds_lut_qdr0_data_out;
  darkquad29_dds_lut_qdr0_data_valid_net <= darkquad29_dds_lut_qdr0_data_valid;
  darkquad29_dds_lut_qdr0_phy_ready_net <= darkquad29_dds_lut_qdr0_phy_ready;
  darkquad29_dds_lut_qdr1_ack_net <= darkquad29_dds_lut_qdr1_ack;
  darkquad29_dds_lut_qdr1_cal_fail_net <= darkquad29_dds_lut_qdr1_cal_fail;
  darkquad29_dds_lut_qdr1_data_out_net <= darkquad29_dds_lut_qdr1_data_out;
  darkquad29_dds_lut_qdr1_data_valid_net <= darkquad29_dds_lut_qdr1_data_valid;
  darkquad29_dds_lut_qdr1_phy_ready_net <= darkquad29_dds_lut_qdr1_phy_ready;
  darkquad29_dds_lut_qdr2_ack_net <= darkquad29_dds_lut_qdr2_ack;
  darkquad29_dds_lut_qdr2_cal_fail_net <= darkquad29_dds_lut_qdr2_cal_fail;
  darkquad29_dds_lut_qdr2_data_out_net <= darkquad29_dds_lut_qdr2_data_out;
  darkquad29_dds_lut_qdr2_data_valid_net <= darkquad29_dds_lut_qdr2_data_valid;
  darkquad29_dds_lut_qdr2_phy_ready_net <= darkquad29_dds_lut_qdr2_phy_ready;
  darkquad29_dds_lut_qdr3_ack_net <= darkquad29_dds_lut_qdr3_ack;
  darkquad29_dds_lut_qdr3_cal_fail_net <= darkquad29_dds_lut_qdr3_cal_fail;
  darkquad29_dds_lut_qdr3_data_out_net <= darkquad29_dds_lut_qdr3_data_out;
  darkquad29_dds_lut_qdr3_data_valid_net <= darkquad29_dds_lut_qdr3_data_valid;
  darkquad29_dds_lut_qdr3_phy_ready_net <= darkquad29_dds_lut_qdr3_phy_ready;
  darkquad29_dds_lut_run_user_data_out_net <= darkquad29_dds_lut_run_user_data_out;
  darkquad29_dds_shift_user_data_out_net <= darkquad29_dds_shift_user_data_out;
  darkquad29_gbe64_dest_ip_user_data_out_net <= darkquad29_gbe64_dest_ip_user_data_out;
  darkquad29_gbe64_one_gbe_app_dbg_data_net <= darkquad29_gbe64_one_gbe_app_dbg_data;
  darkquad29_gbe64_one_gbe_app_dbg_dvld_net <= darkquad29_gbe64_one_gbe_app_dbg_dvld;
  darkquad29_gbe64_one_gbe_app_rx_badframe_net <= darkquad29_gbe64_one_gbe_app_rx_badframe;
  darkquad29_gbe64_one_gbe_app_rx_data_net <= darkquad29_gbe64_one_gbe_app_rx_data;
  darkquad29_gbe64_one_gbe_app_rx_dvld_net <= darkquad29_gbe64_one_gbe_app_rx_dvld;
  darkquad29_gbe64_one_gbe_app_rx_eof_net <= darkquad29_gbe64_one_gbe_app_rx_eof;
  darkquad29_gbe64_one_gbe_app_rx_overrun_net <= darkquad29_gbe64_one_gbe_app_rx_overrun;
  darkquad29_gbe64_one_gbe_app_rx_srcip_net <= darkquad29_gbe64_one_gbe_app_rx_srcip;
  darkquad29_gbe64_one_gbe_app_rx_srcport_net <= darkquad29_gbe64_one_gbe_app_rx_srcport;
  darkquad29_gbe64_one_gbe_app_tx_afull_net <= darkquad29_gbe64_one_gbe_app_tx_afull;
  darkquad29_gbe64_one_gbe_app_tx_overflow_net <= darkquad29_gbe64_one_gbe_app_tx_overflow;
  darkquad29_gbe64_rst_user_data_out_net <= darkquad29_gbe64_rst_user_data_out;
  darkquad29_gbe64_words_per_frame_user_data_out_net <= darkquad29_gbe64_words_per_frame_user_data_out;
  darkquad29_phase_dmp_ch_we_user_data_out_net <= darkquad29_phase_dmp_ch_we_user_data_out;
  darkquad29_phase_dmp_on_user_data_out_net <= darkquad29_phase_dmp_on_user_data_out;
  darkquad29_phase_port_user_data_out_net <= darkquad29_phase_port_user_data_out;
  darkquad29_photon_port_user_data_out_net <= darkquad29_photon_port_user_data_out;
  darkquad29_prog_fir0_load_chan_user_data_out_net <= darkquad29_prog_fir0_load_chan_user_data_out;
  darkquad29_prog_fir0_single_chan_coeffs_data_out_net <= darkquad29_prog_fir0_single_chan_coeffs_data_out;
  darkquad29_prog_fir1_load_chan_user_data_out_net <= darkquad29_prog_fir1_load_chan_user_data_out;
  darkquad29_prog_fir1_single_chan_coeffs_data_out_net <= darkquad29_prog_fir1_single_chan_coeffs_data_out;
  darkquad29_prog_fir2_load_chan_user_data_out_net <= darkquad29_prog_fir2_load_chan_user_data_out;
  darkquad29_prog_fir2_single_chan_coeffs_data_out_net <= darkquad29_prog_fir2_single_chan_coeffs_data_out;
  darkquad29_prog_fir3_load_chan_user_data_out_net <= darkquad29_prog_fir3_load_chan_user_data_out;
  darkquad29_prog_fir3_single_chan_coeffs_data_out_net <= darkquad29_prog_fir3_single_chan_coeffs_data_out;
  darkquad29_run_user_data_out_net <= darkquad29_run_user_data_out;
  darkquad29_sel_ch_user_data_out_net <= darkquad29_sel_ch_user_data_out;
  darkquad29_snp_phs_ss_bram_data_out_net <= darkquad29_snp_phs_ss_bram_data_out;
  darkquad29_snp_phs_ss_ctrl_user_data_out_net <= darkquad29_snp_phs_ss_ctrl_user_data_out;
  darkquad29_start_cap_user_data_out_net <= darkquad29_start_cap_user_data_out;
  darkquad29_timekeeper_base_ts_user_data_out_net <= darkquad29_timekeeper_base_ts_user_data_out;
  darkquad29_trig_snp_user_data_out_net <= darkquad29_trig_snp_user_data_out;
  darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_rx_rst <= darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_rx_rst_net;
  darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_tx_data <= darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_tx_data_net;
  darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_tx_rst <= darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_tx_rst_net;
  darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_tx_val <= darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_tx_val_net;
  darkquad29_a2g_ctrl_last_tx_data_user_data_in <= darkquad29_a2g_ctrl_last_tx_data_user_data_in_net;
  darkquad29_a2g_ctrl_lut_dump_dac_lut_buffer_addr <= darkquad29_a2g_ctrl_lut_dump_dac_lut_buffer_addr_net;
  darkquad29_a2g_ctrl_lut_dump_dac_lut_buffer_data_in <= darkquad29_a2g_ctrl_lut_dump_dac_lut_buffer_data_in_net;
  darkquad29_a2g_ctrl_lut_dump_dac_lut_buffer_we <= darkquad29_a2g_ctrl_lut_dump_dac_lut_buffer_we_net;
  darkquad29_a2g_ctrl_lut_dump_sending_data_user_data_in <= darkquad29_a2g_ctrl_lut_dump_sending_data_user_data_in_net;
  darkquad29_a2g_ctrl_reg_rx_full_user_data_in <= darkquad29_a2g_ctrl_reg_rx_full_user_data_in_net;
  darkquad29_a2g_ctrl_reg_tx_full_user_data_in <= darkquad29_a2g_ctrl_reg_tx_full_user_data_in_net;
  darkquad29_a2g_ctrl_v7_ready_user_data_in <= darkquad29_a2g_ctrl_v7_ready_user_data_in_net;
  darkquad29_acc_iq_avg0_ss_bram_addr <= darkquad29_acc_iq_avg0_ss_bram_addr_net;
  darkquad29_acc_iq_avg0_ss_bram_data_in <= darkquad29_acc_iq_avg0_ss_bram_data_in_net;
  darkquad29_acc_iq_avg0_ss_bram_we <= darkquad29_acc_iq_avg0_ss_bram_we_net;
  darkquad29_acc_iq_avg0_ss_status_user_data_in <= darkquad29_acc_iq_avg0_ss_status_user_data_in_net;
  darkquad29_acc_iq_avg1_ss_bram_addr <= darkquad29_acc_iq_avg1_ss_bram_addr_net;
  darkquad29_acc_iq_avg1_ss_bram_data_in <= darkquad29_acc_iq_avg1_ss_bram_data_in_net;
  darkquad29_acc_iq_avg1_ss_bram_we <= darkquad29_acc_iq_avg1_ss_bram_we_net;
  darkquad29_acc_iq_avg1_ss_status_user_data_in <= darkquad29_acc_iq_avg1_ss_status_user_data_in_net;
  darkquad29_acc_iq_avg2_ss_bram_addr <= darkquad29_acc_iq_avg2_ss_bram_addr_net;
  darkquad29_acc_iq_avg2_ss_bram_data_in <= darkquad29_acc_iq_avg2_ss_bram_data_in_net;
  darkquad29_acc_iq_avg2_ss_bram_we <= darkquad29_acc_iq_avg2_ss_bram_we_net;
  darkquad29_acc_iq_avg2_ss_status_user_data_in <= darkquad29_acc_iq_avg2_ss_status_user_data_in_net;
  darkquad29_acc_iq_avg3_ss_bram_addr <= darkquad29_acc_iq_avg3_ss_bram_addr_net;
  darkquad29_acc_iq_avg3_ss_bram_data_in <= darkquad29_acc_iq_avg3_ss_bram_data_in_net;
  darkquad29_acc_iq_avg3_ss_bram_we <= darkquad29_acc_iq_avg3_ss_bram_we_net;
  darkquad29_acc_iq_avg3_ss_status_user_data_in <= darkquad29_acc_iq_avg3_ss_status_user_data_in_net;
  darkquad29_adc_in_adcdac_2g_user_dly_val <= darkquad29_adc_in_adcdac_2g_user_dly_val_net;
  darkquad29_adc_in_adcdac_2g_user_inc_mmcm_phs <= darkquad29_adc_in_adcdac_2g_user_inc_mmcm_phs_net;
  darkquad29_adc_in_adcdac_2g_user_load_dly0 <= darkquad29_adc_in_adcdac_2g_user_load_dly0_net;
  darkquad29_adc_in_adcdac_2g_user_pos_mmcm_phs <= darkquad29_adc_in_adcdac_2g_user_pos_mmcm_phs_net;
  darkquad29_adc_in_adcdac_2g_user_rdy_i0 <= darkquad29_adc_in_adcdac_2g_user_rdy_i0_net;
  darkquad29_adc_in_locked_user_data_in <= darkquad29_adc_in_locked_user_data_in_net;
  darkquad29_adc_in_n_miss_pps_user_data_in <= darkquad29_adc_in_n_miss_pps_user_data_in_net;
  darkquad29_adc_in_raw_pps_user_data_in <= darkquad29_adc_in_raw_pps_user_data_in_net;
  darkquad29_adc_in_snp_cal0_ss_bram_addr <= darkquad29_adc_in_snp_cal0_ss_bram_addr_net;
  darkquad29_adc_in_snp_cal0_ss_bram_data_in <= darkquad29_adc_in_snp_cal0_ss_bram_data_in_net;
  darkquad29_adc_in_snp_cal0_ss_bram_we <= darkquad29_adc_in_snp_cal0_ss_bram_we_net;
  darkquad29_adc_in_snp_cal0_ss_status_user_data_in <= darkquad29_adc_in_snp_cal0_ss_status_user_data_in_net;
  darkquad29_adc_in_snp_cal1_ss_bram_addr <= darkquad29_adc_in_snp_cal1_ss_bram_addr_net;
  darkquad29_adc_in_snp_cal1_ss_bram_data_in <= darkquad29_adc_in_snp_cal1_ss_bram_data_in_net;
  darkquad29_adc_in_snp_cal1_ss_bram_we <= darkquad29_adc_in_snp_cal1_ss_bram_we_net;
  darkquad29_adc_in_snp_cal1_ss_status_user_data_in <= darkquad29_adc_in_snp_cal1_ss_status_user_data_in_net;
  darkquad29_adc_in_snp_cal2_ss_bram_addr <= darkquad29_adc_in_snp_cal2_ss_bram_addr_net;
  darkquad29_adc_in_snp_cal2_ss_bram_data_in <= darkquad29_adc_in_snp_cal2_ss_bram_data_in_net;
  darkquad29_adc_in_snp_cal2_ss_bram_we <= darkquad29_adc_in_snp_cal2_ss_bram_we_net;
  darkquad29_adc_in_snp_cal2_ss_status_user_data_in <= darkquad29_adc_in_snp_cal2_ss_status_user_data_in_net;
  darkquad29_adc_in_snp_cal3_ss_bram_addr <= darkquad29_adc_in_snp_cal3_ss_bram_addr_net;
  darkquad29_adc_in_snp_cal3_ss_bram_data_in <= darkquad29_adc_in_snp_cal3_ss_bram_data_in_net;
  darkquad29_adc_in_snp_cal3_ss_bram_we <= darkquad29_adc_in_snp_cal3_ss_bram_we_net;
  darkquad29_adc_in_snp_cal3_ss_status_user_data_in <= darkquad29_adc_in_snp_cal3_ss_status_user_data_in_net;
  darkquad29_adc_in_ts0_user_data_in <= darkquad29_adc_in_ts0_user_data_in_net;
  darkquad29_adc_in_ts1_user_data_in <= darkquad29_adc_in_ts1_user_data_in_net;
  darkquad29_adc_in_ts2_user_data_in <= darkquad29_adc_in_ts2_user_data_in_net;
  darkquad29_adc_in_ts3_user_data_in <= darkquad29_adc_in_ts3_user_data_in_net;
  darkquad29_adc_in_valid_user_data_in <= darkquad29_adc_in_valid_user_data_in_net;
  darkquad29_capture0_pix_addr <= darkquad29_capture0_pix_addr_net;
  darkquad29_capture0_pix_data_in <= darkquad29_capture0_pix_data_in_net;
  darkquad29_capture0_pix_we <= darkquad29_capture0_pix_we_net;
  darkquad29_capture1_pix_addr <= darkquad29_capture1_pix_addr_net;
  darkquad29_capture1_pix_data_in <= darkquad29_capture1_pix_data_in_net;
  darkquad29_capture1_pix_we <= darkquad29_capture1_pix_we_net;
  darkquad29_capture2_pix_addr <= darkquad29_capture2_pix_addr_net;
  darkquad29_capture2_pix_data_in <= darkquad29_capture2_pix_data_in_net;
  darkquad29_capture2_pix_we <= darkquad29_capture2_pix_we_net;
  darkquad29_capture3_pix_addr <= darkquad29_capture3_pix_addr_net;
  darkquad29_capture3_pix_data_in <= darkquad29_capture3_pix_data_in_net;
  darkquad29_capture3_pix_we <= darkquad29_capture3_pix_we_net;
  darkquad29_check_lag_data_ch_user_data_in <= darkquad29_check_lag_data_ch_user_data_in_net;
  darkquad29_check_lag_dds_ch_user_data_in <= darkquad29_check_lag_dds_ch_user_data_in_net;
  darkquad29_dds_lut_qdr0_address <= darkquad29_dds_lut_qdr0_address_net;
  darkquad29_dds_lut_qdr0_be <= darkquad29_dds_lut_qdr0_be_net;
  darkquad29_dds_lut_qdr0_data_in <= darkquad29_dds_lut_qdr0_data_in_net;
  darkquad29_dds_lut_qdr0_rd_en <= darkquad29_dds_lut_qdr0_rd_en_net;
  darkquad29_dds_lut_qdr0_wr_en <= darkquad29_dds_lut_qdr0_wr_en_net;
  darkquad29_dds_lut_qdr1_address <= darkquad29_dds_lut_qdr1_address_net;
  darkquad29_dds_lut_qdr1_be <= darkquad29_dds_lut_qdr1_be_net;
  darkquad29_dds_lut_qdr1_data_in <= darkquad29_dds_lut_qdr1_data_in_net;
  darkquad29_dds_lut_qdr1_rd_en <= darkquad29_dds_lut_qdr1_rd_en_net;
  darkquad29_dds_lut_qdr1_wr_en <= darkquad29_dds_lut_qdr1_wr_en_net;
  darkquad29_dds_lut_qdr2_address <= darkquad29_dds_lut_qdr2_address_net;
  darkquad29_dds_lut_qdr2_be <= darkquad29_dds_lut_qdr2_be_net;
  darkquad29_dds_lut_qdr2_data_in <= darkquad29_dds_lut_qdr2_data_in_net;
  darkquad29_dds_lut_qdr2_rd_en <= darkquad29_dds_lut_qdr2_rd_en_net;
  darkquad29_dds_lut_qdr2_wr_en <= darkquad29_dds_lut_qdr2_wr_en_net;
  darkquad29_dds_lut_qdr3_address <= darkquad29_dds_lut_qdr3_address_net;
  darkquad29_dds_lut_qdr3_be <= darkquad29_dds_lut_qdr3_be_net;
  darkquad29_dds_lut_qdr3_data_in <= darkquad29_dds_lut_qdr3_data_in_net;
  darkquad29_dds_lut_qdr3_rd_en <= darkquad29_dds_lut_qdr3_rd_en_net;
  darkquad29_dds_lut_qdr3_wr_en <= darkquad29_dds_lut_qdr3_wr_en_net;
  darkquad29_gbe64_one_gbe_app_rx_ack <= darkquad29_gbe64_one_gbe_app_rx_ack_net;
  darkquad29_gbe64_one_gbe_app_rx_rst <= darkquad29_gbe64_one_gbe_app_rx_rst_net;
  darkquad29_gbe64_one_gbe_app_tx_data <= darkquad29_gbe64_one_gbe_app_tx_data_net;
  darkquad29_gbe64_one_gbe_app_tx_destip <= darkquad29_gbe64_one_gbe_app_tx_destip_net;
  darkquad29_gbe64_one_gbe_app_tx_destport <= darkquad29_gbe64_one_gbe_app_tx_destport_net;
  darkquad29_gbe64_one_gbe_app_tx_dvld <= darkquad29_gbe64_one_gbe_app_tx_dvld_net;
  darkquad29_gbe64_one_gbe_app_tx_eof <= darkquad29_gbe64_one_gbe_app_tx_eof_net;
  darkquad29_gbe64_one_gbe_app_tx_rst <= darkquad29_gbe64_one_gbe_app_tx_rst_net;
  darkquad29_gbe64_tx_afull_user_data_in <= darkquad29_gbe64_tx_afull_user_data_in_net;
  darkquad29_gbe64_tx_overrun_user_data_in <= darkquad29_gbe64_tx_overrun_user_data_in_net;
  darkquad29_n_eof_sent_user_data_in <= darkquad29_n_eof_sent_user_data_in_net;
  darkquad29_n_photons_user_data_in <= darkquad29_n_photons_user_data_in_net;
  darkquad29_pfb_fft_check_fft_oflow_user_data_in <= darkquad29_pfb_fft_check_fft_oflow_user_data_in_net;
  darkquad29_prog_fir0_single_chan_coeffs_addr <= darkquad29_prog_fir0_single_chan_coeffs_addr_net;
  darkquad29_prog_fir0_single_chan_coeffs_data_in <= darkquad29_prog_fir0_single_chan_coeffs_data_in_net;
  darkquad29_prog_fir0_single_chan_coeffs_we <= darkquad29_prog_fir0_single_chan_coeffs_we_net;
  darkquad29_prog_fir1_single_chan_coeffs_addr <= darkquad29_prog_fir1_single_chan_coeffs_addr_net;
  darkquad29_prog_fir1_single_chan_coeffs_data_in <= darkquad29_prog_fir1_single_chan_coeffs_data_in_net;
  darkquad29_prog_fir1_single_chan_coeffs_we <= darkquad29_prog_fir1_single_chan_coeffs_we_net;
  darkquad29_prog_fir2_single_chan_coeffs_addr <= darkquad29_prog_fir2_single_chan_coeffs_addr_net;
  darkquad29_prog_fir2_single_chan_coeffs_data_in <= darkquad29_prog_fir2_single_chan_coeffs_data_in_net;
  darkquad29_prog_fir2_single_chan_coeffs_we <= darkquad29_prog_fir2_single_chan_coeffs_we_net;
  darkquad29_prog_fir3_single_chan_coeffs_addr <= darkquad29_prog_fir3_single_chan_coeffs_addr_net;
  darkquad29_prog_fir3_single_chan_coeffs_data_in <= darkquad29_prog_fir3_single_chan_coeffs_data_in_net;
  darkquad29_prog_fir3_single_chan_coeffs_we <= darkquad29_prog_fir3_single_chan_coeffs_we_net;
  darkquad29_snp_phs_ss_bram_addr <= darkquad29_snp_phs_ss_bram_addr_net;
  darkquad29_snp_phs_ss_bram_data_in <= darkquad29_snp_phs_ss_bram_data_in_net;
  darkquad29_snp_phs_ss_bram_we <= darkquad29_snp_phs_ss_bram_we_net;
  darkquad29_snp_phs_ss_status_user_data_in <= darkquad29_snp_phs_ss_status_user_data_in_net;
  darkquad29_timekeeper_sec_now_user_data_in <= darkquad29_timekeeper_sec_now_user_data_in_net;

  a2g_ctrl_bf2306676d: entity work.a2g_ctrl_entity_bf2306676d
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_rx_data => darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_rx_data_net,
      darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_rx_full => darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_rx_full_net,
      darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_rx_val => darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_rx_val_net,
      darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_tx_full => darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_tx_full_net,
      darkquad29_a2g_ctrl_en_bram_dump_user_data_out => darkquad29_a2g_ctrl_en_bram_dump_user_data_out_net,
      darkquad29_a2g_ctrl_in_val_user_data_out => darkquad29_a2g_ctrl_in_val_user_data_out_net,
      darkquad29_a2g_ctrl_lut_dump_buffer_size_user_data_out => darkquad29_a2g_ctrl_lut_dump_buffer_size_user_data_out_net,
      darkquad29_a2g_ctrl_lut_dump_dac_lut_buffer_data_out => darkquad29_a2g_ctrl_lut_dump_dac_lut_buffer_data_out_net,
      darkquad29_a2g_ctrl_lut_dump_data_period_user_data_out => darkquad29_a2g_ctrl_lut_dump_data_period_user_data_out_net,
      darkquad29_a2g_ctrl_rst_user_data_out => darkquad29_a2g_ctrl_rst_user_data_out_net,
      darkquad29_a2g_ctrl_tx_en_user_data_out => darkquad29_a2g_ctrl_tx_en_user_data_out_net,
      adcdac_2g_ctrl => darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_tx_rst_net,
      adcdac_2g_ctrl_x0 => darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_tx_data_net,
      adcdac_2g_ctrl_x1 => darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_rx_rst_net,
      adcdac_2g_ctrl_x2 => darkquad29_a2g_ctrl_adcdac_2g_ctrl_user_tx_val_net,
      last_tx_data => darkquad29_a2g_ctrl_last_tx_data_user_data_in_net,
      lut_dump => darkquad29_a2g_ctrl_lut_dump_dac_lut_buffer_addr_net,
      lut_dump_x0 => darkquad29_a2g_ctrl_lut_dump_dac_lut_buffer_data_in_net,
      lut_dump_x1 => darkquad29_a2g_ctrl_lut_dump_dac_lut_buffer_we_net,
      lut_dump_x2 => darkquad29_a2g_ctrl_lut_dump_sending_data_user_data_in_net,
      reg_rx_full => darkquad29_a2g_ctrl_reg_rx_full_user_data_in_net,
      reg_tx_full => darkquad29_a2g_ctrl_reg_tx_full_user_data_in_net,
      v7_ready => darkquad29_a2g_ctrl_v7_ready_user_data_in_net
    );

  acc_iq_643c27e9df: entity work.acc_iq_entity_643c27e9df
    port map (
      ce_1 => ce_1_sg_x1054,
      ch_in => register1_q_net_x11,
      clk_1 => clk_1_sg_x1054,
      darkquad29_acc_iq_avg0_ss_ctrl_user_data_out => darkquad29_acc_iq_avg0_ss_ctrl_user_data_out_net,
      darkquad29_acc_iq_avg1_ss_ctrl_user_data_out => darkquad29_acc_iq_avg1_ss_ctrl_user_data_out_net,
      darkquad29_acc_iq_avg2_ss_ctrl_user_data_out => darkquad29_acc_iq_avg2_ss_ctrl_user_data_out_net,
      darkquad29_acc_iq_avg3_ss_ctrl_user_data_out => darkquad29_acc_iq_avg3_ss_ctrl_user_data_out_net,
      darkquad29_acc_iq_start_acc_user_data_out => darkquad29_acc_iq_start_acc_user_data_out_net,
      din0 => register1_q_net_x22,
      din1 => register1_q_net_x5,
      din2 => register1_q_net_x6,
      din3 => register1_q_net_x7,
      avg0 => darkquad29_acc_iq_avg0_ss_bram_addr_net,
      avg0_x0 => darkquad29_acc_iq_avg0_ss_bram_data_in_net,
      avg0_x1 => darkquad29_acc_iq_avg0_ss_bram_we_net,
      avg0_x2 => darkquad29_acc_iq_avg0_ss_status_user_data_in_net,
      avg1 => darkquad29_acc_iq_avg1_ss_bram_addr_net,
      avg1_x0 => darkquad29_acc_iq_avg1_ss_bram_data_in_net,
      avg1_x1 => darkquad29_acc_iq_avg1_ss_bram_we_net,
      avg1_x2 => darkquad29_acc_iq_avg1_ss_status_user_data_in_net,
      avg2 => darkquad29_acc_iq_avg2_ss_bram_addr_net,
      avg2_x0 => darkquad29_acc_iq_avg2_ss_bram_data_in_net,
      avg2_x1 => darkquad29_acc_iq_avg2_ss_bram_we_net,
      avg2_x2 => darkquad29_acc_iq_avg2_ss_status_user_data_in_net,
      avg3 => darkquad29_acc_iq_avg3_ss_bram_addr_net,
      avg3_x0 => darkquad29_acc_iq_avg3_ss_bram_data_in_net,
      avg3_x1 => darkquad29_acc_iq_avg3_ss_bram_we_net,
      avg3_x2 => darkquad29_acc_iq_avg3_ss_status_user_data_in_net
    );

  adc_in_b5ae14177c: entity work.adc_in_entity_b5ae14177c
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      darkquad29_adc_in_adcdac_2g_user_data_i0 => darkquad29_adc_in_adcdac_2g_user_data_i0_net,
      darkquad29_adc_in_adcdac_2g_user_data_i1 => darkquad29_adc_in_adcdac_2g_user_data_i1_net,
      darkquad29_adc_in_adcdac_2g_user_data_i2 => darkquad29_adc_in_adcdac_2g_user_data_i2_net,
      darkquad29_adc_in_adcdac_2g_user_data_i3 => darkquad29_adc_in_adcdac_2g_user_data_i3_net,
      darkquad29_adc_in_adcdac_2g_user_data_i4 => darkquad29_adc_in_adcdac_2g_user_data_i4_net,
      darkquad29_adc_in_adcdac_2g_user_data_i5 => darkquad29_adc_in_adcdac_2g_user_data_i5_net,
      darkquad29_adc_in_adcdac_2g_user_data_i6 => darkquad29_adc_in_adcdac_2g_user_data_i6_net,
      darkquad29_adc_in_adcdac_2g_user_data_i7 => darkquad29_adc_in_adcdac_2g_user_data_i7_net,
      darkquad29_adc_in_adcdac_2g_user_data_q0 => darkquad29_adc_in_adcdac_2g_user_data_q0_net,
      darkquad29_adc_in_adcdac_2g_user_data_q1 => darkquad29_adc_in_adcdac_2g_user_data_q1_net,
      darkquad29_adc_in_adcdac_2g_user_data_q2 => darkquad29_adc_in_adcdac_2g_user_data_q2_net,
      darkquad29_adc_in_adcdac_2g_user_data_q3 => darkquad29_adc_in_adcdac_2g_user_data_q3_net,
      darkquad29_adc_in_adcdac_2g_user_data_q4 => darkquad29_adc_in_adcdac_2g_user_data_q4_net,
      darkquad29_adc_in_adcdac_2g_user_data_q5 => darkquad29_adc_in_adcdac_2g_user_data_q5_net,
      darkquad29_adc_in_adcdac_2g_user_data_q6 => darkquad29_adc_in_adcdac_2g_user_data_q6_net,
      darkquad29_adc_in_adcdac_2g_user_data_q7 => darkquad29_adc_in_adcdac_2g_user_data_q7_net,
      darkquad29_adc_in_adcdac_2g_user_mmcm_locked => darkquad29_adc_in_adcdac_2g_user_mmcm_locked_net,
      darkquad29_adc_in_adcdac_2g_user_sync => darkquad29_adc_in_adcdac_2g_user_sync_net,
      darkquad29_adc_in_adcdac_2g_user_valid => darkquad29_adc_in_adcdac_2g_user_valid_net,
      darkquad29_adc_in_dly_val_user_data_out => darkquad29_adc_in_dly_val_user_data_out_net,
      darkquad29_adc_in_i_scale_user_data_out => darkquad29_adc_in_i_scale_user_data_out_net,
      darkquad29_adc_in_inc_phs_user_data_out => darkquad29_adc_in_inc_phs_user_data_out_net,
      darkquad29_adc_in_load_dly_user_data_out => darkquad29_adc_in_load_dly_user_data_out_net,
      darkquad29_adc_in_pos_phs_user_data_out => darkquad29_adc_in_pos_phs_user_data_out_net,
      darkquad29_adc_in_snp_cal0_ss_ctrl_user_data_out => darkquad29_adc_in_snp_cal0_ss_ctrl_user_data_out_net,
      darkquad29_adc_in_snp_cal1_ss_ctrl_user_data_out => darkquad29_adc_in_snp_cal1_ss_ctrl_user_data_out_net,
      darkquad29_adc_in_snp_cal2_ss_ctrl_user_data_out => darkquad29_adc_in_snp_cal2_ss_ctrl_user_data_out_net,
      darkquad29_adc_in_snp_cal3_ss_ctrl_user_data_out => darkquad29_adc_in_snp_cal3_ss_ctrl_user_data_out_net,
      darkquad29_adc_in_trig_user_data_out => darkquad29_adc_in_trig_user_data_out_net,
      run => register1_q_net_x40,
      sync_in => edge_op_y_net_x4,
      adcdac_2g => darkquad29_adc_in_adcdac_2g_user_rdy_i0_net,
      adcdac_2g_x0 => darkquad29_adc_in_adcdac_2g_user_dly_val_net,
      adcdac_2g_x1 => darkquad29_adc_in_adcdac_2g_user_load_dly0_net,
      adcdac_2g_x2 => darkquad29_adc_in_adcdac_2g_user_pos_mmcm_phs_net,
      adcdac_2g_x3 => darkquad29_adc_in_adcdac_2g_user_inc_mmcm_phs_net,
      dout => concatenate_y_net_x2,
      locked => darkquad29_adc_in_locked_user_data_in_net,
      n_miss_pps => darkquad29_adc_in_n_miss_pps_user_data_in_net,
      pps_out => logical1_y_net_x1,
      raw_pps => darkquad29_adc_in_raw_pps_user_data_in_net,
      snp_cal0 => darkquad29_adc_in_snp_cal0_ss_bram_addr_net,
      snp_cal0_x0 => darkquad29_adc_in_snp_cal0_ss_bram_data_in_net,
      snp_cal0_x1 => darkquad29_adc_in_snp_cal0_ss_bram_we_net,
      snp_cal0_x2 => darkquad29_adc_in_snp_cal0_ss_status_user_data_in_net,
      snp_cal1 => darkquad29_adc_in_snp_cal1_ss_bram_addr_net,
      snp_cal1_x0 => darkquad29_adc_in_snp_cal1_ss_bram_data_in_net,
      snp_cal1_x1 => darkquad29_adc_in_snp_cal1_ss_bram_we_net,
      snp_cal1_x2 => darkquad29_adc_in_snp_cal1_ss_status_user_data_in_net,
      snp_cal2 => darkquad29_adc_in_snp_cal2_ss_bram_addr_net,
      snp_cal2_x0 => darkquad29_adc_in_snp_cal2_ss_bram_data_in_net,
      snp_cal2_x1 => darkquad29_adc_in_snp_cal2_ss_bram_we_net,
      snp_cal2_x2 => darkquad29_adc_in_snp_cal2_ss_status_user_data_in_net,
      snp_cal3 => darkquad29_adc_in_snp_cal3_ss_bram_addr_net,
      snp_cal3_x0 => darkquad29_adc_in_snp_cal3_ss_bram_data_in_net,
      snp_cal3_x1 => darkquad29_adc_in_snp_cal3_ss_bram_we_net,
      snp_cal3_x2 => darkquad29_adc_in_snp_cal3_ss_status_user_data_in_net,
      ts0 => darkquad29_adc_in_ts0_user_data_in_net,
      ts1 => darkquad29_adc_in_ts1_user_data_in_net,
      ts2 => darkquad29_adc_in_ts2_user_data_in_net,
      ts3 => darkquad29_adc_in_ts3_user_data_in_net,
      valid => darkquad29_adc_in_valid_user_data_in_net
    );

  assert_phase: entity work.xlpassthrough
    generic map (
      din_width => 64,
      dout_width => 64
    )
    port map (
      din => mux4_y_net,
      dout => assert_phase_dout_net_x0
    );

  board_num_00082f664f: entity work.board_num_entity_00082f664f
    port map (
      darkquad29_board_num_user_data_out => darkquad29_board_num_user_data_out_net,
      in_reg => reint1_output_port_net_x0
    );

  bus_create_1645e0fabf: entity work.bus_create_entity_1645e0fabf
    port map (
      in1 => convert9_dout_net_x1,
      in2 => convert3_dout_net_x3,
      in3 => convert4_dout_net_x3,
      in4 => convert6_dout_net_x1,
      in5 => delay76_q_net_x1,
      bus_out => concatenate_y_net_x1
    );

  bus_expand1_44b59daeff: entity work.bus_expand1_entity_44b59daeff
    port map (
      bus_in => register1_q_net_x16,
      lsb_out1 => reinterpret1_output_port_net_x1,
      msb_out5 => reinterpret5_output_port_net_x0,
      out2 => reinterpret2_output_port_net_x0,
      out3 => reinterpret3_output_port_net_x0,
      out4 => reinterpret4_output_port_net_x0
    );

  capture0_6e7ee31b1e: entity work.capture0_entity_6e7ee31b1e
    port map (
      ce_1 => ce_1_sg_x1054,
      ch_in => delay13_q_net_x3,
      clk_1 => clk_1_sg_x1054,
      darkquad29_capture0_base_kf_user_data_out => darkquad29_capture0_base_kf_user_data_out_net,
      darkquad29_capture0_base_kq_user_data_out => darkquad29_capture0_base_kq_user_data_out_net,
      darkquad29_capture0_cps_lim_user_data_out => darkquad29_capture0_cps_lim_user_data_out_net,
      darkquad29_capture0_load_thresh_user_data_out => darkquad29_capture0_load_thresh_user_data_out_net,
      darkquad29_capture0_pix_data_out => darkquad29_capture0_pix_data_out_net,
      darkquad29_capture0_threshold_user_data_out => darkquad29_capture0_threshold_user_data_out_net,
      data_in => delay10_q_net_x2,
      pps => delay14_q_net_x5,
      ts_in => delay9_q_net_x6,
      ch_out => delay95_q_net_x0,
      phase_out => delay58_q_net_x1,
      photon_out => delay87_q_net_x1,
      pix => darkquad29_capture0_pix_addr_net,
      pix_x0 => darkquad29_capture0_pix_data_in_net,
      pix_x1 => darkquad29_capture0_pix_we_net,
      we_out => logical2_y_net_x2
    );

  capture1_3d7d95492d: entity work.capture1_entity_3d7d95492d
    port map (
      ce_1 => ce_1_sg_x1054,
      ch_in => delay9_q_net_x2,
      clk_1 => clk_1_sg_x1054,
      darkquad29_capture1_base_kf_user_data_out => darkquad29_capture1_base_kf_user_data_out_net,
      darkquad29_capture1_base_kq_user_data_out => darkquad29_capture1_base_kq_user_data_out_net,
      darkquad29_capture1_cps_lim_user_data_out => darkquad29_capture1_cps_lim_user_data_out_net,
      darkquad29_capture1_load_thresh_user_data_out => darkquad29_capture1_load_thresh_user_data_out_net,
      darkquad29_capture1_pix_data_out => darkquad29_capture1_pix_data_out_net,
      darkquad29_capture1_threshold_user_data_out => darkquad29_capture1_threshold_user_data_out_net,
      data_in => delay8_q_net_x2,
      pps => delay14_q_net_x5,
      ts_in => delay9_q_net_x6,
      phase_out => delay58_q_net_x2,
      photon_out => delay87_q_net_x2,
      pix => darkquad29_capture1_pix_addr_net,
      pix_x0 => darkquad29_capture1_pix_data_in_net,
      pix_x1 => darkquad29_capture1_pix_we_net,
      we_out => logical2_y_net_x1
    );

  capture2_a102a35138: entity work.capture2_entity_a102a35138
    port map (
      ce_1 => ce_1_sg_x1054,
      ch_in => delay34_q_net_x1,
      clk_1 => clk_1_sg_x1054,
      darkquad29_capture2_base_kf_user_data_out => darkquad29_capture2_base_kf_user_data_out_net,
      darkquad29_capture2_base_kq_user_data_out => darkquad29_capture2_base_kq_user_data_out_net,
      darkquad29_capture2_cps_lim_user_data_out => darkquad29_capture2_cps_lim_user_data_out_net,
      darkquad29_capture2_load_thresh_user_data_out => darkquad29_capture2_load_thresh_user_data_out_net,
      darkquad29_capture2_pix_data_out => darkquad29_capture2_pix_data_out_net,
      darkquad29_capture2_threshold_user_data_out => darkquad29_capture2_threshold_user_data_out_net,
      data_in => delay33_q_net_x2,
      pps => delay14_q_net_x5,
      ts_in => delay9_q_net_x6,
      phase_out => delay58_q_net_x3,
      photon_out => delay87_q_net_x3,
      pix => darkquad29_capture2_pix_addr_net,
      pix_x0 => darkquad29_capture2_pix_data_in_net,
      pix_x1 => darkquad29_capture2_pix_we_net,
      we_out => logical2_y_net_x3
    );

  capture3_cfd3dd3fa9: entity work.capture3_entity_cfd3dd3fa9
    port map (
      ce_1 => ce_1_sg_x1054,
      ch_in => delay46_q_net_x0,
      clk_1 => clk_1_sg_x1054,
      darkquad29_capture3_base_kf_user_data_out => darkquad29_capture3_base_kf_user_data_out_net,
      darkquad29_capture3_base_kq_user_data_out => darkquad29_capture3_base_kq_user_data_out_net,
      darkquad29_capture3_cps_lim_user_data_out => darkquad29_capture3_cps_lim_user_data_out_net,
      darkquad29_capture3_load_thresh_user_data_out => darkquad29_capture3_load_thresh_user_data_out_net,
      darkquad29_capture3_pix_data_out => darkquad29_capture3_pix_data_out_net,
      darkquad29_capture3_threshold_user_data_out => darkquad29_capture3_threshold_user_data_out_net,
      data_in => delay45_q_net_x2,
      pps => delay14_q_net_x5,
      ts_in => delay9_q_net_x6,
      phase_out => delay58_q_net_x4,
      photon_out => delay87_q_net_x4,
      pix => darkquad29_capture3_pix_addr_net,
      pix_x0 => darkquad29_capture3_pix_data_in_net,
      pix_x1 => darkquad29_capture3_pix_we_net,
      we_out => logical2_y_net_x4
    );

  chan_sel_2cc6acb10c: entity work.chan_sel_entity_2cc6acb10c
    port map (
      bin_ctr => delay14_q_net_x1,
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      darkquad29_chan_sel_ch_bin0_user_data_out => darkquad29_chan_sel_ch_bin0_user_data_out_net,
      darkquad29_chan_sel_ch_bin1_user_data_out => darkquad29_chan_sel_ch_bin1_user_data_out_net,
      darkquad29_chan_sel_ch_bin2_user_data_out => darkquad29_chan_sel_ch_bin2_user_data_out_net,
      darkquad29_chan_sel_ch_bin3_user_data_out => darkquad29_chan_sel_ch_bin3_user_data_out_net,
      darkquad29_chan_sel_load_user_data_out => darkquad29_chan_sel_load_user_data_out_net,
      fft_data => register1_q_net_x1,
      fft_rdy => delay12_q_net_x1,
      ch0_data => reinterpret4_output_port_net_x1,
      ch1_data => reinterpret3_output_port_net_x1,
      ch2_data => reinterpret2_output_port_net_x1,
      ch3_data => reinterpret1_output_port_net_x2,
      ch_ctr => delay6_q_net_x2
    );

  check_lag_eee441ab05: entity work.check_lag_entity_eee441ab05
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      darkquad29_check_lag_latch_user_data_out => darkquad29_check_lag_latch_user_data_out_net,
      data_ch_in => delay6_q_net_x2,
      dds_ch_in => reinterpret1_output_port_net_x1,
      data_ch => darkquad29_check_lag_data_ch_user_data_in_net,
      dds_ch => darkquad29_check_lag_dds_ch_user_data_in_net
    );

  concat: entity work.concat_5a376c5bcd
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      in0 => constant3_op_net,
      in1 => register1_q_net_x30,
      in2 => slice1_y_net,
      in3 => reinterpret_output_port_net,
      y => concat_y_net_x1
    );

  constant3: entity work.constant_19562ab42f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      op => constant3_op_net
    );

  conv_phase0_6bd627872e: entity work.conv_phase0_entity_6bd627872e
    port map (
      ce_1 => ce_1_sg_x1054,
      ch_in => delay36_q_net_x0,
      clk_1 => clk_1_sg_x1054,
      darkquad29_conv_phase0_centers_user_data_out => darkquad29_conv_phase0_centers_user_data_out_net,
      darkquad29_conv_phase0_load_centers_user_data_out => darkquad29_conv_phase0_load_centers_user_data_out_net,
      data_in => delay35_q_net_x0,
      ch_out => delay1_q_net_x0,
      phase_out => arctan_phase_out_net_x0
    );

  conv_phase1_1a26ce14a5: entity work.conv_phase1_entity_1a26ce14a5
    port map (
      ce_1 => ce_1_sg_x1054,
      ch_in => delay18_q_net_x0,
      clk_1 => clk_1_sg_x1054,
      darkquad29_conv_phase1_centers_user_data_out => darkquad29_conv_phase1_centers_user_data_out_net,
      darkquad29_conv_phase1_load_centers_user_data_out => darkquad29_conv_phase1_load_centers_user_data_out_net,
      data_in => delay17_q_net_x0,
      ch_out => delay1_q_net_x2,
      phase_out => arctan_phase_out_net_x1
    );

  conv_phase2_f3d301a38c: entity work.conv_phase2_entity_f3d301a38c
    port map (
      ce_1 => ce_1_sg_x1054,
      ch_in => delay28_q_net_x0,
      clk_1 => clk_1_sg_x1054,
      darkquad29_conv_phase2_centers_user_data_out => darkquad29_conv_phase2_centers_user_data_out_net,
      darkquad29_conv_phase2_load_centers_user_data_out => darkquad29_conv_phase2_load_centers_user_data_out_net,
      data_in => delay26_q_net_x0,
      ch_out => delay1_q_net_x3,
      phase_out => arctan_phase_out_net_x2
    );

  conv_phase3_5b7a61fe21: entity work.conv_phase3_entity_5b7a61fe21
    port map (
      ce_1 => ce_1_sg_x1054,
      ch_in => delay40_q_net_x0,
      clk_1 => clk_1_sg_x1054,
      darkquad29_conv_phase3_centers_user_data_out => darkquad29_conv_phase3_centers_user_data_out_net,
      darkquad29_conv_phase3_load_centers_user_data_out => darkquad29_conv_phase3_load_centers_user_data_out_net,
      data_in => delay39_q_net_x0,
      ch_out => delay1_q_net_x4,
      phase_out => arctan_phase_out_net_x3
    );

  dds_delay_255e95bed2: entity work.dds_delay_entity_255e95bed2
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      delay => register1_q_net_x26,
      din => register1_q_net_x27,
      dout => dual_port_ram_doutb_net_x1
    );

  dds_lut_798e2870b3: entity work.dds_lut_entity_798e2870b3
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      darkquad29_dds_lut_qdr0_data_out => darkquad29_dds_lut_qdr0_data_out_net,
      darkquad29_dds_lut_qdr1_data_out => darkquad29_dds_lut_qdr1_data_out_net,
      darkquad29_dds_lut_qdr2_data_out => darkquad29_dds_lut_qdr2_data_out_net,
      darkquad29_dds_lut_qdr3_data_out => darkquad29_dds_lut_qdr3_data_out_net,
      darkquad29_dds_lut_run_user_data_out => darkquad29_dds_lut_run_user_data_out_net,
      start => register1_q_net_x40,
      ctr_out => delay76_q_net_x1,
      dds0 => convert9_dout_net_x1,
      dds1 => convert3_dout_net_x3,
      dds2 => convert4_dout_net_x3,
      dds3 => convert6_dout_net_x1,
      qdr0 => darkquad29_dds_lut_qdr0_address_net,
      qdr0_x0 => darkquad29_dds_lut_qdr0_be_net,
      qdr0_x1 => darkquad29_dds_lut_qdr0_data_in_net,
      qdr0_x2 => darkquad29_dds_lut_qdr0_rd_en_net,
      qdr0_x3 => darkquad29_dds_lut_qdr0_wr_en_net,
      qdr1 => darkquad29_dds_lut_qdr1_address_net,
      qdr1_x0 => darkquad29_dds_lut_qdr1_be_net,
      qdr1_x1 => darkquad29_dds_lut_qdr1_data_in_net,
      qdr1_x2 => darkquad29_dds_lut_qdr1_rd_en_net,
      qdr1_x3 => darkquad29_dds_lut_qdr1_wr_en_net,
      qdr2 => darkquad29_dds_lut_qdr2_address_net,
      qdr2_x0 => darkquad29_dds_lut_qdr2_be_net,
      qdr2_x1 => darkquad29_dds_lut_qdr2_data_in_net,
      qdr2_x2 => darkquad29_dds_lut_qdr2_rd_en_net,
      qdr2_x3 => darkquad29_dds_lut_qdr2_wr_en_net,
      qdr3 => darkquad29_dds_lut_qdr3_address_net,
      qdr3_x0 => darkquad29_dds_lut_qdr3_be_net,
      qdr3_x1 => darkquad29_dds_lut_qdr3_data_in_net,
      qdr3_x2 => darkquad29_dds_lut_qdr3_rd_en_net,
      qdr3_x3 => darkquad29_dds_lut_qdr3_wr_en_net
    );

  dds_shift_45e6bf424b: entity work.dds_shift_entity_45e6bf424b
    port map (
      darkquad29_dds_shift_user_data_out => darkquad29_dds_shift_user_data_out_net,
      in_reg => reint1_output_port_net_x1
    );

  delay1: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d(0) => register1_q_net_x29,
      en => '1',
      rst => '1',
      q(0) => delay1_q_net_x1
    );

  delay10: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 12
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => convert_dout_net_x0,
      en => '1',
      rst => '1',
      q => delay10_q_net_x2
    );

  delay11: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 12
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => arctan_phase_out_net_x1,
      en => '1',
      rst => '1',
      q => delay11_q_net_x0
    );

  delay12: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d(0) => slice1_y_net_x0,
      en => '1',
      rst => '1',
      q(0) => delay12_q_net_x1
    );

  delay13: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => delay14_q_net_x0,
      en => '1',
      rst => '1',
      q => delay13_q_net_x3
    );

  delay14: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => pfb_fft_bin_ctr_net_x0,
      en => '1',
      rst => '1',
      q => delay14_q_net_x1
    );

  delay15: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => delay1_q_net_x2,
      en => '1',
      rst => '1',
      q => delay15_q_net_x0
    );

  delay16: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d(0) => register1_q_net_x2,
      en => '1',
      rst => '1',
      q(0) => delay16_q_net
    );

  delay17: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 38
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => concat_y_net_x3,
      en => '1',
      rst => '1',
      q => delay17_q_net_x0
    );

  delay18: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => delay9_q_net_x3,
      en => '1',
      rst => '1',
      q => delay18_q_net_x0
    );

  delay19: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 76
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => concat_y_net_x7,
      en => '1',
      rst => '1',
      q => delay19_q_net_x1
    );

  delay2: entity work.xldelay
    generic map (
      latency => 49,
      reg_retiming => 0,
      reset => 0,
      width => 36
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => convert_dout_net_x4,
      en => '1',
      rst => '1',
      q => delay2_q_net_x0
    );

  delay20: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => delay49_q_net_x0,
      en => '1',
      rst => '1',
      q => delay20_q_net_x1
    );

  delay21: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 64
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => reinterpret4_output_port_net_x0,
      en => '1',
      rst => '1',
      q => delay21_q_net_x1
    );

  delay22: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 72
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => reinterpret3_output_port_net_x1,
      en => '1',
      rst => '1',
      q => delay22_q_net_x1
    );

  delay23: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 12
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => arctan_phase_out_net_x2,
      en => '1',
      rst => '1',
      q => delay23_q_net_x0
    );

  delay24: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => delay1_q_net_x3,
      en => '1',
      rst => '1',
      q => delay24_q_net_x0
    );

  delay25: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 12
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => arctan_phase_out_net_x0,
      en => '1',
      rst => '1',
      q => delay25_q_net_x0
    );

  delay26: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 38
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => concat_y_net_x4,
      en => '1',
      rst => '1',
      q => delay26_q_net_x0
    );

  delay27: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => delay1_q_net_x0,
      en => '1',
      rst => '1',
      q => delay27_q_net_x0
    );

  delay28: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => delay9_q_net_x4,
      en => '1',
      rst => '1',
      q => delay28_q_net_x0
    );

  delay29: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 76
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => concat_y_net_x8,
      en => '1',
      rst => '1',
      q => delay29_q_net_x1
    );

  delay3: entity work.xldelay
    generic map (
      latency => 5,
      reg_retiming => 0,
      reset => 0,
      width => 36
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => register1_q_net_x28,
      en => '1',
      rst => '1',
      q => delay3_q_net
    );

  delay30: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => delay49_q_net_x0,
      en => '1',
      rst => '1',
      q => delay30_q_net_x1
    );

  delay31: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 64
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => reinterpret3_output_port_net_x0,
      en => '1',
      rst => '1',
      q => delay31_q_net_x1
    );

  delay32: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 72
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => reinterpret2_output_port_net_x1,
      en => '1',
      rst => '1',
      q => delay32_q_net_x1
    );

  delay33: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 12
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => convert_dout_net_x2,
      en => '1',
      rst => '1',
      q => delay33_q_net_x2
    );

  delay34: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => delay14_q_net_x3,
      en => '1',
      rst => '1',
      q => delay34_q_net_x1
    );

  delay35: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 38
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => concat_y_net_x2,
      en => '1',
      rst => '1',
      q => delay35_q_net_x0
    );

  delay36: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => delay9_q_net_x1,
      en => '1',
      rst => '1',
      q => delay36_q_net_x0
    );

  delay37: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 12
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => arctan_phase_out_net_x3,
      en => '1',
      rst => '1',
      q => delay37_q_net_x0
    );

  delay38: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => delay1_q_net_x4,
      en => '1',
      rst => '1',
      q => delay38_q_net_x0
    );

  delay39: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 38
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => concat_y_net_x5,
      en => '1',
      rst => '1',
      q => delay39_q_net_x0
    );

  delay4: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d(0) => edge_op_y_net_x4,
      en => '1',
      rst => '1',
      q(0) => delay4_q_net_x1
    );

  delay40: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => delay9_q_net_x5,
      en => '1',
      rst => '1',
      q => delay40_q_net_x0
    );

  delay41: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 76
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => concat_y_net_x9,
      en => '1',
      rst => '1',
      q => delay41_q_net_x1
    );

  delay42: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => delay49_q_net_x0,
      en => '1',
      rst => '1',
      q => delay42_q_net_x1
    );

  delay43: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 64
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => reinterpret2_output_port_net_x0,
      en => '1',
      rst => '1',
      q => delay43_q_net_x1
    );

  delay44: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 72
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => reinterpret1_output_port_net_x2,
      en => '1',
      rst => '1',
      q => delay44_q_net_x1
    );

  delay45: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 12
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => convert_dout_net_x3,
      en => '1',
      rst => '1',
      q => delay45_q_net_x2
    );

  delay46: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => delay14_q_net_x4,
      en => '1',
      rst => '1',
      q => delay46_q_net_x0
    );

  delay49: entity work.xldelay
    generic map (
      latency => 8,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => delay75_q_net,
      en => '1',
      rst => '1',
      q => delay49_q_net_x0
    );

  delay5: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 36
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => delay7_q_net,
      en => '1',
      rst => '1',
      q => delay5_q_net_x1
    );

  delay50: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 76
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => concat_y_net_x6,
      en => '1',
      rst => '1',
      q => delay50_q_net_x1
    );

  delay52: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => delay49_q_net_x0,
      en => '1',
      rst => '1',
      q => delay52_q_net_x1
    );

  delay6: entity work.xldelay
    generic map (
      latency => 1,
      reg_retiming => 0,
      reset => 0,
      width => 1
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d(0) => relational5_op_net,
      en => '1',
      rst => '1',
      q(0) => delay6_q_net_x3
    );

  delay7: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 36
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => delay3_q_net,
      en => '1',
      rst => '1',
      q => delay7_q_net
    );

  delay73: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 64
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => reinterpret5_output_port_net_x0,
      en => '1',
      rst => '1',
      q => delay73_q_net_x1
    );

  delay74: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 72
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => reinterpret4_output_port_net_x1,
      en => '1',
      rst => '1',
      q => delay74_q_net_x1
    );

  delay75: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => delay6_q_net_x2,
      en => '1',
      rst => '1',
      q => delay75_q_net
    );

  delay8: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 12
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => convert_dout_net_x1,
      en => '1',
      rst => '1',
      q => delay8_q_net_x2
    );

  delay9: entity work.xldelay
    generic map (
      latency => 2,
      reg_retiming => 0,
      reset => 0,
      width => 8
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      d => delay14_q_net_x2,
      en => '1',
      rst => '1',
      q => delay9_q_net_x2
    );

  downsample0_dda67ea834: entity work.downsample0_entity_dda67ea834
    port map (
      ce_1 => ce_1_sg_x1054,
      ch_in => delay52_q_net_x1,
      clk_1 => clk_1_sg_x1054,
      data_in => delay50_q_net_x1,
      ch_out => delay9_q_net_x1,
      data_out => concat_y_net_x2
    );

  downsample1_879d358173: entity work.downsample0_entity_dda67ea834
    port map (
      ce_1 => ce_1_sg_x1054,
      ch_in => delay20_q_net_x1,
      clk_1 => clk_1_sg_x1054,
      data_in => delay19_q_net_x1,
      ch_out => delay9_q_net_x3,
      data_out => concat_y_net_x3
    );

  downsample2_5460ce0453: entity work.downsample0_entity_dda67ea834
    port map (
      ce_1 => ce_1_sg_x1054,
      ch_in => delay30_q_net_x1,
      clk_1 => clk_1_sg_x1054,
      data_in => delay29_q_net_x1,
      ch_out => delay9_q_net_x4,
      data_out => concat_y_net_x4
    );

  downsample3_9b0ed73eba: entity work.downsample0_entity_dda67ea834
    port map (
      ce_1 => ce_1_sg_x1054,
      ch_in => delay42_q_net_x1,
      clk_1 => clk_1_sg_x1054,
      data_in => delay41_q_net_x1,
      ch_out => delay9_q_net_x5,
      data_out => concat_y_net_x5
    );

  edge_detect2_86689f3503: entity work.edge_detect3_entity_2efb246ca9
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      in_x0 => register1_q_net_x29,
      out_x0 => edge_op_y_net_x2
    );

  edge_detect3_8c8ed7e87b: entity work.edge_detect3_entity_2efb246ca9
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      in_x0 => register1_q_net_x29,
      out_x0 => edge_op_y_net_x0
    );

  edge_detect_27d310ecc3: entity work.edge_detect3_entity_2efb246ca9
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      in_x0 => register1_q_net_x40,
      out_x0 => edge_op_y_net_x4
    );

  en6: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => reint1_output_port_net_x4,
      y(0) => en6_y_net_x0
    );

  eof_ctr: entity work.xlcounter_free_darkquad29
    generic map (
      core_name0 => "cntr_11_0_9ca51386af2c7a71",
      op_arith => xlUnsigned,
      op_width => 32
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      clr => '0',
      en(0) => delay7_q_net_x0,
      rst(0) => edge_op_y_net_x0,
      op => eof_ctr_op_net_x0
    );

  gbe64_1d1f7cbd44: entity work.gbe64_entity_1d1f7cbd44
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      darkquad29_gbe64_dest_ip_user_data_out => darkquad29_gbe64_dest_ip_user_data_out_net,
      darkquad29_gbe64_one_gbe_app_tx_afull => darkquad29_gbe64_one_gbe_app_tx_afull_net,
      darkquad29_gbe64_one_gbe_app_tx_overflow => darkquad29_gbe64_one_gbe_app_tx_overflow_net,
      darkquad29_gbe64_rst_user_data_out => darkquad29_gbe64_rst_user_data_out_net,
      darkquad29_gbe64_words_per_frame_user_data_out => darkquad29_gbe64_words_per_frame_user_data_out_net,
      data => assert_phase_dout_net_x0,
      dest_port => mux1_y_net_x1,
      hdr => concat_y_net_x1,
      hdr_ts => delay5_q_net_x1,
      rst_ctr => edge_op_y_net_x2,
      run => delay1_q_net_x1,
      we => mux5_y_net_x0,
      eof_snt => delay7_q_net_x0,
      one_gbe => darkquad29_gbe64_one_gbe_app_rx_ack_net,
      one_gbe_x0 => darkquad29_gbe64_one_gbe_app_rx_rst_net,
      one_gbe_x1 => darkquad29_gbe64_one_gbe_app_tx_data_net,
      one_gbe_x2 => darkquad29_gbe64_one_gbe_app_tx_destip_net,
      one_gbe_x3 => darkquad29_gbe64_one_gbe_app_tx_eof_net,
      one_gbe_x4 => darkquad29_gbe64_one_gbe_app_tx_destport_net,
      one_gbe_x5 => darkquad29_gbe64_one_gbe_app_tx_rst_net,
      one_gbe_x6 => darkquad29_gbe64_one_gbe_app_tx_dvld_net,
      tx_afull => darkquad29_gbe64_tx_afull_user_data_in_net,
      tx_overrun => darkquad29_gbe64_tx_overrun_user_data_in_net
    );

  mixer0_b53ac8f98f: entity work.mixer0_entity_b53ac8f98f
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      data_in => delay74_q_net_x1,
      dds_in => delay73_q_net_x1,
      data_out => concat_y_net_x6
    );

  mixer1_d7e89e7a7b: entity work.mixer0_entity_b53ac8f98f
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      data_in => delay22_q_net_x1,
      dds_in => delay21_q_net_x1,
      data_out => concat_y_net_x7
    );

  mixer2_a0599ef625: entity work.mixer0_entity_b53ac8f98f
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      data_in => delay32_q_net_x1,
      dds_in => delay31_q_net_x1,
      data_out => concat_y_net_x8
    );

  mixer3_61b64e1455: entity work.mixer0_entity_b53ac8f98f
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      data_in => delay44_q_net_x1,
      dds_in => delay43_q_net_x1,
      data_out => concat_y_net_x9
    );

  mux1: entity work.mux_bfe1d4f686
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      clr => '0',
      d0 => slice_y_net,
      d1 => slice10_y_net,
      sel(0) => register1_q_net_x29,
      y => mux1_y_net_x1
    );

  mux2: entity work.mux_597bf1b21b
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      clr => '0',
      d0 => register0_q_net_x0,
      d1 => register0_q_net_x1,
      d2 => register0_q_net_x2,
      d3 => register0_q_net_x3,
      sel => slice4_y_net,
      y => mux2_y_net_x0
    );

  mux4: entity work.mux_fd01d62b53
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      clr => '0',
      d0 => register1_q_net_x24,
      d1 => register1_q_net_x0,
      sel(0) => register1_q_net_x29,
      y => mux4_y_net
    );

  mux5: entity work.mux_1e22c21d05
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      clr => '0',
      d0(0) => register1_q_net_x25,
      d1(0) => register1_q_net_x2,
      sel(0) => register1_q_net_x29,
      y(0) => mux5_y_net_x0
    );

  n_eof_sent_ff012b1e74: entity work.last_tx_data_entity_4b5ba71046
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      out_reg => register1_q_net_x10,
      cast_gw_x0 => darkquad29_n_eof_sent_user_data_in_net
    );

  n_photons_b53fdaae91: entity work.last_tx_data_entity_4b5ba71046
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      out_reg => register1_q_net_x23,
      cast_gw_x0 => darkquad29_n_photons_user_data_in_net
    );

  pack_buf_bd697fc584: entity work.pack_buf_entity_bd697fc584
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      pack0 => register1_q_net_x8,
      pack1 => register1_q_net_x13,
      pack2 => register1_q_net_x17,
      pack3 => register1_q_net_x19,
      we0 => register1_q_net_x9,
      we1 => register1_q_net_x14,
      we2 => register1_q_net_x18,
      we3 => register1_q_net_x20,
      pack_out => mux_y_net_x1,
      we_out => mux1_y_net_x2
    );

  pfb_fft_e22b93a038: entity work.pfb_fft_entity_e22b93a038
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      data_in => register1_q_net_x12,
      sync_in => delay4_q_net_x1,
      bin_ctr => pfb_fft_bin_ctr_net_x0,
      check => darkquad29_pfb_fft_check_fft_oflow_user_data_in_net,
      data_out => concatenate_y_net_x3,
      fft_rdy => slice1_y_net_x0
    );

  ph_ctr: entity work.xlcounter_free_darkquad29
    generic map (
      core_name0 => "cntr_11_0_1e48762428ed22e0",
      op_arith => xlUnsigned,
      op_width => 32
    )
    port map (
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      clr => '0',
      en(0) => delay16_q_net,
      rst(0) => edge_op_y_net_x2,
      op => ph_ctr_op_net_x0
    );

  phase_dmp_b612ec57bc: entity work.phase_dmp_entity_b612ec57bc
    port map (
      ce_1 => ce_1_sg_x1054,
      ch_in => delay13_q_net_x3,
      clk_1 => clk_1_sg_x1054,
      darkquad29_phase_dmp_ch_we_user_data_out => darkquad29_phase_dmp_ch_we_user_data_out_net,
      darkquad29_phase_dmp_on_user_data_out => darkquad29_phase_dmp_on_user_data_out_net,
      data0 => delay10_q_net_x2,
      data1 => delay8_q_net_x2,
      data2 => delay33_q_net_x2,
      data3 => delay45_q_net_x2,
      gbe_data => delay7_q_net_x1,
      gbe_we => logical1_y_net_x2
    );

  phase_port_f9871a72ee: entity work.phase_port_entity_f9871a72ee
    port map (
      darkquad29_phase_port_user_data_out => darkquad29_phase_port_user_data_out_net,
      in_reg => reint1_output_port_net_x2
    );

  photon_port_7880d661a3: entity work.photon_port_entity_7880d661a3
    port map (
      darkquad29_photon_port_user_data_out => darkquad29_photon_port_user_data_out_net,
      in_reg => reint1_output_port_net_x3
    );

  pipeline10_744174dac8: entity work.pipeline10_entity_744174dac8
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      d => mux_y_net_x1,
      q => register1_q_net_x0
    );

  pipeline11_6e24620bd8: entity work.pipeline3_entity_fb0a315a6d
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      d => mux1_y_net_x2,
      q => register1_q_net_x2
    );

  pipeline12_8739e01f61: entity work.pipeline10_entity_744174dac8
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      d => delay87_q_net_x1,
      q => register1_q_net_x8
    );

  pipeline13_944327ad9a: entity work.pipeline3_entity_fb0a315a6d
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      d => logical2_y_net_x2,
      q => register1_q_net_x9
    );

  pipeline14_5b68b86bd8: entity work.pipeline14_entity_5b68b86bd8
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      d => concat_y_net_x7,
      q => register1_q_net_x5
    );

  pipeline15_44be80ceec: entity work.pipeline14_entity_5b68b86bd8
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      d => concat_y_net_x8,
      q => register1_q_net_x6
    );

  pipeline16_c0c8dccc04: entity work.pipeline4_entity_7ef90e571d
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      d => slice7_y_net_x0,
      q => register1_q_net_x3
    );

  pipeline17_b2b3937b76: entity work.pipeline14_entity_5b68b86bd8
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      d => concat_y_net_x9,
      q => register1_q_net_x7
    );

  pipeline18_5993153804: entity work.pipeline1_entity_986e3344b8
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      d => eof_ctr_op_net_x0,
      q => register1_q_net_x10
    );

  pipeline19_e8275394dd: entity work.pipeline4_entity_7ef90e571d
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      d => delay49_q_net_x0,
      q => register1_q_net_x11
    );

  pipeline1_dac2d70fc1: entity work.pipeline1_entity_dac2d70fc1
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      d => concatenate_y_net_x3,
      q => register1_q_net_x1
    );

  pipeline20_d9f7f271c8: entity work.pipeline10_entity_744174dac8
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      d => delay87_q_net_x2,
      q => register1_q_net_x13
    );

  pipeline21_597cbd3cba: entity work.pipeline3_entity_fb0a315a6d
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      d => logical2_y_net_x1,
      q => register1_q_net_x14
    );

  pipeline22_f410b0c4e1: entity work.pipeline3_entity_fb0a315a6d
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      d => logical1_y_net_x1,
      q => register1_q_net_x15
    );

  pipeline23_b97e8b3020: entity work.pipeline23_entity_b97e8b3020
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      d => dual_port_ram_doutb_net_x1,
      q => register1_q_net_x16
    );

  pipeline24_68c5a6954b: entity work.pipeline10_entity_744174dac8
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      d => delay87_q_net_x3,
      q => register1_q_net_x17
    );

  pipeline25_4cedd60828: entity work.pipeline3_entity_fb0a315a6d
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      d => logical2_y_net_x3,
      q => register1_q_net_x18
    );

  pipeline26_410dce80d4: entity work.pipeline10_entity_744174dac8
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      d => delay87_q_net_x4,
      q => register1_q_net_x19
    );

  pipeline27_b86e1aa4af: entity work.pipeline3_entity_fb0a315a6d
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      d => logical2_y_net_x4,
      q => register1_q_net_x20
    );

  pipeline28_ce566f2f61: entity work.pipeline3_entity_fb0a315a6d
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      d => slice3_y_net_x0,
      q => register1_q_net_x21
    );

  pipeline29_a961a1093b: entity work.pipeline3_entity_fb0a315a6d
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      d => logical2_y_net_x2,
      q => register1_q_net_x4
    );

  pipeline2_67c1158a1a: entity work.pipeline2_entity_67c1158a1a
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      d => concatenate_y_net_x2,
      q => register1_q_net_x12
    );

  pipeline30_beeb8ae1a6: entity work.pipeline30_entity_beeb8ae1a6
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      d => delay58_q_net_x1,
      q => register0_q_net_x0
    );

  pipeline31_267451c9b2: entity work.pipeline1_entity_986e3344b8
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      d => ph_ctr_op_net_x0,
      q => register1_q_net_x23
    );

  pipeline32_ee983b0e75: entity work.pipeline30_entity_beeb8ae1a6
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      d => delay58_q_net_x2,
      q => register0_q_net_x1
    );

  pipeline33_1b8e7040c6: entity work.pipeline10_entity_744174dac8
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      d => delay7_q_net_x1,
      q => register1_q_net_x24
    );

  pipeline34_b627ef2e8f: entity work.pipeline30_entity_beeb8ae1a6
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      d => delay58_q_net_x3,
      q => register0_q_net_x2
    );

  pipeline35_36ecd73cd3: entity work.pipeline30_entity_beeb8ae1a6
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      d => delay58_q_net_x4,
      q => register0_q_net_x3
    );

  pipeline36_e37725dea2: entity work.pipeline3_entity_fb0a315a6d
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      d => logical1_y_net_x2,
      q => register1_q_net_x25
    );

  pipeline3_935caa61aa: entity work.pipeline14_entity_5b68b86bd8
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      d => concat_y_net_x6,
      q => register1_q_net_x22
    );

  pipeline4_f4fac8adb0: entity work.pipeline4_entity_f4fac8adb0
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      d => slice6_y_net_x0,
      q => register1_q_net_x26
    );

  pipeline5_976df9e662: entity work.pipeline23_entity_b97e8b3020
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      d => concatenate_y_net_x1,
      q => register1_q_net_x27
    );

  pipeline6_f8a2b1329a: entity work.pipeline6_entity_f8a2b1329a
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      d => delay2_q_net_x0,
      q => register1_q_net_x28
    );

  pipeline7_4e12768aec: entity work.pipeline3_entity_fb0a315a6d
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      d => slice2_y_net_x0,
      q => register1_q_net_x29
    );

  pipeline8_e15728175f: entity work.pipeline3_entity_fb0a315a6d
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      d => en6_y_net_x0,
      q => register1_q_net_x40
    );

  pipeline9_2138cb0687: entity work.pipeline4_entity_7ef90e571d
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      d => slice5_y_net_x0,
      q => register1_q_net_x30
    );

  prog_fir0_fe8268b744: entity work.prog_fir0_entity_fe8268b744
    port map (
      ce_1 => ce_1_sg_x1054,
      ch_in => delay27_q_net_x0,
      clk_1 => clk_1_sg_x1054,
      darkquad29_prog_fir0_load_chan_user_data_out => darkquad29_prog_fir0_load_chan_user_data_out_net,
      darkquad29_prog_fir0_single_chan_coeffs_data_out => darkquad29_prog_fir0_single_chan_coeffs_data_out_net,
      data_in => delay25_q_net_x0,
      ch_out => delay14_q_net_x0,
      data_out => convert_dout_net_x0,
      single_chan_coeffs => darkquad29_prog_fir0_single_chan_coeffs_addr_net,
      single_chan_coeffs_x0 => darkquad29_prog_fir0_single_chan_coeffs_data_in_net,
      single_chan_coeffs_x1 => darkquad29_prog_fir0_single_chan_coeffs_we_net
    );

  prog_fir1_b14c72270e: entity work.prog_fir1_entity_b14c72270e
    port map (
      ce_1 => ce_1_sg_x1054,
      ch_in => delay15_q_net_x0,
      clk_1 => clk_1_sg_x1054,
      darkquad29_prog_fir1_load_chan_user_data_out => darkquad29_prog_fir1_load_chan_user_data_out_net,
      darkquad29_prog_fir1_single_chan_coeffs_data_out => darkquad29_prog_fir1_single_chan_coeffs_data_out_net,
      data_in => delay11_q_net_x0,
      ch_out => delay14_q_net_x2,
      data_out => convert_dout_net_x1,
      single_chan_coeffs => darkquad29_prog_fir1_single_chan_coeffs_addr_net,
      single_chan_coeffs_x0 => darkquad29_prog_fir1_single_chan_coeffs_data_in_net,
      single_chan_coeffs_x1 => darkquad29_prog_fir1_single_chan_coeffs_we_net
    );

  prog_fir2_7a88e27847: entity work.prog_fir2_entity_7a88e27847
    port map (
      ce_1 => ce_1_sg_x1054,
      ch_in => delay24_q_net_x0,
      clk_1 => clk_1_sg_x1054,
      darkquad29_prog_fir2_load_chan_user_data_out => darkquad29_prog_fir2_load_chan_user_data_out_net,
      darkquad29_prog_fir2_single_chan_coeffs_data_out => darkquad29_prog_fir2_single_chan_coeffs_data_out_net,
      data_in => delay23_q_net_x0,
      ch_out => delay14_q_net_x3,
      data_out => convert_dout_net_x2,
      single_chan_coeffs => darkquad29_prog_fir2_single_chan_coeffs_addr_net,
      single_chan_coeffs_x0 => darkquad29_prog_fir2_single_chan_coeffs_data_in_net,
      single_chan_coeffs_x1 => darkquad29_prog_fir2_single_chan_coeffs_we_net
    );

  prog_fir3_f2fb14267e: entity work.prog_fir3_entity_f2fb14267e
    port map (
      ce_1 => ce_1_sg_x1054,
      ch_in => delay38_q_net_x0,
      clk_1 => clk_1_sg_x1054,
      darkquad29_prog_fir3_load_chan_user_data_out => darkquad29_prog_fir3_load_chan_user_data_out_net,
      darkquad29_prog_fir3_single_chan_coeffs_data_out => darkquad29_prog_fir3_single_chan_coeffs_data_out_net,
      data_in => delay37_q_net_x0,
      ch_out => delay14_q_net_x4,
      data_out => convert_dout_net_x3,
      single_chan_coeffs => darkquad29_prog_fir3_single_chan_coeffs_addr_net,
      single_chan_coeffs_x0 => darkquad29_prog_fir3_single_chan_coeffs_data_in_net,
      single_chan_coeffs_x1 => darkquad29_prog_fir3_single_chan_coeffs_we_net
    );

  reinterpret: entity work.reinterpret_86b044698f
    port map (
      ce => '0',
      clk => '0',
      clr => '0',
      input_port => delay5_q_net_x1,
      output_port => reinterpret_output_port_net
    );

  relational5: entity work.relational_deb0401f42
    port map (
      a => register1_q_net_x3,
      b => delay95_q_net_x0,
      ce => ce_1_sg_x1054,
      clk => clk_1_sg_x1054,
      clr => '0',
      op(0) => relational5_op_net
    );

  run_d5b94f8831: entity work.run_entity_d5b94f8831
    port map (
      darkquad29_run_user_data_out => darkquad29_run_user_data_out_net,
      in_reg => reint1_output_port_net_x4
    );

  sel_ch_9462bb8e75: entity work.sel_ch_entity_9462bb8e75
    port map (
      darkquad29_sel_ch_user_data_out => darkquad29_sel_ch_user_data_out_net,
      in_reg => reint1_output_port_net_x5
    );

  slice: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 15,
      x_width => 32,
      y_width => 16
    )
    port map (
      x => reint1_output_port_net_x2,
      y => slice_y_net
    );

  slice1: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 11,
      x_width => 32,
      y_width => 12
    )
    port map (
      x => eof_ctr_op_net_x0,
      y => slice1_y_net
    );

  slice10: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 15,
      x_width => 32,
      y_width => 16
    )
    port map (
      x => reint1_output_port_net_x3,
      y => slice10_y_net
    );

  slice2: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => reint1_output_port_net_x6,
      y(0) => slice2_y_net_x0
    );

  slice3: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 0,
      x_width => 32,
      y_width => 1
    )
    port map (
      x => reint1_output_port_net_x7,
      y(0) => slice3_y_net_x0
    );

  slice4: entity work.xlslice
    generic map (
      new_lsb => 8,
      new_msb => 9,
      x_width => 32,
      y_width => 2
    )
    port map (
      x => reint1_output_port_net_x5,
      y => slice4_y_net
    );

  slice5: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 7,
      x_width => 32,
      y_width => 8
    )
    port map (
      x => reint1_output_port_net_x0,
      y => slice5_y_net_x0
    );

  slice6: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 8,
      x_width => 32,
      y_width => 9
    )
    port map (
      x => reint1_output_port_net_x1,
      y => slice6_y_net_x0
    );

  slice7: entity work.xlslice
    generic map (
      new_lsb => 0,
      new_msb => 7,
      x_width => 32,
      y_width => 8
    )
    port map (
      x => reint1_output_port_net_x5,
      y => slice7_y_net_x0
    );

  snp_phs_5ab5aa3d1e: entity work.snp_phs_entity_5ab5aa3d1e
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      darkquad29_snp_phs_ss_ctrl_user_data_out => darkquad29_snp_phs_ss_ctrl_user_data_out_net,
      in_phase => mux2_y_net_x0,
      in_trig => register1_q_net_x4,
      trig => register1_q_net_x21,
      we => delay6_q_net_x3,
      ss => darkquad29_snp_phs_ss_bram_addr_net,
      ss_x0 => darkquad29_snp_phs_ss_bram_data_in_net,
      ss_x1 => darkquad29_snp_phs_ss_bram_we_net,
      ss_x2 => darkquad29_snp_phs_ss_status_user_data_in_net
    );

  start_cap_8dd836ec5d: entity work.start_cap_entity_8dd836ec5d
    port map (
      darkquad29_start_cap_user_data_out => darkquad29_start_cap_user_data_out_net,
      in_reg => reint1_output_port_net_x6
    );

  timekeeper_3a138ccb56: entity work.timekeeper_entity_3a138ccb56
    port map (
      ce_1 => ce_1_sg_x1054,
      clk_1 => clk_1_sg_x1054,
      darkquad29_timekeeper_base_ts_user_data_out => darkquad29_timekeeper_base_ts_user_data_out_net,
      pps => register1_q_net_x15,
      ms_out => convert_dout_net_x4,
      pps_out => delay14_q_net_x5,
      sec_now => darkquad29_timekeeper_sec_now_user_data_in_net,
      us_since_halfms => delay9_q_net_x6
    );

  trig_snp_db92f5316d: entity work.trig_snp_entity_db92f5316d
    port map (
      darkquad29_trig_snp_user_data_out => darkquad29_trig_snp_user_data_out_net,
      in_reg => reint1_output_port_net_x7
    );

end structural;
